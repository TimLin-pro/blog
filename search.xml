<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[深入理解 RecyclerView 缓存机制]]></title>
      <url>https://timlin-pro.github.io/blog/2020/05/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>使用 ScrollView 的时候，它的所有子 view 都会一次性被加载出来。而正确使用 RecyclerView 可以做到按需加载，按需绑定，并实现复用。本文主要分析 RecyclerView 缓存复用的原理。</p>
<a id="more"></a>
<h2 id="从缓存获取-ViewHolder-流程概览"><a href="#从缓存获取-ViewHolder-流程概览" class="headerlink" title="从缓存获取 ViewHolder 流程概览"></a>从缓存获取 ViewHolder 流程概览</h2><p>从缓存获取的大致流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/image-RecyclerView.png" alt="缓存获取流程"></p>
<p>说明：</p>
<p>在创建 ViewHolder 之前，RecyclerView 会先从缓存中尝试获取是否有符合要求的 ViewHolder，详见 <code>Recycler#tryGetViewHolderForPositionByDeadline</code> 方法</p>
<ul>
<li>第一次，尝试从 mChangedScrap 中获取。<ul>
<li>只有在 mState.isPreLayout() 为 true 时，也就是预布局阶段，才会做这次尝试。</li>
<li>「预布局」的概念会在介绍。</li>
</ul>
</li>
<li>第二次，getScrapOrHiddenOrCachedHolderForPosition() 获得 ViewHolder。<ul>
<li>尝试从 1. mAttachedScrap 2.mHiddenViews 3.mCachedViews 中查找 ViewHolder<ul>
<li>其中 mAttachedScrap 和 mCachedViews 都是 Recycler 的成员变量</li>
<li>如果成功获得 ViewHolder 则检验其有效性，<ul>
<li>若<strong>检验失败则将其回收</strong>到 RecyclerViewPool 中</li>
<li>检验成功可以直接使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第三次，如果给 Adapter 设置了 stableId，调用 getScrapOrCachedViewForId 尝试获取 ViewHolder。<ul>
<li>跟第二次的区别在于，之前是根据 position 查找，现在是根据 id 查找</li>
</ul>
</li>
<li>第四次，mViewCacheExtension 不为空的话，则调用 ViewCacheExtension#getViewForPositionAndType 方法尝试获取 <strong>View</strong><ul>
<li>注：ViewCacheExtension 是由开发者设置的，默认情况下为空，一般我们也不会设置。这层缓存大部分情况下可以忽略。</li>
</ul>
</li>
<li>第五次。尝试从 RecyclerViewPool 中获取，相比较于 mCachedViews，从 mRecyclerPool 中成功获取 ViewHolder 对象后并没有做合法性和 item 位置校验，只检验 viewType 是否一致。<ul>
<li>从 RecyclerViewPool 中取出来的 ViewHolder 需要重新执行 bind 才能使用。</li>
</ul>
</li>
<li>如果上面五次尝试都失败了，调用 RecyclerView.Adapter#createViewHolder 创建一个新的 ViewHolder</li>
<li>最后根据 ViewHolder 的状态，确定是否需要调用 bindViewHolder 进行数据绑定。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="预布局、预测动画是什么？"><a href="#预布局、预测动画是什么？" class="headerlink" title="预布局、预测动画是什么？"></a>预布局、预测动画是什么？</h3><p>理解「预布局」需要先了解「预测动画」。考虑这样一个场景：</p>
<p>用户有 A、B、C 三个 item，A，B 刚好显示在屏幕中，这个时候，用户把 B 删除了，那么最终 C 会显示在 B 原来的位置</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/image-预测动画问题.png" alt=""></p>
<p>如果 C 从底部平滑地滑动到之前 B 的位置将会更符合直觉。但是要做到这点实际上没那么简单。因为我们只知道 C 最终的位置，但是不知道 C 的起始位置在哪里，无法确定 C 应该从哪里滑动过来。如果根据最终的状态，就断定 C 应该要从底部滑动过来的话，很可能是有问题的。因为在其他 LayoutManager 中，它可能是从侧面或者是其他地方滑动过来的。</p>
<p>那根据原状态与最终状态之间的差异，能不能得出我们应该执行什么样的切换动画呢？答案依然是 no。因为在原状态中，C 根本就不存在。（这个时候，我们并不知道，B 要被删除了，如果把 C 给加载出来，很可能是一种资源浪费。）</p>
<p>设计 RecyclerView 的工程师是这么解决的。当 Adapter 发生变化的时候，RecyclerView 会让 LayoutManager 进行两次布局。</p>
<ul>
<li>第一次是<strong>预布局</strong>。将之前原状态 下的 item 都布局出来。并且根据 Adapter 的 notify 信息，我们知道哪些 item 即将变化了，所以可以<strong>加载出另外的 View</strong>。在上述例子中，因为知道 B 已经被删除了，所以可以<strong>把屏幕之外的 C 也加载出来</strong>。</li>
<li>第二个，最终的布局，也就是变化完成之后的布局。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/image-预布局.png" alt="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/image-%E9%A2%84%E5%B8%83%E5%B1%80.png"></p>
<p>这样只要比较前后布局的变化，就能得出应该执行什么动画了。</p>
<p>这种负责执行动画的 view 在原布局或新布局中不存在的动画，就称为<strong>预测动画</strong>。</p>
<p><strong>预布局</strong>是实现预测动画的一个步骤。</p>
<p>下面两个动图展示了普通动画与预测动画效果的区别：</p>
<p>普通动画 👇</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/remove_itemwithou.gif" alt=""></p>
<p>预测动画 👇</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/remove_item_predictive-20200502223349463.gif" alt=""></p>
<p>关于预测动画，感兴趣的同学可以进一步阅读<a href="http://frogermcs.github.io/recyclerview-animations-androiddevsummit-write-up/" target="_blank" rel="noopener">这篇文章</a>。</p>
<h3 id="关于-Scrap"><a href="#关于-Scrap" class="headerlink" title="关于 Scrap"></a>关于 Scrap</h3><p>Scrap 缓存列表（mChangedScrap、mAttachedScrap）是 RecyclerView 最先查找 ViewHolder 地方，它跟 RecyclerViewPool 或者 ViewCache 有很大的区别。</p>
<p>mChangedScrap 和 mAttachedScrap 只在布局阶段使用。其他时候它们是空的。布局完成之后，这两个缓存中的 viewHolder，会移到 mCacheView 或者 RecyclerViewPool 中。</p>
<p>当 LayoutManager 开始布局的时候（预布局或者是最终布局），当前布局中的所有 view，都会被 dump 到 scrap 中（具体实现可见 <code>LinearLayoutManager#onLayoutChildren() 方法中调用了 detachAndScrapAttachedViews()</code> ），然后 LayoutManager 挨个地取回 view，除非 view 发生了什么变化，否则它会马上从 scrap 中回到原来的位置。</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/scrap-example-.png" alt="img"></p>
<p>以上图为例，我们删除掉 b，调用 notifyItemRemove 方法，触发重新布局，这时 a,b,c 都会被 dump 到 scrap 中，然后 LayoutManager  会从 scrap 中取回  a 和 c。</p>
<p>偏个题，这个时候，b 去哪了？ RecyclerView 看到 b 没有出现在最终的布局中，会 unscrap 它，让它执行一个消失的动画然后隐藏。动画执行完之后，b 被放到 RecyclerViewPool 中。</p>
<p>为什么 LayoutManager 需要先执行 detach，然后再重新 attach 这些 view，而不是只移除哪些变化的子 view 呢？Scrap 缓存列表的存在，是为了隔离 LayoutManager 和 RecyclerView.Recycler 之间的关注点/职责。LayoutManager 不需要知道哪一个子 view 应该保留 或者是 应该被回收到 pool 亦或者其他什么地方。这是 Recycler 的职责。</p>
<p>除了在布局时不为空外，还有另一个与 scrap 有关的规律：所有 scrap 的 view 都会跟 RecyclerView 分离。ViewGroup 中的 attachView 和 detachView 方法跟 addView 和 removeView 方法很像，但是不会触发请求布局会重绘的事件。它们只是从 ViewGroup 的子 view 列表中删除对应的子 view，并将该子 view 的 parent 设置为 null。detached 状态必须是临时，后面紧随着 attach 或者 remove 事件</p>
<p>如果在计算一个新布局的时候，已经添加了一堆子 view，可以放心的将它们全部 detach ，Recyclerview 就是这么做的。</p>
<h3 id="Attached-vs-Changed-scrap"><a href="#Attached-vs-Changed-scrap" class="headerlink" title="Attached vs Changed scrap"></a>Attached vs Changed scrap</h3><p>Recycler 类中，我们可以看到两个单独的 scrap 容器: mAttachedScrap 和 mChangedScrap。为什么需要两个呢？</p>
<p>ViewHolder 只有在满足下面情况才会被添加到 mChangedScrap：当它关联的 item 发生了变化（notifyItemChanged 或者 notifyItemRangeChanged 被调用），并且 ItemAnimator 调用 ViewHolder#canReuseUpdatedViewHolder 方法时，返回了 false。否则，ViewHolder 会被添加到AttachedScrap 中。</p>
<p>canReuseUpdatedViewHolder 返回 “false” 表示我们要执行用一个 view 替换另一个 view 的动画，例如淡入淡出动画。 “true”表示动画在 view 内部发生。</p>
<p>mAttachedScrap 在 整个布局过程中都能使用，但是 changed scrap — 只能在预布局阶段使用。</p>
<p>这是有道理的：在布局后，新的 ViewHolder 应该替换掉“改变了的”视图，因此 AttachedScrap 在布局后是没有用的。 更改动画执行完成后，change scrap 将按预期方式转存到 pool 中</p>
<p>默认的 ItemAnimator 可以在 3 种情况下重用更新的 ViewHolder：</p>
<ul>
<li>调用了 setSupportsChangeAnimations(false)。</li>
<li>调用了 notifyDataSetChanged 而不是 notifyItemChanged 或 notifyItemRangeChanged 。</li>
<li>提供了这样的更改 payload：adapter.notifyItemChanged(index，anyObject)。</li>
</ul>
<p>最后一种情况显示了一种很好的方法，当只想更改一些内部元素时，可以避免创建/绑定新的 ViewHolder。</p>
<h3 id="Hidden-Views-是什么？"><a href="#Hidden-Views-是什么？" class="headerlink" title="Hidden Views 是什么？"></a>Hidden Views 是什么？</h3><p>前面提到在第二次尝试获取 ViewHolder 的时候，有一个子步骤会从 hidden view 中搜索，这里的 hidden view 指的是什么？「hidden view」指的是那些正在从 RecyclerView 边界中脱离的 view。为了让这些 view 正确地执行对应的分离动画，它们仍然作为 RecyclerView 的子 view 被保留下来。</p>
<p>站在 LayoutManager 的角度，这些 view 已经不存在了，因此不应该被包含在计算里面。比如 在部分 view 正在执行消失动画的过程中，调用 LayoutManager#getChildAt 方法，这些 view 不算在下标里面。来自 LayoutManager 的所有对 getChildAt()、getChildCount()、addView() 等的方法调用 在应用到实际的可回收view 之前，都要通过 ChildHelper 处理，ChildHelper 的职责是重新计算非隐藏的子 view 列表和完整的子 view 列表之间的索引。</p>
<p>请记住，我们正在搜索要提供给 LayoutManager 的视图，<strong>但是 LayoutManager 不应了解隐藏 View</strong>！</p>
<p>举一个实际的🌰：这种让人费解的“从隐藏的 view 弹跳”（bouncing from hidden views）机制对于处理下面这种情况而言是很有必要的。 考虑这种场景，我们插入一个 item ，然后在插入动画完成之前，马上删除该 item：</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/hiddenview.png" alt="img"></p>
<p>我们想要看到的是 b 从 c 移除时的位置开始向上平移。 但是在那个时候，b 是一个隐藏的 view！ 如果我们忽略了它（“隐藏”的 b），那会导致在现有 b 下面创建一个新的 b。更糟糕的是，这两个 view 会重叠，因为 新的 b 会往上，旧的 b 会往下。 为了避免这种错误，在搜索 ViewHolder 的较早步骤之一中，RecyclerView 会询问 ChildHelper 是否具有合适的 hidden view。 所谓「合适」，表示这个 view 跟我们需要的位置相关联，并具有正确的 view type，并且这个 view 的被隐藏的原因不是为了移除掉它（我们不应该让被移除的 view 复活）</p>
<p>如果有这样的 view ，RecyclerView 会将其返回到 LayoutManager 并将其添加到 preLayout 中以标记应从其进行动画处理的位置（详见 recordAnimationInfoIfBouncedHiddenView 方法）。 </p>
<p>什么？在 布局前后 添加内容不应该是 LayoutManager 的职责吗？怎么现在 RecyclerView 也在往 preLayout 中添加view？  是的，这种机制看起来有点职责部分，但这是也说明我们有必要了解它。</p>
<h3 id="Stable-Id-的作用是什么？"><a href="#Stable-Id-的作用是什么？" class="headerlink" title="Stable Id 的作用是什么？"></a>Stable Id 的作用是什么？</h3><p>理解 stable Id 特性的最重要的一个点是，它只会在调用 notifyDataSetChanged 方法之后，影响 RecyclerView 的行为。</p>
<p>如果调用 notifyDataSetChanged 的时候，Adapter 并没有设置 hasStableId，RecyclerView 不知道 发生了什么，哪一些东西变化了，所以，它假设所有的东西都变了，每一个 ViewHolder 都是无效的，因此应该把它们放到 RecyclerViewPool 而不是 scrap 中。</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/stable.png" alt="img"></p>
<p>如果有 Stable Id，那那将会是像下面这样：</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/hasstableid.png" alt="img"></p>
<p>ViewHolder 会进入 scrap 而不是 pool 中。然后会通过特定的 Id（Adapter 中的 getItemId 获取到的 id）而不是 postion 到 scrap 中查找 ViewHolder。</p>
<p>好处是什么？</p>
<ol>
<li>不会导致 RecyclerViewPool 溢出，因此非必须情况下，不需要创建新的 ViewHolder。之前的 ViewHolder 会重新绑定，因为 Id 没有变化不代表内容没有变化</li>
<li>最大好处的好处是 支持动画。上面移动 item4 到 item6 的位置。正常情况下，我们需要调用 notifyItemMoved(4,6) 才能得到一个移动动画。但是通过 stable id，调用 notifyDataSetChanged 也能支持这一点。因为 RecyclerView 可以看到特定 id 的 view 在新旧布局的上的位置，<ul>
<li>要注意的是，这里的动画只支持简单的动画，预测动画无法支持。 如果我们在新布局中看到一些 ID，而在旧布局中没有，那么我们如何知道它是新插入的 item 还是从某处移入的 item，在后一种情况下它究竟是从哪里来的呢？ 通常，这些问题的答案会在预布局中找到，根据适配器的更改，该布局已超出 RecyclerView 的范围，但现在这种情况下， 我们不知道这些更改具体是什么</li>
</ul>
</li>
</ol>
<p>总体而言，stable id 的使用场景似乎比较有限。 不过，还是有这样一个使用场景：如果是从 ListView 迁移到 RecyclerView，将所有 notifyDataSetChanged 调用，都转换为特定更改的通知可能会很痛苦。 在这种情况下，stable id 可以提供给你提供简单的 RecyclerView 动画。</p>
<h2 id="缓存优化实践"><a href="#缓存优化实践" class="headerlink" title="缓存优化实践"></a>缓存优化实践</h2><ul>
<li><p>尽量使用 notifyItemXxx 方法进行细粒度的通知更新，而不是 notifyDatasetChanged</p>
<ul>
<li>如果变更前后是两个数据集，无法确定具体哪一些数据项变化了，可以考虑使用 <a href="https://developer.android.google.cn/reference/androidx/recyclerview/widget/DiffUtil" target="_blank" rel="noopener">DiffUtil</a> 。</li>
<li>如果数据集较大，建议结合使用 <a href="https://developer.android.google.cn/reference/androidx/recyclerview/widget/AsyncListDiffer" target="_blank" rel="noopener">AsyncListDiffer</a> 在子线程做 diff 运算。</li>
</ul>
</li>
<li><p>如果特定 viewType 的 item 只有一个，可以通过 <code>RecyclerView#getRecycledViewPool()#setMaxRecycledViews(viewType,1);</code> 来调整缓存区的大小，减少内存占用</p>
</li>
<li><p>如果特定 viewType 的 item 特别多，但是不得不通过 notifyDataSetChange 方法更新数据，可以通过下面这种方式，在变更前调大缓存，变更完成后，调小缓存。这样布局变化也可以最大程度地复用已有的 ViewHolder。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mRecyclerView.getRecycledViewPool().setMaxRecycledViews(<span class="number">0</span>, 屏幕显示的item总数+<span class="number">7</span> );</div><div class="line">mAdapter.notifyDataSetChanged();</div><div class="line"><span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        mRecyclerView.getRecycledViewPool()</div><div class="line">                .setMaxRecycledViews(<span class="number">0</span>, <span class="number">5</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>如果 RecyclerView 中的每个 item 都是一个 RecyclerView， 并且子 RecyclerView 的 item type 相同可以通过 RecyclerView#setRecycledViewPool(); 方法，实现缓存池的复用。<img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/image-RecyclerViewpool-reuse.png" alt=""></p>
</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://android.jlelse.eu/anatomy-of-recyclerview-part-1-a-search-for-a-viewholder-404ba3453714" target="_blank" rel="noopener">https://android.jlelse.eu/anatomy-of-recyclerview-part-1-a-search-for-a-viewholder-404ba3453714</a></li>
<li><a href="http://www.programmersought.com/article/4558924504/" target="_blank" rel="noopener">http://www.programmersought.com/article/4558924504/</a></li>
<li><a href="https://juejin.im/post/5b79a0b851882542b13d204b" target="_blank" rel="noopener">https://juejin.im/post/5b79a0b851882542b13d204b</a></li>
<li><a href="https://juejin.im/post/5c696ba9e51d457f136d24ff" target="_blank" rel="noopener">https://juejin.im/post/5c696ba9e51d457f136d24ff</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 中更新 UI 的线程限制问题探究]]></title>
      <url>https://timlin-pro.github.io/blog/2020/04/18/Android%20%E4%B8%AD%E6%9B%B4%E6%96%B0%20UI%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98%E6%8E%A2%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h1 id="Android-中子线程真的不能更新-UI-吗？"><a href="#Android-中子线程真的不能更新-UI-吗？" class="headerlink" title="Android 中子线程真的不能更新 UI 吗？"></a>Android 中子线程真的不能更新 UI 吗？</h1><p>2020-04-18  基于 2017-08-16 的内容更新。</p>
<p>先说结论：Android 中子线程在满足一定的条件下可以更新 UI。</p>
<ul>
<li><p>在 ViewRootImpl 还没创建出来之前</p>
<ul>
<li>UI 修改的操作没有线程限制。</li>
</ul>
</li>
<li><p>在 ViewRootImpl 创建完成之后</p>
<ol>
<li><p>保证「创建 ViewRootImpl 的操作」和「执行修改 UI 的操作」在同一个线程即可。也就是说，要在同一个线程调用 ViewManager#addView 和 ViewManager#updateViewLayout 的方法。</p>
<ul>
<li>注：ViewManager 是一个接口，WindowManger 接口继承了这个接口，我们通常都是通过 WindowManger（具体实现为 WindowMangerImpl） 进行 view 的 add remove update 操作的。</li>
</ul>
</li>
<li><p>对应的线程需要创建 Looper 并且调用 Looper#loop 方法，开启消息循环。</p>
</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h2 id="一个栗子："><a href="#一个栗子：" class="headerlink" title="一个栗子："></a>一个栗子：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ImageView mImageView;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">      	mImageView = (ImageView)findViewById(R.id.iv);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				mImageView.setImageResource(R.drawable.ic_book);<span class="comment">//更新 ui</span></div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上在 onCreate 方法中新建一个线程对 mImageView 进行了操作，成功从子线程更新了 ui。</p>
<p>但是如果让线程 sleep 一段时间（比如 300ms），</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">300</span>);<span class="comment">//睡眠 300 ms</span></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        mImageView.setImageResource(R.drawable.ic_book);<span class="comment">//更新 ui</span></div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>那么就很可能会报如下错误：(如果 300ms 不报错，可将其改为 1000ms)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</div><div class="line">    at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:<span class="number">7194</span>)</div><div class="line">    at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:<span class="number">1111</span>)</div><div class="line">    at android.view.ViewGroup.invalidateChild(ViewGroup.java:<span class="number">4833</span>)</div><div class="line">    at android.view.View.invalidateInternal(View.java:<span class="number">12102</span>)</div><div class="line">    at android.view.View.invalidate(View.java:<span class="number">12062</span>)</div><div class="line">    at android.view.View.invalidate(View.java:<span class="number">12046</span>)</div><div class="line">    at android.widget.ImageView.setImageDrawable(ImageView.java:<span class="number">456</span>)</div><div class="line">    at android.support.v7.widget.AppCompatImageView.setImageDrawable(AppCompatImageView.java:<span class="number">100</span>)</div><div class="line">    at android.support.v7.widget.AppCompatImageHelper.setImageResource(AppCompatImageHelper.java:<span class="number">89</span>)</div><div class="line">    at android.support.v7.widget.AppCompatImageView.setImageResource(AppCompatImageView.java:<span class="number">94</span>)</div><div class="line">    at com.android.rdc.librarysystem.MainActivity$<span class="number">1</span>.run(MainActivity.java:<span class="number">52</span>)</div><div class="line">    at java.lang.Thread.run(Thread.java:<span class="number">818</span>)</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该异常是从哪里抛出的？   </p>
<p>从出错的堆栈信息中可以异常看到是 <code>ViewRootImpl#checkThread()</code> 方法中抛出的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</div><div class="line">                <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当访问 UI 时，ViewRootImpl 会调用 checkThread 方法去检查当前访问 UI 的线程是否为创建 UI 的那个线程，如果不是。则会抛出异常。但是<strong>为什么一开始在 MainActivity 的 onCreate 方法中创建一个子线程访问 UI，程序还是正常能跑起来呢</strong>？    </p>
<blockquote>
<p>  上述例子中的 Thread 执行时，ViewRootImpl 还没创建，ViewRootImpl 无法对 view tree 的根节点 DecorView 执行 performTraversals，view tree 里的所有 View 都没有被赋值 mAttachInfo（注：AttachInfo 中存储了一组信息。当 View 被连接到它的父节点时，会给这个 View 的 AttachInfo 赋值）。</p>
<p>  在 onCreate 完成时，Activity 并没有完成初始化 view tree。<strong>view tree 的初始化是从 ViewRootImpl 执行 performTraversals 开始</strong>，这个过程会对 view tree 进行从根节点 DecorView 开始的遍历，对所有视图完成初始化，初始化包括视图的大小布局，以及 AttachInfo，ViewParent 等属性域的初始化。</p>
</blockquote>
<p><code>ImageView#setImageResource</code>触发的调用流程 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ImageView#setImageResource </div><div class="line">  --&gt;  如果最新资源的宽度或者高度跟已有的不同，</div><div class="line">  	--&gt; View#requestLayout</div><div class="line">  		--&gt; 满足条件，最终会调用 ViewRootImpl#requestLayout</div><div class="line">	--&gt;  View#invalidate </div><div class="line">		--&gt;  View#invalidate(boolean)</div><div class="line">      		--&gt;  View#invalidateInternal //如果 </div><div class="line">  			if mAttachInfo 以及 mParent 都不为空</div><div class="line">      			--&gt; ViewGroup#invalidateChild</div><div class="line">      				//这里会不断循环去取上一个结点的 mParent,一直到 mParent == null 也就是到达顶部 View 为止</div><div class="line">                        --&gt;  ViewRootImpl#invalidateChildInParent // 注意 DecorView 的 mParent 是 ViewRootImpl</div><div class="line">                            --&gt;  ViewRootImpl#checkThread //在这里执行 checkThread，如果当前线程不是创建 UI 的线程则抛出异常</div><div class="line">             else</div><div class="line">        </div><div class="line">----------------------------------------------------------------------</div><div class="line">//View#invalidateInternal </div><div class="line"></div><div class="line">final AttachInfo ai = mAttachInfo;</div><div class="line">final ViewParent p = mParent;</div><div class="line">//只有当 mAttachInfo 以及 mParent 都不为空时，才会触发重绘</div><div class="line">if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class="line">    //....</div><div class="line">    p.invalidateChild(this, damage);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述流程可以看出，只有在 mAttachInfo 以及 mParent 都不为空时， <code>ViewGroup#invalidateChild</code> 才会被调用，该方法最终会触发 checkThread，而向上面所提到的， onCreate 方法调用时 ViewRootImpl 还未创建， mAttachInfo 以及 mParent 均为 null，所以在子线程修改 UI 不会报错。</p>
<p>但是这个时候对 View 的修改是有效果的。那么，ViewRootImpl 创建之前的，程序对 UI 的更新操作是如何进行的呢？在最初的<code>ImageView#setImageResource</code> 方法中已经将要图片资源 id 赋给了ImageView 的一个属性 mResource ，等到 ViewRootImpl  创建完毕之后就可以得到更新了。</p>
<h3 id="ViewRootImpl-何时被创建？"><a href="#ViewRootImpl-何时被创建？" class="headerlink" title="ViewRootImpl 何时被创建？"></a>ViewRootImpl 何时被创建？</h3><p>回过头看，抛异常的方法既然是 ViewRootImpl 中的方法，那首先应该去看看 ViewRootImpl 是在哪里、在什么时候被创建的。</p>
<p>如果你对 Activity 的启动流程有所了解，应该知道，Activity 的启动与生命周期都是由 ActivityThread 相应的方法触发的。我们知道每一个 Activity 都有一个顶级 View ——DecorView，当 Activity 中的视图显示出来的时候 DecorView 肯定已经创建完毕了。而 ViewRootImpl 作为 DecorView 与 WindowManager 之间的「桥梁」，应该也是在视图变得可见之前被创建出来的。说到视图可见与否，一般都会想起 onResume（实际上 onResume 调用时，Activity 的视图也不一定可见）。</p>
<p>从<code>ActivityThread#handleLaunchActivity</code> 方法出发，查看其调用流程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ActivityThread#handleLaunchActivity</div><div class="line">	--&gt; performLaunchActivity //创建 Activity </div><div class="line">    *--&gt; handleResumeActivity</div><div class="line">        --&gt; performResumeActivity//回调 onResume</div><div class="line">            --&gt;  Activity#performResume();</div><div class="line">                --&gt; Instrumentation#callActivityOnResume</div><div class="line">                    --&gt; Activity#onResume();//回调 onResume </div><div class="line">      **--&gt; Activity#makeVisible();</div><div class="line">            --&gt; WindowManagerGlobal#addView()</div><div class="line">                --&gt; root = new ViewRootImpl(view.getContext(), display);//创建 ViewRootImpl</div><div class="line">                --&gt; ViewRootImpl#setView</div></pre></td></tr></table></figure>
<p>从上述流程可以看出，ViewRootImpl 是在 WindowManagerGlobal#addView() 方法中被创建出来的。并且是在 Activity#onResume 方法调用之后才被创建。因此我们如果在 onResume 方法中创建一个子线程去修改 UI，大多数情况下也是可以成功的。</p>
<h2 id="一个在子线程更新-UI-的栗子："><a href="#一个在子线程更新-UI-的栗子：" class="headerlink" title="一个在子线程更新 UI 的栗子："></a>一个在子线程更新 UI 的栗子：</h2><p>创建一个 handlerThread并调用它的 start 方法，获取handlerThread 中的 looper 构造一个  Handler。在该 Handler的 handleMessage方法（运行在子线程） 中将 view 添加到 WindowManger里面，并支持进行更新操作。</p>
<p><a href="https://github.com/TimLin-pro/UpdateUiOnSubThread/blob/master/app/src/main/java/com/timlin/updateuionsubthread/ManageUiOnHandlerThreadActivity.java" target="_blank" rel="noopener">示例代码地址</a></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>ViewRootImpl 的创建在 onResume 方法回调之后，而我们一开篇是在 onCreate 方法中创建了子线程并访问 UI，在那个时刻，ViewRootImpl 还没有创建，我们在子线程调用 了 ImageView#setImageResource，虽然可能会触发 View#requestLayout 和 View#invalidate() ，但是由于 ViewRootImpl还未创建出来，因此 ViewRootImpl#checkThread 没有被调用到，也就是说，检测当前线程是否是创建的 UI 那个线程 的逻辑没有执行到，所以程序没有崩溃一样能跑起来。而之后修改了程序，让线程休眠了 300 毫秒后，程序就崩了。很明显 300 毫秒后 ViewRootImpl 已经创建了，可以执行 checkThread 方法检查当前线程。</p>
<p>开篇的例子中我们在 onCreate 方法中创建的子线程访问 UI 是一种极端的情况。实际开发中不会这么做。</p>
<h4 id="下次如果有人问你-Android-中子线程真的不能更新-UI-吗？-你可以这么回答："><a href="#下次如果有人问你-Android-中子线程真的不能更新-UI-吗？-你可以这么回答：" class="headerlink" title="下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答："></a>下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答：</h4><p>任何线程都可以更新自己创建的 UI。只要保证满足下面几个条件就好了</p>
<ul>
<li><p>在 ViewRootImpl 还没创建出来之前</p>
<ul>
<li>UI 修改的操作没有线程限制。</li>
</ul>
</li>
<li><p>在 ViewRootImpl 创建完成之后</p>
<ol>
<li><p>保证「创建 ViewRootImpl 的操作」和「执行修改 UI 的操作」在同一个线程即可。也就是说，要在同一个线程调用 ViewManager#addView 和 ViewManager#updateViewLayout 的方法。</p>
<ul>
<li>注：ViewManager 是一个接口，WindowManger 接口继承了这个接口，我们通常都是通过 WindowManger（具体实现为 WindowMangerImpl） 进行 view 的 add remove update 操作的。</li>
</ul>
</li>
<li><p>对应的线程需要创建 Looper 并且调用 Looper#loop 方法，开启消息循环。</p>
</li>
</ol>
</li>
</ul>
<h4 id="有同学可能会问，保证上述条件-1-成立，不就可以避免-checkThread-时候抛出异常了吗？为什么还需要开启消息循坏？"><a href="#有同学可能会问，保证上述条件-1-成立，不就可以避免-checkThread-时候抛出异常了吗？为什么还需要开启消息循坏？" class="headerlink" title="有同学可能会问，保证上述条件 1 成立，不就可以避免 checkThread 时候抛出异常了吗？为什么还需要开启消息循坏？"></a>有同学可能会问，保证上述条件 1 成立，不就可以避免 checkThread 时候抛出异常了吗？为什么还需要开启消息循坏？</h4><ul>
<li>条件 1 可以避免检查异常，但是无法保证 UI 可以被绘制出来。</li>
<li>条件 2 可以让更新的 UI 效果呈现出来<ul>
<li>WindowManger#addView 最终会调用 WindowManageGlobal#addView 方法，进而触发ViewRootImpl#setView 方法，该方法内部会调用 ViewRootImpl#requestLayout 方法。</li>
<li>了解过 UI 绘制原理的同学应该知道 下一步就是 scheduleTraversals 了，该方法会往消息队列中插入一条消息屏障，然后调用 Choreographer#postCallback 方法，往 looper 中插入一条异步的 MSG_DO_SCHEDULE_CALLBACK 消息。等待垂直同步信号回来之后执行。<ul>
<li>注：ViewRootImpl 有一个 Choreographer  成员变量，ViewRootImpl 的构造函数中会调用 Choreographer#getInstance(); 方法，获取一个当前线程的 Choreographer 局部实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="使用子线程更新-UI-有实际应用场景吗？"><a href="#使用子线程更新-UI-有实际应用场景吗？" class="headerlink" title="使用子线程更新 UI 有实际应用场景吗？"></a>使用子线程更新 UI 有实际应用场景吗？</h4><p>Android 中的  SurfaceView 通常会通过一个子线程来进行页面的刷新。如果我们的自定义 View 需要频繁刷新，或者刷新时数据处理量比较大，那么可以考虑使用 SurfaceView 来取代 View。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://blog.csdn.net/xyh269/article/details/52728861" target="_blank" rel="noopener">Android 中子线程真的不能更新 UI 吗？</a></li>
<li><a href="http://blog.csdn.net/u010198148/article/details/51779567" target="_blank" rel="noopener">多线程学习之–真的不能在子线程里更新 UI 吗？</a></li>
<li><a href="https://www.zybuluo.com/natsumi/note/736165" target="_blank" rel="noopener">互联网笔记 Android 中子线程真的不能更新 UI 吗？</a></li>
<li><a href="https://www.zhihu.com/question/24764972/answer/36053366" target="_blank" rel="noopener">Android 只在 UI 主线程修改 UI，是个谎言吗？ 为什么这段代码能完美运行？</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> 探究 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 探究 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RxJava中switchMap和flapMap 有何区别？]]></title>
      <url>https://timlin-pro.github.io/blog/2020/03/20/RxJava%E4%B8%ADswitchMap%E5%92%8CflapMap-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>flapMap 和 switchMap 都是 RxJava 中的转换操作符，都可以将上游的输入转换为一个数据源（比如 Observable）输出给下游。</p>
<a id="more"></a>
<h2 id="switchMap-的使用场景"><a href="#switchMap-的使用场景" class="headerlink" title="switchMap 的使用场景"></a>switchMap 的使用场景</h2><ul>
<li><p>switchMap 的使用场景：监听用户在输入框输入的内容，定时触发搜索并展示结果</p>
<ol>
<li><p>创建一个 <code>PublishSubject&lt;String&gt;</code></p>
</li>
<li><p>输入框中的文字变化的时候，调用 onNext 方法发布变更</p>
</li>
<li><p>使用 debounce 去抖动，避免频繁触发</p>
</li>
<li><p>使用 switchMap 切换到搜索网络请求</p>
</li>
<li><p>subscribe 处理搜索结果（也可以加一个 map 操作），并更新 UI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mExecSearchDisposable = searchObservable</div><div class="line">    <span class="comment">//防抖</span></div><div class="line">    .debounce(<span class="number">100</span>, TimeUnit.MILLISECONDS, BearSchedulers.mainThread())</div><div class="line">    <span class="comment">//有变化才往下游发送</span></div><div class="line">    .distinctUntilChanged()</div><div class="line">    .toFlowable(BackpressureStrategy.LATEST)</div><div class="line">    <span class="comment">//对上游的输入（用户输入的搜索关键字）进行查询；如果有新的输入，旧的输入还未拿到查询结果，则旧的查询结果会直接丢弃。</span></div><div class="line">    .switchMap &#123; s -&gt;</div><div class="line">			<span class="comment">//如果输入为空串，则展示空页面</span></div><div class="line">      <span class="keyword">if</span> (s.isEmpty()) &#123;</div><div class="line">            Flowable.just(Notification.createOnError(EmptySearchException()))</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//显示 loading</span></div><div class="line">            view.loading()</div><div class="line">              <span class="comment">//构建搜索参数</span></div><div class="line">            val params = buildSearchParams(s)</div><div class="line">              <span class="comment">//有网络，执行网络查询，无网络，执行本地数据库查询</span></div><div class="line">            val searchFlowable = <span class="keyword">if</span> (connectionService.networkState.isConnected) &#123;</div><div class="line">                mSearchDataRepository.searchFromNet(params)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mSearchDataRepository.searchFromDb(params)</div><div class="line">            &#125;</div><div class="line">            searchFlowable.observeOn(BearSchedulers.computation())</div><div class="line">                    .map &#123;</div><div class="line">                        val resultList = resolveResponse(it)</div><div class="line">                        Notification.createOnNext(resultList)</div><div class="line">                    &#125;</div><div class="line">                    .onErrorReturn &#123; Notification.createOnError(it) &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    .observeOn(BearSchedulers.mainThread())</div><div class="line">    .subscribe &#123; notification -&gt;</div><div class="line">        <span class="keyword">if</span> (notification.isOnNext) &#123;</div><div class="line">          <span class="comment">//刷新 UI</span></div><div class="line">            view.refreshUi(notification.value, <span class="keyword">false</span>)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (notification.isOnError) &#123;</div><div class="line">            <span class="keyword">if</span> (notification.error is EmptySearchException) &#123;</div><div class="line">                view.refreshUi(Collections.emptyList(), <span class="keyword">true</span>)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                view.onError(notification.error?.message)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>如果使用 flatMap，则搜索结果有可能是过时的，因为客户端拿到的搜索结果 顺序有可能是乱序的。（网络请求的时延不可控）</p>
<ul>
<li>为了解决该问题，可以通过 switchMap，因为switchMap 保证新的 Observable 提供的时候， 旧的 Observable 会被取消掉。</li>
</ul>
</li>
</ul>
<h2 id="大理石图"><a href="#大理石图" class="headerlink" title="大理石图"></a>大理石图</h2><ul>
<li><p>switchMap ；因为在发出第二个绿色方块之前，上游输入一个 深蓝色珠子，因此第二个绿色方块之前被丢弃</p>
<p><img src="https://img.mubu.com/document_image/b9064af5-a131-423b-95c8-9e6653d3e42c-4072084.jpg" alt="img"></p>
</li>
<li><p>flatMap，虽然深蓝色的珠子紧随绿色珠子，但是，第二个绿色方块也正常发送了出去，只不过，顺序乱了（这里的 「乱」指的是，第二个绿色方块没有在蓝色的第一个方块之前发出）</p>
<p><img src="https://img.mubu.com/document_image/5dccd09c-af63-4a6a-8bda-cfc7d4c30ad0-4072084.jpg" alt="img"></p>
</li>
</ul>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ul>
<li>flatMap 适用于各个结果都有用，不管它们的先后时间</li>
<li>switchMap就像flatMap，<strong>但它仅保留最新的观察到结果。过时的事件会被丢弃掉。</strong><ul>
<li>怎么样算过期？<ul>
<li>假设 Observable1 事件还没发送完，此时有了新的 Observable2 ，则Observable1 未发布的/未转换完的事件就不会发送出去了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://lorentzos.com/improving-ux-with-rxjava-4440a13b157f" target="_blank" rel="noopener">https://lorentzos.com/improving-ux-with-rxjava-4440a13b157f</a></li>
<li><a href="https://www.jianshu.com/p/33c548bce571" target="_blank" rel="noopener">https://www.jianshu.com/p/33c548bce571</a></li>
<li><a href="https://stackoverflow.com/questions/28175702/what-is-the-difference-between-flatmap-and-switchmap-in-rxjava" target="_blank" rel="noopener">https://stackoverflow.com/questions/28175702/what-is-the-difference-between-flatmap-and-switchmap-in-rxjava</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> RxJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RxJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于EditText几个小Tips]]></title>
      <url>https://timlin-pro.github.io/blog/2019/10/31/%E5%85%B3%E4%BA%8EEditText%E5%87%A0%E4%B8%AA%E5%B0%8FTips/</url>
      <content type="html"><![CDATA[<h3 id="1-显示清除按钮"><a href="#1-显示清除按钮" class="headerlink" title="1.显示清除按钮"></a>1.显示清除按钮</h3><p>最简便的方式：利用 kotlin 拓展函数，通过 TextView#setCompoundDrawablesWithIntrinsicBounds 方法实现</p>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> EditText.<span class="title">setupClearButtonWithAction</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">    addTextChangedListener(<span class="keyword">object</span> : TextWatcher &#123;</div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTextChanged</span><span class="params">(editable: <span class="type">Editable</span>?)</span></span> &#123;</div><div class="line">            <span class="keyword">val</span> clearIcon = <span class="keyword">if</span> (editable?.isNotEmpty() == <span class="literal">true</span>) R.drawable.ic_clear <span class="keyword">else</span> <span class="number">0</span></div><div class="line">            setCompoundDrawablesWithIntrinsicBounds(<span class="number">0</span>, <span class="number">0</span>, clearIcon, <span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, count: <span class="type">Int</span>, after: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(s: <span class="type">CharSequence</span>?, start: <span class="type">Int</span>, before: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> = <span class="built_in">Unit</span></div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    setOnTouchListener(View.OnTouchListener &#123; _, event -&gt;</div><div class="line">        <span class="keyword">if</span> (event.action == MotionEvent.ACTION_UP) &#123;</div><div class="line">            <span class="keyword">if</span> (event.rawX &gt;= (<span class="keyword">this</span>.right - <span class="keyword">this</span>.compoundPaddingRight)) &#123;</div><div class="line">                <span class="keyword">this</span>.setText(<span class="string">""</span>)</div><div class="line">                <span class="keyword">return</span><span class="symbol">@OnTouchListener</span> <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span><span class="symbol">@OnTouchListener</span> <span class="literal">false</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-禁止复制粘贴"><a href="#2-禁止复制粘贴" class="headerlink" title="2.禁止复制粘贴"></a>2.禁止复制粘贴</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> TextView.<span class="title">disableCopyPaste</span><span class="params">()</span></span> &#123;</div><div class="line">    isLongClickable = <span class="literal">false</span></div><div class="line">    setTextIsSelectable(<span class="literal">false</span>)</div><div class="line">    customSelectionActionModeCallback = <span class="keyword">object</span> : ActionMode.Callback &#123;</div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateActionMode</span><span class="params">(mode: <span class="type">ActionMode</span>?, menu: <span class="type">Menu</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPrepareActionMode</span><span class="params">(mode: <span class="type">ActionMode</span>?, menu: <span class="type">Menu</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActionItemClicked</span><span class="params">(mode: <span class="type">ActionMode</span>?, item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyActionMode</span><span class="params">(mode: <span class="type">ActionMode</span>?)</span></span> &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-仅支持输入可打印的-ASCII-值"><a href="#3-仅支持输入可打印的-ASCII-值" class="headerlink" title="3.仅支持输入可打印的 ASCII 值"></a>3.仅支持输入可打印的 ASCII 值</h3><p>可打印的 ASCII 字符，可以通过遍历 1~128 ，将其强转为 char 类型实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</div><div class="line">     System.out.print((<span class="keyword">char</span>) i);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>!”#$%&amp;’()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~</p>
</blockquote>
<p>因为 “ 、回车、 空格、’、 &amp;、&lt; 、&gt; 需要进行转义，才能在 android 的 xml 中使用。对照如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&amp;#34; 或 &amp;quot;   			&quot;		</div><div class="line">\n										回车</div><div class="line">&amp;#160;								空格</div><div class="line">&amp;#39; 或 &amp;apos; 				&apos;</div><div class="line">&amp;#38; 或 &amp;amp;					&amp;</div><div class="line">&amp;#60; 或 &amp;lt;					&lt;</div><div class="line">&amp;#62; 或 &amp;gt;					&gt;</div></pre></td></tr></table></figure>
<p>若直接使用字符，比如 &lt;，会报错：</p>
<blockquote>
<p>The value of attribute “android:digits” associated with an element type “EditText” must not contain the ‘&lt;’ character.</p>
</blockquote>
<p>因此，在 xml 文件中给 EditText 指明 digits 属性为即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:digits="!#$%&amp;amp;'()*+,-./0123456789:;&amp;lt;=&amp;gt;@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&amp;#34;"</div></pre></td></tr></table></figure>
<p><a href="https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html#IME_FLAG_FORCE_ASCII" target="_blank" rel="noopener">另一种方式</a>，可以改变键盘的<strong>初始状态</strong>：imeOptions=”flagForceAscii” </p>
<p>也可以在代码中，通过 setTextFilter 来实现。</p>
<p>判断是否为 ASCII</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isASCII</span><span class="params">(String s)</span>  </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) </div><div class="line">        <span class="keyword">if</span> (s.charAt(i) &gt; <span class="number">127</span>) </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[迁移到AndroidX]]></title>
      <url>https://timlin-pro.github.io/blog/2019/10/27/%E5%BF%AB%E9%80%9F%E8%BF%81%E7%A7%BB%E5%88%B0%20AndroidX/</url>
      <content type="html"><![CDATA[<p>Android Studio 提供的 Migrate to AndroidX 功能不是特别完善，很多文件的包名替换不完整。可以通过自定义脚本来处理这个流程。</p>
<a id="more"></a>
<p>包名映射文件下载地址： <code>https://developer.android.com/topic/libraries/support-library/downloads/androidx-class-mapping.csv</code></p>
<p>脚本文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env bash</div><div class="line"></div><div class="line">MAPPING_FILE=csv文件路径</div><div class="line">PROJECT_DIR=项目目录</div><div class="line"></div><div class="line">replace=&quot;&quot;</div><div class="line">while IFS=, read -r from to</div><div class="line">do</div><div class="line">	replace+=&quot;; s/$from/$to/g&quot;</div><div class="line">done &lt;&lt;&lt; &quot;$(cat $MAPPING_FILE)&quot;</div><div class="line">fd . $PROJECT_DIR -e kt -e java -e xml --print0 | xargs -0 gsed -i &quot;$replace&quot;</div></pre></td></tr></table></figure>
<p>注：mac 需要安装 fd 和 gnu-sed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install fd # fd 是 find 命令的替代品</div><div class="line">brew install gnu-sed</div></pre></td></tr></table></figure>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://gist.github.com/dlew/5db1b780896bbc6f542e7c00a11db6a0" target="_blank" rel="noopener">https://gist.github.com/dlew/5db1b780896bbc6f542e7c00a11db6a0</a></li>
<li><a href="https://gist.github.com/dudeinthemirror/cb4942e0ee5c3df0fcb678d1798e1d4d" target="_blank" rel="noopener">https://gist.github.com/dudeinthemirror/cb4942e0ee5c3df0fcb678d1798e1d4d</a></li>
<li><a href="https://developer.android.com/jetpack/androidx/migrate" target="_blank" rel="noopener">迁移到 AndroidX</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[保险基础知识]]></title>
      <url>https://timlin-pro.github.io/blog/2019/05/26/%E4%BF%9D%E9%99%A9%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="1、为什么要买保险？"><a href="#1、为什么要买保险？" class="headerlink" title="1、为什么要买保险？"></a>1、为什么要买保险？</h2><p>购买保险是为了减少预期以外的事件对被保险人的财务状况造成冲击，为受益人提供经济补偿减轻负担。<strong>用经济学原理来解释就是被保险人通过缴纳保费换取未来财务状况更大的确定性</strong>。</p>
<a id="more"></a>
<blockquote>
<p>假设没买保险前，你未来财富现值的范围是 [-50 万元，200 万元]，有负值的原因可能是各种财富损失，比如家里大火，比如治病过程中支付的高额医疗费用；而通过购买保险，你的未来财富现值的范围可能变成 [80 万，190 万]，虽然最大值因为要交保费而变小了，但是波动范围更加确定了（这个例子中波动范围从 250 万缩小到 110 万，所以未来更确定了)。</p>
</blockquote>
<p><strong>50w 保额 20 年后很可能就不值钱了，买保险还有意义吗</strong>？</p>
<blockquote>
<p>买保险其实买的是保障。假设你买一个 50w 保额的重疾险，缴费期为 30 年。然后购买之后缴了1 年就出险了，你立刻就能拿到 <strong>50w</strong>，而且后面的保费都从此不用缴了。如果买的是多次赔付重疾，除了这次出险赔付的疾病外，后面如果得了其他满足赔付条件的其他疾病，还能再次得到赔付。</p>
</blockquote>
<p>其实通胀对所有资产类型都有影响。</p>
<p>无论是现金、存款、股票、房产，都或多或少会受到通货膨胀的影响。除非你马上、立刻、当下、就把这钱花了。通货膨胀所带来的保额缩水，确实是一个客观存在的事实，但它是资产整体的变化，而不是保险本身带来的问题。短期内的通货膨胀对我们的影响其实很小，但是保险交完马上有保障（等待期结束之后）。</p>
<blockquote>
<p><strong>别用看理财产品的眼光，去要求一种风险管理工具。</strong></p>
<p><strong>最好的抗通胀工具，是你的赚钱能力。</strong></p>
</blockquote>
<p><strong>多数人的重疾保障是不足的</strong>。</p>
<p>很多人除了国家强制缴纳的五险之外，没有给自己购买其他保险。而五险并没有保障重疾。可能部分企业为员工投保了员工保险福利计划，也就是商业性团体保险。如果就职所在公司或单位已为员工购买了商业团体保险，可以进一步看一下保障计划组合内是否有提供相关的重疾保障。</p>
<p>但是，公司给员工买的保险，通常都是一年期的短期险，当员工离职之后也就不再保障了。所以，条件允许的情况下，还是自己购买一份长期的保险比较稳妥。</p>
<h2 id="2、保险的分类"><a href="#2、保险的分类" class="headerlink" title="2、保险的分类"></a>2、保险的分类</h2><p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/%E4%BF%9D%E9%99%A9%E5%88%86%E7%B1%BB.jpg" alt=""></p>
<h3 id="一、财产保险"><a href="#一、财产保险" class="headerlink" title="一、财产保险"></a>一、财产保险</h3><p>财产保险，又称产物保险，是以各种财产及其相关利益为保险标的的保险。财产保险是一种社会化的经济补偿制度，其主要目的是补偿投保人或者被保险人的经济损失。</p>
<p>大家比较熟悉的机动车辆保险也称汽车保险或车险，是财产保险的一种， 以车辆本身及第三者责任为保险标的。主要保障因车祸或者自然灾害导致的损失。其保险标的，主要是车辆。</p>
<h3 id="二、人身险"><a href="#二、人身险" class="headerlink" title="二、人身险"></a>二、人身险</h3><p>人身险，是以人的寿命和身体作为投保标的保险。在中国，人身险又分为社会强制保险和商业保险两大类。</p>
<p>我们日常中常说「五险一金」：</p>
<ul>
<li>「五险」其实就是指「社会保险」，简称社保，包括养老保险、医疗保险、生育保险、工伤保险、失业保险。</li>
<li>「一金」指的是住房公积金。</li>
</ul>
<p><strong>人寿保险、意外险、重疾险这几个险种是相互补充的关系</strong>。</p>
<p><strong>买了重疾险就不用买寿险</strong>？<strong>非也</strong>。重疾险的身故责任是和重疾共享保额的。就是说，如果小明患了重疾，然后保险公司就把钱赔给他，身故保障责任就完全终止了。如果小明重疾不治而亡，保险公司就不会赔他身故费用。而且重疾险的治疗费用高昂，如果你买了 30/50 万的保额，钱很容易就花光了，寿险责任则明显不足。</p>
<p><strong>买了意外险就不用买寿险</strong>？<strong>非也</strong>。举个栗子，意外险一般是不保猝死风险的。猝死的内涵可以概括为 “因病突然死亡”。而意外险是不保因病而伤残和死亡的。所以这个只能在重疾险和寿险里面赔付。相对而言，寿险的范围要广很多。</p>
<p><strong>买了重疾险就不用买意外险？非也。</strong>举个栗子来说明一下～A 先生购买了一份 100 万保额的重疾险，没购买意外险。在某次驾车过程中，不小心发生了车祸，造成左手中指功能丧失、无名指和食指缺失。不符合保险合同约定的疾病定义，无法获得赔付。</p>
<p><strong>大部分商业保险主要为以下三种类型</strong>：</p>
<ol>
<li>给付型：即发生保险事故或符合理赔条件时，保险公司按照合同约定的金额一次性或分固定的多次将保额支付给被保险人。比如重疾险。</li>
<li>报销型/补偿型：即发生保险事故或符合理赔条件时，保险公司将被保险人因为出险事件实际支出或实际损失，将在保额范围内的金额支付给被保险人。类似于二次报销的防癌险。比如二次报销型的医疗保险。</li>
<li>津贴型：主要用于发生保险事故时，被保险人不能参加工作造成的收入损失，以及因为住院治疗产生的必要间接费用等的损失的赔付，一般是按保险合同约定的金额支付。</li>
</ol>
<h4 id="人身保险的类型"><a href="#人身保险的类型" class="headerlink" title="人身保险的类型"></a>人身保险的类型</h4><p>每个国家的保险划分都是不同的。在中国，人身保险是指以人的寿命和身体为保险标的的一种保险，分为三种：寿险、健康险和意外险。</p>
<p>在市面上单独销售的寿险，最长只会保障到 70 周岁。</p>
<ul>
<li>人寿保险：是一种以人的生死为保险对象的保险，是被保险人在保险责任期内生存或死亡，由保险人根据契约规定给付保险金的一种保险。在中国人寿保险的业务范围包括生存保险、死亡保险、两全保险。</li>
<li>健康保险：是以非意外伤害而由被保险人本身疾病导致的伤残、死亡为保险条件的保险。</li>
<li>意外伤害保险：是以人的身体遭受意外伤害为保险条件的保险。</li>
</ul>
<p><strong>什么是长期险和短期险</strong>？</p>
<p>长期险：保险期为一年以上的保险，多数是寿险（包括两全、定期寿险和终身寿险，分红型或非分红型）和健康险中的重疾险</p>
<p>短期险：保险期为一年及以下的保险，多数是意外险（当然现在长期意外险也不少见了）和健康险中的医疗险，因为这些产品理赔经验波动很大，做成短期险方便调整费率或终止销售。</p>
<p>对于人身险，如果有长期产品购买就购买长期的，不推荐购买短期产品，正是因为一般不保证下一年能续保，通常也不保证费率的因素。</p>
<p><strong>理财型 vs 保障型保险</strong></p>
<p>理财型保险，顾名思义，是一种理财兼顾保险作用的产品。保费分为两部分，一部分保费用来提供保险保障（例如身故返还等），而另一部分用来投资。</p>
<p>精算师认为，<strong>对于理财型保险，应更多的将其视为理财产品而非保险</strong>，如果需要的是风险保障，那么还是购买传统保障型产品更合适。</p>
<p>通常，理财型保险的保障不足，理财的收益也不高，所以，一般建议如果需要的是风险保障，那么还是购买传统保障型产品更合适。如果需要理财，那么购买专业的理财产品收益率会更加可观。</p>
<h2 id="3、重疾"><a href="#3、重疾" class="headerlink" title="3、重疾"></a>3、重疾</h2><p>什么是重疾保障？保险产品中的重疾定义是有严格规定的。简单来说根据中国保险监督管理委员会（简称「保监会」）产品监管要求，能冠名重疾产品的保险产品必须按中国保险行业协会与中国医师协会的重疾定义提供以下 6 种保障：<strong>恶性肿瘤、急性心肌梗塞、脑中风后遗症、重大器官移植术或造血干细胞移植术、冠状动脉搭桥术和终末期肾病</strong>。只有保障了这 6 种核心重疾的产品才能被命名为 “XX 重大疾病保险”，这6种重疾已经占到一般人群所有重疾发病的  80%-85%。</p>
<p>重疾险属于给付型的健康险。绝大多数<strong>重疾险按给付方式只分为两种</strong>：</p>
<ol>
<li><strong>提前给付型</strong>：重大疾病保险金与产品或产品组合里包含的任何身故保险金责任共用保额，也就是身故或重疾哪个先发生就先赔保额，但<strong>只赔付一次</strong>，赔付完之后，保单即终止失效，因此产品价格较额外给付的产品便宜。</li>
<li><strong>额外给付型</strong>：只要发生重疾就给付重大疾病保险金保额，保单继续有效，后续如果身故并且产品或产品组合里有提供身故责任的相关保险，再给付一次身故保险金，很明显由于它有<strong>可能赔付两次</strong>（先重疾一次、身故再赔一次），所以它的价格要比提前给付型产品要贵。</li>
</ol>
<h3 id="3-1-重疾保障的病种数目越大越好吗？"><a href="#3-1-重疾保障的病种数目越大越好吗？" class="headerlink" title="3.1 重疾保障的病种数目越大越好吗？"></a>3.1 重疾保障的病种数目越大越好吗？</h3><p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/%E9%87%8D%E7%96%BE%E5%8F%91%E7%97%85%E7%8E%87.jpg" alt=""></p>
<p>截止 2016 年保监会最新定义的行业标准重大疾病是 25 种，我们可以简称为 <strong>“行标 25 种，必备 6 种”</strong>。这 6+19 种一共 25 种重疾已经占到了所有重疾发生概率的 95%。目前无论保障范围是 80 种重疾，还是 100 种重疾，前 6 种病种各家保险公司定义都是相同的，19 种是如果有，需要跟标准中规定的一致。</p>
<p><strong>所以，病种数量不代表什么</strong>。对于 99% 的国人来说，遇到行业 25 种重疾之外的其他重疾概率实在是微乎其微。 </p>
<h3 id="3-2-什么是重疾分组？？"><a href="#3-2-什么是重疾分组？？" class="headerlink" title="3.2 什么是重疾分组？？"></a>3.2 什么是重疾分组？？</h3><p><strong>经常看到 “重疾分组” 这个词，是什么意思</strong>？</p>
<p>解答：某重疾险分 ABCD 四个组，假设某人得了 B 组中的疾病 B1，保险公司理赔过了，以后只管 ACD 组里的疾病，再得 B 组里的任何疾病都不赔付，这是重疾分组的涵义。分组在本质上是保险公司在回避自己的风险，因为<strong>分组后同一组别只赔付一次</strong>。</p>
<p>对于多次赔付的重疾，直观地看是不分组自然比分组的好，但重疾险不分组意味着保险公司赔付的概率更大、风险更高。所以市面上多次赔付的重疾险，不分组的比较少，价格也很高。</p>
<p><strong>购买重疾分组的产品应该怎么选</strong>？</p>
<ol>
<li>癌症（恶性肿瘤）单独分组的好过癌症不单独分组，没有单独分组但同组疾病的数量少或者没有那么高发也是比较好的情况。</li>
<li>分组多、高发疾病越分散越好。</li>
</ol>
<p>对于重疾多次赔付的产品，我们认为癌症多次赔付 &gt; 重疾不分组 &gt; 重疾分组合理 &gt; 重疾分组不合理，最好的是癌症多次赔付的。</p>
<h4 id="3-2-1分组跟不分组的有什么区别？"><a href="#3-2-1分组跟不分组的有什么区别？" class="headerlink" title="3.2.1分组跟不分组的有什么区别？"></a>3.2.1分组跟不分组的有什么区别？</h4><p>其实重疾险中最优的选择是重疾不分组且赔付多次的，比如长生福优加，它是 100 种重疾不分组，最高赔付 2 次的。当然价格也会比较贵，不分组的多次赔付重疾险会比分组的多次赔付重疾险费率要贵很多，要清楚自己的预算。</p>
<p><strong>长生福优加 &gt; 康乐一生加倍保 &gt; 常青树加倍版 &gt; 弘康多啦 A 保</strong>。</p>
<h4 id="3-2-2分组的选择原则"><a href="#3-2-2分组的选择原则" class="headerlink" title="3.2.2分组的选择原则"></a>3.2.2分组的选择原则</h4><p>1、恶性肿瘤最好单独分组，这个最重要。<br>2、恶性肿瘤、终末期肾病、重大疾器官移植术或造血干细胞移植术，这三类重疾的内在关联性较强，最好可以把它们分配到不同组别。<br>3、急性心梗后要马上实施冠状动脉搭桥手术，时间间隔非常短，如果分组了，要注意间隔期。</p>
<h3 id="3-3赔付多少次的最佳？"><a href="#3-3赔付多少次的最佳？" class="headerlink" title="3.3赔付多少次的最佳？"></a>3.3赔付多少次的最佳？</h3><p>其次买重疾险，赔付次数 2~4 次最佳，虽然市面上现在出现了很多可赔付 5 次、6 次，甚至 7 次的重疾险，但这其实是保险公司为了降低赔付率从而做出的选择。</p>
<p>其实重疾赔付 2 次，轻症 3 次基本已经足够了，次数太多并无太大的实质意义。除此之外，赔付间隔 90 天～180 天最佳，1 年间隔期太长，不建议选购。</p>
<h2 id="4、中症"><a href="#4、中症" class="headerlink" title="4、中症"></a>4、中症</h2><p>中症就是处于轻症和重疾险之间的情况，比轻症严重一点，但是还没有达到重疾的严重程度，但是理赔的金额也比轻症会更多一些。</p>
<h2 id="5、轻症"><a href="#5、轻症" class="headerlink" title="5、轻症"></a>5、轻症</h2><p>轻症又叫做<strong>轻度重疾</strong>，也就是说这个病也是病，但没有重疾、中症那么严重，不过如果没有得到及时的发现或者治疗，任由其发展，那么很大概率会造成重疾。比如说癌症的前期表现就是原位癌，脑炎后遗症的前期就是脑炎，脑中风后遗症的前期是轻微脑中风等等。</p>
<h2 id="6、小保险公司靠谱吗？我买的保单安不安全，最后能不能赔？"><a href="#6、小保险公司靠谱吗？我买的保单安不安全，最后能不能赔？" class="headerlink" title="6、小保险公司靠谱吗？我买的保单安不安全，最后能不能赔？"></a>6、小保险公司靠谱吗？我买的保单安不安全，最后能不能赔？</h2><p>在中国如果某个公司要经营保险业务，要卖保单给自然人或企业，根据保险法，<strong>这个公司必须持有保监会批准的保险业务经营许可牌照，并接受偿付能力监管</strong>。<strong>而保险公司牌照是稀缺资源</strong>。据说各种在保监会排队等批牌照的公司目前超过了 100 家。</p>
<p><strong>从对保险公司偿付能力监管来看，中国是目前世界上保险业监管水平最全面最先进的国家之一</strong>。</p>
<p>中国保险业的偿付能力二代监管规则，业内简称 C-ROSS，是以风险为导向的新一代偿付能力监管规则。具体怎么计算实在太专业了，这里就不展开了。简单来说，根据监管要求和指引，在每季末、每年末保险公司会通过建立详尽的数学模型和压力测试后能确保<strong>自己有能力在 99.5% 的概率下无论发生什么事件都不会倒闭</strong>。</p>
<p>也就是说，在中国买保险不用看公司大小，因为门槛高，监管严，即使真破产了 zf 也会兜底，所以主要看产品的性价比。</p>
<p>一个故事：</p>
<blockquote>
<p>2008年金融危机的时候，大多数人只知道雷曼兄弟破产，却不知道当时还有一家规模类似的公司也濒临破产的边缘。它就是友邦保险 AIA 的母公司 AIG —— 美国国际集团。<br>AIG 从大家熟悉的美亚财险起家，1919 年成立于上海，可以说和中国有着很深的联系。到现在，AIG 旗下的友邦保险 AIA，仍是国内唯一一家独资的外资保险公司。在美国，AIG 也是工商银行最大的包销商。<br>金融危机到来的时候，AIG 也面临了严重的流动性危机。<br>美国政府在对待两家公司的态度上，可以说是天壤之别。一边眼睁睁的看着雷曼兄弟破产，一边就在雷曼破产的第二天，为 AIG 提供了 850 亿美金的贷款，前前后后一共花了 1820 亿美金救援 AIG ，几乎相当于把 AIG 国有化了。（当然，我估计还是美国政府太穷，没钱，救不起两家公司。哈哈哈。）<br>这是美国历史上最大规模的一次政府对企业资金援助的行为。</p>
<p>浅层的理解，雷曼兄弟是家投资银行，投资的钱嘛，基本算是闲余资金，投资这件事，本身就是要承担风险的，赔了也只能认命。AIG 公司里躺着美国无数老百姓的养老金，这要是打了水漂，社会稳定都成问题。所以美国政府舍「雷曼」保「AIG」，是为了保持社会稳定，降低动荡的可能性。</p>
<p>更深层次的原因，经济学上有一个概念，「大到不能倒」（Too Big to Fail，缩写 TBTF），指当一些规模极大或在产业中具有关键性重要地位的企业濒临破产时，政府不能等闲视之，甚至要不惜投入公帑相救，以避免那些企业倒闭后所掀起的巨大连锁反应造成社会整体更严重的伤害，这种情况称为 「大到不能倒」。<br>不是只大就行，必须是倒闭了会产生对社会经济有巨大影响的系统性风险。</p>
</blockquote>
<h2 id="7、市面上几款重疾保险产品"><a href="#7、市面上几款重疾保险产品" class="headerlink" title="7、市面上几款重疾保险产品"></a>7、市面上几款重疾保险产品</h2><p>按照赔付次数分，重疾保险产品可分为单次和多次。多次赔付的产品中根据分组与否又分为两类。下图中列举了不同类型的重疾险。具体评测请自行 google/baidu :smiley: 。</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/%E9%87%8D%E7%96%BE%E9%99%A9%E5%88%86%E7%B1%BB.png" alt=""></p>
<h2 id="8、其他"><a href="#8、其他" class="headerlink" title="8、其他"></a>8、其他</h2><p><strong>寿险保障期限选择</strong></p>
<p>个人倾向于选择保 20 年，或者保障到 70 岁。前者是因为保险期间适中，后者是因为到 70 岁，子女差不多成年并工作一段时间经济很可能已经独立，那时候万一有事也不会对子女造成太大影响</p>
<p><strong>缴费期限的选择</strong></p>
<p>缴费期限选择，大部分人建议是能缴多长就缴多长，主要原因他们认为是未来很长一段时间国内将会是低利率时代（目前一年期存款利率仅 1.5%，国外美国欧元区日本这些就更低了），而保险产品目前定价利率一般都在 3.5%，这是一个不错的 「收益」。</p>
<p><strong>等待期：</strong>设置的初衷是为了防止本身患病的人骗保，即所谓 “逆向选择”。但是普通人如果不注意这个时间，可能发生患病无法理赔的情况。一般来说，尽量选择等待期短的产品。<br><strong>免责：</strong>很多保险产品的 “陷阱” 会设置在这里。<br><strong>豁免：</strong>主要定义了一些可以免交或少交保费的情况。一旦意外发生，豁免条款可以减轻经济负担。</p>
<p><strong>主险和附加险有什么区别</strong>？</p>
<p>在个险产品范畴，主险通常单件保费较高，能支撑业务开展成本，保费中所含的费用可以打的比较高，可以单独销售。附加险保费通常比较低，如果单独销售不太能支撑业务开展成本，因此通常采用与主险搭售的形式。</p>
<p><strong>我国保险产品是有命名规则的，大致为：保险公司名称 + 可选的吉庆名字 + 具体保险类型</strong>。</p>
<p>比如复星联合优选重大疾病保险 B 款，</p>
<ul>
<li>「复星」是保险公司的的名称</li>
<li>「联合优选」是代表吉庆名字</li>
<li>「重大疾病保险 B 款」代表这产品为个人寿险中的终身寿险。</li>
</ul>
<p>通常保险产品也会取一个群众喜闻乐见的别名，比如「哆啦 A 保」、「阿童木」等等。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://www.zhihu.com/question/22316395/answer/100909780?from=profile_answer_card" target="_blank" rel="noopener">如何用保险保障自己的一生？</a></li>
<li><a href="https://www.zhihu.com/question/20745287/answer/22304813" target="_blank" rel="noopener">怎么购买一份合适的重疾险组合？</a></li>
<li>保监会官方运营的公众教育微信号：「保监微课堂」</li>
<li><a href="https://www.zhihu.com/question/33180934/answer/55997947" target="_blank" rel="noopener">为什么人身保险一般分为寿险、健康险、意外险？</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢</p>
]]></content>
      
        <categories>
            
            <category> 技术之外 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术之外 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈重构]]></title>
      <url>https://timlin-pro.github.io/blog/2018/11/14/%E6%B5%85%E8%B0%88%E9%87%8D%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="1-何谓重构"><a href="#1-何谓重构" class="headerlink" title="1.何谓重构"></a>1.何谓重构</h2><p>「重构」有两种不同含义：</p>
<ul>
<li>作为名词时的含义：软件内部结构的一种调整，目的是在不改变「软件的可视行为」前提下，提高它的可拓展性，降低修改成本。</li>
<li>作为动词时的含义：使用一系列重构的准则，在不改变「软件的可视行为」前提下，调整其结构。</li>
</ul>
<a id="more"></a>
<p>注：「软件的可视行为」的指的是程序运行时表现。</p>
<h3 id="几个常见的问题："><a href="#几个常见的问题：" class="headerlink" title="几个常见的问题："></a>几个常见的问题：</h3><h4 id="「重构」只是整理代码吗？"><a href="#「重构」只是整理代码吗？" class="headerlink" title="「重构」只是整理代码吗？"></a>「重构」只是整理代码吗？</h4><p>从某种角度而言，是的。</p>
<ul>
<li>重构（包含的各种原则）是整理代码的一套方法论。掌握之后，可以吧帮助我们更高效并且可控地整理好代码。</li>
</ul>
<h4 id="「重构」与「性能优化」的区别"><a href="#「重构」与「性能优化」的区别" class="headerlink" title="「重构」与「性能优化」的区别"></a>「重构」与「性能优化」的区别</h4><p>和重构一样，性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是<strong>两者出发点不同</strong>：</p>
<p>性能优化往往使代码较难理解，但为了得到所需的性能你不得不那么做。</p>
<p>我要强调的第二点是：重构不会改变软件「可受观察之行为」——重构之后软件功能一如以往。</p>
<h4 id="「添加新功能」和「重构」的区别"><a href="#「添加新功能」和「重构」的区别" class="headerlink" title="「添加新功能」和「重构」的区别"></a>「添加新功能」和「重构」的区别</h4><ul>
<li>添加新功能时，你不应该修改既有代码，只管添加新功能。通过测试（并让测试正常运行〉，你可以衡量自己的工作进度。</li>
<li>重构时你就不能再添加功能，只管改进程序结构。此时你不应该添加任何测试（除非发现先前遗漏的任何东西），只在绝对必要（用以处理接口变化〕时才修改测试。</li>
</ul>
<p>无论何时都应该清楚自己当前在做什么，是「添加新功能」还是在「重构」。</p>
<h2 id="2-为何重构"><a href="#2-为何重构" class="headerlink" title="2.为何重构"></a>2.为何重构</h2><ol>
<li>改进软件设计。比如消除重复代码。代码数量减少将使未来可能的程序修改动作容易得多。确定代码将所有事物和行为都只表述一次。</li>
<li>提高可读性，降低维护成本 <ul>
<li>我们写下的源码有两个读者——计算机 和 另一些程序员。让后者能够读懂你的代码才是最重要的。（业务需求总是改变的，可能十天后就会有新同事需要尝试读懂你的代码，并做一些修改）</li>
<li>当你努力让程序运转的时候，你不会想到未来出现的那个开发者。其实很多时候，那个「未来的开发者」就是你自己。也就是说，重构可以帮助你完成这些</li>
<li>利用重构来协助我理解不熟悉的代码</li>
</ul>
</li>
<li>帮助找到 bug。<ul>
<li>对代码进行重构，我就可以深入理解代码的作为，并恰到好处地把新的理解反馈回去。搞清楚程序结构的同时，我也清楚了自己所做的一些假设</li>
</ul>
</li>
<li>帮助提高编程速度。如果设计不合理。或许某一段时间内你的进展迅速，但<strong>恶劣的设计很快就让你的速度慢下来</strong>。你会把时间花在调试上面，无法添加新功能。修改时间愈来愈长，因为你必须花愈来愈多的时间去理解系统、寻找重复代码。</li>
</ol>
<h2 id="3-何时重构"><a href="#3-何时重构" class="headerlink" title="3.何时重构"></a>3.何时重构</h2><p>重构本来就不是一件「特别拨出时间做」的事情，<strong>重构应该随时随地进行</strong>。你不应该为重构而重构，你<strong>之所以重构，是因为你想做别的什么事，而重构可以帮助你把那些事做好</strong>。</p>
<p>几个典型的重构时机：</p>
<ul>
<li>添加功能时一并重构</li>
<li>修补错误时一并重构</li>
<li>code review 时一并重构</li>
</ul>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>坏味道的代码编写而成的程序，有以下几个特征：</p>
<ul>
<li>难以阅读的程序，难以修改。</li>
<li>逻辑重复（duplicated logic）的程序，难以修改。</li>
<li>添加新行为时需要修改既有代码的程序，难以修改。</li>
<li>带复杂条件逻辑（complex conditional logic）的程序，难以修改。</li>
</ul>
<p>因此，我们希望程序：</p>
<ol>
<li>容易理解；</li>
<li>所有逻辑都只在唯一一处指定；</li>
<li>新的改动不会危及现有行为；</li>
<li>尽可能简单表达条件逻辑（conditional logic）。</li>
</ol>
<p>重构是这样一个过程：它在一个目前可运行的程序上进行，企图在「不改变程序行为」的情况下赋予上述美好性质，使我们能够继续保持高速开发，从而增加程序的价值。</p>
<h2 id="5-参考资料与学习资源推荐"><a href="#5-参考资料与学习资源推荐" class="headerlink" title="5.参考资料与学习资源推荐"></a>5.参考资料与学习资源推荐</h2><ul>
<li>《重构，改善既有代码的设计》</li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        
        <tags>
            
            <tag> 代码质量 </tag>
            
            <tag> 编码规范 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Skeleton 工作原理]]></title>
      <url>https://timlin-pro.github.io/blog/2018/11/07/Skeleton-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Skeleton Screen（加载占位图）是近年流行的加载控件，通常表现形式是在界面上待加载区域填充灰色的占位图，与线框图的效果非常相似。Skeleton Screen 本质上是界面加载过程中的过渡效果。</p>
<a id="more"></a>
<p>使用 Skeleton 的效果图如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fwyt63fc6bj30fz0sgwes.jpg" alt=""></p>
<h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2.工作原理"></a>2.工作原理</h2><p>从上面的效果图，不难看出，「Skeleton」有一个显示和隐藏的过程。下面针对普通的 view 和 RecyclerView 分别说明其中的显示/隐藏的过程。</p>
<h3 id="2-1-对于普通的-View"><a href="#2-1-对于普通的-View" class="headerlink" title="2.1 对于普通的 View"></a>2.1 对于普通的 View</h3><p>从常规的使用方法看起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mTvSkeletonScreen = Skeleton.bind(textView)</div><div class="line">        .load(R.layout.share_skeleton_text_view)</div><div class="line">        .show();</div></pre></td></tr></table></figure>
<p>首先调用了 <code>Skeleton.bind();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewSkeletonScreen.<span class="function">Builder <span class="title">bind</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewSkeletonScreen.Builder(view);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>bind 方法返回的是一个 ViewSkeletonScreen.Builder</p>
<p>也就是一个建造器，其中提供了各种配置方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> View mView;<span class="comment">//依附的 view</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSkeletonLayoutResID;<span class="comment">//外部注入的 id</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mShimmer = <span class="keyword">true</span>;<span class="comment">//是否闪烁</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShimmerColor;<span class="comment">//闪烁的颜色</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShimmerDuration = <span class="number">1000</span>;<span class="comment">//闪烁时间，默认是 1000ms</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShimmerAngle = <span class="number">20</span>;<span class="comment">//闪烁的角度</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mView = view;<span class="comment">//从外部注入的目标 view</span></div><div class="line">        <span class="keyword">this</span>.mShimmerColor = ContextCompat.getColor(mView.getContext(), R.color.shimmer_color);<span class="comment">//默认的 shimmer 颜色</span></div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> ViewSkeletonScreen <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">        ViewSkeletonScreen skeletonScreen = <span class="keyword">new</span> ViewSkeletonScreen(<span class="keyword">this</span>);</div><div class="line">        skeletonScreen.show();</div><div class="line">        <span class="keyword">return</span> skeletonScreen;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>设置好之后，调用 show，即可将 Skeleton 显示 出来</p>
<p>ViewSkeletonScreen.Builder#show</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ViewSkeletonScreen <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">    ViewSkeletonScreen skeletonScreen = <span class="keyword">new</span> ViewSkeletonScreen(<span class="keyword">this</span>);<span class="comment">//根据当前 builder 创建一个 ViewSkeletonScreen</span></div><div class="line">    skeletonScreen.show();<span class="comment">//显示</span></div><div class="line">    <span class="keyword">return</span> skeletonScreen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Builder#show 方法返回的是一个 ViewSkeletonScreen 对象。</p>
<p>ViewSkeletonScreen 实现了 SkeletonScreen 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SkeletonScreen</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-1-1-显示"><a href="#2-1-1-显示" class="headerlink" title="2.1.1 显示"></a>2.1.1 显示</h4><h5 id="ViewSkeletonScreen-show"><a href="#ViewSkeletonScreen-show" class="headerlink" title="ViewSkeletonScreen#show()"></a>ViewSkeletonScreen#show()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">    View skeletonLoadingView = generateSkeletonLoadingView();<span class="comment">//生成 loading view</span></div><div class="line">    <span class="keyword">if</span> (skeletonLoadingView != <span class="keyword">null</span>) &#123;</div><div class="line">        mViewReplacer.replace(skeletonLoadingView);<span class="comment">//将 bind 进来的 view 替换为 loadingview</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="1-生成-loadingView"><a href="#1-生成-loadingView" class="headerlink" title="1.生成 loadingView"></a>1.生成 loadingView</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">generateSkeletonLoadingView</span><span class="params">()</span> </span>&#123;</div><div class="line">    ViewParent viewParent = mActualView.getParent();<span class="comment">//获取实际 view 的 parent</span></div><div class="line">    <span class="keyword">if</span> (viewParent == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有父 view</span></div><div class="line">        Log.e(TAG, <span class="string">"the source view have not attach to any view"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ViewGroup parentView = (ViewGroup) viewParent;</div><div class="line">    <span class="keyword">if</span> (mShimmer) &#123;</div><div class="line">        <span class="keyword">return</span> generateShimmerContainerLayout(parentView);<span class="comment">//生成 shimmer layout。在现有的 view 上面包装一层，当 view 关联到 window 的时候，开始播放动画；当 view 从 window 中分离的时候停止播放动画。 </span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> LayoutInflater.from(mActualView.getContext()).inflate(mSkeletonResID, parentView, <span class="keyword">false</span>);<span class="comment">//渲染出 view</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-显示"><a href="#2-显示" class="headerlink" title="2.显示"></a>2.显示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replace</span><span class="params">(View targetView)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mCurrentView == targetView) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (targetView.getParent() != <span class="keyword">null</span>) &#123;<span class="comment">//如果 loadingview 的 parent 不为 null，将它从父容器中移除</span></div><div class="line">        ((ViewGroup) targetView.getParent()).removeView(targetView);<span class="comment">//移除 view</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (init()) &#123;<span class="comment">//初始化</span></div><div class="line">        mTargetView = targetView;</div><div class="line">        mSourceParentView.removeView(mCurrentView);<span class="comment">//移除掉源 view</span></div><div class="line">        mTargetView.setId(mSourceViewId);<span class="comment">//设置 id，</span></div><div class="line">        mSourceParentView.addView(mTargetView, mSourceViewIndexInParent, mSourceViewLayoutParams);<span class="comment">//添加到父 view 中</span></div><div class="line">        mCurrentView = mTargetView;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mSourceParentView == <span class="keyword">null</span>) &#123;<span class="comment">//</span></div><div class="line">        mSourceParentView = (ViewGroup) mSourceView.getParent();<span class="comment">//获取 bind 进来的 view 的父容器</span></div><div class="line">        <span class="keyword">if</span> (mSourceParentView == <span class="keyword">null</span>) &#123;<span class="comment">//如果父容器为空，说明未关联到任何 view，直接返回</span></div><div class="line">            Log.e(TAG, <span class="string">"the source view have not attach to any view"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//遍历获取当前 view 在父容器中下标</span></div><div class="line">        <span class="keyword">int</span> count = mSourceParentView.getChildCount();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; count; index++) &#123;</div><div class="line">            <span class="keyword">if</span> (mSourceView == mSourceParentView.getChildAt(index)) &#123;</div><div class="line">                mSourceViewIndexInParent = index;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-1-2-隐藏"><a href="#2-1-2-隐藏" class="headerlink" title="2.1.2 隐藏"></a>2.1.2 隐藏</h4><p>com.ethanhua.skeleton.ViewSkeletonScreen#hide</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mViewReplacer.getTargetView() <span class="keyword">instanceof</span> ShimmerLayout) &#123;</div><div class="line">        ((ShimmerLayout) mViewReplacer.getTargetView()).stopShimmerAnimation();</div><div class="line">    &#125;</div><div class="line">    mViewReplacer.restore();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>com.ethanhua.skeleton.ViewReplacer#restore </p>
<p>其实就是 replace 方法的逆向。将 「loading view 」从父 view 中移除掉，将「原 view」（bind 进来的 view），添加到父 view。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mSourceParentView != <span class="keyword">null</span>) &#123;</div><div class="line">        mSourceParentView.removeView(mCurrentView);<span class="comment">//移除掉当前的 view。</span></div><div class="line">        mSourceParentView.addView(mSourceView, mSourceViewIndexInParent, mSourceViewLayoutParams);</div><div class="line">        mCurrentView = mSourceView;</div><div class="line">        mTargetView = <span class="keyword">null</span>;</div><div class="line">        mTargetViewResID = -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-对于-RecyclerView"><a href="#2-2-对于-RecyclerView" class="headerlink" title="2.2 对于 RecyclerView"></a>2.2 对于 RecyclerView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> RecyclerViewSkeletonScreen.<span class="function">Builder <span class="title">bind</span><span class="params">(RecyclerView recyclerView)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecyclerViewSkeletonScreen.Builder(recyclerView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> RecyclerView.Adapter mActualAdapter;<span class="comment">//适配器</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RecyclerView mRecyclerView;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mShimmer = <span class="keyword">true</span>;<span class="comment">//默认支持 shimmer </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mItemCount = <span class="number">10</span>;<span class="comment">//默认为 10</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mItemResID = R.layout.layout_default_item_skeleton;<span class="comment">//默认的列表项布局</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShimmerColor;<span class="comment">//颜色</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShimmerDuration = <span class="number">1000</span>;<span class="comment">//</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShimmerAngle = <span class="number">20</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mFrozen = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(RecyclerView recyclerView)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mRecyclerView = recyclerView;</div><div class="line">        <span class="keyword">this</span>.mShimmerColor = ContextCompat.getColor(recyclerView.getContext(), R.color.shimmer_color);<span class="comment">//默认的闪烁颜色</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> adapter the target recyclerView actual adapter</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">adapter</span><span class="params">(RecyclerView.Adapter adapter)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mActualAdapter = adapter;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> itemCount the child item count in recyclerView</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">count</span><span class="params">(<span class="keyword">int</span> itemCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mItemCount = itemCount;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> frozen whether frozen recyclerView during skeleton showing</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">frozen</span><span class="params">(<span class="keyword">boolean</span> frozen)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mFrozen = frozen;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> RecyclerViewSkeletonScreen <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">        RecyclerViewSkeletonScreen recyclerViewSkeleton = <span class="keyword">new</span> RecyclerViewSkeletonScreen(<span class="keyword">this</span>);</div><div class="line">        recyclerViewSkeleton.show();</div><div class="line">        <span class="keyword">return</span> recyclerViewSkeleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与普通 view 不同， recyclerview 的 Skeleton Builder 提供了多个  adapter 方法来设置适配器，count 方法用于设置 列表项数目，frozen 控制 Skeleton 显示期间是否冻结 RecyclerView。</p>
<p>上面的 RecyclerViewSkeletonScreen.Builder#show 方法，首先创建了 一个 RecyclerViewSkeletonScreen ，然后调用它的 show 方法</p>
<p>RecyclerViewSkeletonScreen#RecyclerViewSkeletonScreen </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">RecyclerViewSkeletonScreen</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    mRecyclerView = builder.mRecyclerView;</div><div class="line">    mActualAdapter = builder.mActualAdapter;<span class="comment">//真正的适配器，隐藏 Skeleton 之后，显示真实的 view 时需要用到</span></div><div class="line">    mSkeletonAdapter = <span class="keyword">new</span> SkeletonAdapter();<span class="comment">//创建 adapter</span></div><div class="line">    mSkeletonAdapter.setItemCount(builder.mItemCount);<span class="comment">//列表的总项数</span></div><div class="line">    mSkeletonAdapter.setLayoutReference(builder.mItemResID);<span class="comment">//列表项的 id</span></div><div class="line">    mSkeletonAdapter.shimmer(builder.mShimmer);<span class="comment">//是否闪烁</span></div><div class="line">    mSkeletonAdapter.setShimmerColor(builder.mShimmerColor);<span class="comment">//闪烁的颜色</span></div><div class="line">    mSkeletonAdapter.setShimmerAngle(builder.mShimmerAngle);<span class="comment">//闪烁的角度</span></div><div class="line">    mSkeletonAdapter.setShimmerDuration(builder.mShimmerDuration);<span class="comment">//闪烁时长</span></div><div class="line">    mRecyclerViewFrozen = builder.mFrozen;<span class="comment">//是否冻结</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-1-显示"><a href="#2-2-1-显示" class="headerlink" title="2.2.1 显示"></a>2.2.1 显示</h4><p>RecyclerViewSkeletonScreen#show</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">    mRecyclerView.setAdapter(mSkeletonAdapter);</div><div class="line">    <span class="keyword">if</span> (!mRecyclerView.isComputingLayout() &amp;&amp; mRecyclerViewFrozen) &#123;<span class="comment">//如果不是正在计算布局，并且设置了冻结，则将 Recyclerview 冻结</span></div><div class="line">        mRecyclerView.setLayoutFrozen(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-2-隐藏"><a href="#2-2-2-隐藏" class="headerlink" title="2.2.2 隐藏"></a>2.2.2 隐藏</h4><p>RecyclerViewSkeletonScreen#hide</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">    mRecyclerView.setAdapter(mActualAdapter);<span class="comment">//将真实的 adapter 设置回去。内部会触发刷新，进而显示出</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SkeletonAdapter 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkeletonAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecyclerView</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        LayoutInflater inflater = LayoutInflater.from(parent.getContext());</div><div class="line">        <span class="keyword">if</span> (mShimmer) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ShimmerViewHolder(inflater, parent, mLayoutReference);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RecyclerView.ViewHolder(inflater.inflate(mLayoutReference, parent, <span class="keyword">false</span>)) &#123;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mShimmer) &#123;</div><div class="line">            ShimmerLayout layout = (ShimmerLayout) holder.itemView;</div><div class="line">            layout.setShimmerAnimationDuration(mShimmerDuration);</div><div class="line">            layout.setShimmerAngle(mShimmerAngle);</div><div class="line">            layout.setShimmerColor(mColor);</div><div class="line">            layout.startShimmerAnimation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到还是跟普通的 view 一个套路，不闪烁的话，直接将列表项渲染出来就完事。如果设置了闪烁，则需要包装到一个 ShimmerLayout 中，并根据参数进一步设置。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>普通 view， 核心思想就是，利用 ViewGroup#addView，ViewGroup#removeView 对 view 进行替换。</p>
<p>显示 Skeleton 的时候，将原来的 view 替换为 loadingView</p>
<p>隐藏 Skeleton 的时候，将「loadingview」替换为 sourceView。</p>
<p>对于 RecyclerView，在显示期间，通过 SkeletonAdapter 偷天换日，将 loading 显示出来。</p>
<p>隐藏的时候，将真正的 adapter 设置回去。</p>
<h2 id="4-参考资料与学习资源推荐"><a href="#4-参考资料与学习资源推荐" class="headerlink" title="4.参考资料与学习资源推荐"></a>4.参考资料与学习资源推荐</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/26014116" target="_blank" rel="noopener">这个控件叫：Skeleton Screen/加载占位图</a></li>
<li><a href="https://github.com/ethanhua/Skeleton" target="_blank" rel="noopener">Skeleton</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 框架原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[RxJava 订阅原理]]></title>
      <url>https://timlin-pro.github.io/blog/2018/06/24/RxJava-%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RxJava 是什么呢？根据<code>RxJava</code>在<code>GitHub</code>上给出的描述 RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java 大致意思是：一个可以在 JVM上 使用的，是由异步的基于事件编写的通过使用可观察序列构成的一个库。 </p>
<p>关键词：<code>异步</code>，<code>基于事件</code>，<code>可观察序列</code></p>
<p>本文主要讲述 RxJava 的订阅原理。</p>
<a id="more"></a>
<h2 id="示例：HelloRxJava"><a href="#示例：HelloRxJava" class="headerlink" title="示例：HelloRxJava"></a>示例：HelloRxJava</h2><p>一般学一门新的编程语言都是先从打印的「hello word」开始，我们看看如何用 Rxjava 打印出「Hello RxJava」 并以之作为分析的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建 Observable</span></div><div class="line">Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        emitter.onNext(<span class="string">"Hello RxJava"</span>);</div><div class="line">        emitter.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//订阅</span></div><div class="line">observable.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"onSubsribe call"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">		System.out.println(s);<span class="comment">//打印收到的文字，这里是 Hello RxJava</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">		e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"onComplete call"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Observerable-是如何创建的？"><a href="#Observerable-是如何创建的？" class="headerlink" title="Observerable 是如何创建的？"></a>Observerable 是如何创建的？</h2><p>首先 new 了一个 ObservableOnSubscribe 对象，并实现其中的 subscribe 方法。该对象被传递给了 Observable#create 方法以创建 Observable（当然也有其他方法可以创建 Observable ，但是原理大同小异）。</p>
<p><code>io.reactivex.Observable#create</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckReturnValue</span></div><div class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);<span class="comment">//不可为空</span></div><div class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>create 方法传递进来的 Observable 又传递给了 Observable 构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;<span class="comment">//保存成员变量</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.source = source;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>io.reactivex.plugins.RxJavaPlugins#onAssembly(io.reactivex.Observable<t>)</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Calls the associated hook function.</div><div class="line"> * <span class="doctag">@param</span> &lt;T&gt; the value type</div><div class="line"> * <span class="doctag">@param</span> source the hook's input value</div><div class="line"> * <span class="doctag">@return</span> the value returned by the hook</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</div><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(@NonNull Observable&lt;T&gt; source)</span> </span>&#123;</div><div class="line">    Function&lt;? <span class="keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;</div><div class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> apply(f, source);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> source;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>io.reactivex.plugins.RxJavaPlugins#onAssembly 方法中只是调用了相关的 hook 函数（如果有的话），然后返回原对象。</p>
<p>创建的结果：ObservableOnSubsribe 外面包装了一层。如下图所示：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fsmjkz2m4fj307n04qglj.jpg" alt="image-20180624202952875"></p>
<h2 id="订阅过程"><a href="#订阅过程" class="headerlink" title="订阅过程"></a>订阅过程</h2><p>实例代码中在订阅之前我们先创建了一个 <code>observer</code> 对象。</p>
<p>然后调用 <code>Observable#subscribe</code> 方法，将 <code>observer</code> 作为参数传递给该方法。</p>
<p>点开看看 <code>Observable#subscribe</code> 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);<span class="comment">//非空检查</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</div><div class="line"></div><div class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);<span class="comment">//非空检查</span></div><div class="line"></div><div class="line">        subscribeActual(observer);<span class="comment">//调用真正的订阅方法。</span></div><div class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        Exceptions.throwIfFatal(e);</div><div class="line">        <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></div><div class="line">        <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></div><div class="line">        RxJavaPlugins.onError(e);<span class="comment">//</span></div><div class="line"></div><div class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</div><div class="line">        npe.initCause(e);</div><div class="line">        <span class="keyword">throw</span> npe;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面 try 块中的第一行代码调用了 <code>RxJavaPlugins#onSubscribe</code> 。点开看看它具体做了啥？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</div><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observer&lt;? <span class="keyword">super</span> T&gt; onSubscribe(<span class="meta">@NonNull</span> Observable&lt;T&gt; source, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</div><div class="line">    BiFunction&lt;? <span class="keyword">super</span> Observable, ? <span class="keyword">super</span> Observer, ? extends Observer&gt; f = onObservableSubscribe;</div><div class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> apply(f, source, observer);<span class="comment">//调用相应的 hook 函数(如果有的话)</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> observer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们订阅的实际对象是 <code>ObserverableCreate</code>，因此点进去看看其中的 <code>subscribeActual</code> 方法实现：</p>
<p><code>ObservableCreate#subscribeActual</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);<span class="comment">//以 observer 作为参数构造一个 CreateEmitter</span></div><div class="line">    observer.onSubscribe(parent);<span class="comment">//回调 Observer#onSubsribe 方法</span></div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        source.subscribe(parent);<span class="comment">//调用源订阅方法，也就是我们自己实现的在其中发送数据的方法</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">        Exceptions.throwIfFatal(ex);</div><div class="line">        parent.onError(ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>source#subcribe</code> 也就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    emitter.onNext(<span class="string">"hello rxJava"</span>);<span class="comment">//调用 发送数据</span></div><div class="line">    emitter.onComplete();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>订阅是从下游传递到上游。传递到源头之后，会触发调用 <code>Emitter#onXxx</code> 方法，将数据从上游发送到下游。</p>
<h3 id="emitter-是如何将数据发射给-observer-的呢？"><a href="#emitter-是如何将数据发射给-observer-的呢？" class="headerlink" title="emitter 是如何将数据发射给 observer 的呢？"></a>emitter 是如何将数据发射给 observer 的呢？</h3><p>我们先看看 <strong>emitter 是什么</strong>？</p>
<p>上面的 emitter 的实际类型是 CreateEmitter</p>
<p>具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt;</div><div class="line"><span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> &#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3434801548987643227L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</div><div class="line"></div><div class="line">    CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</div><div class="line">        <span class="keyword">this</span>.observer = observer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;<span class="comment">//判空</span></div><div class="line">            onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;<span class="comment">//如果当前状态不是 dispose</span></div><div class="line">            observer.onNext(t);<span class="comment">//调用 observer#onNext</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!tryOnError(t)) &#123;</div><div class="line">            RxJavaPlugins.onError(t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">            t = <span class="keyword">new</span> NullPointerException(<span class="string">"onError called with null. Null values are generally not allowed in 2.x operators and sources."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                observer.onError(t);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                dispose();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isDisposed()) &#123;<span class="comment">//不是出于 disposed 状态</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                observer.onComplete();<span class="comment">//调用</span></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                dispose();<span class="comment">//onComplete 只能调用一次，调用完成之后，状态变为 dispose</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>CreateEmitter</code> 是 <code>ObservableCreate</code>的一个内部类，继承自<code>AtomicReference&lt;Disposable&gt;</code>, 实现了两个接口 <code>ObservableEmitter&lt;T&gt;</code> 和 <code>Disposable</code> 。 </p>
<p>可以看到 <code>CreateEmitter</code> 对 <code>observer</code> 进行了包装（observer 依赖通过构造函数参数注入）。它在调用 observer 的相应方法的前后对状态进行判断和更新。</p>
<h3 id="CreateEmitter-又是在什么时候创建的呢？"><a href="#CreateEmitter-又是在什么时候创建的呢？" class="headerlink" title="CreateEmitter 又是在什么时候创建的呢？"></a><code>CreateEmitter</code> 又是在什么时候创建的呢？</h3><p>在订阅过程中调用到 <code>ObservableCreate#subscribeActual</code> ，该方法会利用 observer 构造一个 <code>CreateEmmiter</code>， 然后把它作为参数去调用 <code>source#subcribe</code> 方法。</p>
<p><code>source</code> 也就是我们创建的 <code>ObservableOnSubscribe</code> 匿名内部类。<code>CreateEmmiter</code> 就是通过这样的方式作为参数传递给了我们自己实现的 <code>subscribe</code> 方法。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>订阅是从下游传递到上游。传递到源头之后，会触发调用 <code>Emitter#onXxx</code> 方法，将数据从上游发送到下游。</p>
<p>上游对数据流的控制是通过 <code>CreateEmitter</code> 实现的。</p>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gradle 中 api provided compile implementation 之间的区别]]></title>
      <url>https://timlin-pro.github.io/blog/2018/06/24/gradle-%E4%B8%ADapi-provided-compile-implementation-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>api、provided、compile、implementation</code> 都是 gradle 添加依赖时的选项，不同的选项表示不同的依赖关系。</p>
<p>其中 api、implementation 是 Gradle 3.4 引入的新的依赖配置，用来代替 <code>compile</code> 依赖配置。其中 <code>api</code> 和以前的 <code>compile</code> 依赖配置是一样的。使用 api/compile 的依赖方式，会向外界暴露本模块所依赖的库的接口，使用 implementation 则不会。</p>
<a id="more"></a>
<h2 id="解决了什么问题？"><a href="#解决了什么问题？" class="headerlink" title="解决了什么问题？"></a>解决了什么问题？</h2><p>为什么要做这样的修改呢？使用 <code>implementation</code> 依赖配置，可以显著减少构建的时间。</p>
<p>考虑这样的场景，有如下六个模块：</p>
<p><img src="https://raw.githubusercontent.com/TimLin-pro/Graph/master/markdown/gradle%20%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E7%A4%BA%E4%BE%8B.jpg" alt=""></p>
<p>D、E、F 三个模块都依赖了 Lib 库。</p>
<p>假设 D、E、F 三个模块都以 <code>implementation</code> 的方式引用 Lib 库，那么上层的 A，B，C 三个模块<strong>在编译期</strong>都无法引用到 Lib 库中的内容。因此当 Lib 发生变化的时候，只有 D E F 这三个模块需要重新编译，A,B,C 则不需要（因为 DEF 三个模块对外的接口都没有改变）。</p>
<p>假设 D、E、F 三个模块都以 <code>compile/api</code>  的方式引用 Lib 库（对外暴露了自己引用的库的接口），那么无论上层的 A，B，C 三个模块对 D、E、F 模块的依赖是 compile、api 方式还是 implementation 方式，它们（A、B、C）都可以引用到 Lib 库中的内容。这种情况下当 Lib 发生变化的时候，A B C D E F 这三个模块都需要重新编译。</p>
<p>Public 可以</p>
<h2 id="其它变化"><a href="#其它变化" class="headerlink" title="其它变化"></a>其它变化</h2><p>在该版本中，官方团队也把之前命名的不规范的地方修改了，provided 改成了 compileOnly，apk 改为了 runtimeOnly。改变的只是名称，功能没变。</p>
<h3 id="compileOnly-的使用场景"><a href="#compileOnly-的使用场景" class="headerlink" title="compileOnly 的使用场景"></a>compileOnly 的使用场景</h3><p>包括但是不限于下面的两种：</p>
<ol>
<li>编译时所需的依赖性，但在运行时从不需要，例如纯源注释或注释处理器;</li>
<li>API 在编译时需要，但其实现由消费库，应用程序或运行时环境提供的依赖项。</li>
</ol>
<h3 id="runtimeOnly-的使用场景"><a href="#runtimeOnly-的使用场景" class="headerlink" title="runtimeOnly 的使用场景"></a>runtimeOnly 的使用场景</h3><p>依赖项仅在运行时对模块及其消费者可用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th>新配置</th>
<th>已弃用配置</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>implementation</code></td>
<td><code>compile</code></td>
<td>依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。 对于大型多项目构建，使用 <code>implementation</code> 而不是 <code>api</code>/<code>compile</code> 可以<strong>显著缩短构建时间</strong>，因为它可以减少构建系统需要重新编译的项目量。 大多数应用和测试模块都应使用此配置。</td>
</tr>
<tr>
<td><code>api</code></td>
<td><code>compile</code></td>
<td>依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。 此配置的行为类似于 <code>compile</code>（现在已弃用），一般情况下，您应当仅在库模块中使用它。 应用模块应使用 <code>implementation</code>，除非您想要将其 API 公开给单独的测试模块。</td>
</tr>
<tr>
<td><code>compileOnly</code></td>
<td><code>provided</code></td>
<td>依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。 此配置的行为类似于 <code>provided</code>（现在已弃用）。</td>
</tr>
<tr>
<td><code>runtimeOnly</code></td>
<td><code>apk</code></td>
<td>依赖项仅在运行时对模块及其消费者可用。 此配置的行为类似于 <code>apk</code>（现在已弃用）。</td>
</tr>
</tbody>
</table>
<blockquote>
<p> <strong>注</strong>：<code>compile</code>、<code>provided</code> 和 <code>apk</code> 目前仍然可用。 不过，它们将在下一个主要版本的 Android 插件中消失。</p>
</blockquote>
<p>日常开发中一般都是用 implementation，部分情况下会用到 api，其他的依赖方式一般不怎么用到。记住 compile、api 依赖方式是「传递性的」，而 implementation 依赖方式的是「非传递性」的。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><p><a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration" target="_blank" rel="noopener">迁移到 Android Plugin for Gradle 3.0.0</a></p>
</li>
<li><p><a href="https://jeroenmols.com/blog/2017/06/14/androidstudio3/" target="_blank" rel="noopener">Implementation vs API dependency</a></p>
</li>
<li><p><a href="https://blog.csdn.net/yuzhiqiang_1993/article/details/78366985" target="_blank" rel="noopener">Android Studio3.x 新的依赖方式（implementation、api、compileOnly）</a></p>
</li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> Gradle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fragment Note]]></title>
      <url>https://timlin-pro.github.io/blog/2018/06/02/Fragment%20Note/</url>
      <content type="html"><![CDATA[<p>笔记自用，部分内容待完善。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当您将片段作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 <code>ViewGroup</code> 内部，并且<strong>片段会定义其自己的视图布局</strong>。您可以通过在 Activity 的<strong>布局文件中声明片段</strong>，将其作为 <code>&lt;fragment&gt;</code> 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 <code>ViewGroup</code>，利用应用代码进行插入。不过，片段<strong>并非必须成为 Activity 布局的一部分</strong>；您还可以将没有自己 UI 的片段用作 Activity 的不可见工作线程。</p>
<a id="more"></a>
<h3 id="Fragment-解决了什么问题？"><a href="#Fragment-解决了什么问题？" class="headerlink" title="Fragment 解决了什么问题？"></a>Fragment 解决了什么问题？</h3><p>不能直接用 View 替代吗？</p>
<p>相对于 view 而言，它的优势在哪？</p>
<p> Android 3.0（API 级别 11）中引入了片段，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用片段实现此类设计时，您<strong>无需管理对视图层次结构的复杂更改</strong>。 </p>
<p>您应该将每个片段都设计为<strong>可重复使用的模块化 Activity 组件</strong>。也就是说，由于每个片段都会通过各自的生命周期回调来定义其自己的布局和行为，您可以<strong>将一个片段加入多个 Activity</strong>，因此，您<strong>应该采用可复用式设计，避免直接从某个片段直接操纵另一个片段</strong>。 这特别重要，因为<strong>模块化片段让您可以通过更改片段的组合方式来适应不同的屏幕尺寸</strong>。 在设计可同时支持平板电脑和手机的应用时，您可以在不同的布局配置中重复使用您的片段，以根据可用的屏幕空间优化用户体验。 </p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>通常至少需要实现以下几个生命周期方法：</p>
<ul>
<li><p>onCreate（）</p>
<ul>
<li>在此方法中初始化那些你希望在fragment 处于 paused or stopped, then resumed状态的时候仍然被保留的组件</li>
</ul>
</li>
<li><p>onCreateView()</p>
<ul>
<li>这个方法必须返回 这个fragment的布局的根View，也如果此fragment不提供一个UI的话，可以返回空</li>
</ul>
</li>
<li><p>onPause()</p>
<ul>
<li>这个方法中你应该<strong>提交你的fragment中的那些需要被保存的数据</strong>。</li>
</ul>
</li>
</ul>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>使用 setArgument 的方式，通过这种方式传递参数，如果配置发生更改，通过<code>Fragment.setArguments(Bundle bundle)</code>方法设置的bundle会保留下来。</p>
<p>如果是通过直接赋值的方式，则需要实现 onSaveInstance 和 onRestoreIntanceState 方法（或者 在 onCreate 方法进行配置）才能应对配置更改。</p>
<p>要注意的问题就是 setArgument 方法要在 Fragment 与 Activity 关联之前调用。</p>
<h3 id="可以被继承的Fragment基类"><a href="#可以被继承的Fragment基类" class="headerlink" title="可以被继承的Fragment基类"></a>可以被继承的Fragment基类</h3><ul>
<li>DialogFragment</li>
</ul>
<blockquote>
<p>Displays a floating dialog. Using this class to create a dialog is a good alternative to using the dialog helper methods in the Activity class, because you can incorporate(包含) a fragment dialog into the back stack of fragments managed by the activity, allowing the user to return to a dismissed fragment.</p>
</blockquote>
<p>相比于 Dialog 的好处：</p>
<ol>
<li>生命周期便于管理；</li>
<li>比 Dialog 更加地强大。「DialogFragment也允许开发者把Dialog作为内嵌的组件进行重用」</li>
</ol>
<p>重写 onCreateView 或者  onCreateDialog </p>
<ul>
<li>ListFragment</li>
</ul>
<blockquote>
<p>Displays a list of items that are managed by an adapter (such as a SimpleCursorAdapter), similar to ListActivity. It provides several methods for managing a list view, such as the onListItemClick() callback to handle click events.</p>
</blockquote>
<p>类似于ListActivity</p>
<ul>
<li>PreferenceFragment</li>
</ul>
<blockquote>
<p>Displays a hierarchy of Preference objects as a list, similar to PreferenceActivity. This is useful when creating a “settings” activity for your application.</p>
</blockquote>
<p>对于“设置”界面而言很有用</p>
<h3 id="特殊用途"><a href="#特殊用途" class="headerlink" title="特殊用途"></a>特殊用途</h3><p>调用 <code>setRetainInstance(true);</code>，会在配置发生改变的时候保存当前Fragment 中的所有对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Control whether a fragment instance is retained across Activity</div><div class="line"> * re-creation (such as from a configuration change).  This can only</div><div class="line"> * be used with fragments not in the back stack.  If set, the fragment</div><div class="line"> * lifecycle will be slightly different when an activity is recreated:</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt; &#123;<span class="doctag">@link</span> #onDestroy()&#125; will not be called (but &#123;<span class="doctag">@link</span> #onDetach()&#125; still</div><div class="line"> * will be, because the fragment is being detached from its current activity).</div><div class="line"> * &lt;li&gt; &#123;<span class="doctag">@link</span> #onCreate(Bundle)&#125; will not be called since the fragment</div><div class="line"> * is not being re-created.</div><div class="line"> * &lt;li&gt; &#123;<span class="doctag">@link</span> #onAttach(Activity)&#125; and &#123;<span class="doctag">@link</span> #onActivityCreated(Bundle)&#125; &lt;b&gt;will&lt;/b&gt;</div><div class="line"> * still be called.</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> */</div><div class="line">该方法控制 Fragment 的实例是否在Activity重新创建的时候保留。</div><div class="line">它只能用于那些不处在回退栈中的Fragment 身上。</div><div class="line">注意，如果保留实例的话，Fragment 的生命周期将会有一些不同</div><div class="line">- onDestory 方法不会被调用，但是 onDetach 方法仍然会被调用，因为 Fragment 从当前 Activity 中剥离了。</div><div class="line">- onCreate 方法也不会被调用，因为 Fragment 并没有重新创建</div><div class="line">- onAttach 和 onActivityCreated 方法依然会被调用。</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRetainInstance</span><span class="params">(<span class="keyword">boolean</span> retain)</span> </span>&#123;</div><div class="line">    mRetainInstance = retain;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于保存数据。</p>
<h2 id="创建-渲染用户界面"><a href="#创建-渲染用户界面" class="headerlink" title="创建/渲染用户界面"></a>创建/渲染用户界面</h2><p>为了提供一个布局给fragment，你必须实现onCreateView()方法,这个方法会在到这个Fragment 绘出它的布局的时候 被安卓系统调用。<br>此外，这个方法中必须 return a View that is the root of your fragment’s layout</p>
<blockquote>
<p>Note: If your fragment is a subclass of ListFragment, the default implementation returns a ListView from onCreateView(), so you don’t need to implement it.</p>
</blockquote>
<p><code>inflate()</code> 方法带有三个参数：</p>
<ul>
<li>您想要inflate的布局的资源 ID；</li>
<li>将作为inflate布局父项的 <code>ViewGroup</code>。传递 <code>container</code> 对系统向inflate布局的根视图（由其所属的父视图指定）应用布局参数具有重要意义；</li>
<li>指示是否应该在inflate期间将inflate布局附加至 <code>ViewGroup</code>（第二个参数）的布尔值。（在本例中，其值为 false，因为系统已经将inflate布局插入 <code>container</code> — 传递 true 值会在最终布局中创建一个多余的视图组。）</li>
</ul>
<p>系统会帮我们 addView，所以 attachToRoot 为 false；</p>
<p><code>android.support.v4.app.FragmentManagerImpl#moveToState(android.support.v4.app.Fragment, int, int, int, boolean)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(container != <span class="keyword">null</span>) &#123;</div><div class="line">    container.addView(f.mView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>推荐用下边这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inflater.inflate(R.layout.item, parent, false);</div></pre></td></tr></table></figure>
<p>测量的时候依赖 parent，但是添加需要手动进行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"inflate"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Context inflaterContext = mContext;</div><div class="line">        <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">        Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</div><div class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</div><div class="line">        View result = root;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Look for the root node.</span></div><div class="line">            <span class="keyword">int</span> type;</div><div class="line">            <span class="keyword">final</span> String name = parser.getName();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</div><div class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></div><div class="line">                            + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Temp is the root view that was found in the xml</span></div><div class="line">                <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                ViewGroup.LayoutParams params = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                        System.out.println(<span class="string">"Creating params from root: "</span> +</div><div class="line">                                root);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// Create layout params that match root, if supplied</span></div><div class="line">                    <span class="comment">//创建 根布局的 layout params</span></div><div class="line">                    params = root.generateLayoutParams(attrs);</div><div class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</div><div class="line">                        <span class="comment">// Set the layout params for temp if we are not</span></div><div class="line">                        <span class="comment">// attaching. (If we are, we use addView, below)</span></div><div class="line">                        temp.setLayoutParams(params);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                    System.out.println(<span class="string">"-----&gt; start inflating children"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Inflate all children under temp against its context.</span></div><div class="line">                rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (DEBUG) &#123;</div><div class="line">                    System.out.println(<span class="string">"-----&gt; done inflating children"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">//根布局存在 并且 待渲染的布局需要关联到 root，那就调用 addView 方法将它添加进去</span></div><div class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</div><div class="line">                    root.addView(temp, params);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//确定返回值是 root 还是  xml 文件中的根布局</span></div><div class="line">                <span class="comment">//root 为 null 或者 不关联到根布局，返回的就是 xml 文件中的根布局</span></div><div class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</div><div class="line">                    result = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</div><div class="line">            <span class="comment">//……</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="将-Fragment-添加到-Activity-的两种方式"><a href="#将-Fragment-添加到-Activity-的两种方式" class="headerlink" title="将 Fragment 添加到 Activity 的两种方式"></a>将 Fragment 添加到 Activity 的两种方式</h2><h3 id="1-在-Activity-的布局文件内声明片段"><a href="#1-在-Activity-的布局文件内声明片段" class="headerlink" title="1.在 Activity 的布局文件内声明片段"></a>1.在 Activity 的布局文件内声明片段</h3><ul>
<li>当系统创建此 Activity 布局时，会<strong>实例化在布局中指定的每个片段</strong>，并为每个片段调用 <code>onCreateView()</code> 方法，以检索每个片段的布局。<strong>系统会直接插入片段返回的 <code>View</code> 来替代 <code>&lt;fragment&gt;</code> 元素</strong>。</li>
</ul>
<p><code>&lt;fragment&gt;</code> 元素中可以通过 <code>class = “ ”</code> 也可以通过 <code>android:name=&quot;&quot;</code> 来指定 要加入的Fragment。</p>
<p>class 的性能会高一点点。</p>
<p>因为：android.support.v4.app.FragmentManagerImpl#onCreateView(android.view.View, java.lang.String, android.content.Context, android.util.AttributeSet)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="string">"fragment"</span>.equals(name)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//通过 class 获取 Fragment 名字</span></div><div class="line">    String fname = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</div><div class="line">    TypedArray a =  context.obtainStyledAttributes(attrs, FragmentTag.Fragment);</div><div class="line">    <span class="keyword">if</span> (fname == <span class="keyword">null</span>) &#123;<span class="comment">//用 class 找不到，通过 android:name 去查找</span></div><div class="line">        fname = a.getString(FragmentTag.Fragment_name);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//……</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注</strong>：每个片段都需要一个唯一的标识符，重启 Activity 时，系统可以使用该标识符来恢复片段（您也可以使用该标识符来捕获片段以执行某些事务，如将其移除）。 可以通过三种方式为片段提供 ID：</p>
<ul>
<li>为 <code>android:id</code> 属性提供唯一 ID。</li>
<li>为 <code>android:tag</code> 属性提供唯一字符串。</li>
<li>如果您未给以上两个属性提供值，系统会使用容器视图的 ID。</li>
</ul>
<h3 id="2-通过java-代码将片段添加到某个现有-ViewGroup"><a href="#2-通过java-代码将片段添加到某个现有-ViewGroup" class="headerlink" title="2.通过java 代码将片段添加到某个现有 ViewGroup"></a>2.通过java 代码将片段添加到某个现有 ViewGroup</h3><p>您可以在 Activity 运行期间随时将片段添加到 Activity 布局中。您只需指定要将片段放入哪个 <code>ViewGroup</code>。</p>
<p>您必须使用 <code>FragmentTransaction</code> 中的 API,才能在 Activity 中执行片段事务（如添加、移除或替换片段）。您可以像下面这样从 <code>Activity</code> 获取一个 <code>FragmentTransaction</code> 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FragmentManager fragmentManager = getFragmentManager();</div><div class="line">FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</div></pre></td></tr></table></figure>
<p>然后，您可以使用 <code>add()</code> 方法添加一个片段，<strong>指定要添加的片段以及将其插入哪个视图</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ExampleFragment fragment = <span class="keyword">new</span> ExampleFragment();</div><div class="line">fragmentTransaction.add(R.id.fragment_container, fragment);<span class="comment">//将要添加的片段</span></div><div class="line">fragmentTransaction.commit();</div></pre></td></tr></table></figure>
<p><strong>传递到 <code>add()</code> 的第一个参数是 <code>ViewGroup</code>，即应该放置片段的位置，由资源 ID 指定，第二个参数是要添加的片段</strong>。</p>
<p>一旦您通过 <code>FragmentTransaction</code> 做出了更改，就必须调用 <code>commit()</code> 以使更改生效。</p>
<h4 id="添加没有-UI-的片段"><a href="#添加没有-UI-的片段" class="headerlink" title="添加没有 UI 的片段"></a>添加没有 UI 的片段</h4><p>可以使用片段为 Activity 提供后台行为，而不显示额外 UI。</p>
<p>要想添加没有 UI 的片段，请使用 <code>add(Fragment, String)</code> 从 Activity 添加片段（为片段提供一个唯一的字符串“标记”，而不是视图 ID）。 这会添加片段，但<strong>由于它并不与 Activity 布局中的视图关联，因此不会收到对<code>onCreateView()</code> 的调用</strong>。因此，您不需要实现 <code>onCreateView()</code>方法。</p>
<p>如果片段没有 UI，则字符串标记将是标识它的唯一方式。</p>
<h3 id="管理片段"><a href="#管理片段" class="headerlink" title="管理片段"></a>管理片段</h3><p>要想管理您的 Activity 中的片段，您需要使用 <code>FragmentManager</code>。要想获取它，请从您的 Activity 调用 <code>getFragmentManager()</code>。</p>
<p>您可以使用 <code>FragmentManager</code> 执行的操作包括：</p>
<ul>
<li>通过 <code>findFragmentById()</code>（对于在 Activity 布局中提供 UI 的片段）或 <code>findFragmentByTag()</code>（对于提供或不提供 UI 的片段）获取 Activity 中存在的片段。</li>
<li>通过 <code>popBackStack()</code>（模拟用户发出的<em>返回</em>命令）将片段从返回栈中弹出。</li>
<li>通过 <code>addOnBackStackChangedListener()</code> 注册一个监听返回栈变化的侦听器。</li>
</ul>
<p>如需了解有关这些方法以及其他方法的详细信息，请参阅 <code>FragmentManager</code> 类文档。</p>
<p>如上文所示，您也可以使用 <code>FragmentManager</code> 打开一个 <code>FragmentTransaction</code>，通过它来执行某些事务，如添加和移除片段。</p>
<h2 id="执行片段事务"><a href="#执行片段事务" class="headerlink" title="执行片段事务"></a>执行片段事务</h2><p>在 Activity 中使用片段的一大优点是，可以根据用户行为通过它们执行添加、移除、替换以及其他操作。 您<strong>提交给 Activity 的<em>每组更改都称为事务</em></strong>，您<strong>可以使用 <code>FragmentTransaction</code> 中的 API 来执行一项事务</strong>。您也可以将每个事务保存到由 Activity 管理的返回栈内，从而让用户能够回退片段更改（类似于回退 Activity）。</p>
<p>可以从 <code>FragmentManager</code> 获取一个 <code>FragmentTransaction</code> 实例。</p>
<p><strong>每个事务</strong>（从FragmentTransaction# begin 到 commit 之间的一组「添加，删除，隐藏，显示」操作）都是您想要同时执行的<strong>一组更改</strong>。您可以使用 <code>add()</code>、<code>remove()</code> 和 <code>replace()</code> 等方法为给定事务设置您想要执行的所有更改。然后，要想将事务应用到 Activity，您必须调用 <code>commit()</code>。</p>
<p>不过，在您调用 <code>commit()</code> 之前，您可能想<strong>调用 <code>addToBackStack()</code>，以将事务添加到片段事务返回栈</strong>。 该返回栈由 Activity 管理，允许用户通过按<em>返回</em>按钮返回上一片段状态。</p>
<p>例如，以下示例说明了如何将一个片段替换成另一个片段，以及如何在返回栈中保留先前状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create new fragment and transaction</span></div><div class="line">Fragment newFragment = <span class="keyword">new</span> ExampleFragment();</div><div class="line">FragmentTransaction transaction = getFragmentManager().beginTransaction();</div><div class="line"></div><div class="line"><span class="comment">// Replace whatever is in the fragment_container view with this fragment,</span></div><div class="line"><span class="comment">// and add the transaction to the back stack</span></div><div class="line">transaction.replace(R.id.fragment_container, newFragment);</div><div class="line">transaction.addToBackStack(<span class="keyword">null</span>);</div><div class="line"></div><div class="line"><span class="comment">// Commit the transaction</span></div><div class="line">transaction.commit();</div></pre></td></tr></table></figure>
<p>在上例中，<code>newFragment</code> 会替换目前在 <code>R.id.fragment_container</code> ID 所标识的布局容器中的任何片段（如有）。通过<strong>调用 <code>addToBackStack()</code> 可将替换事务保存到返回栈</strong>，以便用户能够通过按<em>返回</em>按钮撤消事务并回退到上一片段。</p>
<ul>
<li>替换事务 指的是什么？</li>
</ul>
<p>如果您向事务添加了多个更改（如又一个 <code>add()</code> 或 <code>remove()</code>），并且调用了 <code>addToBackStack()</code>，则在调用 <code>commit()</code> 前应用的<strong>所有更改都将作为单一事务</strong>添加到返回栈，并且<em>返回</em>按钮会将它们一并撤消。</p>
<p>向 <code>FragmentTransaction</code> 添加更改的顺序无关紧要，不过：</p>
<ul>
<li>您必须最后调用 <code>commit()</code></li>
<li>如果您要向同一容器添加多个片段，则您添加片段的顺序将决定它们在视图层次结构中的出现顺序</li>
</ul>
<p>如果您<strong>没有在执行移除片段的事务时调用 <code>addToBackStack()</code>，则事务提交时该片段会被销毁</strong>，用户将无法回退到该片段。 不过，如果您在删除片段时调用了 <code>addToBackStack()</code>，则系统会<em>停止</em>该片段，并在用户回退时将其恢复。</p>
<p><strong>提示</strong>：对于每个片段事务，您都可以通过<strong>在提交前调用 <code>setTransition()</code> 来应用过渡动画</strong>。</p>
<p>调用 <code>commit()</code> <strong>不会立即执行事务</strong>，而是在 Activity 的 UI 线程（“主”线程）可以执行该操作时再安排其在线程上运行。不过，如有必要，您<strong>也可以从 UI 线程调用 <code>executePendingTransactions()</code> 以立即执行 <code>commit()</code> 提交的事务</strong>。通常不必这样做，除非其他线程中的作业依赖该事务。</p>
<p><strong>注意</strong>：您只能在 Activity 保存其状态（用户离开 Activity）之前使用 <code>commit()</code> 提交事务。如果您试图在该时间点后提交，则会引发异常。 这是因为如需恢复 Activity，则提交后的状态可能会丢失。 对于丢失提交无关紧要的情况，请使用 <code>commitAllowingStateLoss()</code>。</p>
<h3 id="FragmentTransaction-commit-vs-FragmentTransaction-commitAllowingStateLoss"><a href="#FragmentTransaction-commit-vs-FragmentTransaction-commitAllowingStateLoss" class="headerlink" title="FragmentTransaction#commit vs  FragmentTransaction#commitAllowingStateLoss"></a>FragmentTransaction#commit vs  FragmentTransaction#commitAllowingStateLoss</h3><h3 id="回退栈"><a href="#回退栈" class="headerlink" title="回退栈"></a>回退栈</h3><p>FragmentTransaction 是在一个链表中存储了一次事务中的所有需要执行的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Add this transaction to the back stack.  This means that the transaction</div><div class="line"> * will be remembered after it is committed, and will reverse its operation</div><div class="line"> * when later popped off the stack.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> name An optional name for this back stack state, or null.</div><div class="line"> */</div><div class="line"><span class="comment">//添加「事务」注意不是某一个 Fragment到回退栈中。这意味着这个事务会在提交后被「记住」</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FragmentTransaction <span class="title">addToBackStack</span><span class="params">(@Nullable String name)</span></span>;</div></pre></td></tr></table></figure>
<p>BackStackRecod 本身还是实现了 Runnabled 接口，是一个可以执行的对象。添加完毕之后，会调用 FragmentHostCallback 中提供的 getHandler 方法，获取到 Handler 方法，然后向主线程的 MessageQueue 中发送一个 mExecCommit 可执行对象</p>
<h3 id="处理片段生命周期"><a href="#处理片段生命周期" class="headerlink" title="处理片段生命周期"></a>处理片段生命周期</h3><p><img src="http://androiddoc.qiniudn.com/images/fragment_lifecycle.png" alt="image"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fpze8kvyyuj309g0irdgj.jpg" alt="activity_fragment_lifecycle"></p>
<p>Activity 生命周期与片段生命周期之间的最显著差异在于它们在其<strong>各自返回栈中的存储方式</strong>。 默认情况下，Activity 停止时会被放入<strong>由<em>系统管理的 Activity 返回栈</em></strong>（以便用户通过<em>返回</em>按钮回退到 Activity，<a href="https://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="noopener">任务和返回栈</a>对此做了阐述）。不过，<strong>仅当在移除片段的事务执行期间通过调用 <code>addToBackStack()</code> 显式请求保存实例时，系统才会将片段放入由<em>宿主 Activity 管理的返回栈</em></strong>。</p>
<p><strong>在其他方面，管理片段生命周期与管理 Activity 生命周期非常相似</strong>。 因此，<a href="https://developer.android.com/guide/components/activities.html#Lifecycle" target="_blank" rel="noopener">管理 Activity 生命周期</a>的做法同样适用于片段。 </p>
<p><strong>注意</strong>：如果需要 Context 的话，可以调用 <code>getActivity()</code>。但要注意，请仅在片段附加到 Activity 时调用 <code>getActivity()</code>。如果片段尚未附加，或在其生命周期结束期间分离，则 <code>getActivity()</code> 将返回 null。</p>
<p>不过，片段还有几个额外的生命周期回调，用于处理与 Activity 的唯一交互，以执行构建和销毁片段 UI 等操作。 这些<strong>额外的回调方法</strong>是：</p>
<ul>
<li><p><code>onAttach()</code></p>
<p>在片段已与 Activity 关联时调用（<code>Activity</code> 传递到此方法内）。</p>
</li>
<li><p><code>onCreateView()</code></p>
<p>调用它可创建与片段关联的视图层次结构。</p>
</li>
<li><p><code>onActivityCreated()</code></p>
<p>在 Activity 的 <code>onCreate()</code> 方法已返回时调用。</p>
</li>
<li><p><code>onDestroyView()</code></p>
<p>在移除与片段关联的视图层次结构时调用。</p>
</li>
<li><p><code>onDetach()</code></p>
<p>在<strong>取消片段与 Activity 的关联时</strong>调用。</p>
</li>
</ul>
<p>一旦 Activity 达到 resume 状态，您就可以随意向 Activity 添加片段和移除其中的片段。 因此，<strong>只有当 Activity 处于 resume 状态时，片段的生命周期才能独立变化</strong>。</p>
<p>Activity 处于resume 状态下时，创建一个 Fragment ，这个Fragment 前面的生命周期会快速走完，直到 resume</p>
<p>不过，当 Activity 离开 resume 状态时，片段会在 Activity 的推动下再次经历其生命周期。</p>
<h2 id="与-Activity-对比"><a href="#与-Activity-对比" class="headerlink" title="与 Activity 对比"></a>与 Activity 对比</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>普通开发者无权使用 Activity 的构造方法，所以，不能通过构造方法从外部注入依赖。</p>
<p>Fragment 的构造方法可以传参进来</p>
<p>Activity 一般是通过 intent。Fragment 会用 setArgument 传一个 Bundle 进来。</p>
<h3 id="设置布局-amp-初始化控件的时机不同"><a href="#设置布局-amp-初始化控件的时机不同" class="headerlink" title="设置布局&amp;初始化控件的时机不同"></a>设置布局&amp;初始化控件的时机不同</h3><p><code>Activity#onCreate</code></p>
<p><code>Fragment#onCreateView</code></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>注: FragmentManagerImpl 定义在 FragmentManager的类文件里面，直接搜只能看到 .class,找不到 .java 文件</li>
</ul>
<p>起始：查找某一个类只看到 .class文件的时候，可以先看看 .class ，它继承/实现了哪些类，然后到父类那里去找，一般都可以找到</p>
<p>我们常看到说 Fragment 的生命周期会与宿主Activity 保持一致，里面究竟是如何实现的呢？</p>
<p>Fragment 的生命周期会在 FragmentActivity 里面的生命周期进行回调</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>因为 Fragment 依附于 Activity（生命周期状态由 Activity 控制），所以Fragment 的生命周期方法是在 Activity 的生命周期方法之后才调用的。</p>
<p>android.app.FragmentManagerImpl#onCreateView()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;    </div><div class="line">    <span class="comment">//……</span></div><div class="line">    </div><div class="line">    <span class="comment">// If we haven't finished entering the CREATED state ourselves yet,</span></div><div class="line">    <span class="comment">// push the inflated child fragment along. This will ensureInflatedFragmentView</span></div><div class="line">    <span class="comment">// at the right phase of the lifecycle so that we will have mView populated</span></div><div class="line">    <span class="comment">// for compliant fragments below.</span></div><div class="line">    <span class="keyword">if</span> (mCurState &lt; Fragment.CREATED &amp;&amp; fragment.mFromLayout) &#123;</div><div class="line">        moveToState(fragment, Fragment.CREATED, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        moveToState(fragment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//……</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><h4 id="add-hide-show-replace"><a href="#add-hide-show-replace" class="headerlink" title="add hide show replace"></a>add hide show replace</h4><p>当然我们注意到 hide 和 show，它们内部实际上不会调用 moveToState, 因为 <strong>hideFragment 实际上就做了三件事请</strong>，</p>
<ul>
<li>设置 mHidden 为 true</li>
<li>fragment.mView.setVisibility(View.GONE); 隐藏 fragment 的 view</li>
<li>fragment.onHiddenChanged(true); 调用 onHiddenChange</li>
</ul>
<p>showFragment 也是类似，只不过行为正好相反。</p>
<h4 id="addFragment"><a href="#addFragment" class="headerlink" title="addFragment"></a>addFragment</h4><p>addFragment 会将 fragment 添加到 mAdded 和 mActive 这两个集合当中，这两个集合维护了当前 activity 中维护的已经添加的 fragment 列表和当前处于活跃状态的 fragment 列表，如果 fragment 位于 mActive 中，那么当 activity 的状态发生变化时，fragment 也会跟随着发生变化。FragmentManger 如何引导 fragment 的状态发生变化呢？</p>
<h4 id="Fragment-状态变迁：moveToState"><a href="#Fragment-状态变迁：moveToState" class="headerlink" title="Fragment 状态变迁：moveToState"></a>Fragment 状态变迁：moveToState</h4><p>Fragment 状态变迁发生在用户主动发起 transaction，或者 fragment 被 add 到 activity 之后跟随 activity 的生命周期变化一起发生改变。每次状态变迁最终都会走到函数 moveToState，字面意思是将 fragment 迁移到新的状态</p>
<p>fragment 的 state 取值，为前面提到的七种状态，其中最低值是 INITIALIZING 状态，代表 fragment <strong>刚创建，还未被 add</strong>， 最高状态值是 RESUMED, 代表 fragment 处于前台。 所以 moveToState 内部分两条线，状态跃升，和状态降低，里面各有一个 switch 判断，注意到 <strong>switch 里每个 case 都没有 break，这意味着，状态可以持续变迁</strong>，比如从 INITIALIZING，一直跃升到 RESUMED，将每个 case 都走一遍，每次 case 语句内，都会改变 state 的值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1008428-c0809de4a37a0d74.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mManager.moveToState(mManager.mCurState, transition, transitionStyle, true);</div></pre></td></tr></table></figure>
<p>就是将 fragment 迁移到 FragmentManager 当前的状态，因为我们不知道用户什么时候 add fragment，因此 fragment 被 add 之后，就将其状态迁移到 FragmentManager 当前的状态，然后跟随 FragmentManager 一起发生状态变迁，除非用户手动 removeFragment 将其从 mActive 列表中移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">getSupportFragmentManager()</div><div class="line">                        .beginTransaction()</div><div class="line">                        .add(,)</div><div class="line">                        .commit();</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">FragmentManagerImpl#beginTransaction //创建一个  BackStackRecord;</div><div class="line">	--&gt; BackStackRecord#add(Fragment, String)</div><div class="line">		--&gt; BackStackRecord#doAddOp</div><div class="line">			--&gt; //进行访问控制检查，如果 Fragment 是一个成员类，那么它必须是 public static 的，这样才能正确地从实例状态中重新创建出来</div><div class="line">				给 mFragmentManager、 mTag 、mContainerId  赋值</div><div class="line">				创建 Op 对象并添加到 Ops （一个 ArrayList） 中 				</div><div class="line">			--&gt; BackStackRecord#commit</div><div class="line">			--&gt; BackStackRecord#commitInternal</div><div class="line">				if mAddToBackStack //添加到回退栈中</div><div class="line">                      mIndex = mManager.allocBackStackIndex(this);//分配回退栈下标</div><div class="line">						--&gt; 主要对下面两个列表进行操作</div><div class="line">						ArrayList&lt;BackStackRecord&gt; mBackStackIndices;</div><div class="line">    					ArrayList&lt;Integer&gt; mAvailBackStackIndices;</div><div class="line">                  else </div><div class="line">                      mIndex = -1;</div><div class="line">                  </div><div class="line">					--&gt; FragmentManagerImpl#enqueueAction//在等待操作的队列中添加一个操作。</div><div class="line">                      	--&gt;  mPendingActions.add(action);//添加到「队列中」 （实际上是一个 ArrayList）</div><div class="line">            		    --&gt; scheduleCommit();//安排 commit</div><div class="line">							--&gt; 内部通过 Handler 来实现</div><div class="line">								执行的是 mExecCommit （一个 Runnable）</div><div class="line">								--&gt; FragmentManagerImpl#execPendingActions</div></pre></td></tr></table></figure>
<p>FragmentManagerImpl#execPendingActions //只能从主线程调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execPendingActions</span><span class="params">()</span> </span>&#123;</div><div class="line">    ensureExecReady(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123;</div><div class="line">        mExecutingActions = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            optimizeAndExecuteOps(mTmpRecords, mTmpIsPop);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            cleanupExec();</div><div class="line">        &#125;</div><div class="line">        didSomething = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    doPendingDeferredStart();</div><div class="line">    burpActive();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> didSomething;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="生命周期方法回调"><a href="#生命周期方法回调" class="headerlink" title="生命周期方法回调"></a>生命周期方法回调</h3><p>Fragment 的各个生命周期方法回调都是通过fragment.app.FragmentManagerImpl#moveToState 方法分发出来的 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ReferenceEquality"</span>)</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(Fragment f, <span class="keyword">int</span> newState, <span class="keyword">int</span> transit, <span class="keyword">int</span> transitionStyle,</span></span></div><div class="line">        <span class="keyword">boolean</span> keepActive) &#123;</div><div class="line">    <span class="comment">// Fragments that are not currently added will sit in the onCreate() state.</span></div><div class="line">    <span class="keyword">if</span> ((!f.mAdded || f.mDetached) &amp;&amp; newState &gt; Fragment.CREATED) &#123;</div><div class="line">        newState = Fragment.CREATED;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (f.mRemoving &amp;&amp; newState &gt; f.mState) &#123;</div><div class="line">        <span class="keyword">if</span> (f.mState == Fragment.INITIALIZING &amp;&amp; f.isInBackStack()) &#123;</div><div class="line">            <span class="comment">// Allow the fragment to be created so that it can be saved later.</span></div><div class="line">            newState = Fragment.CREATED;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// While removing a fragment, we can't change it to a higher state.</span></div><div class="line">            newState = f.mState;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Defer start if requested; don't allow it to move to STARTED or higher</span></div><div class="line">    <span class="comment">// if it's not already started.</span></div><div class="line">    <span class="keyword">if</span> (f.mDeferStart &amp;&amp; f.mState &lt; Fragment.STARTED &amp;&amp; newState &gt; Fragment.ACTIVITY_CREATED) &#123;</div><div class="line">        newState = Fragment.ACTIVITY_CREATED;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (f.mState &lt;= newState) &#123;</div><div class="line">        <span class="comment">// For fragments that are created from a layout, when restoring from</span></div><div class="line">        <span class="comment">// state we don't want to allow them to be created until they are</span></div><div class="line">        <span class="comment">// being reloaded from the layout.</span></div><div class="line">        <span class="keyword">if</span> (f.mFromLayout &amp;&amp; !f.mInLayout) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (f.getAnimatingAway() != <span class="keyword">null</span> || f.getAnimator() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// The fragment is currently being animated...  but!  Now we</span></div><div class="line">            <span class="comment">// want to move our state back up.  Give up on waiting for the</span></div><div class="line">            <span class="comment">// animation, move to whatever the final state should be once</span></div><div class="line">            <span class="comment">// the animation is done, and then we can proceed from there.</span></div><div class="line">            f.setAnimatingAway(<span class="keyword">null</span>);</div><div class="line">            f.setAnimator(<span class="keyword">null</span>);</div><div class="line">            moveToState(f, f.getStateAfterAnimating(), <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">switch</span> (f.mState) &#123;</div><div class="line">            <span class="keyword">case</span> Fragment.INITIALIZING:</div><div class="line">	            	<span class="comment">//新状态大于 初始化状态</span></div><div class="line">                <span class="keyword">if</span> (newState &gt; Fragment.INITIALIZING) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto CREATED: "</span> + f);</div><div class="line">                    <span class="keyword">if</span> (f.mSavedFragmentState != <span class="keyword">null</span>) &#123;</div><div class="line">                        f.mSavedFragmentState.setClassLoader(mHost.getContext()</div><div class="line">                                .getClassLoader());</div><div class="line">                        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(</div><div class="line">                                FragmentManagerImpl.VIEW_STATE_TAG);</div><div class="line">                        f.mTarget = getFragment(f.mSavedFragmentState,</div><div class="line">                                FragmentManagerImpl.TARGET_STATE_TAG);</div><div class="line">                        <span class="keyword">if</span> (f.mTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                            f.mTargetRequestCode = f.mSavedFragmentState.getInt(</div><div class="line">                                    FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, <span class="number">0</span>);</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (f.mSavedUserVisibleHint != <span class="keyword">null</span>) &#123;</div><div class="line">                            f.mUserVisibleHint = f.mSavedUserVisibleHint;</div><div class="line">                            f.mSavedUserVisibleHint = <span class="keyword">null</span>;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(</div><div class="line">                                    FragmentManagerImpl.USER_VISIBLE_HINT_TAG, <span class="keyword">true</span>);</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (!f.mUserVisibleHint) &#123;</div><div class="line">                            f.mDeferStart = <span class="keyword">true</span>;</div><div class="line">                            <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</div><div class="line">                                newState = Fragment.ACTIVITY_CREATED;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    f.mHost = mHost;</div><div class="line">                    f.mParentFragment = mParent;</div><div class="line">                    f.mFragmentManager = mParent != <span class="keyword">null</span></div><div class="line">                            ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl();</div><div class="line"></div><div class="line">                    <span class="comment">// If we have a target fragment, push it along to at least CREATED</span></div><div class="line">                    <span class="comment">// so that this one can rely on it as an initialized dependency.</span></div><div class="line">                    <span class="keyword">if</span> (f.mTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (mActive.get(f.mTarget.mIndex) != f.mTarget) &#123;</div><div class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment "</span> + f</div><div class="line">                                    + <span class="string">" declared target fragment "</span> + f.mTarget</div><div class="line">                                    + <span class="string">" that does not belong to this FragmentManager!"</span>);</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (f.mTarget.mState &lt; Fragment.CREATED) &#123;</div><div class="line">                            moveToState(f.mTarget, Fragment.CREATED, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">true</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    dispatchOnFragmentPreAttached(f, mHost.getContext(), <span class="keyword">false</span>);</div><div class="line">                    f.mCalled = <span class="keyword">false</span>;</div><div class="line">                  	<span class="comment">//回调 onAttach 方法</span></div><div class="line">                    f.onAttach(mHost.getContext());</div><div class="line">                    <span class="keyword">if</span> (!f.mCalled) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Fragment "</span> + f</div><div class="line">                                + <span class="string">" did not call through to super.onAttach()"</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (f.mParentFragment == <span class="keyword">null</span>) &#123;</div><div class="line">                        mHost.onAttachFragment(f);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        f.mParentFragment.onAttachFragment(f);</div><div class="line">                    &#125;</div><div class="line">	                  <span class="comment">//</span></div><div class="line">                    dispatchOnFragmentAttached(f, mHost.getContext(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!f.mIsCreated) &#123;</div><div class="line">                        dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, <span class="keyword">false</span>);</div><div class="line">                      	<span class="comment">//回调 Fragment#onCreate</span></div><div class="line">                        f.performCreate(f.mSavedFragmentState);</div><div class="line">                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, <span class="keyword">false</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	                      <span class="comment">//恢复状态</span></div><div class="line">                        f.restoreChildFragmentState(f.mSavedFragmentState);</div><div class="line">                        f.mState = Fragment.CREATED;</div><div class="line">                    &#125;</div><div class="line">                    f.mRetaining = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// fall through</span></div><div class="line">            <span class="keyword">case</span> Fragment.CREATED:</div><div class="line">                <span class="comment">// This is outside the if statement below on purpose; we want this to run</span></div><div class="line">                <span class="comment">// even if we do a moveToState from CREATED =&gt; *, CREATED =&gt; CREATED, and</span></div><div class="line">                <span class="comment">// * =&gt; CREATED as part of the case fallthrough above.</span></div><div class="line">                ensureInflatedFragmentView(f);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (newState &gt; Fragment.CREATED) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto ACTIVITY_CREATED: "</span> + f);</div><div class="line">                    <span class="keyword">if</span> (!f.mFromLayout) &#123;</div><div class="line">                        ViewGroup container = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (f.mContainerId != <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (f.mContainerId == View.NO_ID) &#123;</div><div class="line">                                throwException(<span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                                        <span class="string">"Cannot create fragment "</span></div><div class="line">                                                + f</div><div class="line">                                                + <span class="string">" for a container view with no id"</span>));</div><div class="line">                            &#125;</div><div class="line">                          	<span class="comment">//查找 container 实例</span></div><div class="line">                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);</div><div class="line">                            <span class="keyword">if</span> (container == <span class="keyword">null</span> &amp;&amp; !f.mRestored) &#123;</div><div class="line">                                String resName;</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    resName = f.getResources().getResourceName(f.mContainerId);</div><div class="line">                                &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</div><div class="line">                                    resName = <span class="string">"unknown"</span>;</div><div class="line">                                &#125;</div><div class="line">                                throwException(<span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                                        <span class="string">"No view found for id 0x"</span></div><div class="line">                                        + Integer.toHexString(f.mContainerId) + <span class="string">" ("</span></div><div class="line">                                        + resName</div><div class="line">                                        + <span class="string">") for fragment "</span> + f));</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        f.mContainer = container;</div><div class="line">                      	<span class="comment">//回调 onCreateView，同时为 Fragment#mView 成员变量赋值</span></div><div class="line">                        f.performCreateView(f.performGetLayoutInflater(</div><div class="line">                                f.mSavedFragmentState), container, f.mSavedFragmentState);</div><div class="line">                        <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</div><div class="line">                            f.mInnerView = f.mView;</div><div class="line">                            f.mView.setSaveFromParentEnabled(<span class="keyword">false</span>);</div><div class="line">                            <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</div><div class="line">                                container.addView(f.mView);</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (f.mHidden) &#123;</div><div class="line">                                f.mView.setVisibility(View.GONE);</div><div class="line">                            &#125;</div><div class="line">                          	<span class="comment">//回调 fragment#onViewCreated</span></div><div class="line">                            f.onViewCreated(f.mView, f.mSavedFragmentState);</div><div class="line">                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,</div><div class="line">                                    <span class="keyword">false</span>);</div><div class="line">                            <span class="comment">// Only animate the view if it is visible. This is done after</span></div><div class="line">                            <span class="comment">// dispatchOnFragmentViewCreated in case visibility is changed</span></div><div class="line">                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE)</div><div class="line">                                    &amp;&amp; f.mContainer != <span class="keyword">null</span>;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            f.mInnerView = <span class="keyword">null</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    f.performActivityCreated(f.mSavedFragmentState);</div><div class="line">                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</div><div class="line">                        f.restoreViewState(f.mSavedFragmentState);</div><div class="line">                    &#125;</div><div class="line">                    f.mSavedFragmentState = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// fall through</span></div><div class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</div><div class="line">                <span class="keyword">if</span> (newState &gt; Fragment.ACTIVITY_CREATED) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto STARTED: "</span> + f);</div><div class="line">                    f.performStart();</div><div class="line">                    dispatchOnFragmentStarted(f, <span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// fall through</span></div><div class="line">            <span class="keyword">case</span> Fragment.STARTED:</div><div class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STARTED) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"moveto RESUMED: "</span> + f);</div><div class="line">                    f.performResume();</div><div class="line">                    dispatchOnFragmentResumed(f, <span class="keyword">false</span>);</div><div class="line">                    f.mSavedFragmentState = <span class="keyword">null</span>;</div><div class="line">                    f.mSavedViewState = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.mState &gt; newState) &#123;</div><div class="line">        <span class="keyword">switch</span> (f.mState) &#123;</div><div class="line">            <span class="keyword">case</span> Fragment.RESUMED:</div><div class="line">                <span class="keyword">if</span> (newState &lt; Fragment.RESUMED) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom RESUMED: "</span> + f);</div><div class="line">                    f.performPause();</div><div class="line">                    dispatchOnFragmentPaused(f, <span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// fall through</span></div><div class="line">            <span class="keyword">case</span> Fragment.STARTED:</div><div class="line">                <span class="keyword">if</span> (newState &lt; Fragment.STARTED) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom STARTED: "</span> + f);</div><div class="line">                    f.performStop();</div><div class="line">                    dispatchOnFragmentStopped(f, <span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// fall through</span></div><div class="line">            <span class="keyword">case</span> Fragment.ACTIVITY_CREATED:</div><div class="line">                <span class="keyword">if</span> (newState &lt; Fragment.ACTIVITY_CREATED) &#123;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom ACTIVITY_CREATED: "</span> + f);</div><div class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// Need to save the current view state if not</span></div><div class="line">                        <span class="comment">// done already.</span></div><div class="line">                        <span class="keyword">if</span> (mHost.onShouldSaveFragmentState(f) &amp;&amp; f.mSavedViewState == <span class="keyword">null</span>) &#123;</div><div class="line">                            saveFragmentViewState(f);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    f.performDestroyView();</div><div class="line">                    dispatchOnFragmentViewDestroyed(f, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (f.mView != <span class="keyword">null</span> &amp;&amp; f.mContainer != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// Stop any current animations:</span></div><div class="line">                        f.mContainer.endViewTransition(f.mView);</div><div class="line">                        f.mView.clearAnimation();</div><div class="line">                        AnimationOrAnimator anim = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (mCurState &gt; Fragment.INITIALIZING &amp;&amp; !mDestroyed</div><div class="line">                                &amp;&amp; f.mView.getVisibility() == View.VISIBLE</div><div class="line">                                &amp;&amp; f.mPostponedAlpha &gt;= <span class="number">0</span>) &#123;</div><div class="line">                            anim = loadAnimation(f, transit, <span class="keyword">false</span>,</div><div class="line">                                    transitionStyle);</div><div class="line">                        &#125;</div><div class="line">                        f.mPostponedAlpha = <span class="number">0</span>;</div><div class="line">                        <span class="keyword">if</span> (anim != <span class="keyword">null</span>) &#123;</div><div class="line">                            animateRemoveFragment(f, anim, newState);</div><div class="line">                        &#125;</div><div class="line">                        f.mContainer.removeView(f.mView);</div><div class="line">                    &#125;</div><div class="line">                    f.mContainer = <span class="keyword">null</span>;</div><div class="line">                    f.mView = <span class="keyword">null</span>;</div><div class="line">                    <span class="comment">// Set here to ensure that Observers are called after</span></div><div class="line">                    <span class="comment">// the Fragment's view is set to null</span></div><div class="line">                    f.mViewLifecycleOwner = <span class="keyword">null</span>;</div><div class="line">                    f.mViewLifecycleOwnerLiveData.setValue(<span class="keyword">null</span>);</div><div class="line">                    f.mInnerView = <span class="keyword">null</span>;</div><div class="line">                    f.mInLayout = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// fall through</span></div><div class="line">            <span class="keyword">case</span> Fragment.CREATED:</div><div class="line">                <span class="keyword">if</span> (newState &lt; Fragment.CREATED) &#123;</div><div class="line">                    <span class="keyword">if</span> (mDestroyed) &#123;</div><div class="line">                        <span class="comment">// The fragment's containing activity is</span></div><div class="line">                        <span class="comment">// being destroyed, but this fragment is</span></div><div class="line">                        <span class="comment">// currently animating away.  Stop the</span></div><div class="line">                        <span class="comment">// animation right now -- it is not needed,</span></div><div class="line">                        <span class="comment">// and we can't wait any more on destroying</span></div><div class="line">                        <span class="comment">// the fragment.</span></div><div class="line">                        <span class="keyword">if</span> (f.getAnimatingAway() != <span class="keyword">null</span>) &#123;</div><div class="line">                            View v = f.getAnimatingAway();</div><div class="line">                            f.setAnimatingAway(<span class="keyword">null</span>);</div><div class="line">                            v.clearAnimation();</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.getAnimator() != <span class="keyword">null</span>) &#123;</div><div class="line">                            Animator animator = f.getAnimator();</div><div class="line">                            f.setAnimator(<span class="keyword">null</span>);</div><div class="line">                            animator.cancel();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (f.getAnimatingAway() != <span class="keyword">null</span> || f.getAnimator() != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// We are waiting for the fragment's view to finish</span></div><div class="line">                        <span class="comment">// animating away.  Just make a note of the state</span></div><div class="line">                        <span class="comment">// the fragment now should move to once the animation</span></div><div class="line">                        <span class="comment">// is done.</span></div><div class="line">                        f.setStateAfterAnimating(newState);</div><div class="line">                        newState = Fragment.CREATED;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"movefrom CREATED: "</span> + f);</div><div class="line">                        <span class="keyword">if</span> (!f.mRetaining) &#123;</div><div class="line">                            f.performDestroy();</div><div class="line">                            dispatchOnFragmentDestroyed(f, <span class="keyword">false</span>);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            f.mState = Fragment.INITIALIZING;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        f.performDetach();</div><div class="line">                        dispatchOnFragmentDetached(f, <span class="keyword">false</span>);</div><div class="line">                        <span class="keyword">if</span> (!keepActive) &#123;</div><div class="line">                            <span class="keyword">if</span> (!f.mRetaining) &#123;</div><div class="line">                                makeInactive(f);</div><div class="line">                            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                f.mHost = <span class="keyword">null</span>;</div><div class="line">                                f.mParentFragment = <span class="keyword">null</span>;</div><div class="line">                                f.mFragmentManager = <span class="keyword">null</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (f.mState != newState) &#123;</div><div class="line">        Log.w(TAG, <span class="string">"moveToState: Fragment state for "</span> + f + <span class="string">" not updated inline; "</span></div><div class="line">                + <span class="string">"expected state "</span> + newState + <span class="string">" found "</span> + f.mState);</div><div class="line">        f.mState = newState;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="getChildFragmentManager"><a href="#getChildFragmentManager" class="headerlink" title="getChildFragmentManager"></a>getChildFragmentManager</h3><p>mChildFragmentManager 的实际类型也是一个 FragmentManager ，</p>
<p>attachController 的时候，会将 当前 Fragment 传递给 parent 参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void attachController(FragmentHostCallback host,</div><div class="line">        FragmentContainer container, Fragment parent) &#123;</div><div class="line">    if (mHost != null) throw new IllegalStateException(&quot;Already attached&quot;);</div><div class="line">    mHost = host;</div><div class="line">    mContainer = container;</div><div class="line">    mParent = parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><p><a href="https://www.jianshu.com/p/180d2cc0feb5" target="_blank" rel="noopener">https://www.jianshu.com/p/180d2cc0feb5</a></p>
</li>
<li><p><a href="https://developer.android.com/reference/android/app/Fragment" target="_blank" rel="noopener">Fragment | Android Developers</a></p>
</li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Http 头部字段]]></title>
      <url>https://timlin-pro.github.io/blog/2018/03/02/Http-%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5/</url>
      <content type="html"><![CDATA[<h2 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h2><p><img src="https://user-images.githubusercontent.com/16668676/44859151-2465cc80-aca6-11e8-9374-e7af115b58b1.png" alt="image"></p>
<h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><p>在请求中，HTTP 报文由<strong>方法、URI、HTTP 版本、HTTP 首部字段</strong>等部分构成。</p>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fqj12dx3guj30wy0acq7h.jpg" alt=""></p>
<h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p>在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、<br>HTTP 首部字段 3 部分构成。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fqj174ztg9j30ws08wgq2.jpg" alt=""></p>
<h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><p>首部和方法配合工作，共同决定了客户端和服务器能做什么事情。    </p>
<p>在请求和响应报文中都可以<strong>用首部来提供信息</strong>，有些首部是某种报文专用的，有些首部则更通用一些。可以将首部分为五个主要的类型。</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>通用首部字段是指，<strong>请求报文和响应报文双方都会使用的首部</strong>。</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Cache-Control</strong></td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td><strong>Upgrade</strong></td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<p><code>Cache-Control: private, max-age=0, no-cache</code></p>
<p>指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。</p>
<h5 id="缓存请求指令"><a href="#缓存请求指令" class="headerlink" title="缓存请求指令"></a>缓存请求指令</h5><table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-cache</td>
<td>无</td>
<td>强制向源服务器再次验证</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>max-age = [ 秒]</td>
<td>必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td>max-stale( = [ 秒])</td>
<td>可省略</td>
<td>接收已过期的响应</td>
</tr>
<tr>
<td>min-fresh = [ 秒]</td>
<td>必需</td>
<td>期望在指定时间内的响应仍有效</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>无</td>
<td>从缓存获取资源</td>
</tr>
<tr>
<td>cache-extension</td>
<td>-</td>
<td>新指令标记（token）</td>
</tr>
</tbody>
</table>
<p>换言之，无参数值的首部字段可以使用缓存。</p>
<blockquote>
<p>从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表<strong>不缓存<em>过期</em>的资源</strong>，缓存会向源服务器进行有效期确认后处理资源，也许称为 <code>do-notserve-from-cache-without-revalidation</code>更合适。<strong><code>no-store</code>才是真正地不进行缓存</strong>，</p>
</blockquote>
<h5 id="max-age"><a href="#max-age" class="headerlink" title="max-age"></a>max-age</h5><p>使用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会<strong>优先处理 max-age 指令</strong>，而<strong>忽略掉 Expires 首部字</strong>段。<br>而HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉</p>
<h5 id="only-if-cached-指令"><a href="#only-if-cached-指令" class="headerlink" title="only-if-cached 指令"></a>only-if-cached 指令</h5><p><code>Cache-Control: only-if-cached</code><br>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令<strong>要求缓存服务器不重新加载响应，也不会再次确认资源有效性</strong>。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">This field&apos;s name &quot;only-if-cached&quot; is misleading. It actually means &quot;do not use the network&quot;. It is set by a client who only wants to make a request if it can be fully satisfied by the cache. Cached responses that would require validation (ie. conditional gets) are not permitted if this header is set.</div><div class="line"></div><div class="line">该字段名有误导性。实际意义是「不要使用网络」。它由一个只有在缓存能够完全满足需求的情况下才想发出请求的客户端。如果设置了该 header，则不允许使用需要验证的缓存响应（ 比如。条件 get 请求）。</div></pre></td></tr></table></figure>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td><strong>If-Modified-Since</strong></td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent HTTP</td>
<td>客户端程序的信息</td>
</tr>
</tbody>
</table>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<h3 id="vary"><a href="#vary" class="headerlink" title="vary"></a>vary</h3><ul>
<li>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</li>
<li>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</li>
</ul>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>实体首部字段是包含在请求报文和响应报文中的<strong>实体部分所使用的首部</strong>，用于补充内容的更新时间等与实体相关的信息。</p>
<p>有很多首部可以用来<strong>描述 HTTP 报文的负荷</strong>。</p>
<p>实体首部提供了<strong>有关实体及其内容的大量信息</strong>，从有关<strong>对象类型的信息</strong>，到能够<strong>对资源使用的各种有效的请求方法</strong>。总之，<strong>实体首部可以告知报文的接收者它在对什么进行处理</strong>。下表中 列出了实体的信息性首部。</p>
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>资源<strong>可支持的HTTP方法</strong></td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td><strong>Content-Length</strong></td>
<td><strong>实体主体的大小</strong>（单位：字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td><strong>Content-MD5</strong></td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td><strong>Content-Range</strong></td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td><strong>Content-Type</strong></td>
<td>实体主体的<strong>媒体类型</strong></td>
</tr>
<tr>
<td><strong>Expires</strong></td>
<td>实体主体<strong>过期的日期时间</strong></td>
</tr>
<tr>
<td><strong>Last-Modified</strong></td>
<td>资源的<strong>最后修改日期时间</strong></td>
</tr>
</tbody>
</table>
<h3 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h3><p>扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的 HTTP 规范中去。即使不知道这些扩展首部的含义，HTTP 程序也要接受它们并对其进行转发。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《图解 HTTP》</li>
<li>《HTTP 权威指南》</li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Http </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[拆轮子系列——LeakCanary工作原理]]></title>
      <url>https://timlin-pro.github.io/blog/2017/12/15/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94LeakCanary%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>LeakCanary 是一个内存泄漏的自动化监测工具。</p>
<h3 id="1-1什么是内存泄漏？"><a href="#1-1什么是内存泄漏？" class="headerlink" title="1.1什么是内存泄漏？"></a>1.1什么是内存泄漏？</h3><p>内存泄漏指的是应该被释放的内存的没有被释放。原因？长生命周期的对象持有短生命周期对象的引用。</p>
<h3 id="1-2哪些对象应该被回收？"><a href="#1-2哪些对象应该被回收？" class="headerlink" title="1.2哪些对象应该被回收？"></a>1.2哪些对象应该被回收？</h3><p>首先要找出哪些对象是<strong>应该被回收</strong>的？Android 中使用最频繁的是 Activity 和 Fragment 了。他们都有 onDestory 方法，当它们的 <strong>onDestroy 执行的时候，就可以把它们列为 「应该被回收的对象</strong>」，可在 onDestory  方法中建立<strong>检测点</strong>。</p>
<a id="more"></a>
<p>注：</p>
<ol>
<li><code>Application#dispatchActivityDestroyed</code> 是在 <code>Activity#onDestroy</code> 方法执行后回调的。</li>
</ol>
<h3 id="1-3如何知道对象是否被回收了？"><a href="#1-3如何知道对象是否被回收了？" class="headerlink" title="1.3如何知道对象是否被回收了？"></a>1.3如何知道对象是否被回收了？</h3><p>手动 GC +ReferenceQueue + WeakReference</p>
<blockquote>
<p>  WeakReference 创建时，传入一个 ReferenceQueue 对象。当被 WeakReference 引用的对象的生命周期结束，一旦被 GC 检查到，GC 将会把该对象添加到 ReferenceQueue 中，待 ReferenceQueue 处理。当 GC 过后对象一直不被加入 ReferenceQueue，说明它可能存在内存泄漏。</p>
</blockquote>
<p>这里其实有一个默认的前提就是，当一个对象存在强引用的时候，这个对象是不会被回收的，所以 GC 前后，可达性并不会发生变化，也就不会被加入到 referenceQueue 中。而如果一个对象只含有弱引用的时候，GC 前后可达性会发生改变——GC 之前弱可达，GC 之后变不可达。</p>
<p>什么样的对象会进入ReferenceQueue？</p>
<blockquote>
<p>创建 Reference 的时候指定了 ReferenceQueue，并且对象的可达性发生了变化。</p>
</blockquote>
<p>具体加入的时间是在 GC前还是 GC后 并不是很重要，重要的是，<strong>一旦被添加到 ReferenceQueue 中，对应的对象一定会被回收</strong> (及时被回收了自然也就没有内存泄漏问题了，所以 LeakCanary 把加入 ReferenceQueue 作为内存泄漏检测的初步判断标准)</p>
<p>假设没有发生内存泄漏，那么这个时候，Activity 仅被我们创建的 KeyedWeakReference 弱引用了。我们第一次手动 GC 的时候，它就会进入引用队列。这个时候可以将它从 retainkeys 中移除。</p>
<p>对象一旦只存在弱引用，会 ReferenceHandler 线程监听到，该线程会将该对象的引用加入 ReferenceQueue 中，这发生在 finalization 或者 gc 之前。</p>
<p>LeakCanary 判断是否发生内存的泄漏的标准：对象的引用是否在<code>Set&lt;String&gt; retainedKeys</code> 中。</p>
<ul>
<li>创建一个跟踪对象，将它的 key 存储在一个 retainedKeys 中。当对象出现在引用队列里面的时候，将它从 set 中移除，如果一个对象的引用不在retainKeys 中，说明没有发生内存泄漏。如果在，则说明可能发生了内存泄漏。</li>
</ul>
<h3 id="1-4未被回收-内存泄漏？"><a href="#1-4未被回收-内存泄漏？" class="headerlink" title="1.4未被回收==内存泄漏？"></a>1.4未被回收==内存泄漏？</h3><h4 id="没被回收的原因：被持有强引用了吗？"><a href="#没被回收的原因：被持有强引用了吗？" class="headerlink" title="没被回收的原因：被持有强引用了吗？"></a>没被回收的原因：被持有强引用了吗？</h4><p>未被回收的对象，是否被其他对象引用？找出<strong>其最短引用链</strong>。<code>VMDebug</code> + <code>HAHA</code> 完成需求。</p>
<p>VMDebug、HAHA。</p>
<blockquote>
<p>  VM 会有堆内各个对象的引用情况，并能以<code>hprof</code>文件导出。HAHA 是一个由 square 开源的 Android 堆分析库，分析 <code>hprof</code> 文件生成<code>Snapshot</code>对象。<code>Snapshot</code>用以查询对象的最短引用链。</p>
</blockquote>
<p>找到最短引用链后，定位问题，排查代码将会事半功倍。</p>
<p>下面是一个总体流程图：（流程图参考自<a href="http://www.jianshu.com/p/3f1a1cc1e964" target="_blank" rel="noopener">这篇文章</a>）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/737949-cff06b0079bf09c4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<p>如果读者还没看过 LeakCanary 的源码，建议照着上面的调用流程图过一遍，这样效果会好很多。why？<a href="https://juejin.im/post/5a137248f265da43333e0418" target="_blank" rel="noopener">为什么源码分析味同嚼蜡？浅析技术写作中的思维误区</a></p>
<h2 id="二、具体流程"><a href="#二、具体流程" class="headerlink" title="二、具体流程"></a>二、具体流程</h2><p>前面讲了大体流程，接下来我们看看内部的实现。</p>
<p>通常会在 Applcation#onCreate 中对 LeakCanary 进行初始化,也就是调用下面的 setupLeakCanary 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> RefWatcher <span class="title">setupLeakCanary</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="keyword">this</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> RefWatcher.DISABLED;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> LeakCanary.install(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-1LeakCanary-install-调用流程"><a href="#2-1LeakCanary-install-调用流程" class="headerlink" title="2.1LeakCanary#install 调用流程"></a>2.1LeakCanary#install 调用流程</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">--&gt; ① LeakCanary#install</div><div class="line">	--&gt; ② refWatcher</div><div class="line">		--&gt; ③ AndroidRefWatcherBuilder#listenerServiceClass	//监听服务类</div><div class="line">			--&gt; ④ AndroidExcludedRefs#createAppDefaults//创建默认的忽略列表</div><div class="line">				--&gt; ⑤ ExcludedRefs.Builder#build</div><div class="line">			--&gt; ⑥ RefWatcherBuilder#excludedRefs//排除一些引用</div><div class="line">			--&gt; ⑦ AndroidRefWatcherBuilder#buildAndInstall//构造一个 RefWatcher </div><div class="line">				--&gt; ⑧ RefWatcherBuilder#build</div><div class="line">				--&gt; ⑨ ActivityRefWatcher#install</div><div class="line">					--&gt; ⑩ new ActivityRefWatcher</div><div class="line">						--&gt; ⑪ ActivityRefWatcher#watchActivities</div><div class="line">						--&gt; ⑫ stopWatchingActivities();//防止装载两次，</div><div class="line">							--&gt; ⑬ Application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);//解注册</div><div class="line">						--&gt; ⑭    </div><div class="line">              Application#registerActivityLifecycleCallbacks(lifecycleCallbacks);//注册生命周期回调</div><div class="line">							--&gt; ⑮1mActivityLifecycleCallbacks.add(callback);//添加到监听者列表中</div></pre></td></tr></table></figure>
<p>注：监听回调进行仅仅实现了 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</div><div class="line">  ActivityRefWatcher.<span class="keyword">this</span>.onActivityDestroyed(activity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可以看出在默认情况下只监听 Activity 的 <code>onDestory</code> 方法，也就是说只是检测 Activity 是否存在内存泄漏。</p>
<h4 id="如果要检测-Fragment-的内存泄漏，应该如何实现？"><a href="#如果要检测-Fragment-的内存泄漏，应该如何实现？" class="headerlink" title="如果要检测 Fragment 的内存泄漏，应该如何实现？"></a>如果要检测 Fragment 的内存泄漏，应该如何实现？</h4><p>因为 Android 中只提供了 Activity 的生命周期方法的回调，而没有提供 Fragment 生命周期回调的监听。 如果要对 Fragment 的内存泄漏进行检测，那么需要自己在 <code>Fragment#onDestroy</code> 方法中手动创建一个 RefWatcher ，然后调用 <code>refWatcher#watch(this)</code>，最好是定义一个 Fragment 基类，在其中的 onDestroy 方法中定义相应的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDestroy();</div><div class="line">    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());</div><div class="line">    refWatcher.watch(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2当监听事件发生时，切换到后台执行"><a href="#2-2当监听事件发生时，切换到后台执行" class="headerlink" title="2.2当监听事件发生时，切换到后台执行"></a>2.2当监听事件发生时，切换到后台执行</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">--&gt; ① ActivityLifecycleCallbacks#onActivityDestroyed</div><div class="line">	--&gt;② ActivityRefWatcher#onActivityDestroyed</div><div class="line">		--&gt;③ RefWatcher#watch(Object)</div><div class="line">			--&gt;④ RefWatcher#watch(Object, String)    内部有一个 ReferenceQueue&lt;Object&gt; queue;</div><div class="line">				--&gt;⑤ new KeyedWeakReference(watchedReference, key, referenceName, queue)//创建 KeyedWeakReference</div><div class="line">  					//两个 Handler,mainHandler 、backgroundHandler</div><div class="line">  				--&gt;⑥ RefWatcher#ensureGoneAsync</div><div class="line">  					--&gt;⑦ WatchExecutor#execute </div><div class="line"> 						if 当前线程为主线程</div><div class="line"> 							==&gt; ⑧AndroidWatchExecutor#waitForIdle// 等待 MainLooper 空闲时发送</div><div class="line"> 							</div><div class="line">								--&gt; ⑨MessageQueue#addIdleHandler//当 Looper 即将闲置时发送</div><div class="line">									--&gt; ⑩AndroidWatchExecutor#postToBackgroundWithDelay</div><div class="line">										--&gt; ⑪backgroundHandler#postDelayed//工作线程 Handler 延迟发送</div><div class="line">											--&gt; ⑫Retryable</div><div class="line">											--&gt; if (result == RETRY) </div><div class="line">         										 ⑬postWaitForIdle(retryable, failedAttempts + 1);</div><div class="line"> 						else ⑧当前线程是工作线程，需要先切换到主线程，再从主线程切换到 HandlerThread 线程</div><div class="line">  							--&gt; ⑨AndroidWatchExecutor#postWaitForIdle</div><div class="line">                          	   		--&gt; ⑩mainHandler#post//通过主线程 Handler 切换到主线程执行	</div><div class="line">                          	   			==&gt; ⑪AndroidWatchExecutor#waitForIdle//等待空闲时发送</div></pre></td></tr></table></figure>
<p>可以看到 <code>Retryable#run</code> 在工作线程执行。<code>AndroidWatchExecutor</code> 内创建了一个 HandlerThread ，通过它创建了一个 Handler。如果当前线程是主线程，直接调用主线程的  <code>Message#addIdleHandler</code> 进行处理，给工作线程发送延时任务。否则，需要先调用 <code>mainHandler#post</code> 方法， 切换到主线程，然后再调用 <code>AndroidWatchExecutor#waitForIdle</code>。之所以要切换到主线程，主要是为了使用主线程的 <code>MessageQueue#addIdleHandler</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(LEAK_CANARY_THREAD_NAME);</div><div class="line">handlerThread.start();</div><div class="line">backgroundHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</div></pre></td></tr></table></figure>
<p>前面所谈都是执行线程的切换，下面开始内存分析任务具体是如何进行的。</p>
<h3 id="2-3内存泄漏分析"><a href="#2-3内存泄漏分析" class="headerlink" title="2.3内存泄漏分析"></a>2.3内存泄漏分析</h3><h4 id="2-3-1工作机制"><a href="#2-3-1工作机制" class="headerlink" title="2.3.1工作机制"></a>2.3.1工作机制</h4><ol>
<li>在后台线程检查引用是否被清除，如果没有，调用 GC。</li>
<li>如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 <code>.hprof</code> 文件中。</li>
<li>在另外一个进程中的 <code>HeapAnalyzerService</code> 有一个 <code>HeapAnalyzer</code> 使用<a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a> 解析这个文件。</li>
<li>得益于唯一的 reference key, <code>HeapAnalyzer</code> 找到 <code>KeyedWeakReference</code>，定位内存泄漏。</li>
<li><code>HeapAnalyzer</code> 计算 <em>到 GC roots 的最短强引用路径</em>，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。</li>
<li>引用链传递到 APP 进程中的 <code>DisplayLeakService</code>， 并以通知的形式展示出来。</li>
</ol>
<h4 id="2-3-2RefWatcher-ensureGone"><a href="#2-3-2RefWatcher-ensureGone" class="headerlink" title="2.3.2RefWatcher#ensureGone"></a>2.3.2RefWatcher#ensureGone</h4><p>在前面的线程切换到目标工作线程之后就调用该方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">RefWatcher#ensureGone</div><div class="line">	--&gt; ① RefWatcher#removeWeaklyReachableReferences//移除所有「弱可达引用」</div><div class="line">	if (debuggerControl.isDebuggerAttached())</div><div class="line">      	--&gt; return RETRY;//调试模式控制</div><div class="line">	if (gone(reference)) //判断类名是否不在 Set&lt;String&gt; retainedKeys 中，若不在，说明内存分析完毕</div><div class="line">    	  return DONE; </div><div class="line">    --&gt; gcTrigger.runGc();//触发 gc，调用的是  Runtime.getRuntime().gc();</div><div class="line">	--&gt; ② RefWatcher#removeWeaklyReachableReferences//再次移除所有「弱可达引用」</div><div class="line">	if !gone(reference)//如果该引用对应的键仍然在 retainKeys 中，说明可能存在内存泄漏，进行 dump 然后分析</div><div class="line">      	--&gt; File heapDumpFile = heapDumper.dumpHeap();// dump 堆内存，会触发 stop the world</div><div class="line">	    if heapDumpFile == RETRY_LATER //现在无法触发 gc ，先返回。稍候重试</div><div class="line">            --&gt; return RETRY;</div><div class="line">        --&gt; new HeapDump</div><div class="line">        --&gt; ServiceHeapDumpListener#analyze</div><div class="line">        	--&gt; HeapAnalyzerService#runAnalysis</div><div class="line">        		--&gt; startService //开启 HeapAnalyzerService 服务，需要 HeapDump 以及接收分析结果的回调类的类名</div></pre></td></tr></table></figure>
<h4 id="2-3-3RefWatcher-removeWeaklyReachableReferences"><a href="#2-3-3RefWatcher-removeWeaklyReachableReferences" class="headerlink" title="2.3.3RefWatcher#removeWeaklyReachableReferences"></a>2.3.3RefWatcher#removeWeaklyReachableReferences</h4><p>移除在 retainedKeys 中的所有弱可达的对象对应的 key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; retainedKeys;</div><div class="line">ReferenceQueue&lt;Object&gt; queue;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWeaklyReachableReferences</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 对象一旦只存在弱引用，马上就会被加入 ReferenceQueue 中，这发生在 finalization 或者 gc 之前</span></div><div class="line">  KeyedWeakReference ref;</div><div class="line">  <span class="keyword">while</span> ((ref = (KeyedWeakReference) queue.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">    retainedKeys.remove(ref.key);<span class="comment">//移除弱引用对应的 key</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-4KeyedWeakReference"><a href="#2-3-4KeyedWeakReference" class="headerlink" title="2.3.4KeyedWeakReference"></a>2.3.4KeyedWeakReference</h4><p>上面使用到了一个 KeyedWeakReference 类型的对象，KeyedWeakReference 意为「带键的弱引用」。具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyedWeakReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String key;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String name;</div><div class="line"></div><div class="line">  KeyedWeakReference(Object referent, String key, String name,</div><div class="line">      ReferenceQueue&lt;Object&gt; referenceQueue) &#123;</div><div class="line">    <span class="keyword">super</span>(checkNotNull(referent, <span class="string">"referent"</span>), checkNotNull(referenceQueue, <span class="string">"referenceQueue"</span>));</div><div class="line">    <span class="keyword">this</span>.key = checkNotNull(key, <span class="string">"key"</span>);</div><div class="line">    <span class="keyword">this</span>.name = checkNotNull(name, <span class="string">"name"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唯一创建了 KeyedReference 的地方：</p>
<p><code>RefWatcher#watch(Object, String)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference, String referenceName)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == DISABLED) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  checkNotNull(watchedReference, <span class="string">"watchedReference"</span>);</div><div class="line">  checkNotNull(referenceName, <span class="string">"referenceName"</span>);</div><div class="line">  <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime = System.nanoTime();</div><div class="line">  String key = UUID.randomUUID().toString();<span class="comment">//创建一个独一无二 key</span></div><div class="line">  retainedKeys.add(key);<span class="comment">//添加到 retainedKeys 中 </span></div><div class="line">  <span class="keyword">final</span> KeyedWeakReference reference =</div><div class="line">      <span class="keyword">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);<span class="comment">//创建一个 「带键的弱引用」</span></div><div class="line"></div><div class="line">  ensureGoneAsync(watchStartNanoTime, reference);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-5retainedKeys"><a href="#2-3-5retainedKeys" class="headerlink" title="2.3.5retainedKeys"></a>2.3.5retainedKeys</h4><p><code>retainedKeys</code> 类型为一个 <code>Set&lt;String&gt;</code>，主要用于判断对象是否被回收。</p>
<p>retainedKeys 的添加与删除</p>
<h5 id="添加："><a href="#添加：" class="headerlink" title="添加："></a>添加：</h5><p>一个带键的弱引用（KeyedWeakReference）被创建的时候，其中的键会被加入 retainedKeys 中。</p>
<h5 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h5><p>通过 RefWatcher#removeWeaklyReachableReferences 方法 可以删除 retainedKeys 中那些仅含有弱引用的 KeyedWeakReference 对应的 key。</p>
<p>如果不在 retainedKeys 中说明该对象已经被回收了。</p>
<h4 id="2-3-6HeapAnalyzerService"><a href="#2-3-6HeapAnalyzerService" class="headerlink" title="2.3.6HeapAnalyzerService"></a>2.3.6HeapAnalyzerService</h4><p>HeapAnalyzerService 是一个 IntentService，它会在  onHandleIntent 方法中对堆进行分析。</p>
<p>HeapAnalyzerService#onHandleIntent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;<span class="comment">// intent 为空直接返回</span></div><div class="line">    CanaryLog.d(<span class="string">"HeapAnalyzerService received a null intent, ignoring."</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);<span class="comment">//获取回调类的类名</span></div><div class="line">  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);<span class="comment">//获取 HeapDump </span></div><div class="line"></div><div class="line">  HeapAnalyzer heapAnalyzer = <span class="keyword">new</span> HeapAnalyzer(heapDump.excludedRefs);<span class="comment">//创建 HeapAnalyzer</span></div><div class="line"></div><div class="line">  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);<span class="comment">//检查泄漏（通过 HAHA 来完成），并获取结果</span></div><div class="line">  AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);<span class="comment">//将分析结果发送给监听器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，onHandleIntent 方法中，会从 Intent 中获取 HeapDump 以及 listenerClassName（监听器类名），然后将相应的数据交给 HAHA 库中的 HeapAnalyzer 进行分析，最后将结果发回给监听器</p>
<p>注：在创建对分析器的时候 会使用到 heapDump.excludedRefs，excludedRefs  实际类型为 AndroidExcludedRefs ，它是一个枚举类，其中设置了一些由于特定制造商的实现引起内存泄漏的类。如果内存泄漏是由该枚举类含有的类锁引起，那么内存泄漏问题会被忽略。</p>
<p>对于大部分应用开发者而言都应该使用 createAppDefaults 方法，不过也可以自己创建一个 EnumSet ，在其中指定自己要忽略的内存泄漏类，并通过 <code>AndroidExcludedRefs#createBuilder(EnumSet)</code>方法进行设置。</p>
<h4 id="2-3-7HeapAnalyzer-checkForLeak-检测内存泄漏"><a href="#2-3-7HeapAnalyzer-checkForLeak-检测内存泄漏" class="headerlink" title="2.3.7HeapAnalyzer#checkForLeak 检测内存泄漏"></a>2.3.7HeapAnalyzer#checkForLeak 检测内存泄漏</h4><p>限于篇幅，仅对 HAHA 进行简单介绍</p>
<p>HAHA 是一个 Java 库，可以自动完成对 Android 堆转储文件的分析。</p>
<p>这个项目实际上是对其他人的工作的重新打包，以使其成为一个小型的 Maven 依赖项。</p>
<p>HAHA  可达性分析算法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AnalysisResult <span class="title">checkForLeak</span><span class="params">(File heapDumpFile, String referenceKey)</span> </span>&#123;</div><div class="line">  <span class="keyword">long</span> analysisStartNanoTime = System.nanoTime();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!heapDumpFile.exists()) &#123;</div><div class="line">    Exception exception = <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File does not exist: "</span> + heapDumpFile);</div><div class="line">    <span class="keyword">return</span> failure(exception, since(analysisStartNanoTime));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    HprofBuffer buffer = <span class="keyword">new</span> MemoryMappedFileBuffer(heapDumpFile);<span class="comment">//通过堆转储文件构造一个 MemoryMappedFileBuffer</span></div><div class="line">    HprofParser parser = <span class="keyword">new</span> HprofParser(buffer);<span class="comment">//创建一个 Hprof 文件解析器</span></div><div class="line">    Snapshot snapshot = parser.parse();<span class="comment">//解析，将结果赋给 Snapshot </span></div><div class="line">    deduplicateGcRoots(snapshot);<span class="comment">//删除重复的 GC Root </span></div><div class="line"></div><div class="line">    Instance leakingRef = findLeakingReference(referenceKey, snapshot);<span class="comment">//利用 referenceKey 和  snapshot 寻找发生泄漏的引用</span></div><div class="line"></div><div class="line">    <span class="comment">// False alarm, weak reference was cleared in between key check and heap dump.</span></div><div class="line">    <span class="keyword">if</span> (leakingRef == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> noLeak(since(analysisStartNanoTime));<span class="comment">//没有发生内存泄漏</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);<span class="comment">//发现内存泄漏</span></div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">    <span class="keyword">return</span> failure(e, since(analysisStartNanoTime));<span class="comment">//</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>得益于唯一的 reference key, <code>HeapAnalyzer</code> 找到 <code>KeyedWeakReference</code>，定位内存泄漏。</li>
<li><code>HeapAnalyzer</code> 计算 <em>到 GC roots 的最短强引用路径</em>，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。</li>
</ol>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>内存泄漏的本质是长生命周期的对象持有短生命周期对象的强引用，导致短生命周期对象使用完了之后无法被回收。也就是应该被回收的对象没有被回收。<br>那么问题就变成了什么对象是应该被回收的对象呢？对于 Activity 而言，执行完 onDestroy 方法之后，就是应该被回收了。因此可以将 Activity#ondestroy 方法作为一个检测点。Application 中提供了各个 Activity 的生命周期回调方法的监听，LeakCanary 就是通过注册  <code>ActivityLifecycleCallbacks</code> ，监听生命周期方法的回调，作为整个内存泄漏分析的入口。</p>
<p>每次 <code>onActivityDestroyed(Activity activity)</code> 方法被回调之后,都会创建一个 <code>KeyedWeakReference</code> 对相应 Activity 的状态进行跟踪，手动调用 gc，后台线程（HandlerThread ）检查引用是否被清除，如果没有就手动调用一次 gc，如果这时还是没有被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 <code>.hprof</code> 文件中。在另一个进程中的 <code>HeapAnalyzerService</code>  中，  HeapAnalyzer 会通过 haha 开源库对文件进行分析。    得益于唯一的 reference key,  <code>HeapAnalyzer</code>  找到 <code>KeyedWeakReference</code>，定位内存泄漏。<code>HeapAnalyzer</code> 计算 <em>到 GC roots 的<strong>最短强引用路径</strong></em>，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。引用链传递到 APP 进程中的 <code>DisplayLeakService</code>， 并以通知的形式展示出来。</p>
<h3 id="进阶使用："><a href="#进阶使用：" class="headerlink" title="进阶使用："></a>进阶使用：</h3><p>了解 LeakCanary 的原理之后，发现其实它就是在对象不可用的时候去判断对象是否被回收了，但 LeakCanary 只检查了 Activity，我们是否可以检查其他对象呢，毕竟 Activity 泄漏只是内存泄漏的一种，答案当然是可以的，我们只要需要进行如下操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LeakCanary.install(app).watch(object)</div></pre></td></tr></table></figure>
<p>但我们在调用这个方法的时候<strong>需要确定这个 object 已经不需要了，可以被回收了</strong>。通过这种方式我们就可以<strong>对任何对象都进行检测</strong>了。</p>
<h2 id="四、参考资料与学习资源推荐"><a href="#四、参考资料与学习资源推荐" class="headerlink" title="四、参考资料与学习资源推荐"></a>四、参考资料与学习资源推荐</h2><ul>
<li><a href="www.jianshu.com/p/3f1a1cc1e964">LeakCanary 原理浅析</a></li>
<li><a href="https://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="noopener">LeakCanary 中文使用说明</a></li>
<li><a href="https://hongjiang.info/java-referencequeue/" target="_blank" rel="noopener">话说 ReferenceQueue</a></li>
<li><a href="https://www.jianshu.com/p/f86d3a43eec5" target="_blank" rel="noopener">Reference 、ReferenceQueue 详解</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 源码分析 </category>
            
            <category> 框架原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> 框架原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[拆轮子系列——LitePal 原理解析]]></title>
      <url>https://timlin-pro.github.io/blog/2017/12/03/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94litepal-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="LitePal-解决了什么问题？"><a href="#LitePal-解决了什么问题？" class="headerlink" title="LitePal 解决了什么问题？"></a>LitePal 解决了什么问题？</h2><blockquote>
<p>  LitePal 采取的是对象关系映射(ORM)的模式，那么什么是对象关系映射呢？简单点说，我们使用的编程语言是面向对象语言，而我们使用的数据库则是关系型数据库，那么将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是对象关系映射了。</p>
<p>  但是我们为什么要使用对象关系映射模式呢？这主要是因为大多数的程序员都很擅长面向对象编程，但其中只有少部分的人才比较精通关系型数据库。而且数据库的 SQL 语言晦涩难懂，就算你很精通它，恐怕也不喜欢经常在代码中去写它吧？而对象关系映射模式则很好地解决了这个问题，它允许我们使用面向对象的方式来操作数据库，从而可以从晦涩难懂的 SQL 语言中解脱出来。</p>
</blockquote>
<a id="more"></a>
<p>Android 已经为我们提供了 SQLiteOpenHelper 以帮助我们完成数据库的创建、表的创建、以及数据的 CRUD 操作。但是使用起来还是不够方便。建立数据库需要继承 SQLiteOpenHelper 重写相应的方法，同时为了方便后续的操作，我们每创建一张表，都要一个相应的 DAO 类，完成相应表的 CRUD 操作。加在一起工作量真的不小。</p>
<p>如果使用 LitePal，只需要建立一个 xml 配置文件，在其中指定数据库名称、版本号，以及需要进行映射的类名，然后让 App 的 Application 类继承 LitePalApplication 进行初始化，就可以完成数据库、表的创建工作。同时，数据的 CRUD 操作只需要通过 DataSupport 的相应方法就能完成。这样工作量是不是少了很多。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>文档中建议通过将在 Manifest 文件中指定 application 为 LitePalApplication  或者通过继承 LitePalApplication 来实现初始化。初始化的目的为了方便获取 Context 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LitePalApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">  </div><div class="line">   <span class="keyword">static</span> Context sContext;</div><div class="line">  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LitePalApplication</span><span class="params">()</span> </span>&#123;<span class="comment">//默认的构造方法，初始化 Context 静态变量</span></div><div class="line">      sContext = <span class="keyword">this</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h2><p>查看文档说明，我们发现 table 的创建和修改都是自动实现的。对外公开的主要是对数据的操作，所以我们就顺着对数据的操作来分析。而进行操作的前提是表中有数据，我们就从插入操作（对应 save 方法）看起。</p>
<p><code>DataSupport#save()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</div><div class="line">  	  <span class="comment">//代码省略</span></div><div class="line">      saveThrows();    </div><div class="line">  	  <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>save 会调用 saveThrows 方法，</p>
<p><code>DataSupport#saveThrows</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saveThrows</span><span class="params">()</span> </span>&#123;</div><div class="line">   SQLiteDatabase db = Connector.getDatabase();<span class="comment">//获取数据库</span></div><div class="line"><span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>saveThrows 方法中首先调用了 Connector.getDatabase() 获取数据库。</p>
<h3 id="Connector-getDatabase"><a href="#Connector-getDatabase" class="headerlink" title="Connector#getDatabase()"></a>Connector#getDatabase()</h3><p><code>Connector#getDatabase</code>主要调用流程如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Connector#getDatabase	</div><div class="line">	 --&gt; getWritableDatabase</div><div class="line">	 	--&gt; buildConnection //获取 LitePalOpenHelper （实际上是一个 SQLiteOpenHelper）</div><div class="line">	 		 --&gt; LitePalAttr.getInstance();//获取单例对象</div><div class="line">	 		 	 --&gt; LitePalAttr = new LitePalAttr();//创建 LitePalAttr</div><div class="line">                  --&gt; loadLitePalXMLConfiguration();//加载 liepal.xml 配置文件中的数据</div><div class="line">                  	 --&gt; LitePalParser.parseLitePalConfiguration() //首先进行解析</div><div class="line">                  	 --&gt; //将解析到的数据（ 数据库名、数据库版本号、需要映射为表的类名、是否大小写敏感、存储路径 ）赋值给 LitePalAttr 中的字段</div><div class="line">			 --&gt; LitePalAttr.checkSelfValid();//参数合法性检查</div><div class="line">			 --&gt; //构造存储路径	</div><div class="line">			 --&gt; //创建 LitePalOpenHelper</div><div class="line">	 	--&gt; SQLiteOpenHelper#getWritableDatabase</div></pre></td></tr></table></figure>
<p>虽然 LitePal 号称零配置，但是基础的准备工作还是需要做的。按照官方教程，在使用 LitePal 之前，需要在 res 目录下面创建一个 xml 目录，然后在该目录中创建一个名为 LitePal 的 xml 文件。举个栗子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LitePal</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--数据库名--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span>=<span class="string">"library"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--版本号--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!--映射表--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.android.rdc.librarysystem.bean.Book"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.android.rdc.librarysystem.bean.BookType"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.android.rdc.librarysystem.bean.Borrow"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">LitePal</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中的 <code>dbname</code> 标签就是用于指定数据库名的。</p>
<p><code>Connector#buildConnection</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LitePalOpenHelper <span class="title">buildConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">   LitePalAttr LitePalAttr = LitePalAttr.getInstance(); <span class="comment">//获取单例对象——LitePalAttr </span></div><div class="line">   LitePalAttr.checkSelfValid();<span class="comment">//参数合法性检查</span></div><div class="line">   <span class="keyword">if</span> (mLitePalHelper == <span class="keyword">null</span>) &#123;</div><div class="line">      String dbName = LitePalAttr.getDbName();<span class="comment">//</span></div><div class="line">    		   <span class="comment">//……省略路径处理代码</span></div><div class="line">               dbName = dbPath + <span class="string">"/"</span> + dbName;</div><div class="line">           </div><div class="line">      mLitePalHelper = <span class="keyword">new</span> LitePalOpenHelper(dbName, LitePalAttr.getVersion());<span class="comment">//</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> mLitePalHelper;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首次连接数据库时，LitePal 会通过 <code>LitePalParser#parseLitePalConfiguration();</code>方法对 xml 配置文件进行解析。大体流程就是使用 <code>XmlPullParser</code> 对 xml 文件的解析，解析完成之后，就将结果保存在 <code>LitePalConfig</code>类中。 LitePalConfig 类字段如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LitePalConfig</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;<span class="comment">//数据库版本号</span></div><div class="line">    <span class="keyword">private</span> String dbName;<span class="comment">//数据库名</span></div><div class="line">    <span class="keyword">private</span> String cases;<span class="comment">//数据库大小写敏感性</span></div><div class="line">    <span class="keyword">private</span> String storage;<span class="comment">//数据库文件的存储路径，可选择内部存储或者外部存储</span></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames;<span class="comment">//需要进行映射的模型类，每一个类名都需要给全名（包括包名）</span></div><div class="line"> 	<span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="注：大小写敏感"><a href="#注：大小写敏感" class="headerlink" title="注：大小写敏感"></a>注：大小写敏感</h4><p>SQLite 是大小写敏感的，具体：</p>
<ol>
<li>创建表、列的时候，SQL 语句里是什么大小写，表名、列名就是什么大小写；</li>
<li>SQL 语句执行的时候：==表名、列名大小写不敏感，都能识别==；</li>
<li>SQL 语句里面，“=”还是 LIKE 都是大小写敏感；</li>
</ol>
<h3 id="buildConnection"><a href="#buildConnection" class="headerlink" title="buildConnection"></a>buildConnection</h3><p><code>buildConnection</code> 方法首先会去获取 LitePalAttr 单例对象（首次调用会触发解析 LitePal.xml 文件），然后检查参数合法性，并根据解析得到的 LitePalAttr  中的字段创建一个 LitePalOpenHelper。</p>
<p>到这里，数据库已经创建完成了。那么数据库中的<strong>表是什么时候创建的</strong>呢？回到前面的 saveThrows 方法，该方法在获取数据库之后就开始做保存工作了（表创建工作不应该放在 保存工作过程中，因为这样不合理）。因此，表很可能就是在数据库创建过程中顺便创建的。实际上也确实如此。</p>
<h3 id="LitePalOpenHelper-onCreate-调用链"><a href="#LitePalOpenHelper-onCreate-调用链" class="headerlink" title="LitePalOpenHelper#onCreate 调用链"></a><code>LitePalOpenHelper#onCreate</code> 调用链</h3><p>主要流程如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">LitePalOpenHelper#onCreate//数据库 onCreate 回调方法</div><div class="line">   --&gt; Generator#create()</div><div class="line">  	 	--&gt; create(db, true);</div><div class="line">			 --&gt; new Creator();</div><div class="line">			 --&gt; creator.createOrUpgradeTable(db, force);		</div><div class="line">				 --&gt; 迭代调用 createOrUpgradeTable(tableModel, db, force);</div><div class="line">						--&gt; getCreateTableSQLs(tableModel, db, force) //拼接建表 sql 语句，存储在 ArrayList 中</div><div class="line">						--&gt; execute();	</div><div class="line">							 --&gt; 迭代调用 db.execSQL() 执行 SQL 语句</div><div class="line">						--&gt; AssociationCreator#giveTableSchemaACopy</div><div class="line">	 	--&gt; addAssociation(db, true);</div></pre></td></tr></table></figure>
<p>上述过程中，我们看下 getCreateTableSQLs 方法，该方法会先生成删除表的语句 sql，然后再生成创建表的语句，并将它们按序存在 ArrayList 中。也就是说，每次建表之前先尝试删除同名的表（如果有的话）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCreateTableSQLs</span><span class="params">(TableModel tableModel, SQLiteDatabase db, <span class="keyword">boolean</span> force)</span> </span>&#123;</div><div class="line">       List&lt;String&gt; sqls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">   <span class="keyword">if</span> (force) &#123;</div><div class="line">           sqls.add(generateDropTableSQL(tableModel));</div><div class="line">           sqls.add(generateCreateTableSQL(tableModel));</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (DBUtility.isTableExists(tableModel.getTableName(), db)) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">               sqls.add(generateCreateTableSQL(tableModel));</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">       <span class="keyword">return</span> sqls;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此数据库和表创建完毕。</p>
<h2 id="dataSupport-save-的背后"><a href="#dataSupport-save-的背后" class="headerlink" title="dataSupport#save() 的背后"></a>dataSupport#save() 的背后</h2><p>先看下整体的调用流程</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">datasupport#save</div><div class="line"> --&gt; saveThrows</div><div class="line"> 	 --&gt; 创建 SaveHanlder </div><div class="line">	 --&gt; 调用 SaveHanlder#onSave</div><div class="line">	 	 --&gt; getSupportedFields//获取支持域</div><div class="line">		 --&gt; getSupportedGenericFields//获取支持的泛型域</div><div class="line">		 --&gt; getAssociationInfo//获取关联关系</div><div class="line">	 	 --&gt; if(baseObjId &gt; 0)  doUpdateAction//执行更新操作</div><div class="line">	 	 --&gt; else doSaveAction</div><div class="line">	 	 	 --&gt; values.clear();//清空 ContentValue</div><div class="line">	 	 	 --&gt; beforeSave();//存放值（对象本身的值与外键）</div><div class="line">	 	 	 --&gt; long id = saving();</div><div class="line">				 --&gt; SQLiteDatabase#insert()// 将记录插入数据库</div><div class="line">                   	 --&gt; SQLiteDatabase#insertWithOnConflict()//拼接 sql 语句 </div><div class="line">			 --&gt; afterSave() 	 	 </div><div class="line"> 	 --&gt; clearAssociatedData();//清除所有的关联数据</div><div class="line">	 --&gt; SQLiteDatabase#setTransactionSuccessful();//设置事务成功</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      saveThrows();</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LitePal 文档中对 save 方法的说明如下:</p>
<blockquote>
<p>  如果是一条新记录，则插入一个新的行。如果保存过程中出错，整个操作取消，相应的修改会回滚。如果数据类中含有名为 id 或者 _id 并且类型为 int / long 的字段，那么在该对象被保存之后它们会被赋予相应的  id 值。（与 DataSupport 类中的 baseObjId 相同）</p>
</blockquote>
<p>从 synchronized 可以看出 save 是一个同步方法，保证线程安全。它在内部调用了 saveThrows 方法。如果捕获到异常就 return false；否则 return true 表示保存成功。</p>
<h3 id="saveThrows"><a href="#saveThrows" class="headerlink" title="saveThrows"></a>saveThrows</h3><p><code>DataSupport#saveThrows</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saveThrows</span><span class="params">()</span> </span>&#123;</div><div class="line">   SQLiteDatabase db = Connector.getDatabase();<span class="comment">//获取数据库</span></div><div class="line">   db.beginTransaction();<span class="comment">//开始事务</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      SaveHandler saveHandler = <span class="keyword">new</span> SaveHandler(db);<span class="comment">//创建 SaveHandler，构造方法会创建一个 ContentValues </span></div><div class="line">      saveHandler.onSave(<span class="keyword">this</span>);<span class="comment">//保存</span></div><div class="line">      clearAssociatedData();<span class="comment">//清除关联数据</span></div><div class="line">      db.setTransactionSuccessful();<span class="comment">//事务成功</span></div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> DataSupportException(e.getMessage(), e);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      db.endTransaction();<span class="comment">//结束事务</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>saveThrows 方法中使用了事务保证了数据的原子性。不过它没有做具体的保存工作，而是创建一个 SaveHandler 然后将自身的引用传递给 onSave 方法。</p>
<h3 id="SaveHandler"><a href="#SaveHandler" class="headerlink" title="SaveHandler"></a>SaveHandler</h3><p>继承结构如下：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/33593102-d1bd9cb6-d9c8-11e7-94fe-38117ed0ee50.png" alt="image"></p>
<p><strong>DataHandler</strong> 是 CRUD 组件的基类。里面定义了一些 CRUD 操作所需要通用方法。DataHandler 中又继承自<strong>LitePalBase</strong>。LitePalBase 是所有 的 LitePal 组件的基类。主要是给有如下需求的组件提供解决方案：①需要与其他组件进行交互的组件②有通用的逻辑代码的组件。</p>
<p><strong>SaveHandler</strong> 继承自 DataHandler。从继承关系图中可以看到所有的 CRUD 操作都有相应的 Handler 。而且他们都继承自 DataHandler。是 DataSupport 下面的一个组件。SaveHandler 处理保存的工作。所有的实现基于所有的实现都基于 java 反射 API 和 Android SQLiteDatabase API。它如果关联模型已经存储了，它会自动在当前模型与关联模型之间建立关系。</p>
<p><code>SaveHandler#onSave</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onSave</span><span class="params">(DataSupport baseObj)</span> <span class="keyword">throws</span> SecurityException, IllegalArgumentException,</span></div><div class="line">      NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123;</div><div class="line">   String className = baseObj.getClassName();<span class="comment">//获取要保存对象的类名</span></div><div class="line">   List&lt;Field&gt; supportedFields = getSupportedFields(className);<span class="comment">//获取支持的字段</span></div><div class="line">       List&lt;Field&gt; supportedGenericFields = getSupportedGenericFields(className);<span class="comment">//获取支持的泛型信息</span></div><div class="line">   Collection&lt;AssociationsInfo&gt; associationInfos = getAssociationInfo(className);<span class="comment">//获取关联信息</span></div><div class="line">   <span class="keyword">if</span> (!baseObj.isSaved()) &#123;</div><div class="line">           <span class="keyword">if</span> (!ignoreAssociations) &#123;</div><div class="line">               analyzeAssociatedModels(baseObj, associationInfos);</div><div class="line">           &#125;</div><div class="line">      doSaveAction(baseObj, supportedFields, supportedGenericFields);<span class="comment">//对 id 值&lt;=0 对象执行保存操作</span></div><div class="line">           <span class="keyword">if</span> (!ignoreAssociations) &#123;</div><div class="line">               analyzeAssociatedModels(baseObj, associationInfos);</div><div class="line">           &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (!ignoreAssociations) &#123;</div><div class="line">               analyzeAssociatedModels(baseObj, associationInfos);</div><div class="line">           &#125;</div><div class="line">      doUpdateAction(baseObj, supportedFields, supportedGenericFields);<span class="comment">//对象本身存在数据库中，执行更新操作</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> onSave 方法会先去收集 LitePal 支持的类型和基础类型的 Filed 并将它们分别存在两个 List 中，同时也会获取关联信息。然后通过判断对象的 baseObjid &gt; 0 是否成立，不成立，说明对象是一个未保存的对象，执行 doSaveAction 方法；否则调用 doUpdateAction 方法。</p>
<p><code>LitePalBase#getSupportedFields</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;Field&gt; <span class="title">getSupportedFields</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">       List&lt;Field&gt; fieldList = classFieldsMap.get(className);<span class="comment">//尝试从缓存中获取</span></div><div class="line">       <span class="keyword">if</span> (fieldList == <span class="keyword">null</span>) &#123;<span class="comment">//</span></div><div class="line">           List&lt;Field&gt; supportedFields = <span class="keyword">new</span> ArrayList&lt;Field&gt;();</div><div class="line">           Class&lt;?&gt; clazz;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               clazz = Class.forName(className);<span class="comment">//获取类名</span></div><div class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> DatabaseGenerateException(DatabaseGenerateException.CLASS_NOT_FOUND + className);</div><div class="line">           &#125;</div><div class="line">           recursiveSupportedFields(clazz, supportedFields);<span class="comment">//递归类型</span></div><div class="line">           classFieldsMap.put(className, supportedFields);<span class="comment">//缓存到 hashMap 中</span></div><div class="line">           <span class="keyword">return</span> supportedFields;<span class="comment">//返回</span></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> fieldList;<span class="comment">//缓存命中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recursiveSupportedFields</span><span class="params">(Class&lt;?&gt; clazz, List&lt;Field&gt; supportedFields)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (clazz == DataSupport.class || clazz == Object.class) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    Field[] fields = clazz.getDeclaredFields();</div><div class="line">    <span class="keyword">if</span> (fields != <span class="keyword">null</span> &amp;&amp; fields.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">            Column annotation = field.getAnnotation(Column.class);</div><div class="line">            <span class="keyword">if</span> (annotation != <span class="keyword">null</span> &amp;&amp; annotation.ignore()) &#123;<span class="comment">//有注解，但是注解设置为忽略</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> modifiers = field.getModifiers();<span class="comment">//获取修饰符</span></div><div class="line">            <span class="keyword">if</span> (!Modifier.isStatic(modifiers)) &#123;<span class="comment">//不是静态的 </span></div><div class="line">                Class&lt;?&gt; fieldTypeClass = field.getType();<span class="comment">//获取字段域类型</span></div><div class="line">                String fieldType = fieldTypeClass.getName();<span class="comment">//字段类型的名称</span></div><div class="line">                <span class="keyword">if</span> (BaseUtility.isFieldTypeSupported(fieldType)) &#123;</div><div class="line">                    supportedFields.add(field);<span class="comment">//非静态、并且受支持的字段添加到 List&lt;Filed&gt; 中</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    recursiveSupportedFields(clazz.getSuperclass(), supportedFields);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>递归调用，直到是 DataSupport 或者 Object 为止，通过反射取得所有的 fields，当不需要忽略时，不是静态，一些基本支持的数据类型时会直接加入到这个 fieldList 里边。</p>
<p>getSupportedGenericFields() 方法与上面的类似，只不过处理的是泛型。</p>
<h3 id="LitePalBase-getAssociationInfo"><a href="#LitePalBase-getAssociationInfo" class="headerlink" title="LitePalBase#getAssociationInfo"></a>LitePalBase#getAssociationInfo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Collection&lt;AssociationsInfo&gt; mAssociationInfos;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;AssociationsInfo&gt; <span class="title">getAssociationInfo</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mAssociationInfos == <span class="keyword">null</span>) &#123;</div><div class="line">      mAssociationInfos = <span class="keyword">new</span> HashSet&lt;AssociationsInfo&gt;();</div><div class="line">   &#125;</div><div class="line">   mAssociationInfos.clear();<span class="comment">//清理关系集</span></div><div class="line">   analyzeClassFields(className, GET_ASSOCIATION_INFO_ACTION);<span class="comment">//分析类的字段域</span></div><div class="line">   <span class="keyword">return</span> mAssociationInfos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析类字段以找出关联关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">analyzeClassFields</span><span class="params">(String className, <span class="keyword">int</span> action)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">      Class&lt;?&gt; dynamicClass = Class.forName(className);<span class="comment">//加载类</span></div><div class="line">      Field[] fields = dynamicClass.getDeclaredFields();<span class="comment">//</span></div><div class="line">      <span class="keyword">for</span> (Field field : fields) &#123;</div><div class="line">         <span class="keyword">if</span> (isNonPrimitive(field)) &#123;<span class="comment">//不是原生类型</span></div><div class="line">            Column annotation = field.getAnnotation(Column.class);<span class="comment">//获取注解</span></div><div class="line">            <span class="keyword">if</span> (annotation != <span class="keyword">null</span> &amp;&amp; annotation.ignore()) &#123;</div><div class="line">            	<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">            oneToAnyConditions(className, field, action);<span class="comment">//一对？关系</span></div><div class="line">            manyToAnyConditions(className, field, action);<span class="comment">//多对？关系</span></div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">		<span class="comment">//代码省略</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="LitePalBase-oneToAnyConditions"><a href="#LitePalBase-oneToAnyConditions" class="headerlink" title="LitePalBase#oneToAnyConditions"></a>LitePalBase#oneToAnyConditions</h4><p>首先我们要明确，oneToAnyConditions  是在遍历处理类的所有字段的过程中调用的。并且只有当字段类型是非原生类型时才会进入该方法。</p>
<p>设有 A 和 B 两个类。现在对 A 中存在类型为 B 的字段。首先判断 B 是否在配置文件里边配置的。如果是，就找到这个类的所有字段。找到一个和 A 相同的字段，这代表 A 里边有一个 B，B 里边有一个 A，是一对一关系；如果 B 找到的和 A 相同的字段是一个集合，代表 A 里边有一个 B，B 里边有多个 A，是多对一关系。</p>
<p>最后统一把关系加入到一个集合里边来管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">oneToAnyConditions</span><span class="params">(String className, Field field, <span class="keyword">int</span> action)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">   Class&lt;?&gt; fieldTypeClass = field.getType();<span class="comment">//获取字段的类型</span></div><div class="line"></div><div class="line">  <span class="comment">//字段的类型包含在 LitePal 配置文件映射的列表中</span></div><div class="line">   <span class="keyword">if</span> (LitePalAttr.getInstance().getClassNames().contains(fieldTypeClass.getName())) &#123;</div><div class="line">      Class&lt;?&gt; reverseDynamicClass = Class.forName(fieldTypeClass.getName());<span class="comment">//通过类名加载字段的类（简称为 B）</span></div><div class="line">      Field[] reverseFields = reverseDynamicClass.getDeclaredFields();</div><div class="line">      <span class="keyword">boolean</span> reverseAssociations = <span class="keyword">false</span>;</div><div class="line">      <span class="comment">//  开始检查类 B 中的属性</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; reverseFields.length; i++) &#123;</div><div class="line">         Field reverseField = reverseFields[i];<span class="comment">//</span></div><div class="line">         <span class="keyword">if</span> (!Modifier.isStatic(reverseField.getModifiers())) &#123;</div><div class="line">            Class&lt;?&gt; reverseFieldTypeClass = reverseField.getType();</div><div class="line">            <span class="comment">// B 中也有 A 的引用。因此是一对一的双向关系</span></div><div class="line">            <span class="keyword">if</span> (className.equals(reverseFieldTypeClass.getName())) &#123;</div><div class="line">               <span class="keyword">if</span> (action == GET_ASSOCIATIONS_ACTION) &#123;</div><div class="line">                  addIntoAssociationModelCollection(className, fieldTypeClass.getName(),</div><div class="line">                        fieldTypeClass.getName(), Const.Model.ONE_TO_ONE);</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == GET_ASSOCIATION_INFO_ACTION) &#123;</div><div class="line">                  addIntoAssociationInfoCollection(className, fieldTypeClass.getName(),</div><div class="line">                        fieldTypeClass.getName(), field, reverseField, Const.Model.ONE_TO_ONE);</div><div class="line">               &#125;</div><div class="line">               reverseAssociations = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// B 类中有字段： List&lt;A&gt; 说明是多对一关系</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isCollection(reverseFieldTypeClass)) &#123;</div><div class="line">               String genericTypeName = getGenericTypeName(reverseField);</div><div class="line">               <span class="keyword">if</span> (className.equals(genericTypeName)) &#123;</div><div class="line">                  <span class="keyword">if</span> (action == GET_ASSOCIATIONS_ACTION) &#123;</div><div class="line">                     addIntoAssociationModelCollection(className, fieldTypeClass.getName(),</div><div class="line">                           className, Const.Model.MANY_TO_ONE);</div><div class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == GET_ASSOCIATION_INFO_ACTION) &#123;</div><div class="line">                     addIntoAssociationInfoCollection(className, fieldTypeClass.getName(),</div><div class="line">                           className, field, reverseField, Const.Model.MANY_TO_ONE);</div><div class="line">                  &#125;</div><div class="line">                  reverseAssociations = <span class="keyword">true</span>;</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">     	  <span class="comment">// B 中没有 A 的引用，AB 是单向的一对一关系</span></div><div class="line">           <span class="keyword">if</span> (!reverseAssociations) &#123;</div><div class="line">               <span class="keyword">if</span> (action == GET_ASSOCIATIONS_ACTION) &#123;</div><div class="line">                   addIntoAssociationModelCollection(className, fieldTypeClass.getName(),</div><div class="line">                           fieldTypeClass.getName(), Const.Model.ONE_TO_ONE);</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == GET_ASSOCIATION_INFO_ACTION) &#123;</div><div class="line">                   addIntoAssociationInfoCollection(className, fieldTypeClass.getName(),</div><div class="line">                           fieldTypeClass.getName(), field, <span class="keyword">null</span>, Const.Model.ONE_TO_ONE);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>manyToAnyConditions 也是通过类似的逻辑进行分析处理。</p>
<p>回到 saveThrows 方法，可以看到后续会调用 doSaveAction。</p>
<h3 id="doSaveAction"><a href="#doSaveAction" class="headerlink" title="doSaveAction"></a>doSaveAction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSaveAction</span><span class="params">(DataSupport baseObj, List&lt;Field&gt; supportedFields, List&lt;Field&gt; supportedGenericFields)</span></span></div><div class="line">      <span class="keyword">throws</span> SecurityException, IllegalArgumentException, NoSuchMethodException,</div><div class="line">      IllegalAccessException, InvocationTargetException &#123;</div><div class="line">   values.clear();<span class="comment">//先清除 contentValue 中的值</span></div><div class="line">   beforeSave(baseObj, supportedFields, values);</div><div class="line">   <span class="keyword">long</span> id = saving(baseObj, values);<span class="comment">//保存</span></div><div class="line">   afterSave(baseObj, supportedFields, supportedGenericFields, id);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doSaveAction 方法中依次调用了 beforeSave  saving afterSave 三个方法。</p>
<ul>
<li>beforeSave 方法会将相应的字段列与值以键值对的形式存放到 values 中， values 将作为后面 saving 方法的参数。</li>
<li>saving 方法内部会调用 调用 <code>SQLiteDatabase#insert</code> 方法对数据进行保存。</li>
<li>afterSave 所做的工作是获取刚刚保存的那条记录的 id ，然后以反射的形式将它赋给对象的 baseObjId 字段，同时还会更新关联表的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">saving</span><span class="params">(DataSupport baseObj, ContentValues values)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (values.size() == <span class="number">0</span>) &#123;<span class="comment">//如果 contentValue 中的大小为 0，那就存储一个仅有 id 的空行</span></div><div class="line">           values.putNull(<span class="string">"id"</span>);</div><div class="line">       &#125;</div><div class="line">   <span class="keyword">return</span> mDatabase.insert(baseObj.getTableName(), <span class="keyword">null</span>, values);<span class="comment">//终于看到了 SqlLite 的保存操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SQLiteDatabase-insert"><a href="#SQLiteDatabase-insert" class="headerlink" title="SQLiteDatabase#insert"></a>SQLiteDatabase#insert</h3><p>insert 方法内部会调用 SQLiteDatabase#insertWithOnConflict 方法。</p>
<p>可以看到该方法的实现是将相应的数据结构拼接为一个 SQL 插入语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CONFLICT_VALUES = <span class="keyword">new</span> String[]</div><div class="line">        &#123;<span class="string">""</span>, <span class="string">" OR ROLLBACK "</span>, <span class="string">" OR ABORT "</span>, <span class="string">" OR FAIL "</span>, <span class="string">" OR IGNORE "</span>, <span class="string">" OR REPLACE "</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">insertWithOnConflict</span><span class="params">(String table, String nullColumnHack,</span></span></div><div class="line">        ContentValues initialValues, <span class="keyword">int</span> conflictAlgorithm) &#123;</div><div class="line">    acquireReference();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        StringBuilder sql = <span class="keyword">new</span> StringBuilder();</div><div class="line">        sql.append(<span class="string">"INSERT"</span>);</div><div class="line">        sql.append(CONFLICT_VALUES[conflictAlgorithm]);</div><div class="line">        sql.append(<span class="string">" INTO "</span>);</div><div class="line">        sql.append(table);<span class="comment">//表名</span></div><div class="line">        sql.append(<span class="string">'('</span>);</div><div class="line"></div><div class="line">        Object[] bindArgs = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> size = (initialValues != <span class="keyword">null</span> &amp;&amp; !initialValues.isEmpty())</div><div class="line">                ? initialValues.size() : <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">            bindArgs = <span class="keyword">new</span> Object[size];</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (String colName : initialValues.keySet()) &#123;</div><div class="line">                sql.append((i &gt; <span class="number">0</span>) ? <span class="string">","</span> : <span class="string">""</span>);</div><div class="line">                sql.append(colName);<span class="comment">//添加名称</span></div><div class="line">                bindArgs[i++] = initialValues.get(colName);<span class="comment">//列名对应的值，将其存在数组中</span></div><div class="line">            &#125;</div><div class="line">            sql.append(<span class="string">')'</span>);</div><div class="line">            sql.append(<span class="string">" VALUES ("</span>);</div><div class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">                sql.append((i &gt; <span class="number">0</span>) ? <span class="string">",?"</span> : <span class="string">"?"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sql.append(nullColumnHack + <span class="string">") VALUES (NULL"</span>);<span class="comment">//空行</span></div><div class="line">        &#125;</div><div class="line">        sql.append(<span class="string">')'</span>);</div><div class="line"></div><div class="line">        SQLiteStatement statement = <span class="keyword">new</span> SQLiteStatement(<span class="keyword">this</span>, sql.toString(), bindArgs);<span class="comment">// 利用表名，以及需要更新的列名，还有相应的列参数「bindArgs」 创建一个 SQLiteStatement</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> statement.executeInsert();<span class="comment">//执行插入操作</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            statement.close();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        releaseReference();<span class="comment">//释放引用</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，save 过程分析完成。</p>
<h2 id="find-过程浅析"><a href="#find-过程浅析" class="headerlink" title="find 过程浅析"></a>find 过程浅析</h2><p>DataSupport#find 大体流程：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">find()</div><div class="line">  --&gt; find(modelClass, id, false);</div><div class="line">       --&gt; 创建 QueryHandler </div><div class="line">       --&gt; queryHandler#onFind</div><div class="line">           --&gt; query  //获取符合条件的 list</div><div class="line">             --&gt; DataHandler#query</div><div class="line">                     --&gt; getSupportedFields //获取支持的字段</div><div class="line">                     --&gt; //调用相关方法。做一些铺垫工作</div><div class="line">                    --&gt; SQLiteDatabase#query  //调用 SQLiteDataBase#query （该方法最终会调用 buildQueryString 拼接出字符串）。然后通过 cursor 逐行取出数据</div><div class="line">                         --&gt; //省略一些转发方法</div><div class="line">                           --&gt; SQLiteDatabase#queryWithFactory</div><div class="line">                           		--&gt; SQLiteQueryBuilder#buildQueryString//拼接 sql 语句</div></pre></td></tr></table></figure>
<h3 id="SQLiteQueryBuilder-buildQueryString"><a href="#SQLiteQueryBuilder-buildQueryString" class="headerlink" title="SQLiteQueryBuilder#buildQueryString"></a>SQLiteQueryBuilder#buildQueryString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildQueryString</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">boolean</span> distinct, String tables, String[] columns, String where,</div><div class="line">        String groupBy, String having, String orderBy, String limit) &#123;</div><div class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(groupBy) &amp;&amp; !TextUtils.isEmpty(having)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                <span class="string">"HAVING clauses are only permitted when using a groupBy clause"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(limit) &amp;&amp; !sLimitPattern.matcher(limit).matches()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid LIMIT clauses:"</span> + limit);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    StringBuilder query = <span class="keyword">new</span> StringBuilder(<span class="number">120</span>);</div><div class="line"></div><div class="line">    query.append(<span class="string">"SELECT "</span>);</div><div class="line">    <span class="keyword">if</span> (distinct) &#123;</div><div class="line">        query.append(<span class="string">"DISTINCT "</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (columns != <span class="keyword">null</span> &amp;&amp; columns.length != <span class="number">0</span>) &#123;</div><div class="line">        appendColumns(query, columns);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        query.append(<span class="string">"* "</span>);</div><div class="line">    &#125;</div><div class="line">    query.append(<span class="string">"FROM "</span>);</div><div class="line">    query.append(tables);</div><div class="line">    appendClause(query, <span class="string">" WHERE "</span>, where);</div><div class="line">    appendClause(query, <span class="string">" GROUP BY "</span>, groupBy);</div><div class="line">    appendClause(query, <span class="string">" HAVING "</span>, having);</div><div class="line">    appendClause(query, <span class="string">" ORDER BY "</span>, orderBy);</div><div class="line">    appendClause(query, <span class="string">" LIMIT "</span>, limit);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> query.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>小结：find 就是通过相应的查询条件拼接为 SQL 查询语句，然后将查询结果返回。</p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h3><p>对于每一个 CRUD 操作，LitePal 都有同步以及相对应的异步方法。</p>
<h4 id="以异步-save-为例"><a href="#以异步-save-为例" class="headerlink" title="以异步 save 为例"></a>以异步 save 为例</h4><p>异步更新只是新开一条线程来执行 save 方法，并在主线程进行结果回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SaveExecutor <span class="title">saveAsync</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> SaveExecutor executor = <span class="keyword">new</span> SaveExecutor();<span class="comment">//参加一个 SaveExecutor</span></div><div class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;<span class="comment">//创建一个 Runnable 匿名内部子类，</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (DataSupport.class) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> success = save();<span class="comment">//调用保存方法</span></div><div class="line">                <span class="keyword">if</span> (executor.getListener() != <span class="keyword">null</span>) &#123;</div><div class="line">                    LitePal.getHandler().post(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//切换到主线程中回调</span></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            executor.getListener().onFinish(success);<span class="comment">//回调</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    executor.submit(runnable);</div><div class="line">    <span class="keyword">return</span> executor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveExecutor</span> <span class="keyword">extends</span> <span class="title">AsyncExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> SaveCallback cb;<span class="comment">//回调接口</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册回调接口之后，马上执行异步任务</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(SaveCallback callback)</span> </span>&#123;<span class="comment">//注册回调</span></div><div class="line">        cb = callback;</div><div class="line">        execute();<span class="comment">//执行异步任务</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SaveCallback <span class="title">getListener</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span>  cb;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SaveExecutor 继承自 AsyncExecutor。特别之处在于它是通过 listen 方法来触发异步任务执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Runnable pendingTask;<span class="comment">//延时任务</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 提交任务</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">        pendingTask = task;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 后台执行延时任务</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pendingTask != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(pendingTask).start();<span class="comment">//新建线程执行任务</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AsyncExecutor 一个简单的异步执行器，在后台线程中运行任务。它是所有的异步操作执行器的基类。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/33612586-0077ccc2-da0d-11e7-80a5-5e093b7e79ba.png" alt="image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LitePal 需要在 Application 中进行初始化。首次获取数据库的时会触发数据库以及表的创建。后续的 CRUD 操作都是通过<strong>反射机制和 Android SQLite API</strong> 来实现的。它会自动分析表与表之间的关联关系，并帮助创建表、自动管理表。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p><strong>配置简单，操作方便，业务对象清晰，LitePal 很「轻」，jar 包只有 100k 不到</strong>。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>反射影响性能。</li>
<li>无法直接进行关联查询。</li>
</ol>
<h3 id="与同类框架（GreenDAO）对比："><a href="#与同类框架（GreenDAO）对比：" class="headerlink" title="与同类框架（GreenDAO）对比："></a>与同类框架（GreenDAO）对比：</h3><p>GreetDao 一开始就人工生成业务需要的 Model 和 DAO 文件，业务中可以直接调用相应的 DAO 文件进行数据库的增删改查操作，从而避免了因反射带来的性能损耗和效率低。因此大批量的插入、更新、查询等操作，greenDAO 用时短，执行快更适合。但是 greenDAO 使用不方便，学习成本较高。</p>
<p>如果应用对性能要求不是特别苛刻并且数据量也不大的情况下，轻量级的 LitePal，基本能满足我们的需求了。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><p><a href="http://www.jianshu.com/p/35c704701638" target="_blank" rel="noopener">数据库 ORM 之 LitePal</a></p>
</li>
<li><p><a href="http://blog.csdn.net/column/details/android-database-pro.html" target="_blank" rel="noopener">Android 数据库高手秘籍</a></p>
</li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 源码分析 </category>
            
            <category> 框架原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> 框架原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[拆轮子系列——EventBus 源码解析]]></title>
      <url>https://timlin-pro.github.io/blog/2017/10/14/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>项目地址：<a href="https://link.jianshu.com/?t=https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a>，本文分析版本: 3.1.1</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>EventBus 是一个 Android <strong>事件发布/订阅框架</strong>，通过<strong>解耦</strong>发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。<br>传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</p>
<a id="more"></a>
<ul>
<li><strong>事件(Event)：</strong>又可称为消息，本文中统一用事件表示。其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。<code>事件类型(EventType)</code>指事件所属的 Class。<ul>
<li>事件分为一般事件和 Sticky 事件，相对于一般事件，Sticky 事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件<strong>最近一个</strong> Sticky 事件（所谓「最近一个」指的就是该类型事件「最后一次发出」）。</li>
</ul>
</li>
<li><strong>订阅者(Subscriber)：</strong>订阅某种事件类型的对象。当有发布者发布这类事件后，EventBus 会执行订阅者的 onEvent 函数，这个函数叫<code>事件响应函数</code>。订阅者通过 register 接口订阅某个事件类型，unregister 接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为 0。</li>
<li><strong>发布者(Publisher)：</strong>发布某事件的对象，通过 post 接口发布事件。</li>
</ul>
<h2 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h2><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><h4 id="方式一，运行期处理注解"><a href="#方式一，运行期处理注解" class="headerlink" title="方式一，运行期处理注解"></a>方式一，运行期处理注解</h4><p>在app 的 build.gradle 文件中添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    implementation <span class="string">'org.greenrobot:eventbus:3.1.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方式二，编译期预处理注解"><a href="#方式二，编译期预处理注解" class="headerlink" title="方式二，编译期预处理注解"></a>方式二，编译期预处理注解</h4><p>Android Studio  3.0 及以上</p>
<p>在 app 的 build.gradle 文件中添加</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">	<span class="comment">//……</span></div><div class="line">    defaultConfig &#123;</div><div class="line">        <span class="comment">//……</span></div><div class="line">        javaCompileOptions &#123;</div><div class="line">            annotationProcessorOptions &#123;</div><div class="line">                arguments = [<span class="string">eventBusIndex:</span> <span class="string">'org.greenrobot.eventbusperf.MyEventBusIndex'</span>]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    implementation <span class="string">'org.greenrobot:eventbus:3.1.1'</span></div><div class="line">    annotationProcessor  <span class="string">'org.greenrobot:eventbus-annotation-processor:3.0.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>build 之后，会生成一个 MyEventBusIndex.java类。</p>
<p>然后在使用 EventBus 实例之前，又有两种方式可以将配置MyEventBusIndex.java配置到类中是哟经。</p>
<h6 id="方式一-在构造-EventBus-时传入我们自定义的-EventBusIndex，"><a href="#方式一-在构造-EventBus-时传入我们自定义的-EventBusIndex，" class="headerlink" title="方式一 在构造 EventBus 时传入我们自定义的 EventBusIndex，"></a>方式一 在构造 EventBus 时传入我们自定义的 EventBusIndex，</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus mEventBus = EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).build();</div></pre></td></tr></table></figure>
<h6 id="方式二-将索引应用到默认的单例中"><a href="#方式二-将索引应用到默认的单例中" class="headerlink" title="方式二 将索引应用到默认的单例中"></a>方式二 将索引应用到默认的单例中</h6><p>使用 EventBus 之前，先调用下面的代码初始化 EventBus。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.builder().addIndex(<span class="keyword">new</span> MyEventBusIndex()).installDefaultEventBus();</div></pre></td></tr></table></figure>
<h3 id="2-2-定义事件类"><a href="#2-2-定义事件类" class="headerlink" title="2.2 定义事件类"></a>2.2 定义事件类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEvent</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String mEventName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEventName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mEventName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEventName</span><span class="params">(String eventName)</span> </span>&#123;</div><div class="line">        mEventName = eventName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-注册为监听者"><a href="#2-3-注册为监听者" class="headerlink" title="2.3 注册为监听者"></a>2.3 注册为监听者</h3><p>在合适的地方（比如 Activity#onCreate、Fragment#onCreateView）通过下方代码进行注册</p>
<p><code>EventBus.getDefault().register(this);</code></p>
<h3 id="2-4-编写响应事件的订阅方法"><a href="#2-4-编写响应事件的订阅方法" class="headerlink" title="2.4 编写响应事件的订阅方法"></a>2.4 编写响应事件的订阅方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND, sticky = <span class="keyword">true</span>, priority = <span class="number">100</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(CustomEvent event)</span> </span>&#123;</div><div class="line">    Log.d(TAG, <span class="string">"onMessage: "</span> + event.getEventName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用编译期注解处理的情况下，订阅方法的访问控制权限必须是 非 private 并且非 static 的</p>
<p>使用运行期反射处理的情况下，订阅方法的访问控制权限必须是 public 的</p>
<ul>
<li>通过 ThreadMode 可以指定订阅方法在哪个线程执行，有四种选择<ul>
<li>ThreadMode.MAIN 事件订阅方法会在 UI 线程中执行<ul>
<li>使用此模式的事件订阅方法必须快速返回以避免阻塞主线程。</li>
</ul>
</li>
<li>ThreadMode.POSTING （默认的模式）表示事件在哪个线程中发布出来的，事件订阅方法就会在这个线程中运行；<ul>
<li>该模式避免了线程切换，适用于那些在很短的时间内完成的简单任务，无需主线程。使用这种模式的事件订阅方法必须快速返回以避免阻塞发布线程（发布线程可能是主线程）。</li>
</ul>
</li>
<li>ThreadMode.MAIN_ORDERED<ul>
<li>在 Android 上，订阅方法将在 Android 的主线程中被调用。事件将会排队等待交付，这确保了 post 调用是非阻塞的。</li>
</ul>
</li>
<li>ThreadMode.BACKGROUND 子线程执行，如果本来就在子线程，直接在该子线程执行<ul>
<li>EventBus 使用一个后台线程，将按顺序发送所有事件。使用这种模式的订阅方法应该尽快返回以避免阻塞后台线程。<ul>
<li>注意：「一个后台线程」所指的并不是 <code>Executors.newSingleThreadPool()</code>，而是使用 EventBus 在实例化时创建的 cacheThreadPool 中的某一个线程。</li>
</ul>
</li>
</ul>
</li>
<li>ThreadMode.ASYNC 新建子线程执行。适用于耗时操作<ul>
<li>发布事件永远不会等待使用此模式的订阅方法。适用于比较耗时的订阅方法，比如用于网络请求。使用时应该避免同时触发大量长时间运行的异步订阅方法来限制并发线程的数量。 EventBus 使用线程池有效地重用已完成的异步用户通知中的线程。</li>
</ul>
</li>
</ul>
</li>
<li>通过 sticky 指定是否接收粘性事件，默认为 false</li>
<li>通过 priority 设置接收订阅方法的优先级，相同的事件，优先级越高的订阅方法 越早收到事件</li>
</ul>
<h3 id="2-5-发送事件"><a href="#2-5-发送事件" class="headerlink" title="2.5 发送事件"></a>2.5 发送事件</h3><p>通过<code>EventBus</code>的<code>post()</code>方法来发送事件, 发送之后就会执行注册过这个事件的对应类的方法. 或者通过<code>postSticky()</code>来发送一个粘性事件。</p>
<h3 id="2-6-解除注册"><a href="#2-6-解除注册" class="headerlink" title="2.6 解除注册"></a>2.6 解除注册</h3><p>在合适的地方（比如 Activity#onDestroy）使用下面的代码进行解除注册 <code>EventBus.getDefault().unregister(this);</code></p>
<h3 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h3><p>要实现订阅，需要进行注册，以及解注册，订阅方法以「目标事件」作为方法的参数， 使用 Subscribe 注解，可以指定订阅方法执行的线程、是否接收 sticky 事件、订阅方法的优先级。</p>
<p>至于发送方，只需要创建相应的 事件实例，然后调用 post 或者 postSticky 将事件发送出去即可。</p>
<h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="3-1-初始化-EventBus"><a href="#3-1-初始化-EventBus" class="headerlink" title="3.1 初始化 EventBus"></a>3.1 初始化 EventBus</h3><p>开发者通常是调用 EventBus#getDefault 方法获取 EventBus 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> defaultInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getDefault 通过双重校验锁的方式来实现单例</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 getDefault 获取的 EventBus 对象是通过默认的 EventBusBuilder 构造而成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();<span class="comment">//默认为 CachedThreadPool，不限制线程数</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> logSubscriberExceptions = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">boolean</span> logNoSubscriberMessages = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">boolean</span> sendSubscriberExceptionEvent = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">boolean</span> sendNoSubscriberEvent = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">boolean</span> throwSubscriberException;</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> strictMethodVerification;<span class="comment">//</span></div><div class="line">ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;<span class="comment">//默认的线程池</span></div><div class="line">List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;</div><div class="line">List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;</div><div class="line">MainThreadSupport mainThreadSupport;</div><div class="line"></div><div class="line">EventBus(EventBusBuilder builder) &#123;</div><div class="line">	<span class="comment">//……</span></div><div class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	<span class="comment">//……</span></div><div class="line">    eventInheritance = builder.eventInheritance;</div><div class="line">    executorService = builder.executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要看以下几个单例的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> eventInheritance = <span class="keyword">true</span>;<span class="comment">//是否允许事件继承</span></div><div class="line"><span class="keyword">boolean</span> ignoreGeneratedIndex;<span class="comment">//是否忽略 生成的 index，默认为 false，也就是会先尝试寻找编译期注解生成的订阅方法信息，找不到再使用反射去获取。</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandlerPoster mainThreadPoster;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundPoster backgroundPoster;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncPoster asyncPoster;</div></pre></td></tr></table></figure>
<ul>
<li>subscriptionsByEventType ，key 是事件类型，value 为 订阅了该事件的方法列表</li>
<li>typesBySubscriber，key 为订阅者，value 某个订阅者订阅的事件列表</li>
<li>stickyEvents，key 为事件类型，value 为具体的事件实例</li>
<li>mainThreadPoster 主线程分发</li>
<li>backgroundPoster 后台线程分发</li>
<li>asyncPoster 异步线程分发</li>
</ul>
<h3 id="3-2-注册订阅"><a href="#3-2-注册订阅" class="headerlink" title="3.2 注册订阅"></a>3.2 注册订阅</h3><p>org.greenrobot.eventbus.EventBus#register</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();<span class="comment">//获取订阅者的 class 对象</span></div><div class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);<span class="comment">//查找订阅者中所有的订阅方法</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">//迭代遍历订阅者中所有的订阅方法</span></div><div class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">            subscribe(subscriber, subscriberMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EventBus#findSubscriberMethods </p>
<p>找出给定 class 中所有的订阅方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = <span class="keyword">new</span> ConcurrentHashMap();<span class="comment">//以 class 为 key，方法列表为 value 的，Map 作为缓存</span></div><div class="line"></div><div class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    List subscriberMethods = (List)METHOD_CACHE.get(subscriberClass);<span class="comment">//缓存中获取</span></div><div class="line">    <span class="keyword">if</span>(subscriberMethods != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> subscriberMethods;<span class="comment">//缓存命中，直接返回</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.ignoreGeneratedIndex) &#123;<span class="comment">//忽略编译期生成的 订阅方法信息</span></div><div class="line">            subscriberMethods = <span class="keyword">this</span>.findUsingReflection(subscriberClass);<span class="comment">//通过反射获取订阅方法信息</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//获取编译期生成的 订阅方法信息</span></div><div class="line">            subscriberMethods = <span class="keyword">this</span>.findUsingInfo(subscriberClass);<span class="comment">//</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(subscriberMethods.isEmpty()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);<span class="comment">//添加到缓存中</span></div><div class="line">            <span class="keyword">return</span> subscriberMethods;<span class="comment">//返回</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EventBus#subscribe()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//必须从同步块中调用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;<span class="comment">//事件类型</span></div><div class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);<span class="comment">//新建一个 Subscription，存储订阅的对象以及 响应的方法</span></div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);<span class="comment">//Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; 从 map 中获取相应订阅类型的 列表</span></div><div class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;<span class="comment">//如果没有则新建一个</span></div><div class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">        subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">                    + eventType);<span class="comment">//没有则抛出异常。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">    <span class="comment">//遍历监听列表，将新的 subscription 插入到正确位置。列表按照优先级递减的顺序排序</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">            subscriptions.add(i, newSubscription);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">    &#125;</div><div class="line">    subscribedEvents.add(eventType);</div><div class="line">	<span class="comment">//如果触发的方法 要接收「粘性事件」，获取相应类型的 Event 并触发相应的方法</span></div><div class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></div><div class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></div><div class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></div><div class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></div><div class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                    Object stickyEvent = entry.getValue();</div><div class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会将相应的事件插入对应事件的列表中。如果在方法注解中声明了 sticky，还会马上调用该方法。</p>
<p>检测 stick 事件，如果相应的事件定义有子类的话，会遍历事件的事件子类逐一通知该方法。</p>
<h4 id="3-2-1-通过反射处理注解"><a href="#3-2-1-通过反射处理注解" class="headerlink" title="3.2.1 通过反射处理注解"></a>3.2.1 通过反射处理注解</h4><p>SubscriberMethodFinder#findUsingReflection</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    FindState findState = prepareFindState();</div><div class="line">    findState.initForSubscriber(subscriberClass);</div><div class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">        findUsingReflectionInSingleClass(findState);</div><div class="line">        findState.moveToSuperclass();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SubscriberMethodFinder#findUsingReflectionInSingleClass</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">        Method[] methods;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></div><div class="line">            methods = findState.clazz.getDeclaredMethods();<span class="comment">//获取的是类的所有公有方法，这就包括自身 和从基类继承的、从接口实现的所有 public 方法。</span></div><div class="line">            <span class="comment">//getDeclareMethods 返回的是该类中定义的「所有方法」，但是不包括从父类继承而来的方法</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">            methods = findState.clazz.getMethods();</div><div class="line">            findState.skipSuperClasses = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Method method : methods) &#123;<span class="comment">//遍历方法</span></div><div class="line">            <span class="keyword">int</span> modifiers = method.getModifiers();</div><div class="line">            <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</div><div class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">                <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;<span class="comment">//参数列表长度为 0</span></div><div class="line">                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">                    <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">                        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</div><div class="line">                        <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</div><div class="line">                            ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">                            <span class="comment">//将订阅方法信息添加到 findState 中</span></div><div class="line">                            findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</div><div class="line">                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                    String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</div><div class="line">                            <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</div><div class="line">                        <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="ignoreGeneratedIndex-是什么"><a href="#ignoreGeneratedIndex-是什么" class="headerlink" title="ignoreGeneratedIndex 是什么?"></a>ignoreGeneratedIndex 是什么?</h5><p>由于反射成本高,而且 EventBus 3.0 引入了 EventBusAnnotationProcessor,故默认 ignoreGeneratedIndex 为 false,<strong>需要注意的是,如果设置 ignoreGeneratedIndex 为 true,则前面使用的 MyEventBusIndex 无效,还是会走反射解析的分支</strong>。</p>
<h4 id="3-2-2-使用编译期生成的订阅方法信息"><a href="#3-2-2-使用编译期生成的订阅方法信息" class="headerlink" title="3.2.2 使用编译期生成的订阅方法信息"></a>3.2.2 使用编译期生成的订阅方法信息</h4><p>网上有很多介绍 EventBus 的文章,但是几乎没有提到 EventBusAnnotationProcessor 的。在 3.0 版本开始，<code>EventBus</code>提供了一个<code>EventBusAnnotationProcessor</code>注解处理器来在编译期通过读取<code>@Subscribe()</code>注解并解析,处理其中所包含的信息,然后生成<code>java</code>类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.我们可以参考<code>EventBus</code>项目里的<a href="https://link.jianshu.com?t=https://github.com/greenrobot/EventBus/tree/master/EventBusPerformance" target="_blank" rel="noopener">EventBusPerformance</a>这个例子,编译后我们可以在<code>build</code>文件夹里找到这个类,<a href="https://link.jianshu.com?t=https://github.com/greenrobot/EventBus/blob/master/EventBusPerformance/build.gradle#L27" target="_blank" rel="noopener">MyEventBusIndex</a> 类,当然类名是可以自定义的.我们大致看一下生成的<code>MyEventBusIndex</code>类是什么样的:</p>
<p>订阅者中的 订阅方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveEventFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line">    <span class="comment">//……</span></div><div class="line">    </div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN, priority = <span class="number">0</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(MsgEvent event)</span> </span>&#123;</div><div class="line">        Log.d(TAG, <span class="string">"onReceive: "</span> + event);</div><div class="line">        mTvMsg.setText(String.format(<span class="string">"msgId:%d\nmsg:%s"</span>, event.msgId, event.msg));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN, priority = <span class="number">10000</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowToast</span><span class="params">(MsgEvent event)</span> </span>&#123;</div><div class="line">        Toast.makeText(getActivity(), String.format(<span class="string">"msgId:%d\nmsg:%s"</span>, event.msgId, event.msg), Toast.LENGTH_SHORT).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();<span class="comment">//以订阅者为 key，以订阅者中的 订阅方法列表为 value 的 map</span></div><div class="line">		<span class="comment">//将 ReceiveEventFragment 的订阅信息存储到 map 中</span></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(com.test.commentdemo.eventbusdemo.ReceiveEventFragment.class,</div><div class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</div><div class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onReceive"</span>, com.test.commentdemo.eventbusdemo.MsgEvent.class,</div><div class="line">                    ThreadMode.MAIN),</div><div class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"ShowToast"</span>, com.test.commentdemo.eventbusdemo.MsgEvent.class,</div><div class="line">                    ThreadMode.MAIN, <span class="number">10000</span>, <span class="keyword">false</span>),</div><div class="line">        &#125;));<span class="comment">//订阅者中所有的订阅方法</span></div><div class="line">        </div><div class="line">        <span class="comment">//……代码省略（存储其他订阅者的订阅信息到 map 中）</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</div><div class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);<span class="comment">//根据类型从 Map 获取订阅者的订阅信息</span></div><div class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续前面 ignoreGeneratedIndex 为 false 时，会执行以下分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">    FindState findState = prepareFindState();</div><div class="line">    findState.initForSubscriber(subscriberClass);</div><div class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</div><div class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();<span class="comment">//获取订阅的方法信息</span></div><div class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</div><div class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</div><div class="line">                    findState.subscriberMethods.add(subscriberMethod);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            findUsingReflectionInSingleClass(findState);<span class="comment">//如果找不到相应的订阅方法信息（可能使用 EventBus 实例之前，没有将MyEventBusIndex ），需要通过反射获取订阅方法信息</span></div><div class="line">        &#125;</div><div class="line">        findState.moveToSuperclass();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>findUsingInfo()</code>方法,其无非就是通过查找我们前面所说的<code>MyEventBusIndex</code>类中的信息,来转换成<code>List&lt;SubscriberMethod&gt;</code>从而获得订阅类的相关订阅函数的各种信息</p>
<p>SubscriberMethodFinder#getSubscriberInfo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(SubscriberMethodFinder.FindState findState)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) </div><div class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();<span class="comment">//获取父类的订阅方法信息</span></div><div class="line">        <span class="keyword">if</span>(findState.clazz == superclassInfo.getSubscriberClass()) &#123;<span class="comment">//</span></div><div class="line">            <span class="keyword">return</span> superclassInfo;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</div><div class="line">        Iterator superclassInfo1 = <span class="keyword">this</span>.subscriberInfoIndexes.iterator();</div><div class="line">		<span class="comment">//遍历，从 index 中获取 订阅信息</span></div><div class="line">        <span class="keyword">while</span>(superclassInfo1.hasNext()) &#123;</div><div class="line">            SubscriberInfoIndex index = (SubscriberInfoIndex)superclassInfo1.next();</div><div class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);<span class="comment">//从自动生成的 MyEventBusIndex 类中的 SUBSCRIBER_INDEX 里面获取订阅方法信息</span></div><div class="line">            <span class="keyword">if</span>(info != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> info;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-解注册"><a href="#3-3-解注册" class="headerlink" title="3.3 解注册"></a>3.3 解注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Unregisters the given subscriber from all event classes. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);<span class="comment">//获取订阅者订阅的事件列表</span></div><div class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;<span class="comment">//遍历订阅者所订阅的事件</span></div><div class="line">            <span class="comment">//从事件对应的订阅列表中 订阅者的订阅信息</span></div><div class="line">            unsubscribeByEventType(subscriber, eventType);</div><div class="line">        typesBySubscriber.remove(subscriber);<span class="comment">//移除订阅者</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        logger.log(Level.WARNING, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">    <span class="comment">//从事件对应的订阅列表中 订阅者的订阅信息</span></div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> size = subscriptions.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            Subscription subscription = subscriptions.get(i);</div><div class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</div><div class="line">                subscription.active = <span class="keyword">false</span>;</div><div class="line">                subscriptions.remove(i);</div><div class="line">                i--;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-发送事件"><a href="#3-4-发送事件" class="headerlink" title="3.4 发送事件"></a>3.4 发送事件</h3><p>EventBus#post</p>
<h4 id="1-获取订阅列表"><a href="#1-获取订阅列表" class="headerlink" title="1. 获取订阅列表"></a>1. 获取订阅列表</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class EventBus &#123;</div><div class="line"></div><div class="line">    private final ThreadLocal&lt;EventBus.PostingThreadState&gt; currentPostingThreadState;//线程私有变量——当前发布线程状态</div><div class="line"></div><div class="line">    public void post(Object event) &#123;</div><div class="line">        EventBus.PostingThreadState postingState = (EventBus.PostingThreadState)this.currentPostingThreadState.get();//记录发布线程的状态（比如是否是主线程）</div><div class="line">        List eventQueue = postingState.eventQueue;//从发布状态中获取事件队列</div><div class="line">        eventQueue.add(event);//添加进事件队列的队尾</div><div class="line">        if(!postingState.isPosting) &#123;//当前不是处于分发状态</div><div class="line">            postingState.isMainThread = this.isMainThread();//是否在主线程</div><div class="line">            postingState.isPosting = true;//将状态改为发布中</div><div class="line">            if(postingState.canceled) &#123;//取消发布</div><div class="line">                throw new EventBusException("Internal error. Abort state was not reset</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                while(!eventQueue.isEmpty()) &#123;//只要事件队列非空，就一直往外取出事件并发布</div><div class="line">                    this.postSingleEvent(eventQueue.remove(0), postingState);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                postingState.isPosting = false;</div><div class="line">                postingState.isMainThread = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">                                            </div><div class="line">    static final class PostingThreadState &#123;</div><div class="line">        final List&lt;Object&gt; eventQueue = new ArrayList();//事件队列</div><div class="line">        boolean isPosting;</div><div class="line">        boolean isMainThread;</div><div class="line">        Subscription subscription;</div><div class="line">        Object event;</div><div class="line">        boolean canceled;</div><div class="line"></div><div class="line">        PostingThreadState() &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;                                                                   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//事件队列</span></div><div class="line">    <span class="keyword">boolean</span> isPosting;<span class="comment">//是否正在分发中</span></div><div class="line">    <span class="keyword">boolean</span> isMainThread;<span class="comment">//是否在主线程</span></div><div class="line">    Subscription subscription;</div><div class="line">    Object event;<span class="comment">//事件</span></div><div class="line">    <span class="keyword">boolean</span> canceled;<span class="comment">//取消</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</div><div class="line">    &#125;</div><div class="line">&#125;;<span class="comment">//currentPostingThreadState 是一个线程局部变量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/** Posts the given event to the event bus. */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    PostingThreadState postingState = currentPostingThreadState.get();<span class="comment">//获取当前线程事件分发状态</span></div><div class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">    eventQueue.add(event);<span class="comment">//添加到事务队列中</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;<span class="comment">//如果当前不是在分发状态,则进入分发状态</span></div><div class="line">        postingState.isMainThread = isMainThread();</div><div class="line">        postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//编译事件队列，逐一进行分发</span></div><div class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">            postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EventBus#postSingleEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</div><div class="line">    Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (eventInheritance) &#123;<span class="comment">//如果事件支持子类型，查找该事件的所有子类型</span></div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</div><div class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</div><div class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</div><div class="line">            logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</div><div class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EventBus#postSingleEventForEventType，       </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//查找 事件所对应的订阅者列表，然后迭代列表，切换到目标线程执行</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</div><div class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        subscriptions = subscriptionsByEventType.get(eventClass);<span class="comment">//查找 事件所对应的订阅者列表</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">            postingState.event = event;</div><div class="line">            postingState.subscription = subscription;</div><div class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">                aborted = postingState.canceled;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postingState.event = <span class="keyword">null</span>;</div><div class="line">                postingState.subscription = <span class="keyword">null</span>;</div><div class="line">                postingState.canceled = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (aborted) &#123;<span class="comment">//事件取消了</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-切换到指定线程"><a href="#2-切换到指定线程" class="headerlink" title="2.切换到指定线程"></a>2.切换到指定线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">        <span class="keyword">case</span> POSTING:<span class="comment">//</span></div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MAIN:</div><div class="line">            <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mainThreadPoster.enqueue(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MAIN_ORDERED:</div><div class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="keyword">null</span>) &#123;</div><div class="line">                mainThreadPoster.enqueue(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> BACKGROUND:<span class="comment">//后台线程</span></div><div class="line">            <span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">                backgroundPoster.enqueue(subscription, event);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ASYNC:<span class="comment">//新建一个子线程处理</span></div><div class="line">            asyncPoster.enqueue(subscription, event);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);<span class="comment">//包装为一个 PendingPost</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//加锁，进入同步块</span></div><div class="line">        queue.enqueue(pendingPost);<span class="comment">//添加到队列中</span></div><div class="line">        <span class="keyword">if</span> (!executorRunning) &#123;<span class="comment">//如果现在没有在执行 后台任务，则获取一个新线程执行任务</span></div><div class="line">            executorRunning = <span class="keyword">true</span>;</div><div class="line">            eventBus.getExecutorService().execute(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//循环，直到队列为空</span></div><div class="line">                PendingPost pendingPost = queue.poll(<span class="number">1000</span>);<span class="comment">//获取 PendingPost，最多等到 1 秒</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">	                <span class="comment">//前面取不到 PendingPost，下面进行双重校验检查</span></div><div class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                        <span class="comment">// Check again, this time in synchronized</span></div><div class="line">                        pendingPost = queue.poll();<span class="comment">//</span></div><div class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="comment">//队列确实为空，停止运行</span></div><div class="line">                            executorRunning = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                eventBus.invokeSubscriber(pendingPost);<span class="comment">//通过反射调用相应的方法</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">" was interruppted"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        executorRunning = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="MAIN"><a href="#MAIN" class="headerlink" title="MAIN"></a>MAIN</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mainThreadPoster.enqueue(subscription, event);</div></pre></td></tr></table></figure>
<p>HandlerPoster#enqueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//加锁</span></div><div class="line">        queue.enqueue(pendingPost);<span class="comment">//加入 pendingQueue 中。该队列会在 handleMessage 方法中调用</span></div><div class="line">        <span class="keyword">if</span> (!handlerActive) &#123;<span class="comment">//如果当前 handler 不是处于活跃状态，则退出</span></div><div class="line">            handlerActive = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;<span class="comment">//发送信息，提示</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>org.greenrobot.eventbus.HandlerPoster#handleMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">long</span> started = SystemClock.uptimeMillis();</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            PendingPost pendingPost = queue.poll();</div><div class="line">            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                    <span class="comment">// Check again, this time in synchronized</span></div><div class="line">                    pendingPost = queue.poll();</div><div class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">                        handlerActive = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            eventBus.invokeSubscriber(pendingPost);</div><div class="line">            <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</div><div class="line">            <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</div><div class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</div><div class="line">                &#125;</div><div class="line">                rescheduled = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        handlerActive = rescheduled;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 handleMessage 方法内部停留时间不能大于 10 毫秒，从</p>
<h5 id="MAIN-ORDERED"><a href="#MAIN-ORDERED" class="headerlink" title="MAIN_ORDERED"></a>MAIN_ORDERED</h5><p>新增加的模式，但是当前版本的实现还不完善。</p>
<h5 id="ASYN"><a href="#ASYN" class="headerlink" title="ASYN"></a>ASYN</h5><p>将事件添加 cachedThreadPool 中执行(如果当前有空闲线程，则复用空闲线程，如果没有就创建新线程)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">    queue.enqueue(pendingPost);</div><div class="line">    eventBus.getExecutorService().execute(<span class="keyword">this</span>);<span class="comment">//放到默认的 cachedThreaPool 中执行</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    PendingPost pendingPost = queue.poll();</div><div class="line">    <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</div><div class="line">    &#125;</div><div class="line">    eventBus.invokeSubscriber(pendingPost);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-反射调用订阅方法"><a href="#3-反射调用订阅方法" class="headerlink" title="3.反射调用订阅方法"></a>3.反射调用订阅方法</h4><p>org.greenrobot.eventbus.EventBus#invokeSubscriber(org.greenrobot.eventbus.PendingPost)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</div><div class="line">    Object event = pendingPost.event;</div><div class="line">    Subscription subscription = pendingPost.subscription;</div><div class="line">    PendingPost.releasePendingPost(pendingPost);</div><div class="line">    <span class="keyword">if</span> (subscription.active) &#123;</div><div class="line">        invokeSubscriber(subscription, event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">        handleSubscriberException(subscription, event, e.getCause());</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>切换到指定线程之后，通过反射的方法，调用订阅方法。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>EventBus 的实现原理可以归结为以下三点</p>
<ul>
<li>注册—&gt;扫描订阅方法，添加到订阅方法列表中</li>
<li>发送事件—&gt;根据事件的类型，遍历方法列表，反射调用订阅方法</li>
<li>解注册—&gt;从订阅方法列表中移除相应的订阅方法</li>
</ul>
<p><code>EventBus</code> 虽然不是标准的观察者模式的实现, 但是它的整体就是一个发布 / 订阅框架, 也拥有观察者模式的优点, 比如: 发布者和订阅者的解耦。</p>
<h2 id="五、参考资料与学习资源推荐"><a href="#五、参考资料与学习资源推荐" class="headerlink" title="五、参考资料与学习资源推荐"></a>五、参考资料与学习资源推荐</h2><ul>
<li><a href="http://p.codekk.com/blogs/detail/54cfab086c4761e5001b2538" target="_blank" rel="noopener">EventBus 源码解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22489785" target="_blank" rel="noopener">EventBus 高效使用及源码解析-知乎专栏</a></li>
<li><a href="https://www.jianshu.com/p/f057c460c77e" target="_blank" rel="noopener">EventBus 3.0 源码分析</a></li>
<li><a href="http://xuchongyang.com/2017/07/17/EventBus-3-0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%A8%E8%A7%A3/" target="_blank" rel="noopener">EventBus 3.0 源码分析（二）注解处理器的使用</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我。谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 源码分析 </category>
            
            <category> 框架原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> 框架原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[拆轮子系列——ButterKnife工作原理]]></title>
      <url>https://timlin-pro.github.io/blog/2017/10/07/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ButterKnife%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本篇博客主要包括以下三个部分</p>
<ul>
<li>日常使用 ButterKnife 的方式以及 ButterKnife 的 bind 方法</li>
<li>Xxx_ViewBinding 类是如何生成的？</li>
<li>注解处理器是怎么注册的？</li>
</ul>
<p>其中的代码基于 ButterKnife 8.6.0</p>
<p>本文假设你已经对注解有所了解。不了解注解的同学可以先看看<a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E6%B3%A8%E8%A7%A3%20Annotation" target="_blank" rel="noopener">这篇文章</a> ，我们主要关注编译期注解。</p>
<a id="more"></a>
<h2 id="运行期-ButterKnife-bind"><a href="#运行期-ButterKnife-bind" class="headerlink" title="运行期 ButterKnife#bind"></a>运行期 ButterKnife#bind</h2><p>我们通常都是通过以下方式使用 ButterKnife 的。将要绑定的控件加上 @BindView 注解，在 onCreate 方法    完成 <code>setContentView(R.layout.activity_main);</code> 之后。调用 <code>ButterKnife.bind(this);</code> 对相应的  View 进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.btn)</div><div class="line">    Button mBtn;</div><div class="line">    <span class="meta">@BindView</span>(R.id.radar_view)</div><div class="line">    RadarView mRadarView;</div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);<span class="comment">//ButterKnife 的入口</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>public static Unbinder bind(@NonNull Activity target)</code> ，在 Activity 中以该方法作为入口，首先获取 与 Activity 相关联的 window，然后再通过 window 获取 DecorView。最后通过 <code>createBinding</code> 方法创建相关绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</div><div class="line">  View sourceView = target.getWindow().getDecorView();</div><div class="line">  <span class="keyword">return</span> createBinding(target, sourceView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title">createBinding</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</div><div class="line">  Class&lt;?&gt; targetClass = target.getClass();</div><div class="line">  <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up binding for "</span> + targetClass.getName());</div><div class="line">  Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);<span class="comment">//查找目标类的构造器</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> Unbinder.EMPTY;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> constructor.newInstance(target, source);<span class="comment">//利用反射创建一个实例，这里实际上调用了 Xxx_ViewBinding 的构造方法（由此可以看到，Butterknife 也是有用到一点反射的）</span></div><div class="line">  &#125; </div><div class="line">  <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();<span class="comment">//LinkedHashMap 作为缓存容器</span></div><div class="line"></div><div class="line"><span class="meta">@Nullable</span> <span class="meta">@CheckResult</span> <span class="meta">@UiThread</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</div><div class="line">  Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);<span class="comment">//先从缓存中查找</span></div><div class="line">  <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> bindingCtor;<span class="comment">//缓存命中直接返回</span></div><div class="line">  &#125;</div><div class="line">  String clsName = cls.getName();<span class="comment">//获取类型</span></div><div class="line">  <span class="comment">//如果是 Framework 层的类，则直接返回 null</span></div><div class="line">  <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + <span class="string">"_ViewBinding"</span>);<span class="comment">//加载类</span></div><div class="line">    <span class="comment">//noinspection unchecked</span></div><div class="line">    bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);<span class="comment">//获取构造器</span></div><div class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">    bindingCtor = findBindingConstructorForClass(cls.getSuperclass());<span class="comment">//递归查找父类的构造器</span></div><div class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to find binding constructor for "</span> + clsName, e);</div><div class="line">  &#125;</div><div class="line">  BINDINGS.put(cls, bindingCtor);<span class="comment">//加入到缓存中</span></div><div class="line">  <span class="keyword">return</span> bindingCtor;<span class="comment">//返回构造器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下为编译器生成的 MainActivity_ViewBinding 类，该类在构造方法中对那些在 MainActivity 中打了注解（例如：<code>@BindView</code>）的 View 进行了初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_ViewBinding</span> <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> MainActivity target;<span class="comment">//目标类</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span> View view2131427444;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> View view2131427442;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> View view2131427443;</div><div class="line"></div><div class="line">  <span class="meta">@UiThread</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_ViewBinding</span><span class="params">(MainActivity target)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(target, target.getWindow().getDecorView());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@UiThread</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> MainActivity target, View source)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.target = target;</div><div class="line"></div><div class="line">    View view;</div><div class="line">    view = Utils.findRequiredView(source, R.id.btn, <span class="string">"field 'mBtn' and method 'onViewClicked'"</span>);<span class="comment">//findViewbyId</span></div><div class="line">    target.mBtn = Utils.castView(view, R.id.btn, <span class="string">"field 'mBtn'"</span>, Button.class);<span class="comment">//强制类型转换</span></div><div class="line">    view2131427444 = view;</div><div class="line">    view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;<span class="comment">//注册监听器</span></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</div><div class="line">        target.onViewClicked(p0);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    target.mRadarView = Utils.findRequiredViewAsType(source, R.id.radar_view, <span class="string">"field 'mRadarView'"</span>, RadarView.class);<span class="comment">//findViewbyId</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里插一个小话题：通常我们都会把不需要被外部使用到的成员变量声明为 private 的，但是回头看看我们使用 <code>@BindView</code>的 View 访问权限均为 defalut 。为什么呢？从 MainActivity_ViewBinding 的构造方法中可以看到对 View 进行赋值时直接使用了 <code>target.mBtn、 target.mRadarView</code>，如果声明为 private ，那就需要通过反射才能访问到对应的 View，这样会有性能上的损失。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在运行时以 <code>ButterKnife#bind</code> 方法作为入口，首先以目标 class 为 key 到缓存（一个 <code>LinkedHashMap</code>）中查找相应的 binding class，如果命中直接返回。如果没有缓存，则通过类加载器加载对应的 <code>Xxx_ViewBinding</code> 类，并将其加入到缓存中，然后返回。最后调用 Xxx_ViewBinding 类的构造器（通过反射）创建一个实例。Xxx_ViewBinding 类的构造器中完成了对 View 的绑定。比如  <code>findViewById，setOnClickListener</code></p>
<h2 id="编译期生成代码"><a href="#编译期生成代码" class="headerlink" title="编译期生成代码"></a>编译期生成代码</h2><h3 id="Q：前面提到的-MainActivity-ViewBinding-类是如何生成的呢？"><a href="#Q：前面提到的-MainActivity-ViewBinding-类是如何生成的呢？" class="headerlink" title="Q：前面提到的 MainActivity_ViewBinding  类是如何生成的呢？"></a>Q：前面提到的 MainActivity_ViewBinding  类是如何生成的呢？</h3><p> Answer: 在编译时对类中的 Annotation 进行解析，通过 JavaPoet 生成相应的代码。</p>
<p><code>编译时 Annotation</code> 指 @Retention 为 CLASS 的 Annotation，由编译器自动解析。开发人员需要做的<br>a. 自定义类继承自 AbstractProcessor<br>b. 重写其中的 process 函数<br>c. 注册注解处理器。注册完成后，<strong>编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理</strong></p>
<h3 id="自定义-Annotation-用于存储元数据"><a href="#自定义-Annotation-用于存储元数据" class="headerlink" title="自定义 Annotation  用于存储元数据"></a>自定义 Annotation  用于存储元数据</h3><p>以 BindView 注解为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(CLASS) <span class="meta">@Target</span>(FIELD)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</div><div class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></div><div class="line">  <span class="meta">@IdRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>@Retention(CLASS)</code> ：表示保留到编译期</li>
<li><code>@Target(FIELD)</code>：表示作用域为成员变量</li>
</ul>
<h3 id="注解处理器-ButterKnifeProcessor"><a href="#注解处理器-ButterKnifeProcessor" class="headerlink" title="注解处理器 ButterKnifeProcessor"></a>注解处理器 ButterKnifeProcessor</h3><p>ButterKnifeProcessor 继承自 AbstractProcessor ，AbstractProcessor 的主要源码如下，我们主要关注四个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> ProcessingEnvironment processingEnv;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractProcessor</span><span class="params">()</span> </span>&#123;<span class="comment">//默认构造器</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">//获取支持的注解类型</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">        SupportedAnnotationTypes var1 = (SupportedAnnotationTypes)<span class="keyword">this</span>.getClass().getAnnotation(SupportedAnnotationTypes.class);<span class="comment">//获取支持的注解类型</span></div><div class="line">        <span class="keyword">if</span>(var1 == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isInitialized()) &#123;<span class="comment">//如果已经初始化了，打印提醒</span></div><div class="line">                <span class="keyword">this</span>.processingEnv.getMessager().printMessage(Kind.WARNING, <span class="string">"No SupportedAnnotationTypes annotation found on "</span> + <span class="keyword">this</span>.getClass().getName() + <span class="string">", returning an empty set."</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> Collections.emptySet();<span class="comment">//返回空集</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> arrayToSet(var1.value());<span class="comment">//返回支持的注解集合</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;<span class="comment">//获取支持的源码版本</span></div><div class="line">        SupportedSourceVersion var1 = (SupportedSourceVersion)<span class="keyword">this</span>.getClass().getAnnotation(SupportedSourceVersion.class);<span class="comment">//支持的源码版本</span></div><div class="line">        SourceVersion var2 = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(var1 == <span class="keyword">null</span>) &#123;</div><div class="line">            var2 = SourceVersion.RELEASE_6;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isInitialized()) &#123;</div><div class="line">                <span class="keyword">this</span>.processingEnv.getMessager().printMessage(Kind.WARNING, <span class="string">"No SupportedSourceVersion annotation found on "</span> + <span class="keyword">this</span>.getClass().getName() + <span class="string">", returning "</span> + var2 + <span class="string">"."</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            var2 = var1.value();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> var2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment var1)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.initialized) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot call init more than once."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Objects.requireNonNull(var1, <span class="string">"Tool provided null ProcessingEnvironment"</span>);</div><div class="line">            <span class="keyword">this</span>.processingEnv = var1;</div><div class="line">            <span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; var1, RoundEnvironment var2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>init(ProcessingEnvironment env)</code>：每个注解处理器都必须有个空的构造方法。不过，有一个特殊的 init 方法，它会被注解处理器工具传入一个 ProcessingEnvironment 作为参数来调用。ProcessingEnvironment 提供了一些有用的工具类，如 Elements，Types 和 Filter。我们后面会用到它们。</li>
<li><code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code>：这个方法可以看做每个处理器的 main 方法。你要在这里写下你的扫描，判断和处理注解的代码，并生成 java 文件。通过传入的 RoundEnvironment 参数，你可以<strong>查询使用了某个特定注解的所有元素</strong>，我们稍后会看到。</li>
<li><code>getSupportedAnnotationTypes( )</code>：这里你需要说明这个处理器需要针对哪些注解来注册。注意返回类型是一个字符串的 Set，包含了你要用这个处理器处理的注解类型的全名</li>
<li><code>getSupportedSourceVersion( )</code>：用于指定你使用的 java 版本。通常会选择返回<code>SourceVersion.latestSupported( )</code>。当然，你也可以指定具体 java 版本：比如<code>return SourceVersion.RELEASE_7</code>;</li>
</ul>
<p>ButterKnife 的解析工作就是通过 <code>ButterKnife#process</code> 方法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Filer filer;<span class="comment">//成员变量</span></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</div><div class="line">    Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);<span class="comment">//扫描并解析目标类，获取 存储绑定信息的 bindingMap。</span></div><div class="line">  	<span class="comment">//遍历获取到的注解</span></div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</div><div class="line">      TypeElement typeElement = entry.getKey();</div><div class="line">      BindingSet binding = entry.getValue();</div><div class="line"></div><div class="line">      JavaFile javaFile = binding.brewJava(sdk);<span class="comment">//使用 javaPoet 生成 java 文件</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        javaFile.writeTo(filer);<span class="comment">//调用 javaPoet 的方法，将内容写入文件</span></div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        error(typeElement, <span class="string">"Unable to write binding for type %s: %s"</span>, typeElement, e.getMessage());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>process 方法首先调用 findAndParseTargets 方法获取解析的目标类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; <span class="title">findAndParseTargets</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</div><div class="line">   Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</div><div class="line">   Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line"></div><div class="line">   scanForRClasses(env);</div><div class="line"></div><div class="line">   <span class="comment">// 处理 @BindArray 元素.</span></div><div class="line">   <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindArray.class)) &#123;</div><div class="line">     <span class="keyword">if</span> (!SuperficialValidation.validateElement(element)) <span class="keyword">continue</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       parseResourceArray(element, builderMap, erasedTargetNames);</div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logParsingError(element, BindArray.class, e);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">//代码省略</span></div><div class="line">  </div><div class="line">   <span class="comment">// 遍历处理每一个打了 @BindView 注解的元素</span></div><div class="line">   <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</div><div class="line">     <span class="comment">// 解析 BindView 注解</span></div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       parseBindView(element, builderMap, erasedTargetNames);</div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logParsingError(element, BindView.class, e);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 处理每一个关联有监听器的注解</span></div><div class="line">   <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123;</div><div class="line">     findAndParseListener(env, listener, builderMap, erasedTargetNames);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Associate superclass binders with their subclass binders. This is a queue-based tree walk</span></div><div class="line">   <span class="comment">// which starts at the roots (superclasses) and walks to the leafs (subclasses).</span></div><div class="line">   Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =</div><div class="line">       <span class="keyword">new</span> ArrayDeque&lt;&gt;(builderMap.entrySet());</div><div class="line">   Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</div><div class="line">   <span class="keyword">while</span> (!entries.isEmpty()) &#123;</div><div class="line">     Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();</div><div class="line"></div><div class="line">     TypeElement type = entry.getKey();</div><div class="line">     BindingSet.Builder builder = entry.getValue();</div><div class="line"></div><div class="line">     TypeElement parentType = findParentType(type, erasedTargetNames);</div><div class="line">     <span class="keyword">if</span> (parentType == <span class="keyword">null</span>) &#123;</div><div class="line">       bindingMap.put(type, builder.build());</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       BindingSet parentBinding = bindingMap.get(parentType);</div><div class="line">       <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</div><div class="line">         builder.setParent(parentBinding);</div><div class="line">         bindingMap.put(type, builder.build());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="comment">// Has a superclass binding but we haven't built it yet. Re-enqueue for later.</span></div><div class="line">         entries.addLast(entry);</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> bindingMap;<span class="comment">//返回 bindingMap，用于后续 javapoet 生成代码</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>上面的方法是以注解为单位，处理各个使用了注解的属性，然后将它们存放到一个 Map 中。（该 Map 以属性所在类为 key，以属性集 BindingSet.Builder  为 value）。那么具体是如何解析的呢？</p>
<p>对于 ButterKnife 我们最常用的是 <code>@BindView</code>，针对 BindView 我们主要看 <code>parseBindView</code> 方法，该方法将使用了<code>@BindView</code> 的属性的绑定信息，存放到以该属性所在类为 key ，值为  <code>BindingSet.Builder</code> 的Map 中，供后续 javaPoet 生成代码使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBindView</span><span class="params">(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</span></span></div><div class="line">     Set&lt;TypeElement&gt; erasedTargetNames) &#123;</div><div class="line">   TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();<span class="comment">//获取该元素所在的类对应的元素。</span></div><div class="line"></div><div class="line">   <span class="comment">// 检查常见的代码生成限制</span></div><div class="line">   <span class="keyword">boolean</span> hasError = isInaccessibleViaGeneratedCode(BindView.class, <span class="string">"fields"</span>, element)</div><div class="line">       || isBindingInWrongPackage(BindView.class, element);</div><div class="line"></div><div class="line">   <span class="comment">// 检查目标类型是否继承自 View</span></div><div class="line">   TypeMirror elementType = element.asType();</div><div class="line">   <span class="keyword">if</span> (elementType.getKind() == TypeKind.TYPEVAR) &#123;</div><div class="line">     TypeVariable typeVariable = (TypeVariable) elementType;</div><div class="line">     elementType = typeVariable.getUpperBound();</div><div class="line">   &#125;</div><div class="line">   Name qualifiedName = enclosingElement.getQualifiedName();<span class="comment">//获取全称</span></div><div class="line">   Name simpleName = element.getSimpleName();<span class="comment">//获取简单名</span></div><div class="line"><span class="comment">//代码省略……</span></div><div class="line"><span class="comment">//如果不是接口而且不是 View 的子类，则打印错误信息，将 hasError 置为true</span></div><div class="line">   <span class="keyword">if</span> (hasError) &#123;</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 下面开始拼接要绑定的属性的信息</span></div><div class="line">  </div><div class="line">   <span class="keyword">int</span> id = element.getAnnotation(BindView.class).value();<span class="comment">//获取 R.id.xx</span></div><div class="line"></div><div class="line">   BindingSet.Builder builder = builderMap.get(enclosingElement);<span class="comment">//获取该属性所在的类的 builder</span></div><div class="line">   QualifiedId qualifiedId = elementToQualifiedId(element, id);<span class="comment">//从绑定记录中获取，如果相应的 id 已经被绑定过了，则报错，并打印相应的错误信息</span></div><div class="line">   <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</div><div class="line">     String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));</div><div class="line">     <span class="keyword">if</span> (existingBindingName != <span class="keyword">null</span>) &#123;</div><div class="line">       error(element, <span class="string">"Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)"</span>,</div><div class="line">           BindView.class.getSimpleName(), id, existingBindingName,</div><div class="line">           enclosingElement.getQualifiedName(), element.getSimpleName());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">//创建一个 BindingBuilder</span></div><div class="line">     builder = getOrCreateBindingBuilder(builderMap, enclosingElement);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   String name = simpleName.toString();<span class="comment">//简单类名</span></div><div class="line">   TypeName type = TypeName.get(elementType);<span class="comment">//获取该属性所在类的类名</span></div><div class="line">   <span class="keyword">boolean</span> required = isFieldRequired(element);</div><div class="line"></div><div class="line">   builder.addField(getId(qualifiedId), <span class="keyword">new</span> FieldViewBinding(name, type, required));<span class="comment">//创建 Field 并添加到 BindingSet.Builder 的 field 中</span></div><div class="line"></div><div class="line">   <span class="comment">// Add the type-erased version to the valid binding targets set.</span></div><div class="line">   erasedTargetNames.add(enclosingElement);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>假设我们在某一个类中重复绑定了相同的 id，比如下面这个例子对 R.id.app_bar_layout 进行了两次绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindView</span>(R.id.app_bar_layout)</div><div class="line">AppBarLayout mAppBarLayout;</div><div class="line"><span class="meta">@BindView</span>(R.id.app_bar_layout)<span class="comment">//绑定了相同的 id，会报错</span></div><div class="line">AppBarLayout mAppBarLayout2;</div></pre></td></tr></table></figure>
<p>在编译期会报如下错误：</p>
<p><code>Error:(36, 18) 错误: Attempt to use @BindView for an already bound ID 2131230757 on &#39;mAppBarLayout&#39;. (com.android.rdc.librarysystem.MainActivity.mAppBarLayout2)</code></p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>ButterKnife 是以这样的方式来处理注解的：ButterKnife 支持多种注解（比如 @BindView 、@BindColor），这些注解被按照一定的顺序处理。获取使用了某个注解的所有 Element，对该 Element 的进行处理，生成相应的 FieldXxxBinding 然后将它添加到该 Element 所在类的 <code>BindingSet.Builder</code> 中。</p>
<p>也就是说，ButterKnife 是以注解为单位进行解析，处理完了，就把它放到相应属性所在类对应的 Set 里面（而不是一次扫描一个类，然后对该类中属性使用到的注解进行处理，一次性生成某个类的所对应的 <code>BindingSet.Builder</code> ）。</p>
<h4 id="通过-JavaPoet-生成-java-文件"><a href="#通过-JavaPoet-生成-java-文件" class="headerlink" title="通过 JavaPoet 生成 java 文件"></a>通过 JavaPoet 生成 java 文件</h4><p>正如其名，poet 指诗人，也就是作诗的人。java poet 指的是能够自动写 java 源代码的库。</p>
<p>javapoet 里面常用的几个类：</p>
<ul>
<li><code>TypeName</code> Java 系统的所有类型，加上 void 类型</li>
<li><code>MethodSpec</code> 代表一个构造函数或方法声明。</li>
<li><code>TypeSpec</code> 代表一个类，接口，或者枚举声明。</li>
<li><code>FieldSpec</code> 代表一个成员变量，一个字段声明。</li>
<li><code>JavaFile</code>包含一个顶级类的 Java 文件。</li>
</ul>
<p>回到前面的 process 方法，可以看到 <code>JavaFile javaFile = binding.brewJava(sdk);</code> <code>javaFile.writeTo(filer);</code></p>
<p>BindingSet#brewJava 。该方法通过 Javapoet 生成一个 java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">JavaFile <span class="title">brewJava</span><span class="params">(<span class="keyword">int</span> sdk)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> JavaFile.builder(bindingClassName.packageName(), createType(sdk))</div><div class="line">      .addFileComment(<span class="string">"Generated code from Butter Knife. Do not modify!"</span>)<span class="comment">//添加文件注释</span></div><div class="line">      .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 javapoet 的介绍详见<a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="注解处理器的注册"><a href="#注解处理器的注册" class="headerlink" title="注解处理器的注册"></a>注解处理器的注册</h3><h4 id="方法-1：使用-google-提供的注册处理器库"><a href="#方法-1：使用-google-提供的注册处理器库" class="headerlink" title="方法 1：使用 google 提供的注册处理器库"></a>方法 1：使用 google 提供的注册处理器库</h4><p>最简单的方式是使用 google 提供的一个注册处理器的库。 <code>compile &#39;com.google.auto.service:auto-service:1.0-rc2&#39;</code></p>
<p>然后<code>@AutoService(Processor.class)</code>:向 javac 注册我们这个自定义的注解处理器，这样，在 javac 编译时，才会调用到我们这个自定义的注解处理器方法。</p>
<p>AutoService 这里主要是用来生成<br><code>META-INF/services/javax.annotation.processing.Processor</code>文件的。</p>
<h4 id="方法-2：手动注册"><a href="#方法-2：手动注册" class="headerlink" title="方法 2：手动注册"></a>方法 2：手动注册</h4><p>如果不使用上述处理库，那么，你需要自己进行手动配置进行注册，具体手动注册方法如下：<br>1.创建一个<br><code>META-INF/services/javax.annotation.processing.Processor</code> 文件，<br>其内容是一系列的自定义注解处理器完整有效类名集合，以换行切割：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">com.example.MyProcessor</div><div class="line">com.foo.OtherProcessor</div><div class="line">net.blabla.SpecialProcessor</div></pre></td></tr></table></figure>
<p>2.将自定义注解处理器和<br>META-INF/services/javax.annotation.processing.Processor 打包成一个.jar 文件。所以其目录结构大概如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MyProcessor.jar</div><div class="line">  - com</div><div class="line">      - example</div><div class="line">          - MyProcessor.class</div><div class="line"></div><div class="line">  - META-INF</div><div class="line">      - services</div><div class="line">          - javax.annotation.processing.Processor</div></pre></td></tr></table></figure>
<p>ButterKnife 使用的是第一种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ButterKnife 在<strong>编译的时候</strong>帮我们<strong>自动生成</strong>了绑定的代码，然后在<strong>运行的时候调用</strong>就行了。</p>
<ul>
<li>首先我们在需要绑定 View 的 地方使用 @BindView 或者 ButterKnife 提供的其他注解，比如 @BindColor </li>
<li>在编译期  ButterKnifeProcessor 的 process 函数会被调用，在其中获取使用了相应注解的相关方法/成员变量信息，通过 javapoet 生成 Xx_ViewBinder 和 Xx_ViewBinding 类。</li>
<li>运行时，onCreate 方法中通常需要 <code>ButterKnife.Bind()</code>方法，从此处进入，通过 反射调用 Xx_ViewBinding 的构造方法对 View 进行初始化。</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E6%B3%A8%E8%A7%A3%20Annotation" target="_blank" rel="noopener">公共技术点之 Java 注解 Annotation</a></li>
<li><a href="http://www.jianshu.com/p/0f3f4f7ca505" target="_blank" rel="noopener">ButterKnife 源码分析</a></li>
<li><a href="http://dev.qq.com/topic/578753c0c9da73584b025875#rd" target="_blank" rel="noopener">深入理解 ButterKnife，让你的程序学会写代码</a></li>
<li><a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="noopener">javapoet——让你从重复无聊的代码中解放出来</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 源码分析 </category>
            
            <category> 框架原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> 框架原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String StringBuilder与StringBuffer的区别]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/21/String-StringBuilder%E4%B8%8EStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="http://ofucm8avi.bkt.clouddn.com/1.png" alt="image"></p>
<p>CharSequence 就是字符序列，String, StringBuilder 和 StringBuffer 本质上都是通过字符数组实现的。</p>
<ol>
<li>String 字符串<strong>常量</strong>（不可变）</li>
<li>StringBuffer 字符串变量（线程安全）</li>
<li>StringBuilder 字符串变量（非线程安全）</li>
</ol>
<a id="more"></a>
<h2 id="String-类型和-StringBuilder-类型的主要性能区别"><a href="#String-类型和-StringBuilder-类型的主要性能区别" class="headerlink" title="String 类型和 StringBuilder 类型的主要性能区别"></a>String 类型和 StringBuilder 类型的主要性能区别</h2><ol>
<li>String 是<strong>不可变的对象</strong>,因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以<strong>经常改变内容的字符串最好不要用 String</strong> ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，会进一步消耗性能。</li>
<li>StringBuilder 是可变的， 可以对 StringBuilder <strong>对象本身进行操作</strong>，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuilder ，特别是字符串对象经常改变的情况下。</li>
<li>通常 String 对象的字符串拼接其实是被 JVM 解释成了 StringBuilder 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuilder 对象慢。</li>
</ol>
<p>特别是以下的字符串对象生成中，String 效率是远要比 StringBuffer 高的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String S1 = “This is only a” + “ simple” + “ test”;<span class="comment">//直接拼接现有字符串</span></div><div class="line">StringBuffer Sb = <span class="keyword">new</span> StringBuilder(“This is only a”).append(“ simple”).append(“ test”);</div></pre></td></tr></table></figure>
<p>这其实涉及到了编译器的优化。在编译期，编译器会把<strong>字符串常量</strong>相加的情况直接变为拼接为目标字符串。也就是说编译之后就获得了目标字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String S1 = “This is only a” + “ simple” + “test”; </div><div class="line"> <span class="comment">//其实就是：</span></div><div class="line">String S1 = “This is only a simple test”;</div></pre></td></tr></table></figure>
<p>所以当然不需要太多的时间了。要注意的是，如果你的字符串是来自<strong>另外的 String 对象</strong>的话（比如下面所列举的这个例子），直接将 String 相加，性能上不会有什么提升。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String S2 = “This is only a”;</div><div class="line">String S3 = “ simple”;</div><div class="line">String S4 = “ test”;</div><div class="line">String S1 = S2 + S3 + S4;</div></pre></td></tr></table></figure>
<p>这时候 JVM 会规规矩矩的按照原来的方式去做——先创建一个 StringBuilder 对象，然后再进行调用它的 append 方法对 字符串进行拼接。</p>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>StringBuffer 是线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>
<h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作:"></a>主要操作:</h3><p>append 和 insert 方法，可重载这些方法，以接受任意类型的数据。</p>
<p>append 方法始终将这些字符<strong>添加到缓冲区的末端</strong>。</p>
<p>insert 方法则在指定的点添加字符。</p>
<p>例如:<br>z 引用一个当前内容是“start”的字符串缓冲区对象，<br>用 z.append(“le”) 会使字符串缓冲区包含“startle”，<br>而 z.insert(4, “le”) 将<strong>更改字符串缓冲区</strong>，使之包含“starlet”。</p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder 是 Java5 新增的一个非线程安全的可变的字符序列。可以把它理解为 StringBuffer 的非线程安全版本，因为实际应用中很少有需要对字符串进行同步的情况，所以采用 StringBuilder 的性能更加。在不需要同步，优先采用 StringBuilder。</p>
<p>初始长度分为三种情况:</p>
<p> 如果是调用的是无参构造函数，则默认容量为 16</p>
<p>如果指定了一个大于 0 的 capacity，则初始容量为 指定的 capacity</p>
<p>如果使用了参数类型为  CharSequence/String 的构造函数，则初始容量为<code>CharSequence的长度 + 16</code>。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>每次 append 的时候都会调用 ensureCapacityInternal ，当前长度 + append 内容总长度作为 minimumCapacity，如果  minimumCapacity 超过了 value 数组的长度，就将value 数组复制到长度为 newCapacity 的新数组，</p>
<p>一般情况下 newCapacity 大于  minimumCapacity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * For positive values of &#123;<span class="doctag">@code</span> minimumCapacity&#125;, this method</div><div class="line"> * behaves like &#123;<span class="doctag">@code</span> ensureCapacity&#125;, however it is never</div><div class="line"> * synchronized.</div><div class="line"> * If &#123;<span class="doctag">@code</span> minimumCapacity&#125; is non positive due to numeric</div><div class="line"> * overflow, this method throws &#123;<span class="doctag">@code</span> OutOfMemoryError&#125;.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        value = Arrays.copyOf(value,</div><div class="line">                newCapacity(minimumCapacity));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The maximum size of array to allocate (unless necessary).</div><div class="line"> * Some VMs reserve some header words in an array.</div><div class="line"> * Attempts to allocate larger arrays may result in</div><div class="line"> * OutOfMemoryError: Requested array size exceeds VM limit</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a capacity at least as large as the given minimum capacity.</div><div class="line"> * Returns the current capacity increased by the same amount + 2 if</div><div class="line"> * that suffices.</div><div class="line"> * Will not return a capacity greater than &#123;<span class="doctag">@code</span> MAX_ARRAY_SIZE&#125;</div><div class="line"> * unless the given minimum capacity is greater than that.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  minCapacity the desired minimum capacity</div><div class="line"> * <span class="doctag">@throws</span> OutOfMemoryError if minCapacity is less than zero or</div><div class="line"> *         greater than Integer.MAX_VALUE</div><div class="line"> * 返回一个至少跟 minCapacity 一样大的值。如果空间足够的话，当前的容量会增长一倍 +2 。</div><div class="line"> * 除非给定的值超过MAX_ARRAY_SIZE。否则返回的容量不会超过 MAX_ARRAY_SIZE。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code。防止溢出</span></div><div class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;<span class="comment">//当前数组长度 * 2 + 2</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;<span class="comment">//如果新长度 &lt; minCapacity，将新长度赋值为 minCapacity</span></div><div class="line">        newCapacity = minCapacity;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</div><div class="line">       ? hugeCapacity(minCapacity)<span class="comment">//检查溢出。如果溢出了，抛出错误。否则置为 MAX_ARRAY_SIZE</span></div><div class="line">        : newCapacity;<span class="comment">//长度在正常范围内，直接使用该长度</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</div><div class="line">        ? minCapacity : MAX_ARRAY_SIZE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener">Class StringBuilder</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> java 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[虚拟机类加载机制]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/19/JVM%20%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>虚拟机的类加载机制</strong>：虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p>
<p>与那些<strong>在编译时需要进行连接工作的语言</strong>不同，在 Java 语言里面，类型的加载、连接和初始化过程都是<strong>在程序运行期间完成</strong>的，</p>
<ul>
<li>缺点：这种策略会令类加载时稍微<strong>增加一些性能开销</strong></li>
<li>优点：为 Java 应用程序<strong>提供高度的灵活性</strong>，Java 里天生可以动态扩展的语言特性就是依赖<strong>运行期动态加载</strong>和<strong>动态连接</strong>这个特点实现的。<ul>
<li>例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；</li>
</ul>
</li>
</ul>
<p>约定：</p>
<ul>
<li>第一，在实际情况中，后文中直接<strong>对「类」的描述都包括了类和接口的可能性</strong>，而对于类和接口需要分开描述的场景会特别指明；</li>
<li>第二，「Class 文件」并非特指某个存在于具体磁盘中的文件，这里<strong>所说的「Class 文件」应当是一串二进制的字节流，无论以何种形式存在都可以</strong>。</li>
</ul>
<a id="more"></a>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>七个阶段：如下所示<br><img src="https://user-images.githubusercontent.com/16668676/28912625-9333eabc-7867-11e7-9b7f-6a2d4aa3f7a8.png" alt="default"></p>
<p>上图中，<strong>加载、验证、准备、初始化和卸载</strong>这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地<strong>开始</strong>，而==解析阶段则不一定==：它在某些情况下<strong>可以在初始化阶段之后再开始</strong>，这是为了支持 Java 语言的运行时绑定（也称为<strong>动态绑定或晚期绑定</strong>）。注意，这里说的是按部就班地「开始」，这些阶段通常都是<strong>互相交叉地混合式进行的</strong>，通常会<strong>在一个阶段执行的过程中调用</strong>、激活另外一个阶段。也就是说可能有些阶段未完成，下一个阶段就开始了。</p>
<p>什么情况下需要会开始加载一个类？Java 虚拟机规范中并没有进行强制约束。<br>但是对于初始化阶段，虚拟机规范严格规定了<strong>有且只有 5 种情况必须立即对类进行「<em>初始化</em></strong>」（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到 <strong>new、getstatic、putstatic 或 invokestatic</strong> 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<ul>
<li>生成这 4 条指令的最常见的 Java 代码场景是：<ul>
<li>使用 new 关键字实例化对象的时候、</li>
<li><strong>读取或设置一个类的静态字段</strong>（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，</li>
<li>以及<strong>调用一个类的静态方法</strong>的时候。</li>
</ul>
</li>
</ul>
<ol>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个<strong>要执行的主类</strong>（包含 main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK  1.7 的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果 <code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄<br>所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<ul>
<li><strong>主动引用</strong>：以上 5 种场景中的行为称为对一个类进行主动引用。</li>
<li><strong>被动引用</strong>：除了以上 5 种场景中的行为以外的对一个进行引用的行为。</li>
</ul>
<ol>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化，所以<strong>通过一个类的子类来引用父类中定义的静态变量，只会触发父类的初始化，而不会触发子类的初始化</strong>。</li>
<li>通过数组定义来引用类，不会触发此类的初始化。</li>
<li>常量定义在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<ul>
<li>在编译阶段通过常量传播优化实现</li>
</ul>
</li>
</ol>
<p>接口的加载过程与类加载过程稍有一些不同，<strong>接口也有初始化过程</strong>，这点与类是一致的，虽然接口中不能使用 <code>static{}</code>语句块，但编译器仍然会为接口生成 <code>&lt;clinit&gt;()</code>类构造器，<strong>用于初始化接口中所定义的成员变量</strong>。</p>
<ul>
<li>接口与类真正有所区别的是前面讲述的 5 种「有且仅有」需要开始初始化场景中的第 3 种：<ul>
<li>当一个类在初始化时，要求其父类全部都已经初始化过了，但是<strong>一个接口在初始化时</strong>，并不要求其父接口全部都完成了初始化，<strong>只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化</strong>。</li>
</ul>
</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>「加载」是「类加载」（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下 3 件事情：</p>
<ol>
<li>通过一个类的<strong>全限定名</strong>来获取<strong>定义此类的二进制字节流</strong>。</li>
<li>将这个字节流所代表的静态存储结构转化为<strong>方法区的运行时数据结构</strong>。</li>
<li>在内存中<strong>生成一个代表这个类的 java.lang.Class 对象</strong>，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>虚拟机规范的这 3 点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。</p>
<p>一个<strong>非数组类</strong>的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用<strong>系统提供的引导类加载器</strong>来完成，也可以由<strong>用户自定义的类加载器</strong>去完成，开发人员可以通过<strong>定义自己的类加载器</strong>去控制字节流的获取方式（即重写一个类加载器的 loadClass()方法）。</p>
<p>对于<strong>数组类</strong>而言，情况就有所不同，<strong>数组类本身不通过类加载器创建，它是==由 Java 虚拟机直接创建==的</strong>。</p>
<ul>
<li>一个数组类（下面简称为 C）创建过程就遵循以下规则：<ul>
<li>如果数组的组件类型（Component  Type，指的是数组去掉一个维度的类型）是<strong>引用类型</strong>，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将<strong>在加载该组件类型的类加载器的类名称空间上被标识</strong>（一个类必须与类加载器一起确定唯一性）。</li>
<li>如果数组的组件类型<strong>不是引用类型</strong>（例如 int[] 数组），Java 虚拟机将会把数组 C <strong>标记为与引导类加载器关联</strong>。数组类的可见性与它的<strong>组件类型的可见性</strong>一致，<ul>
<li>如果组件类型不是引用类型，那数组类的可见性将默认为 public。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式<strong>存储在方法区之中</strong>，<strong>方法区中的数据存储格式由虚拟机实现自行定义</strong>，虚拟机规范<strong>未规定此区域的具体数据结构</strong>。然后在内存中实例化一个 <code>java.lang.Class</code> 类的对象（并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言，<strong>Class 对象比较特殊，它虽然是对象，但是存放在方法区里面</strong>），这个对象将作为程序<strong>访问方法区中的这些类型数据的外部接口</strong>。</p>
<p><strong>加载阶段与连接阶段的部分内容</strong>（如一部分字节码文件格式验证动作）是<strong>交叉进行</strong>的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的<strong>开始时间仍然保持着固定的先后顺序</strong>。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="为什么需要验证？"><a href="#为什么需要验证？" class="headerlink" title="为什么需要验证？"></a>为什么需要验证？</h4><ul>
<li>虽然在编译时，编译器也会对 java 源码会对代码进行检查。但是 .class 文件并一定不要求用 java 源码编译来的，它可以使用任何途径生成，甚至可以用十六进制编辑器直接编写 class 文件。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃。所以验证是虚拟机对自身保护的一项重要工作。</li>
</ul>
<h4 id="验证什么？"><a href="#验证什么？" class="headerlink" title="验证什么？"></a>验证什么？</h4><ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><ul>
<li>是否以魔数 0xCAFEBABE 开头。</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>……</li>
</ul>
<p>该验证阶段的主要目的是<strong>保证输入的字节流能正确地解析并存储于方法区之内</strong>，格式上符合描述一个 Java 类型信息的要求。这阶段的验证是基于二进制字节流进行的，<strong>只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储</strong>，后面的 3 个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行<strong>语义分析，以保证其描述的信息符合 Java 语言规范的要求</strong></p>
<ul>
<li>这个类<strong>是否有父类</strong>（除了 java.lang.Object 之外，所有的类都应当有父类）。</li>
<li>这个类的父类<strong>是否继承了不允许被继承的类</strong>（被 final 修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。即，非抽象类是否实现了所有应该实现的方法？</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
</ul>
<p>继承关系，方法覆盖</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中<strong>最复杂的一个阶段</strong>，主要目的是通过数据流和控制流分析，<strong>确定程序语义是合法的、符合逻辑的</strong>。这个阶段将<strong>对类的方法体进行校验分析</strong>，<strong>保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</strong>。</p>
<ul>
<li>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；</li>
<li>但如果一个方法体通过了字节码验证，<strong>也不能说明其一定就是安全的</strong>。</li>
</ul>
<p>离散数学中一个很著名的问题「Halting Problem」（停机问题） ：通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>发生在虚拟机<strong>将符号引用转化为直接引用</strong>的时候，这个转化动作将在连接的第三阶段——<strong>解析阶段</strong>中发生。</p>
<p>符号引用验证可以看做是<strong>对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</strong>，通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的<strong>全限定名是否能找到对应的类</strong>。</li>
<li>在指定类中<strong>是否存在符合</strong>方法的字段描述符以及简单名称所描述的<em>*方法和字段</em>。</li>
<li>符号引用中的类、字段、方法的<strong>访问性</strong>（private、protected、public、default）是否可被当前类访问。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置<strong>==类变量==初始值的阶段</strong>，这些变量所使用的内存都将在<strong>方法区</strong>中进行分配。</p>
<ul>
<li>首先，这时候进行内存分配的<strong>仅包括类变量</strong>（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</li>
<li>其次，这里所说的初始值「<strong>通常情况」下是数据类型的零值</strong><ul>
<li>这时候尚未开始执行任何 Java 方法。</li>
<li>「==特殊情况==」：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值。<ul>
<li>假设上面类变量 value 的定义变为：<code>public static final int value=123；</code> 那么在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机<strong>将常量池内的符号引用替换为直接引用的过程</strong>，在 Class 文件中 符号引用 以 <code>CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info</code> 等类型的常量出现</p>
<p><strong>符号引用</strong>（Symbolic  References）：符号引用<strong>以一组符号来描述所引用的目标</strong>，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<strong>各种虚拟机实现的内存布局可以各不相同</strong>，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</p>
<p><strong>直接引用</strong>（Direct References）：直接引用可以是<strong>直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</strong>。</p>
<ul>
<li>直接引用是<strong>和虚拟机实现的内存布局相关的</strong>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。<ul>
<li>如果有了直接引用，那引用的目标必定已经在内存中存在。</li>
</ul>
</li>
</ul>
<p>虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<p>invokedynamic 指令的目的本来就是用于动态语言支持（目前仅使用 Java 语言不会生成这条字节码指令），它所对应的引用称为「动态调用点限定符」（Dynamic  Call  Site Specifier），这里「<strong>动态」的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行</strong>。</p>
<ul>
<li>相对的，其余可触发解析的指令都是「静态」的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。</li>
</ul>
<h4 id="1-类或接口的解析"><a href="#1-类或接口的解析" class="headerlink" title="1. 类或接口的解析"></a>1. 类或接口的解析</h4><p>假设当前代码所处的类为 D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，那虚拟机完成整个解析的过程需要以下 3 个步骤：</p>
<ol>
<li>如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</li>
<li>如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的描述符会是类似「[Ljava/lang/Integer」的形式，那将会按照第 1 点的规则加载数组元素类型。如果 N 的描述符<br>如前面所假设的形式，需要加载的元素类型就是「java.lang.Integer」，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有出现任何异常，那么 C 在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行<strong>符号引用验证</strong>，检查访问权限。如果发现不具备访问权限，将抛出 <code>java.lang.IllegalAccessError 异常。</code></li>
</ol>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>接口的方法、常量都是 public 的，所以不需要进行权限验证</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。<br><strong>到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码</strong>）。</p>
<ul>
<li>在准备阶段，变量已经赋过一次系统要求的初始值</li>
<li>在初始化阶段，根据项目需要对类变量进行相应的初始化，或者可以从另外一个角度来表达：初始化阶段是执行类构造器 <clinit>() 方法的过程。</clinit></li>
</ul>
<p><clinit>()方法是<strong>由编译器</strong>自动收集类中的<strong>所有类变量的==赋值动作==和静态语句块</strong>（static{}块）中的语句合并<strong>产生的</strong>，</clinit></p>
<ul>
<li>编译器收集的顺序是由语句在源文件中出现的顺序所决定的，</li>
<li>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</li>
<li>如果没有静态语句块也没有变量初始化赋值，就不会产生 <init> 方法</init></li>
</ul>
<p><clinit>()方法<strong>不需要显式地调用父类构造器</strong>，虚拟机会保证在子类的 <clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。<br>因此在虚拟机中第一个被执行的 <clinit>()方法的类肯定是 <code>java.lang.Object</code>。</clinit></clinit></clinit></clinit></p>
<p>接口与类一样都会生成 <clinit>()方法。但接口与类不同的是，</clinit></p>
<ul>
<li>执行接口的 <clinit>()方法不需要先执行父接口的 <clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。</clinit></clinit></li>
<li>另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>()方法。</clinit></li>
</ul>
<p><strong>虚拟机</strong>会保证一个类的 <clinit> 方法在多线程环境中被<strong>正确地加锁、同步</strong>，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的 <clinit> ()方法中有耗时很长的操作，就可能造成多个进程阻塞。在实际应用中这种阻塞往往是很隐蔽的</clinit></clinit></clinit></clinit></p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的<strong>唯一性</strong>，每一个类加载器都拥有一个独立的命名空间。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从 <strong>Java 虚拟机的角度</strong>来讲，只存在两种不同的类加载器：</p>
<ul>
<li>一种是启动类加载器（Bootstrap  ClassLoader），这个类加载器使用 <strong>C++ 语言实现</strong> ，是<strong>虚拟机自身的一部分</strong>；</li>
<li>另一种就是所有其他的类加载器，这些类加载器都由 <strong>Java</strong> 语言实现，<strong>独立于虚拟机外部</strong>，并且全都继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p>从 Java 开发人员的角度来看，绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器。</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：这个类将器负责将存放在<code>＜JAVA_HOME＞\lib</code> 目录中的，或者被-Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅<strong>按照文件名识别</strong>，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）<br>类库加载到虚拟机内存中。<ul>
<li>无法直接被用户使用，只能通过子类返回 null 来间接调用。</li>
</ul>
</li>
<li>扩展类加载器：<code>Extension ClassLoader</code>，负责加载<code>＜JAVA_HOME＞\lib\ext</code> (扩展库)目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器：因为可以通过 <code>ClassLoader.getSystemClassLoader()</code> 获取，因此一般也称为<strong>系统类加载器</strong>，负责加载用户路径上所指定类库，可以直接被开发者使用。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/28991885-d64d2c7c-79c1-11e7-9a8f-865a69fc24a2.png" alt="default"></p>
<p>上图中展示的层次关系，称为<strong>类加载器的双亲委派模型</strong>。</p>
<ul>
<li>该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。<ul>
<li>此处的父子关系通常不会通过继承关系来实现，而是选择<strong>组合</strong>关系来复用父加载器的代码</li>
</ul>
</li>
</ul>
<p><strong>工作过程</strong>：当一个类加载器收到了类加载的请求时，它不是自己加载，而是将这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此<strong>所有的加载请求最终都应该传送到顶层的启动类加载器中</strong>，只有当父加载器反馈自己无法完成该请求时，子加载器才会尝试自己去加载。</p>
<p><strong>好处</strong>：</p>
<ul>
<li>Java 类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>。</li>
<li><strong>保证 java 核心库的安全性</strong>（例如：如果用户自己写了一个 java.lang.String 类就会因为双亲委派机制不能被加载，不会破坏原生的 String 类的加载）<ul>
<li>栗子： Object 类，无论哪一个类要加载该类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。</li>
</ul>
</li>
</ul>
<p><strong>实现</strong>：在 ClassLoader 的 loadClass 方法中。</p>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><p>代理模式：</p>
<ul>
<li>与双亲委派机制相反，代理模式是先自己尝试加载，如果无法加载则向上传递。tomcat 就是代理模式。</li>
</ul>
<h3 id="「破坏」双亲委派模型"><a href="#「破坏」双亲委派模型" class="headerlink" title="「破坏」双亲委派模型"></a>「破坏」双亲委派模型</h3><p>双亲委派模型并不是一个强制性的约束模型。</p>
<ul>
<li>双亲委派模型的第一次「被破坏」其实发生在<strong>双亲委派模型出现之前</strong>——即 JDK 1.2 发布之前。</li>
<li>双亲委派模型的第二次「被破坏」是由这个模型<strong>自身的缺陷</strong>所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载）<ul>
<li>基础类之所以称为「基础」，是因为它们总是作为被用户代码调用的 API，但是<strong>基础类调用回用户的代码不容易</strong>（用回调不行？？）</li>
<li>一个典型的例子便是 JNDI 服务</li>
</ul>
</li>
<li>双亲委派模型的第三次「被破坏」是由于用户对<strong>程序动态性</strong>的追求而导致的，这里所说的「动态性」指的是当前一些非常「热门」的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U 盘，不用重启机器就能立即使用。热插拔？</li>
</ul>
<p>在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以 java.*开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载。</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>写出下面代码中的输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</div><div class="line">        count1++;</div><div class="line">        count2++;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> singleTon;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SingleTon singleTon = SingleTon.getInstance();</div><div class="line">        System.out.println(<span class="string">"count1="</span> + singleTon.count1);</div><div class="line">        System.out.println(<span class="string">"count2="</span> + singleTon.count2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析:</p>
<ol>
<li>从 main 函数看起，<code>SingleTon singleTon = SingleTon.getInstance();</code>调用了SingleTon类的静态方法，触发类的初始化。</li>
<li>类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值<code>singleton=null count1=0,count2=0</code></li>
<li>类初始化，为类的静态变量赋值和执行静态代码块。singleton赋值为<code>new SingleTon()</code>。调用类的构造方法</li>
<li>调用类的构造方法后 <code>count=1;count2=1</code></li>
<li>继续为count1与count2赋值,此时count1没有赋值操作,所有count1为1,但是count2执行赋值操作就变为0</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="加载-1"><a href="#加载-1" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。</p>
<h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static int v = 8080;</div></pre></td></tr></table></figure>
<p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;client&gt;</code>方法之中，这里我们后面会解释。</p>
<p>但是注意如果声明为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static final int v = 8080;</div></pre></td></tr></table></figure>
<p>在编译阶段会为 v 生成<code>ConstantValue</code>属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。</p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：</p>
<ul>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Field_info</li>
<li>CONSTANT_Method_info</li>
</ul>
<p>等类型的常量。</p>
<p>下面我们解释一下符号引用和直接引用的概念：</p>
<ul>
<li>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</li>
<li>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li>
</ul>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p>
<p>初始化阶段是执行类构造器<code>&lt;clint&gt;</code>方法的过程。<code>&lt;clint&gt;</code>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<code>&lt;clint&gt;</code>方法执行之前，父类的<code>&lt;clint&gt;</code>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<code>&lt;clint&gt;()</code>方法。</p>
<p><strong>注意以下几种情况不会执行类初始化：</strong></p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li><strong>定义对象数组</strong>，不会触发该类的初始化。<ul>
<li><code>Xxx[] ary = new Xxx[];</code></li>
</ul>
</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li>
<li>通过类名获取 Class 对象，不会触发类的初始化。</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《深入理解 Java 虚拟机》</li>
<li><a href="https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/" target="_blank" rel="noopener">JVM 类加载机制详解</a></li>
</ul>
<p>本文内容主要参考自《深入理解 Java 虚拟机》，当然也有一些个人理解，若有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 集合框架之 LinkedHashMap 工作原理]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/17/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8B-LinkedHashMap-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="一、不同类型-Map-的适用场景"><a href="#一、不同类型-Map-的适用场景" class="headerlink" title="一、不同类型 Map 的适用场景"></a>一、不同类型 Map 的适用场景</h2><ul>
<li>如果需要使用的Map中的<strong>key无序</strong>，选择<code>HashMap</code>；</li>
</ul>
<ul>
<li><p>如果要求<strong>key有序</strong>，则选择<code>TreeMap</code>。 </p>
<ul>
<li>但是选择TreeMap就会有<strong>性能问题</strong>，因为TreeMap的get操作的时间复杂度是<code>O(log(n))</code>的，相比于HashMap的<code>O(1)</code>还是差不少的，</li>
</ul>
</li>
<li><p><code>LinkedHashMap</code>的出现就是为了平衡这些因素，使得 能够以<strong>O(1)时间复杂度增加查找元素，又能够保证key的有序性</strong> 此外，LinkedHashMap提供了两种key的顺序：</p>
<ol>
<li>按照访问顺序排序（access order）。可以使用这种顺序<strong>实现<code>LRU（Least Recently Used）</code>缓存</strong></li>
</ol>
<ul>
<li>因为每次访问后的元素会被移到链表尾部，实现 LRU 只需要移除 链首元素 即可<ul>
<li>「一次访问」的定义是什么？<ul>
<li>put，putIfAbsent，get，getOrDefault，compute，computeIfAbsent，computeIfPresent或merge方法会导致访问相应的条目（假设它在调用完成后存在）。如果值被替换，替换方法只会导致条目的访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>按照插入顺序排序（insertion orde）。注：同一key的多次插入，并不会影响其顺序。</li>
</ol>
</li>
</ul>
<p>注：WeakHashMap 也可以用于实现缓存，二者的使用场景不同。WeakHashMap无法像 LinkedHashMap 那样自定义淘汰规则，它的元素会在 gc 的发生的时候被清除。</p>
<p>特别地，对 collection-view 的操作不会影响后台映射的迭代顺序。</p>
<ul>
<li>collection-view 是否类似于数据库的视图？</li>
</ul>
<h2 id="二、性能"><a href="#二、性能" class="headerlink" title="二、性能"></a>二、性能</h2><p>LinkedHashMap 提供了所有可选的Map操作，并允许使用null元素。与HashMap一样，假设散列函数能够正确地在桶之间分散元素，它为基本操作（添加，包含和删除）提供了恒定的性能。性能可能略低于HashMap的性能，这是因为<strong>维护链接列表的成本增加了</strong>，但有一个<strong>例外</strong>：对LinkedHashMap的collection-view的迭代需要时间<strong>与 map 的size 成比</strong>，而<strong>不关其capacity</strong>。迭代HashMap可能会更加昂贵，需要的时间<strong>与其capacity成正比</strong>。</p>
<p>LinkedHashMap 有两个影响其性能的参数：初始容量和负载因子。它们的定义与HashMap完全相同。但请注意，对于此类，初始容量选择过高值对性能的影响不会像HashMap那么严重，因为此类的迭代时间不受容量影响，迭代只受到 size 的影响。</p>
<h2 id="三、并发问题（fail-fast）"><a href="#三、并发问题（fail-fast）" class="headerlink" title="三、并发问题（fail-fast）"></a>三、并发问题（fail-fast）</h2><p>并发方式：推荐使用 <code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code>进行包装。内部是使用一个内置锁，各个方法的实现只是加锁然后 调用原来的类。这最好在创建时就完成「包装操作」，以防止意外的不同步访问Map。</p>
<p>结构性修改（A structural modification ） 是指</p>
<ul>
<li><strong>添加或删除</strong>一个或多个映射的操作，</li>
<li>在访问有序的LinkedHashMap的情况下会影响迭代顺序。</li>
<li>在插入有序的LinkedHashMap 中，仅更改与已包含在映射中的键相关的值不是结构修改。</li>
<li><strong>在 access-ordered 模式下的 LinkedHashMap中，仅通过get查询map就是一种结构修改</strong>。 </li>
</ul>
<p>迭代遍历过程中如果发现结构性修改问题（使用 iterater#remove 方法产生的结构性修改问题除外 ），马上抛出ConcurrentModificationException，以免造成更大的损失。</p>
<p>「快速失败」具体实现是怎么样的呢？每趟遍历完成之后都会调用 checkForComodification 方法进行检查</p>
<p>java.util.ArrayList.Itr#checkForComodification</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><h3 id="节点数据结构"><a href="#节点数据结构" class="headerlink" title="节点数据结构"></a>节点数据结构</h3><p>主要基于HashMap的节点数据结构实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">//每个节点包含两个指针，指向前继节点与后继节点</span></div><div class="line">    Entry&lt;K,V&gt; before, after;</div><div class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>双向链表实现的LinkedHshMap，所以每个节点须在HashMap的基础上添加指向前继节点与后继节点指针：before，after。</p>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>HashMap 中定义了三个回调方法供 LinkedHashMap 重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap继承于HashMap，重新实现了这3个函数，顾名思义这三个函数的作用分别是：<strong>节点访问后、节点插入后、节点移除后做一些事情</strong>。</p>
<h4 id="1-afterNodeRemoval"><a href="#1-afterNodeRemoval" class="headerlink" title="1.afterNodeRemoval"></a>1.afterNodeRemoval</h4><p>双向链表删除节点可以参考这样思路。</p>
<p>假设 before —&gt;   p —&gt; after</p>
<p>要删除 p</p>
<h5 id="1-先处理-after-方向"><a href="#1-先处理-after-方向" class="headerlink" title="1.先处理 after 方向"></a>1.先处理 after 方向</h5><p>if  p 为第一个节点 before == null  head = after</p>
<p>else before.after = after</p>
<h5 id="2-再处理-before-方向"><a href="#2-再处理-before-方向" class="headerlink" title="2.再处理 before 方向"></a>2.再处理 before 方向</h5><p>if p 为最后一个节点  <code>after == null</code>   <code>tail = before</code><br>else  after.before = before;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">    p.before = p.after = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">        head = a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        b.after = a;</div><div class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</div><div class="line">        tail = b;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        a.before = b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-afterNodeInsertion"><a href="#2-afterNodeInsertion" class="headerlink" title="2.afterNodeInsertion"></a>2.afterNodeInsertion</h4><p> evict参数有什么用？</p>
<ul>
<li>if false, the table is in creation mode.<ul>
<li>Creation mode 是什么？刚刚创建时的模式？</li>
</ul>
</li>
</ul>
<p>HashMap#的 put 方法，调用 putVal 方法时，传入的 evit 为 true。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用处传递 evict 全部为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-afterNodeAccess"><a href="#3-afterNodeAccess" class="headerlink" title="3.afterNodeAccess"></a>3.afterNodeAccess</h4><p>与模式相关 <code>final boolean accessOrder</code></p>
<p>只能在构造函数中指定，默认为 false，</p>
<ul>
<li>true 表示按访问顺序排序</li>
<li>false 表示按插入顺序排序</li>
</ul>
<p>把节点移到链表末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;<span class="comment">//如果是按照访问顺序，并且 不是最后一个元素</span></div><div class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-put"><a href="#4-put" class="headerlink" title="4.put"></a>4.put</h3><p><strong>put</strong> <code>put</code>函数在<code>LinkedHashMap</code>中未重新实现，只是实现了<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>两个回调函数。</p>
<h3 id="5-get"><a href="#5-get" class="headerlink" title="5.get"></a>5.get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>get</code>函数重新实现并加入了<code>afterNodeAccess</code>来保证访问顺序</p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><ol>
<li>怎样保证插入顺序？ 使用前驱和后继指针，使得原来的HashMap有序，在<code>LinkedHashMap</code>中覆盖<code>HashMap</code>中<code>newNode</code> 方法，使得每次put数据时，新建的节点都是<code>LinkedHashMap.Entry&lt;K,v&gt;</code> 类型的，比普通的<code>HsahMap.Entry</code> 多一个前驱结点和一个后继节点，使用前驱和后继保证插入有序。</li>
<li>怎么样保证访问顺序？ 覆盖父类<code>HashMap</code>的<code>afterNodeAccess</code> 方法，使得每次访问后，都改变链表顺序。使得原链表按访问排序。将最新一次访问的节点放到链表的最后。</li>
</ol>
<h2 id="六、参考资料与学习资源推荐"><a href="#六、参考资料与学习资源推荐" class="headerlink" title="六、参考资料与学习资源推荐"></a>六、参考资料与学习资源推荐</h2><ul>
<li><a href="https://my.oschina.net/hgfdoing/blog/634125" target="_blank" rel="noopener">重识java-LinkedHashMap</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 集合框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 内存模型与线程浅析]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/14/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p><strong>多级缓存的作用</strong>：由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以为了<strong>提高处理器的利用率</strong>，现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
<p>缓存虽然解决了速度差，但是也引入了新问题——<strong>缓存与主内存的数据一致性</strong>(Cache Coherence)</p>
<a id="more"></a>
<p><img src="https://user-images.githubusercontent.com/16668676/28780154-57045378-7638-11e7-8145-c98bc2ab581b.png" alt="default"></p>
<p>本文中「<strong>内存模型</strong>」一词，可以理解为<strong>在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象</strong>。</p>
<p>除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能<strong>会对输入代码进行乱序执行(Out-Of-Order Execution)优化</strong>（即 指令重排序），处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致。</p>
<p>Java 语言规范要求 JVM 在线程中维护一种类似串行的语义：<strong>只要程序的最终结果与在严格串行环境中执行的结果相同，那么上述操作（指令重排序、增加高速缓存）都是允许的</strong>。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>以下所谈的<strong>变量</strong>(Variables)与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但<strong>不包括局部变量与方法参数</strong>，因为后者是<em>线程私有的，不会被共享，自然就不会存在竞争问题</em>。</p>
<ul>
<li>~注~：如果局部变量是一个 reference 类型，它引用的对象在 Java 堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中，它是线程私有的。</li>
</ul>
<ul>
<li>Java 内存模型规定了<strong>所有的变量都存储在主内存</strong>(Main  Memory)中(此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分)。</li>
<li>每条线程还有自己的<strong>工作内存</strong>(Working  Memory，可与前面讲的处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的<strong>主内存副本拷贝</strong> [4]</li>
<li>线程对变量的所有<strong>操作(读取、赋值等)都必须在==工作==内存中进行</strong>，而<strong>不能直接读写主内存中的变量</strong>。<ul>
<li>干活要在操作线程中干。</li>
<li>这个对象的引用、对象中某个在线程访问到的字段是有可能存在拷贝的，但不会有虚拟机实现成把整个对象拷<br>贝 A 一次。</li>
</ul>
</li>
<li><strong>不同的线程</strong>之间也无法直接访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/28780155-570d932a-7638-11e7-90cf-082ba9b59d00.png" alt="12.2 线程、主内存、工作内存三者的交互关系"></p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>Java 内存模型中定义了以下 <strong>8 种操作</strong>来完成，虚拟机实现时必须保证<strong>下面提及的每一种操作都是原子的、不可再分的</strong>(对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外。</p>
<ul>
<li>lock、unlock</li>
<li>read 从主存读取</li>
<li>load 加载</li>
<li>use 使用</li>
<li>assign 分配</li>
<li>store 存储 </li>
<li>write 写回主存</li>
<li>如果要把一个变量从主内存<strong>复制到工作内存</strong>，那就要顺序地执行 <strong>read 和 load 操作</strong>，</li>
<li>如果要把变量从工作内存<strong>同步回主内存</strong>，就要顺序地执行 <strong>store 和 write 操作</strong>。</li>
<li>注意，Java 内存模型只要求上述两个操作<strong>必须按顺序执行</strong>，而<strong>没有保证是==连续==执行</strong>。</li>
</ul>
<p>Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许 read 和 load、store 和 write 操作之一<strong>单独出现</strong>，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。<ul>
<li>read 和 load、store 和 write 。工作内存与主内存之间有求必应。</li>
</ul>
</li>
<li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。<ul>
<li>改了一定要让主内存知道。</li>
</ul>
</li>
<li>不允许一个线程无原因地(没有发生过任何 assign 操作)把数据从线程的工作内存同步回主内存中。<ul>
<li>没改就别瞎折腾。</li>
</ul>
</li>
<li>一个新的变量只能在主内存中「诞生」，不允许在工作内存中直接使用一个未被初始化(load 或 assign)的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。<ul>
<li>​</li>
</ul>
</li>
<li>一个变量在同一个时刻<strong>只允许一条线程</strong>对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。<ul>
<li>锁了多少次，开多少次。</li>
</ul>
</li>
<li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。<ul>
<li>没有锁不要乱开锁</li>
</ul>
</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)。<ul>
<li>做好手尾，再开锁。</li>
</ul>
</li>
</ul>
<p>这 8 种内存访问操作以及上述规则限定，再加上稍后介绍的对 volatile 的一些特殊规定，就已经完全确定了 Java 程序中哪些内存访问操作在并发下是安全的。</p>
<h3 id="对于-volatile-型变量的特殊规则"><a href="#对于-volatile-型变量的特殊规则" class="headerlink" title="对于 volatile 型变量的特殊规则"></a>对于 volatile 型变量的特殊规则</h3><p>当一个变量定义为 volatile 之后，它将具备两种特性，</p>
<ul>
<li>第一是保证此变量对所有线程的<strong><em>可见性</em></strong>，这里的「可见性」是指当<strong>一条线程修改了这个变量的值</strong>，新值<strong>对于其他线程来说是可以立即得知</strong>的。<ul>
<li>而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。</li>
</ul>
</li>
<li>第二个语义是<strong><em>禁止指令重排序</em></strong>。</li>
</ul>
<p>可见性 != 线程安全</p>
<p>volatile 变量在各个线程的工作内存中不存在一致性问题(在各个线程的工作内存中，volatile 变量也可以存在不一致的情况，但由于<strong>每次使用之前都要先刷新</strong>，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)，但是 <strong>Java 里面的==运算并非原子操作==</strong>，导致 volatile 变量的运算在并发下一样是不安全的，</p>
<ul>
<li>非原子操作会导致读取数据后，多个线程<strong>并行所进行操作的都是旧值</strong>。那么加载到主内存的值也就不是最新的了。<ul>
<li>非原子操作 执行过程中是可以暂停的，暂停的那一段时间里其他线程可能修改了这个变量的值。</li>
</ul>
</li>
</ul>
<p>由于 volatile 变量只能保证可见性，在<strong>不符合</strong>以下<strong>两条规则</strong>的运算场景中，我们<strong>仍然要通过加锁</strong>(使用 synchronized 或 java.util.concurrent 中的原子类)来保证原子性。</p>
<ul>
<li><strong>运算结果并不依赖变量的当前值</strong>，或者能够<strong>确保只有单一的线程修改变量的值</strong>。</li>
<li>变量<strong>不需要与其他的状态变量共同参与不变约束</strong></li>
</ul>
<h4 id="volatile-性能"><a href="#volatile-性能" class="headerlink" title="volatile 性能"></a>volatile 性能</h4><p>某些情况下，volatile 的同步机制的性能确实要优于锁(使用 synchronized 关键字或 java.util.concurrent 包里面的锁)，但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为 volatile 就会比 synchronized 快多少。</p>
<ul>
<li>volatile 变量<strong>读操作的性能消耗与普通变量几乎没有什么差别</strong>，但是<strong>写操作则可能会慢一些</strong>，因为它需要在本地代码中插入许<br>多内存屏障指令来保证处理器不发生乱序执行。</li>
</ul>
<p>大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中<strong>选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求</strong>。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p><strong>内存屏障</strong>（Memory Barrier，或有时叫做<strong>内存栅栏</strong>，Memory Fence）是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。Java 编译器也会根据内存屏障的规则禁止重排序。<br>内存屏障可以被分为以下 4 种类型</p>
<ul>
<li><strong>LoadLoad 屏障</strong>：对于这样的语句 Load1; LoadLoad 屏障; Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。</li>
<li><strong>StoreStore 屏障</strong>：对于这样的语句 Store1; StoreStore 屏障; Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。</li>
<li><strong>LoadStore 屏障</strong>：对于这样的语句 Load1; LoadStore 屏障; Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。</li>
<li><strong>StoreLoad 屏障</strong>：对于这样的语句 Store1; StoreLoad 屏障; Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的<strong>开销是四种屏障中最大的</strong>。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
<p>有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java 编译器会在这种情况下不放置内存屏障。<br>为了实现 JSR-133 的规定，Java 编译器会这样使用内存屏障：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/30509011-80b17200-9ad7-11e7-9244-2081c271c752.png" alt="fences-table"></p>
<h3 id="对于-long-和-double-型变量的特殊规则"><a href="#对于-long-和-double-型变量的特殊规则" class="headerlink" title="对于 long 和 double 型变量的特殊规则"></a>对于 long 和 double 型变量的特殊规则</h3><p>允许虚拟机实现选择<strong>可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性</strong>，这点就是所谓的 long 和 double 的<strong>非原子性协定</strong>(Nonatomic Treatment ofdouble and long Variables)。</p>
<p>Java 内存模型「强烈建议」虚拟机把这些操作实现为具有原子性的操作。目前各种商用虚拟机也都是将它们实现为原子操作，因此我们在<strong>编写代码时==一般不需要==把用到的 long 和 double 变量专门声明为 volatile</strong>。</p>
<h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p><strong>原子性</strong>是指<strong>一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰</strong>。</p>
<p>由 Java 内存模型直接保证的原子性变量操作包括 read、load、assign、use、store 和 write，我们大致可以认为<strong>基本数据类型的访问读写是具备原子性的</strong>(例外就是 long 和 double 的非原子性协定)。</p>
<p>尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却<strong>提供了更高层次的字节码指令monitorenter 和 monitorexit 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字</strong>，因此在 synchronized 块之间的操作也具备原子性。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><strong>可见性</strong>(Visibility)：可见性是指当一个线程修改了共享变量的值，其他线程能够<strong>立即得知这个修改</strong>。</p>
<p>除了 volatile 以外，Java 还有两个关键字能实现可见性，即 <strong>synchronized 和 final</strong>。</p>
<ul>
<li>同步块的可见性是由「对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)」这条规则获得的，</li>
<li>final 关键字的可见性是指：保证一个对象的构建方法结束前，所有 final 成员变量都必须完成初始化（前提是没有 this 引用溢出）。在构造器中一旦初始化完成，并且构造器没有把「this」的引用传递出去，那在其他线程中就能看见 final 字段的值。<ul>
<li><strong>this 引用逃逸</strong> 是指在构造函数返回之前其他线程就持有该对象的引用。调用尚未构造完全的对象的方法可能引发令人疑惑的错误, 因此应该避免 this 逃逸的发生。<ul>
<li>例子：在<strong>构造函数中</strong>启动线程 / 注册监听器/ 创建匿名内部类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指「线程内表现为串行的语义」(Within-Thread  As-If-Serial Semantics)，后半句是指「指令重排序」现象和「工作内存与主内存同步延迟」现象。</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p><strong>先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据</strong>。</p>
<p>先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。所谓偏序关系可以这样理解：<strong>对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下操作在线程 A 中执行</span></div><div class="line">i=<span class="number">1</span>；</div><div class="line"><span class="comment">//以下操作在线程 B 中执行</span></div><div class="line">j=i；</div><div class="line"><span class="comment">//以下操作在线程 C 中执行</span></div><div class="line">i=<span class="number">2</span>；</div></pre></td></tr></table></figure>
<p>假设 A B C 之间满足 Happens-Before 条件，且 A Happens-Before B Happens-Before C，那么执行结果就是 j = 1; i = 2;</p>
<p>这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。<strong>如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序</strong>。</p>
<ul>
<li><strong>程序次序规则</strong>(Program Order Rule)：<strong>在一个线程内，按照程序代码顺序</strong>，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是<strong>控制流顺序</strong>而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li><strong>管程锁定规则</strong>(Monitor Lock Rule)：一个 <strong>unlock 操作</strong>先行发生于后面对<em>同一个锁</em>的 lock操作。这里必须强调的是<em>同一个锁</em>，而「后面」是指<strong>时间上</strong>的先后顺序。</li>
<li><strong>volatile 变量规则</strong>(Volatile Variable Rule)：对一个 volatile 变量的<strong>写操作先行发生于后面</strong>对这个变量的<strong>读操作</strong>，这里的「后面」同样是指<strong>时间上</strong>的先后顺序。</li>
<li><strong>线程启动规则</strong>(Thread Start Rule)：Thread 对象的 start()方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则</strong>(Thread Termination Rule)：线程中的所有操作必须在其他线程检测到该线程已经结束之前完成，我们可以通过 Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li><strong>线程中断规则</strong>(Thread Interruption Rule)：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生。</li>
<li><strong>对象终结规则</strong>(Finalizer Rule)：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始。</li>
<li><strong>传递性</strong>(Transitivity)：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</li>
</ul>
<p>Java 无需任何同步手段就能成立的先行发生规则就以上 8 点。看上去有些抽象，想要进一步了解的同学可以参考下这篇文章 <a href="https://segmentfault.com/a/1190000011458941" target="_blank" rel="noopener">从Java多线程可见性谈Happens-Before原则</a></p>
<p>==时间先后顺序与先行发生原则之间基本没有太大的关系==，所以我们衡量并发安全问题的时候==不要受到时间顺序的干扰，一切必须以先行发生原则为准==。</p>
<p>这句话应该如何理解呢？</p>
<p>考虑这样一个场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</div><div class="line"><span class="comment">//线程 A 先（时间上）调用了 getValue 方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"><span class="comment">//之后（时间上）线程 B 调用了 setValue(2) 方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是线程 A 的 getValue 获取的结果是什么呢？可能是 0 ，也可能是 2。也就是说，<em>没有进行同步处理的情况下</em>，不同线程对在时间上先后对调用对某个共享变量的操作，并不能保证它们的结果是根据它们在时间上调用顺序确定的。换句话说，在不同线程之间，「时间上的先调用」并不代表「先行发生」。要解决这个问题，可以给 getValue 和 setValue 方法都定义为 synchronized 的，因为这样就可以套用「管程锁定原则」了。或者将 value 定义了 volatile 变量，因为 setValue 方法对 value 的修改不依赖 value 的原值，满足 volatile 关键字使用场景，这样就可以套用 volatile 变量规则来实现先行发生规则了。</p>
<p>通过上面的讨论，我们可以得出结论：一个操作「时间上的先发生」不代表这个操作会会是「先行发生」。那么一个操作「先行发生」是否能推导出这个操作必定是「时间上先发生」呢？这个推论也是不成立的，一个典型的栗子就是「指令重排序」</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>按照程序次序规则，<code>int i = 2;</code> 的操作先行发生与 <code>int j = 1;</code>,但是 <code>int j = 1;</code> 完全可能先执行，这并不影响先行发生原则的正确性，因为在同一条线程中无法感知到这点。</p>
<h3 id="先行发生原则的真正意义"><a href="#先行发生原则的真正意义" class="headerlink" title="先行发生原则的真正意义"></a>先行发生原则的真正意义</h3><p>该段内容参考自<a href="https://segmentfault.com/a/1190000011458941" target="_blank" rel="noopener">从Java多线程可见性谈Happens-Before原则</a></p>
<blockquote>
<p>  从上面的分析中我们可以看出，Happens-Before原则致力于<strong>解决变量间可见性问题</strong>。但是它是如何解决的呢？</p>
<p>  <strong>导致多线程间变量间可见性问题的根源在于 CPU 缓存以及指令重排序</strong>。那么，要解决这个可见性问题，一个最简单粗暴的方法就是禁止所有的重排序和 CPU 缓存。即关闭所有的编译器、操作系统和处理器的优化，这样所有的指令顺序全部按照程序代码书写的顺序执行。去掉 CPU 高速缓存，让 CPU 每次读写操作都直接与主存交互。</p>
<p>  但是，如此粗暴的解决方案是不可取的，因为这会极大影响处理器的计算性能，并且对于那些非多线程共享的 变量是极不公平的。我们可以采用一种折中的方案来解决 CPU 高速缓存与指令重排带来的数据一致性问题。<strong>使用分割线把整个程序划分为几个程序块</strong>，在每个<strong>程序块内部的指令是可重排序的</strong>，但是分割线上的指令与程序块其他指令之间是不可以重排序的。在一个程序块内部，CPU 不用每次都与主内存进行交互，只需要在 CPU 缓存中执行读写操作即可，但是当程序执行到分割线出，CPU 必须将执行结果同步到主内存或者从主内存读取最新的变量值，那么 Happen-before 规则就是定义了这些程序块的分割线。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/16668676/32106891-945e0bb2-bb5f-11e7-8d9e-be0b72d75ff2.png" alt="image"></p>
<blockquote>
<p>  如图所示，这里的unlock M和lock M就是划分程序的分割线。在这里，红色区域和绿色区域的代码内部是可以进行重排序的，但是 unlock 和 lock 操作是不能与它们进行重排序的。即第一个图中的红色部分必须要在unlock M指令之前全部执行完，第二个图中的绿色部分必须全部在lock M指令之后执行。并且在第一个图中的unlock M指令处，红色部分的执行结果要全部刷新到主存中，在第二个图中的lock M指令处，绿色部分用到的变量都要从主存中重新读取。</p>
<p>  在程序中加入分割线将其划分成多个程序块，虽然在程序块<strong>内部代码仍然可能被重排序</strong>，但是<strong>保证了程序代码在宏观上是有序的</strong>。并且可以确保<strong>在分割线处，CPU一定会和主内存进行交互</strong>。<strong>Happens-Before原则就是定义了程序中什么样的代码可以作为分割线</strong>。并且无论是哪条Happens-Before原则，它们所产生分割线的作用都是相同的。</p>
</blockquote>
<h2 id="Java-与线程"><a href="#Java-与线程" class="headerlink" title="Java 与线程"></a>Java 与线程</h2><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>(广义)<br>实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p>
<p>Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的。在 Java API 中，一个 Native 方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现(当然也可能是为了执行效率而使用 Native 方法，不过，通常最高效率的手段也就是平台相关的手段)。</p>
<h4 id="1-内核线程实现"><a href="#1-内核线程实现" class="headerlink" title="1.内核线程实现"></a>1.内核线程实现</h4><p>内核线程(Kernel-Level Thread,KLT)就是<strong>直接由操作系统内核</strong>(Kernel，下称内核)<strong>支持的线程</strong>，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>
<p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——<strong>轻量级进程</strong>(Light Weight Process,LWP)，<strong>轻量级进程就是我们通常意义上所讲的线程</strong>，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。</p>
<p><strong>系统调用的代价</strong>相对较高，需要在<strong>用户态(User Mode)和内核态(Kernel Mode)中来回切换</strong>。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间)，因此一个系统支持轻量级进程的数量是有限的。</p>
<p>1:1</p>
<h4 id="2-使用用户线程实现"><a href="#2-使用用户线程实现" class="headerlink" title="2.使用用户线程实现"></a>2.使用用户线程实现</h4><p>从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程(User Thread,UT)，因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。<br><strong>狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知用户线程存在的实现</strong>。</p>
<p>现在使用用户线程的程序越来越少了，Java、Ruby 等语言都曾经使用过用户线程，最终又都放弃使用它。</p>
<h4 id="3-使用用户线程加轻量级进程混合实现"><a href="#3-使用用户线程加轻量级进程混合实现" class="headerlink" title="3.使用用户线程加轻量级进程混合实现"></a>3.使用用户线程加轻量级进程混合实现</h4><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为 N：M 的关系</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>主要调度方式有两种，分别是<strong>协同式线程调度</strong>(Cooperative  Threads-Scheduling)和<strong>抢占式线程调度</strong>(Preemptive  Threads-Scheduling)。</p>
<p>如果使用协同式调度的多线程系统，<strong>线程的执行时间由线程本身来控制</strong>，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。</p>
<ul>
<li>优点：实现简单，不用考虑同步问题。</li>
<li>缺点：不稳定，前面一个线程执行出现问题，那么后面的线程都会受到影响。</li>
</ul>
<p>如果使用抢占式调度的多线程系统，那么每个线程将<strong>由系统来分配执行时间</strong>，线程的切换不由线程本身来决定。</p>
<ul>
<li>优点：相对于协同式调度而言，较为稳定。</li>
<li>缺点：可控性不是很高，因为线程的优先级不是很靠谱；虽然 Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法。</li>
</ul>
<p>目前 Java 使用的线程调度方式就是抢占式调度。JDK 后续版本中有可能会提供协程(Coroutines)方式来进行多任务处理</p>
<p>为什么说线程优先级并不是太靠谱？因为 Java 的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与 Java 线程的优先级一一对应。</p>
<h3 id="线程的状态转换"><a href="#线程的状态转换" class="headerlink" title="线程的状态转换"></a>线程的状态转换</h3><p>图片参考自<a href="http://uule.iteye.com/blog/1100799" target="_blank" rel="noopener">这篇文章</a></p>
<p><img src="https://user-images.githubusercontent.com/16668676/30508637-9ff0e262-9ace-11e7-8a3a-608482184f5d.jpg" alt="thread state"></p>
<ul>
<li>创建 (New)</li>
<li>运行，两种子状态<ul>
<li>Running 正在执行</li>
<li>Ready 等待着 CPU 给它分配执行时间。</li>
</ul>
</li>
<li>等待 (Waiting)<ul>
<li>无限期等待<ul>
<li>没有设置 Timeout 参数的 Object.wait()方法。</li>
<li>没有设置 Timeout 参数的 Thread.join()方法。</li>
<li>LockSupport.park()方法。</li>
</ul>
</li>
<li>有限期等待 (Timed Waiting)<ul>
<li>Thread.sleep()方法。</li>
<li>设置了 Timeout 参数的 Object.wait()方法。</li>
<li>设置了 Timeout 参数的 Thread.join()方法。</li>
<li>LockSupport.parkNanos()方法。</li>
<li>LockSupport.parkUntil()方法。</li>
</ul>
</li>
</ul>
</li>
<li>阻塞 (Blocked)<ul>
<li>「<strong>阻塞状态」与「等待状态」的区别</strong>是：「阻塞状态」在<strong>等待着获取到一个互斥锁(排它锁)</strong>，这个事件将在另外一个线程放弃这个锁的时候发生；而「等待状态」则是在<strong>等待一段时间</strong>，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
</ul>
</li>
<li>结束 (Terminated)</li>
</ul>
<h4 id="相关方法介绍"><a href="#相关方法介绍" class="headerlink" title="相关方法介绍"></a>相关方法介绍</h4><p>调用 sleep、join 时，不会释放所占用的资源，会<strong>进入阻塞状态</strong>；<br>调用 wait 时，会释放所占用的资源，会<strong>进入等待队列</strong>。</p>
<h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep 方法"></a>sleep 方法</h4><p><strong>线程睡眠到期自动苏醒，并返回到<em>可运行状态</em>，不是运行状态</strong> 。sleep() 中指定的时间是线程不会运行的最短时间。因此，<strong>sleep() 方法不能保证该线程睡眠到期后就开始执行</strong>。</p>
<p><strong>sleep()是静态方法</strong>，只能控制当前正在运行的线程。</p>
<h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait 方法"></a>wait 方法</h4><p>因为 wait() 方法会释放锁，所以必须要在 synchronized 块中调用（也就是要先拿到锁，不然就没有锁可以是释放了）。</p>
<h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h4><p>join() 导致线程栈发生了变化，当然这些变化都是瞬时的。</p>
<p>join() 方法有<strong>带超时限制的重载版本</strong>。 例如 <code>t.join(5000);</code>则让线程等待 5000 毫秒，如果超过这个时间，则停止等待，变为可运行状态。</p>
<h4 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield 方法"></a>yield 方法</h4><p>yield() 方法会停止当前线程（使之进入可运行状态），让同等优先权的线程运行。如果没有同等优先权的线程，那么 yield() 方法将不会起作用。 实际中无法保证 yield() 达到让步目的，因为<strong>让步的线程(回到可执行状态)还有可能被线程调度程序再次选中</strong>。</p>
<h2 id="简记："><a href="#简记：" class="headerlink" title="简记："></a>简记：</h2><h3 id="硬件效率与一致性"><a href="#硬件效率与一致性" class="headerlink" title="硬件效率与一致性"></a>硬件效率与一致性</h3><p>因为处理器需要读取和返回数据，所以需要存储器。而存储器的速度与处理器的运算速度相差几个数量级。所以引入了缓存，引入缓存的同时也引入了主存与缓存中的数据一致性问题。</p>
<p>为了充分利用处理器的运算能力，除了引入缓存以外，处理器可能还会对输入的代码进行来乱序执行(不影响结果)。JVM 的即时编译器中也有类似于指令重排的优化。</p>
<h3 id="工作内存与主内存"><a href="#工作内存与主内存" class="headerlink" title="工作内存与主内存"></a>工作内存与主内存</h3><p>每条线程有自己的工作内存，工作内存是线程私有的，如果要交换必须通过主内存。<br>若要把二者与 Java 中的内存区域对应起来，则工作内存像对应虚拟机栈中的部分区域，主内存对应于堆中的对象实例数据部分。</p>
<p>虚拟机可能会让<strong>工作内存</strong>优先存储在寄存器或者高速缓存中，因为<strong>程序运行时主要访问读写的是工作内存</strong> 。</p>
<h3 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h3><p>(lock)read load use assign store write(unlock)</p>
<ul>
<li>一个变量在同一时刻只能被某<strong>一个</strong>线程 lock。但是该线程可以对这个变量 lock 多次。</li>
<li>某些操作必须成对出现，比如 read 与 load 、store 与 write。</li>
<li>对某个变量执行了 assign 操作，必须把它同步回主内存。</li>
</ul>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>保证可见性、禁止指令重排。</p>
<p>无法保证一致性。以多线程修改变量自增为例，当线程 A 读取了该变量(此时变量的值是正确的)但是还未进行 +1 操作，此变量的值被线程 B 执行了 +1 操作(更新后会通知所有线程，但是由于 线程 A 已经读取过该值了但是由还没有进行赋值操作，所以不会得到最新的值)，但是之后线程 A 会对旧值进行自增操作，导致结果错误。</p>
<ul>
<li>注：i++ 由 4 条字节码指令构成。从字节码层面解释：当 getStatic 指令把 race 的值(进行自增操作的变量)读取到操作栈顶时，volatile 保证 race 的值在此时是正确的，但是在执行 iconst_1、add 这些指令时，其他线程可能已经把  race 的值加大了，而在操作栈顶的值就变成了过期的数据，所以 putStatic 指令执行后就可能把较小的 race 值同步回主内存中。</li>
</ul>
<p>在<strong>不符合</strong>以下两条规则的运算场景中，<strong>仍然要通过加锁</strong>来保证原子性。</p>
<ul>
<li>运算结果不依赖变量当前的值 or 只要单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p>普通变量只保证「结果正确」，volitale 变量还保证「程序正确」</p>
<ul>
<li>「程序正确」指的是按照顺序执行</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《深入理解 Java 虚拟机》 </li>
<li><a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">Java 内存访问重排序的研究</a></li>
<li><a href="http://uule.iteye.com/blog/1100799" target="_blank" rel="noopener">线程状态的转换</a></li>
<li><a href="https://segmentfault.com/a/1190000011458941" target="_blank" rel="noopener">从Java多线程可见性谈Happens-Before原则</a></li>
</ul>
<p>若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 线程安全与锁优化]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/11/Java%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1.线程安全"></a>1.线程安全</h2><p>当我们谈线程安全的时候，我们谈些什么？</p>
<p>先看看「线程安全」的定义：</p>
<p>当<strong>多个线程访问一个对象</strong>时，如果<strong>不用考虑这些线程在运行时环境下的调度和交替执行</strong>，也不需要进行<strong>额外</strong>的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p>
<h3 id="1-1-Java-语言中的线程安全"><a href="#1-1-Java-语言中的线程安全" class="headerlink" title="1.1 Java 语言中的线程安全"></a>1.1 Java 语言中的线程安全</h3><p>可将 Java 语言中的各种操作共享的数据分为以下 5 类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<a id="more"></a>
<h4 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h4><p>只要一个不可变对象被正确地构建出来（没有 this 引用逃逸的情况），那么其外部的可见状态永远也不会改变。</p>
<p>final  + 基本数据类型，则该变量为不可变变量<br>final  + 对象，无法保证对象是不可变的</p>
<p>如何保证对象的行为不会对其状态产生任何影响？最简单的就是<strong>将对象中带有状态的变量都声明为 final</strong>。</p>
<p>Java API 中属于不可变的类有以下几种：</p>
<ul>
<li>String</li>
<li>基础数据类型包装类</li>
<li>BigInteger</li>
<li>BigDecimal </li>
</ul>
<p>注意：同为 Number 的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。因为它们都有 set 方法，可以改变对象的状态。</p>
<h4 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2. 绝对线程安全"></a>2. 绝对线程安全</h4><p>绝对线程安全的定义是很严格的。Java API 中标注自己的是线程安全的类，大多数都不是绝对的线程安全。</p>
<p>栗子：Vector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> jvm.ch13;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Vector;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; sIntegerVector = <span class="keyword">new</span> Vector&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                sIntegerVector.add(i);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sIntegerVector.size(); i++) &#123;</div><div class="line">                    sIntegerVector.remove(i);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sIntegerVector.size(); i++) &#123;</div><div class="line">                    System.out.println(sIntegerVector.get(i));</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            removeThread.start();</div><div class="line">            printThread.start();</div><div class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码可能会报 ArrayIndexOutOfBoundException</p>
<p>因为可能出现一个线程恰好在一个错误的时间删除了一个元素，导致 i 元素已经不再可用，另一个线程访问了 i 元素。（比如：<strong>get(i) 进入等待锁期间，remove(i) 刚好执行完了</strong>）。</p>
<p>解决：操作时加上锁，使得复合操作变为原子操作。</p>
<p>原子操作与复合操作简介：</p>
<ul>
<li>原子操作：不可分割的操作，要么成功要么失败。</li>
<li><strong>复合操作：可分割的操作</strong>，可能出现数据失效的问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">    <span class="keyword">synchronized</span> (sIntegerVector) &#123;<span class="comment">//加上锁使之成为原子操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sIntegerVector.size(); i++) &#123;</div><div class="line">            sIntegerVector.remove(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">    <span class="keyword">synchronized</span> (sIntegerVector) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sIntegerVector.size(); i++) &#123;</div><div class="line">            System.out.println(sIntegerVector.get(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为什么是使用 Vector 对象作为锁？因为 Vector  内部是使用自带的锁来实现的。</p>
<h4 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3. 相对线程安全"></a>3. 相对线程安全</h4><p>即通常意义上所讲的线程安全。它需要保证对这个对象单独操作是线程安全的，调用时就不需要做额外的保障措施。</p>
<p><strong>对于一些特定顺序的连续调用，就可能需要在调用端使用<em>额外的同步手段</em>来保证调用的正确性</strong>。</p>
<p>Java API 中大部分线程安全的类都属于这种类型：</p>
<ul>
<li><code>Vector，HashTable，Collections.sychronizedCollection()</code></li>
</ul>
<h4 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4. 线程兼容"></a>4. 线程兼容</h4><p>也就是平常所说的线程不安全类。对象本身并不安全，但是可以通过在调用端正确地使用同步手段来保证对象子啊并发环境中可以安全地使用。</p>
<p>比如：ArrayList、HashKMap</p>
<h4 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5. 线程对立"></a>5. 线程对立</h4><p>在调用端是否使用同步手段都无法再多线程环境下使用。</p>
<ul>
<li>这种排斥多线程代码很少出现。</li>
</ul>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><p>线程安全的实现方法主要有以下几种：互斥同步、非阻塞同步、无同步方案。</p>
<h4 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1. 互斥同步"></a>1. 互斥同步</h4><p>「互斥同步」的意思是通过互斥来实现同步。<br><strong>同步</strong>是指在多个线程并发访问共享数据的时候，保证共享数据在<strong>同一时刻只能有一个（或者一些，使用信号量的时候）线程使用</strong>。<strong>临界区、互斥量、信号量都是主要的互斥实现方式</strong>。</p>
<p>最基本的互斥同步实现方法就是使用 synchronized 关键字。synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter、monitorexit 两条指令。根据虚拟机规范的要求，</p>
<ul>
<li>在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，</li>
</ul>
<ul>
<li>在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，那当前线程就要<strong>阻塞等待</strong>，直到对象锁被另外一个线程释放为止。</li>
</ul>
<p>上述描述中有两点是需要特别注意的。</p>
<ul>
<li>首先，synchronized 同步块对同一条线程来说是<strong>可重入的</strong>，不会出现自己把自己锁死的问题。</li>
<li>其次，同步块在已进入的线程执行完之前，会<strong>阻塞后面其他线程的进入</strong>。</li>
</ul>
<p>Java 的线程是映射到<strong>操作系统的原生线程</strong>之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要<strong>从用户态转换到核心态中</strong>，因此<strong>状态转换需要耗费很多的处理器时间</strong>。</p>
<p>除了 synchronized 之外，我们还可以使用 java.util.concurrent（简称 J.U.C）包中的重入锁（ReentrantLock）来实现同步，在基本用法上，ReentrantLock 与 synchronized 很相似，他们<strong>都具备一样的线程重入特性</strong>，不同点表现在代码写法上</p>
<ul>
<li>一个表现为 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成），</li>
<li>另一个表现为原生语法层面的互斥锁。</li>
</ul>
<p>相比 synchronized,ReentrantLock 增加了一些<strong>高级功能</strong>，主要有以下 3 项：</p>
<ul>
<li><strong>等待可中断</strong>,如果持有锁的线程长时间不释放锁，正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li>公平锁<ul>
<li>多个线程在等待同一个锁时，必须<strong>按照申请锁的时间顺序来依次获得锁</strong>; </li>
<li>非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。</li>
<li>synchronized 中的锁是非公平的，</li>
<li>ReentrantLock <strong>默认情况下也是非公平的</strong>，但可以通过带布尔值的构造函数要求使用公平锁。</li>
</ul>
</li>
<li>锁<strong>可以绑定多个条件</strong><ul>
<li>一个 ReentrantLock 对象<strong>可以同时绑定多个 Condition 对象</strong></li>
<li>而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法<strong>可以实现一个隐含的条件</strong>，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁。</li>
</ul>
</li>
</ul>
<h5 id="ReentrantLock-还是-synchronized？"><a href="#ReentrantLock-还是-synchronized？" class="headerlink" title="ReentrantLock 还是 synchronized？"></a>ReentrantLock 还是 synchronized？</h5><p>关于性能：<strong>Java 1.6 发布之后，synchronized 与 ReentrantLock 的性能基本上是完全持平了</strong>。因此，Java 1.6 或以上，性能因素就不再是选择 ReentrantLock 的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized。</p>
<p>因此在<strong>不需要用到 ReentrantLock 三个特性的情况下，优先考虑使用 synchronized 来进行同步</strong>。</p>
<h4 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2. 非阻塞同步"></a>2. 非阻塞同步</h4><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为<strong>阻塞同步</strong>（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种<strong>悲观的并发策略</strong>，<strong>总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题</strong>。</p>
<p><strong>基于冲突检测</strong>的<strong>乐观并发策略</strong>，通俗地说，就是先进行操作，</p>
<ul>
<li>如果没有其他线程争用共享数据，那操作就成功了；</li>
<li>如果共享数据有争用，产生了冲突，那就再采取其他的<strong>补偿措施</strong>（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的<strong>许多实现都不需要把线程挂起</strong>，因此这种同步操作称为<strong>非阻塞同步</strong>（Non-Blocking Synchronization）。</li>
</ul>
<p>为什么说使用乐观并发策略需要 “硬件指令集的发展” 才能进行呢？</p>
<ul>
<li>因为我们<strong>需要操作和冲突检测这两个步骤具备原子性</strong>，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，<strong>硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成</strong>。</li>
<li>这类指令常用的有：<ul>
<li>测试并设置（Test-and-Set）。</li>
<li>获取并增加（Fetch-and-Increment）。</li>
<li>交换（Swap）。</li>
<li>==比较并交换（Compare-and-Swap，下文称 CAS==）。</li>
<li>加载链接/条件存储（Load-Linked/Store-Conditional，下文称 LL/SC）。</li>
</ul>
</li>
</ul>
<p>Java 1.5 之后，Java 程序中才可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 <code>compareAndSwapInt()</code>和 <code>compareAndSwapLong()</code> 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令。</p>
<p><strong>CAS 指令</strong>需要有 <strong>3 个操作数</strong>，分别是<strong>内存位置</strong>（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、<strong>旧的预期值</strong>（用 A 表示）和<strong>新值</strong>（用 B 表示）。<strong>CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新</strong>，但是<strong>无论是否更新了 V 的值，都会返回 V 的旧值</strong>，上述的处理过程是一个<strong>原子操作</strong>。</p>
<p>Unsafe 类<strong>不是提供给用户程序调用的类</strong>（Unsafe.getUnsafe()的代码中限制了只有启动类加载器（Bootstrap  ClassLoader）加载的 Class 才能访问它），因此，如果不采用反射手段，我们只能通过其他的 Java  API 来间接使用它。</p>
<ul>
<li>如 J.U.C（java.util.concurrent） 包里面的整数原子类，其中的 compareAndSet()和 getAndIncrement()等方法都使用了 Unsafe 类的 CAS 操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>（;;）&#123;</div><div class="line">        <span class="keyword">int</span> current = get()；</div><div class="line">        <span class="keyword">int</span> next = current+<span class="number">1</span>；</div><div class="line">        <span class="keyword">if</span>（compareAndSet（current,next））</div><div class="line">            <span class="keyword">return</span> next；</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CAS 存在的问题：</p>
<ul>
<li><strong>无法涵盖互斥同步的所有使用场景</strong></li>
<li>存在==ABA 问题==，值改了但是自己却不知道。<ul>
<li>怎么解决？<ul>
<li>加入引用计数。</li>
<li>加入修改记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>可重入代码</strong>（Reentrant Code）：这种代码也叫做<strong>纯代码</strong>（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p><strong>可重入代码的一些共同的特征</strong>：</p>
<ul>
<li>不依赖存储在堆上的数据和公用的系统资源、</li>
<li>用到的状态量都<strong>由参数中传入</strong>、</li>
<li>不调用非可重入的方法等。</li>
</ul>
<p><strong>判断代码是否具备可重入性</strong>：如果一个方法，它的<strong>返回结果是可以预测的</strong>，也就是说只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p>
<h4 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3. 无同步方案"></a>3. 无同步方案</h4><p>一个数据的可见范围局限在同一个线程之内， 不会存在多线程竞争问题，也就不需要进行同步了。</p>
<p>如果一个变量要被某个线程独享，Java 中可以通过 <code>java.lang.ThreadLocal</code> 类来实现线程本地存储的功能。每一个线程的 Thread 对象中都有一个 ThreadLocalMap 对象，这个对象存储了一组以 <code>ThreadLocal.threadLocalHashCode</code> 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值，使用这个值就可以在线程 K-V 值对中找回对应的本地线程变量。</p>
<h2 id="2-Java-中锁的分类与优化"><a href="#2-Java-中锁的分类与优化" class="headerlink" title="2. Java 中锁的分类与优化"></a>2. Java 中锁的分类与优化</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>又称为「递归锁」，指的是当同一个线程的外层方法获取锁时，进入内层方法会自动获取锁。</p>
<p>可重入锁的一个好处就是可以在一定程度上避免死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Thread.sleep(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="独享-占-锁-共享锁"><a href="#独享-占-锁-共享锁" class="headerlink" title="独享(占)锁/共享锁"></a>独享(占)锁/共享锁</h3><p>根据能够同时被多少线程持有来区分。</p>
<ul>
<li>独享锁就是指该锁一次仅能被一个线程所持有。</li>
<li>共享锁可以同时被多个线程持有。</li>
</ul>
<h3 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h3><p>上面讲的<strong>独享锁/共享锁</strong>就是一种<strong>广义的说法</strong>，<strong>互斥锁/读写锁</strong>就是<strong>具体的实现</strong>。</p>
<ul>
<li>互斥锁：在 Java 中的具体就是 ReentrantLock</li>
<li>读写锁：在 Java 中的具体实现就是 ReadWriteLock。其读锁是共享锁，其写锁是独享锁。<ul>
<li>读锁的共享可保证高效并发。</li>
<li>读写、写读、写写的过程是<strong>互斥的</strong></li>
</ul>
</li>
</ul>
<p>独享锁与共享锁也是使用 AQS 来实现的。通过实现不同的方法来实现独享或者共享。</p>
<h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h3><p>并不是指具体类型的锁，而是指<strong>看待并发同步的态度</strong>。</p>
<p><strong>悲观锁</strong>采用一种悲观的并发策略<strong>，</strong>总是<strong>认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题</strong>。<br>所谓<strong>乐观锁</strong>就是，每次不加锁而是<strong>假设没有冲突而去完成某项操作</strong>，如果因为<strong>冲突失败就重试，直到成功为止</strong>。乐观锁<strong>不能解决脏读的问题</strong>。</p>
<h4 id="二者之间如何选择选择？"><a href="#二者之间如何选择选择？" class="headerlink" title="二者之间如何选择选择？"></a>二者之间如何选择选择？</h4><p>首先要弄清楚，<strong>事实是悲观的还是乐观的</strong>？</p>
<p>假如你的资源竞争很激烈，并且无法共享的话，乐观锁不过是让大量请求的希望落空罢了。——如果事实是悲观的，但是采用了乐观锁，那就只会导致大量请求落空罢了。</p>
<p>假如你的资源没什么竞争（这个和并发高低没必然的关联，业务的影响更大），那悲观锁意味着不必要地加锁。如果原本是可共享的资源（比如资源支持多个只读方），那么悲观锁意味着失去原本的可以使用的时间。——如果事实是乐观的，但是使用了悲观锁，那么就损失一些本来可以使用的时间。</p>
<p>再详细点可以从以下几个方面来判断：</p>
<ol>
<li><strong>响应速度</strong>：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。</li>
<li><strong>冲突频率</strong>：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li>
<li><strong>重试代价</strong>：如果重试代价大，建议采用悲观锁。</li>
</ol>
<p>以上内容参考自<a href="https://segmentfault.com/q/1010000009251675" target="_blank" rel="noopener">高并发下悲观锁与乐观锁的选择问题</a></p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种<strong>锁的设计</strong>，并不是具体的一种锁。</p>
<p>我们以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code>中的分段锁称为 Segment，它即类似于 HashMap（Java7 与 Java8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，<strong>数组中的每个元素又是一个链表；同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock)</strong>。<br>当需要 put 元素的时候，并不是对整个 hashmap 进行加锁，而是<strong>先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁</strong>，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p>
<p>但是，在统计 size 的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计<strong>目的是细化锁的粒度</strong>，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>
<h3 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h3><p>这三种锁是指<strong>锁的状态</strong>，并且是针对<code>Synchronized</code> 的。在 Java1.5 通过引入<strong>锁升级的机制</strong>来实现高效的<code>Synchronized</code>。这三种锁的状态是<strong>通过对象监视器在对象头中的字段来表明的</strong>。</p>
<p><strong>偏向锁</strong>：当一段同步代码总是被一个线程访问的时候， 那么该线程就会自动获取锁，降低获取锁的代价。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是<strong>在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了</strong>。偏向锁的“偏”，意思是这个锁会<strong>偏向于<em>第一个</em>获得它的线程</strong>，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p><strong>轻量级锁</strong>：当锁是偏向锁时（因为经常被一个线程访问），当另外一个线程需要访问相应的同步代码段时，偏向锁会升级为轻量级锁，其他线程会通过<strong>自旋的方式</strong>尝试去获取锁，轻量级锁并不是用来代替重量级锁的，它的本意是<strong>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</p>
<p><strong>重量级锁</strong>：自旋达到一定次数之后，就会膨胀为重量级锁。重量级锁会使其他申请线程进入阻塞状态。</p>
<p>错误观点：<del>锁<strong>可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁</del>。具体可以参考下<a href="http://www.jianshu.com/p/9932047a89be" target="_blank" rel="noopener">这篇文章</a></p>
<p>锁的升级：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/30313216-2beddbd8-97cf-11e7-8e50-d07dccb4ec21.png" alt="lock update"></p>
<h4 id="偏向锁的实现"><a href="#偏向锁的实现" class="headerlink" title="偏向锁的实现"></a>偏向锁的实现</h4><p>假设当前虚拟机启用了偏向锁，那么，当锁对象<strong>第一次被线程获取的时候</strong>，虚拟机将会把对象头中的标志位设为“01”，即<strong>偏向模式</strong>。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，</p>
<ul>
<li>如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking、Unlocking 及对 Mark Word 的 Update 等）。</li>
<li>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</li>
<li>根据锁对象目前是否处于被锁定的状态，<strong>撤销偏向</strong>（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，</li>
<li>后续的同步操作就如上面介绍的轻量级锁那样执行。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/30313215-2bede358-97cf-11e7-84bd-2eeff1472644.png" alt="lock"></p>
<p>图片参考自<a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">聊聊并发（二）——Java SE1.6中的Synchronized</a></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="轻量级锁的加锁过程"><a href="#轻量级锁的加锁过程" class="headerlink" title="轻量级锁的加锁过程"></a>轻量级锁的加锁过程</h5><p>在代码进入同步块的时候，</p>
<ul>
<li>如果此同步对象<strong>没有被锁定</strong>（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为<strong>锁记录</strong>（Lock  Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），这时候线程堆栈与对象头的状态如图 13-3 所示。</li>
<li>然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。<ul>
<li>如果这个<strong>更新动作成功了</strong>，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后 2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示。</li>
<li>如果这个<strong>更新操作失败了</strong>，虚拟机首先会检查对象的 <strong>Mark Word 是否指向当前线程的栈帧</strong>，<ul>
<li>如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，</li>
</ul>
</li>
<li>否则说明这个锁对象已经被其他线程抢占了。<ul>
<li>如果有<strong>两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁</strong>，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/28906024-2978ad6c-7847-11e7-88d2-30d22e7babb0.png" alt="cas"></p>
<p><img src="https://user-images.githubusercontent.com/16668676/30313218-2c1d4698-97cf-11e7-9765-6d1ffdc9b915.png" alt="light weight"></p>
<p>图片参考自<a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">聊聊并发（二）——Java SE1.6中的Synchronized</a></p>
<h5 id="轻量级锁的解锁过程"><a href="#轻量级锁的解锁过程" class="headerlink" title="轻量级锁的解锁过程"></a>轻量级锁的解锁过程</h5><p><strong>解锁过程也是通过 CAS 操作来进行的</strong></p>
<ul>
<li>如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作<strong>把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来</strong>，<ul>
<li>如果替换成功，整个同步过程就完成了。</li>
<li>如果替换失败，说明有其他线程<strong>尝试过获取该锁</strong>，那就要在释放锁的同时，唤醒被挂起的线程。（如何唤醒？ <code>notify()</code> ）</li>
</ul>
</li>
</ul>
<p>轻量级锁能提升程序同步性能的<strong>依据</strong>是“<strong>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</strong>”，这是一个经验数据。</p>
<ul>
<li>如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，</li>
<li>如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在==有竞争的情况下，轻量级锁会比传统的重量级锁更慢==。</li>
</ul>
<h4 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU</td>
<td>追求响应时间,锁占用时间很短</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗 CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量,锁占用时间较长</td>
</tr>
</tbody>
</table>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在 Java 中，自旋锁是指<strong>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</strong>，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。<br>典型的自旋锁实现的例子，可以参考<a href="http://ifeve.com/java_lock_see1/" target="_blank" rel="noopener">自旋锁的实现</a></p>
<p>如果线程<strong>竞争不激烈</strong>，并且保持锁的时间段。适合使用自旋锁。这样可以避免线程挂起和恢复(挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力)，从而降低性能开销。</p>
<ul>
<li>自旋次数的默认值是 10 次，用户可以使用参数<code>-XX：PreBlockSpin</code> 来更改。</li>
</ul>
<p>在 Java 1.6 中引入了<strong>自适应的自旋锁</strong>。自适应意味着<strong>自旋的时间不再固定了</strong>，而是<strong>由前一次在同一个锁上的自旋时间及锁的拥有者的状态</strong>来决定。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p><strong>锁消除</strong>是指虚拟机<strong>即时编译器在运行时</strong>，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p>
<p>锁消除的<strong>主要判定依据</strong>来源于<strong>逃逸分析的数据支持</strong>（第 11 章已经讲解过逃逸分析技术），如果判断在一段代码中，<strong>堆上的所有数据都不会逃逸出去</strong>从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String concatString（String s1，String s2，String s3）&#123;</div><div class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer()；</div><div class="line">    sb.append（s1）;</div><div class="line">    sb.append（s2）;</div><div class="line">    sb.append（s3）;</div><div class="line">    <span class="keyword">return</span> sb.toString()；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个 StringBuffer.append()方法中都有一个同步块，锁就是 sb 对象。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString()方法内部。sb 的所有引用永远不会“逃逸”到 concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在<strong>即时编译之后，这段代码就会忽略掉所有的同步而直接执行</strong>了。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为<strong>使得需要同步的操作数量尽可能变小</strong>。</p>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，<strong>频繁地进行互斥同步操作也会导致不必要的性能损耗</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String concatString（String s1，String s2，String s3）&#123;</div><div class="line">    StringBuffer sb=<span class="keyword">new</span> StringBuffer()；</div><div class="line">    sb.append（s1）；</div><div class="line">    sb.append（s2）；</div><div class="line">    sb.append（s3）；</div><div class="line">    <span class="keyword">return</span> sb.toString()；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面连续的 append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会<strong>把加锁同步的范围扩展（粗化）到整个操作序列的外部</strong>，以上述代码为例，就是扩展到第一个 append()操作之前直至最后一个 append()操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.importnew.com/20472.html" target="_blank" rel="noopener">乐观锁的一种实现方式——CAS</a></li>
<li><a href="http://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">Java 中的锁分类</a></li>
<li><a href="http://blog.csdn.net/vernonzheng/article/details/8275624" target="_blank" rel="noopener">Java多线程（七）之同步器基础：AQS框架深入分析</a></li>
<li><a href="https://segmentfault.com/q/1010000009251675" target="_blank" rel="noopener">高并发下悲观锁与乐观锁的选择问题</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">聊聊并发（二）——Java SE1.6中的Synchronized</a></li>
<li>《深入理解 Java 虚拟机》</li>
</ul>
<p>如果本文中存在不正确的说法，请提出，共同讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 并发 </category>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 集合框架之 HashMap 工作原理]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/10/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8B%20HashMap%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>概括的说，<code>HashMap</code> 是一个<strong>关联数组、哈希表</strong>，它是<strong>线程不安全</strong>的，允许<strong>key 为 null</strong>,<strong>value 为 null</strong>。遍历时<strong>无序</strong>。<br>其底层数据结构是<strong>数组</strong>称之为<strong>哈希桶</strong>，每个<strong>桶里面放的是链表</strong>，链表中的<strong>每个节点</strong>，就是哈希表中的<strong>每个元素</strong>。<br>在 JDK8 中，当链表长度达到 8，会转化成红黑树，以提升它的查询、插入效率，它实现了<code>Map&lt;K,V&gt;, Cloneable, Serializable</code>接口。</p>
<p>因其底层哈希桶的数据结构是数组，所以也会涉及到<strong>扩容</strong>的问题。</p>
<p>当<code>HashMap</code>的容量达到<code>threshold</code>域值时，就会触发扩容。扩容前后，哈希桶的<strong>长度一定会是 2 的次方</strong>。<br>这样在根据 key 的 hash 值寻找对应的哈希桶时，可以<strong>用位运算替代取余操作</strong>，<strong>更加高效</strong>。</p>
<p>而 key 的 hash 值，并不仅仅只是 key 对象的<code>hashCode()</code>方法的返回值，还会经过<strong>扰动函数</strong>的扰动，以使 hash 值更加均衡。<br>因为<code>hashCode()</code>是<code>int</code>类型，取值范围是 40 多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。 </p>
<a id="more"></a>
<p>但就算原本的<code>hashCode()</code>取得很好，每个 key 的<code>hashCode()</code>不同，但是由于<code>HashMap</code>的哈希桶的长度远比 hash 取值范围小，默认是 16，所以当对 hash 值以桶的长度取余，以找到存放该 key 的桶的下标时，由于取余是通过与操作完成的，会忽略 hash 值的高位。因此只有<code>hashCode()</code>的低位参加运算，发生不同的 hash 值，但是得到的 index 相同的情况的几率会大大增加，这种情况称之为<strong>hash 碰撞。</strong> 即，碰撞率会增大。</p>
<p><strong>扰动函数</strong>就是为了解决 hash 碰撞的。它会综合 hash 值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少 hash 碰撞的概率。（在 JDK8 之前，扰动函数会扰动四次，JDK8 简化了这个操作）</p>
<p>执行扩容操作时，会 new 一个新的<code>Node</code>数组作为哈希桶，然后将原哈希表中的所有数据(<code>Node</code>节点)移动到新的哈希桶中，相当于对原哈希表中所有的数据重新做了一个 put 操作。所以性能消耗很大，<strong>可想而知，在哈希表的容量越大时，性能消耗越明显。</strong></p>
<p>扩容时，如果发生过哈希碰撞，节点数小于 8 个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。<br>因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位= low 位+原哈希桶容量<br>如果追加节点后，链表数量》=8，则转化为红黑树</p>
<p>由迭代器的实现可以看出，遍历 HashMap 时，顺序是按照哈希桶从低到高，链表从前往后，依次遍历的。属于<strong>无序</strong>集合。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="两个重要的参数"><a href="#两个重要的参数" class="headerlink" title="两个重要的参数"></a>两个重要的参数</h3><blockquote>
<p>  An instance of <code>HashMap</code> has two parameters that affect its performance: <em>initial capacity</em> and <em>load factor</em>. <strong>The <em>capacity</em> is the number of buckets in the hash table</strong>, and the initial capacity is simply the capacity at the time the hash table is created. The <em>load factor</em> is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is <em>rehashed</em> (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.</p>
</blockquote>
<ul>
<li>capacity：容量。也就是哈希桶数组的长度。默认初始化容量为 16。</li>
<li>loadFactor：加载因子。  扩容的阈值 <code>threshold = capacity * loadFactor</code><ul>
<li>加载因子默认为 0.75，这是时间和空间上的折衷点。大于 0.75，能提高空间利用率，但是会导致查找效率降低。</li>
</ul>
</li>
</ul>
<p>当 hashMap 中元素的总数大于 capacity * loadFactor  时，就会发生扩容（将 buckets 的数目调整为当前的两倍）。</p>
<p>capacity 被控制为 2 的 n 次方（一定是合数），这有点不合常规。常规的做法是将桶数组的长度设置为素数，因为相对而言使用素数发生冲突的概率要比使用合数要小一些。HashTable 默认初始化容量就为 11（素数，Hashtable 扩容后不能保证还是素数）。之所以这样设计是取模和扩容时进行优化（使用位运算<strong>提高效率</strong>），同时也是为了<strong>减少冲突</strong>，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<h3 id="put-函数的实现"><a href="#put-函数的实现" class="headerlink" title="put 函数的实现"></a>put 函数的实现</h3><p>1.8 对 HashMap 的底层实现进行了修改（当相同 hash 值的元素大于 8 个时，会将链表转换为 红黑树，以提高查找效率），所以 put 函数看起来相对复杂了点，通过以下流程图能帮助理解。</p>
<p>图片出自<a href="https://tech.meituan.com/img/java-hashmap/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" target="_blank" rel="noopener">这篇文章</a>。</p>
<p><img width="858" alt="hashmap put" src="https://user-images.githubusercontent.com/16668676/30247192-dbfc4bf8-9640-11e7-9fd6-0aca25db077c.png"></p>
<p>注意：对于 resize 方法的是否需要执行有两次判断：</p>
<p>第一次判断桶数组是否为空，如果为空，则通过 resize 方法执行初始化操作。<br>第二次判断是在插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p>
<p>put 方法具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定的值与该映射中指定的键关联起来。</div><div class="line"> * 如果该 key 对应的 value 存在，则替换旧值</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt;[] tab; java.util.HashMap.Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//桶数组为空或者长度为 0（说明还未初始化）</span></div><div class="line">        n = (tab = resize()).length;<span class="comment">//调用扩容方法进行初始化，并获取初始化后桶数组的长度</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//根据 hash 值与 n-1 进行「模运算」获取插入数组的索引的 i。</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//创建新结点</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//发生碰撞</span></div><div class="line">        java.util.HashMap.Node&lt;K,V&gt; e; K k;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;        <span class="comment">//key 值相同，替换旧值</span></div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> java.util.HashMap.TreeNode)<span class="comment">//该链为树</span></div><div class="line">            e = ((java.util.HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;<span class="comment">//该链为链表</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);<span class="comment">//转换为红黑树</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">        <span class="comment">//如果本身存在相同的 key，则将旧值返回</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;<span class="comment">//结构化修改次数加 1</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//如果当前数量超过阈值，则进行扩容</span></div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);<span class="comment">//默认为空实现</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//原先 key 不存在，也就是说没有旧值，直接返回 null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get-函数的实现"><a href="#get-函数的实现" class="headerlink" title="get 函数的实现"></a>get 函数的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取给定 key 的 hash 值，获取相应位置 value</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> java.util.HashMap.<span class="function">Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt;[] tab; java.util.HashMap.Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; </div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//先检查对应位置的「头结点」，如果匹配直接返回对应的值</span></div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> java.util.HashMap.TreeNode)<span class="comment">//该链是红黑树，根据 hash 和 key 到 树中查找相应的 value,直接返回</span></div><div class="line">                <span class="keyword">return</span> ((java.util.HashMap.TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="comment">//该链是链表，到链表中遍历查找</span></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 get 方法的大致逻辑是这样的：</p>
<ul>
<li>先计算出当前 key 的 hash 值，然后通过 getNode 方法去获取当前对应的结点</li>
<li>如果对应的节点为 null，直接返回 null，</li>
<li>否则返回节点中的  value。</li>
</ul>
<p>getNode 方法的实现思路是这样的：</p>
<ul>
<li>通过 hash 跟 当前容量进行 <strong>与运算</strong> 得到数组下标</li>
<li>使用指定下标去获取对应的节点（从头结点开始）<ul>
<li>如果首个元素就命中，直接返回结点。</li>
<li>存在冲突：<br>如果该 hash 值对应的是一棵<strong>红黑树</strong>，则到红黑树中去获取相应的结点。<br>如果该 hash 值对应的是一个<strong>链表</strong>，则遍历该链表，直到取得相应的结点或者到达链尾。</li>
</ul>
</li>
</ul>
<h3 id="hash-函数的实现"><a href="#hash-函数的实现" class="headerlink" title="hash 函数的实现"></a>hash 函数的实现</h3><p>在 HashMap 中，哈希桶数组 table 的长度 length 大小必须为 2 的 n 次方(一定是合数)，这是一种<strong>非常规的设计</strong>，<strong>常规的设计是把桶的大小设计为素数</strong>。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">这篇文章</a>，Hashtable 初始化桶大小为 11，就是桶大小设计为素数的应用（Hashtable 扩容后不能保证还是素数）。HashMap 采用这种非常规设计，<strong>主要是为了在取模和扩容时做优化，同时为了减少冲突</strong>，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<p>通过 <code>h &amp; (table.length -1)</code> 来得到该对象的保存位，而 <code>HashMap</code> 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。当 length 总是 2 的 n 次方时，h&amp; (length-1) 运算等价于对 length 取模，也就是 h%length，但是&amp;比%具有更高的效率。</p>
<ul>
<li><code>h &amp; (length - 1) 《==》 h % length</code></li>
</ul>
<p>在 JDK1.8 的实现中，优化了高位运算的算法，通过 <code>hashCode()</code>的高 16 位（其实是完整的） 异或 低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。</p>
<p>hash 是 int 类型的（32 位），原 hashcode 异或 右移 16 位后的 hashcode，高低位兼顾</p>
<ul>
<li>右移 16 位，那么高 16 位均为 0，所以高十六位的取值由 key 的 hashCode 的高十六位确定，</li>
<li>低 16 位的值由 hashcode 的低十六位与高十六位</li>
</ul>
<p>在 get 和 put 的过程中，计算下标时，先对 hashCode 进行 hash 操作，然后再通过 hash 值进一步计算下标，如下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6957712/293b52fc-d932-11e4-854d-cb47be67949a.png" alt="hash"></p>
<p>在对 hashCode()计算 hash 时具体实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">  	<span class="comment">//因为 h &gt;&gt;&gt; 16 右移了 16 位(高 16 位都为 0)，因此结果的高 16 位仍然是 key.hashCode() 的高 16 位</span></div><div class="line">  	<span class="comment">//而低 16 位取决于 key.hashCode() 的高十六位和低十六位进行异或的结果</span></div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到这个函数大概的作用就是：<strong>高 16bit 不变，低 16bit 和高 16bit 做了一个异或</strong>。这样做的目的就在于你求余的时候<strong>包含了高 16 位和第 16 位的特性</strong> 也就是说你所计算出来的 hash 值包含从而使得你的 hash 值更加「随机」以降低碰撞的概率</p>
<h4 id="计算下标"><a href="#计算下标" class="headerlink" title="计算下标"></a>计算下标</h4><p>存储结点时，计算得到的 hash 值可能远大于哈希桶数组的长度，为了避免数组越界，我们需要进行<strong>取模运算</strong>。计算下标的时候，是这样实现的(使用<code>&amp;</code>位操作，而非<code>%</code>求余)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(n - <span class="number">1</span>) &amp; hash</div></pre></td></tr></table></figure>
<p>上面的计算实际上等价于<code>hash % n</code>，但是前者的效率比较高。前面我们提到过，HashMap 的数组长度一定是 2 的 ？次方。也就是说 (n - 1) 可以化为 0…0011…1，这样跟 hash 进行与运算，就相当于取模运算。</p>
<h4 id="Java-8-所做的优化"><a href="#Java-8-所做的优化" class="headerlink" title="Java 8 所做的优化"></a>Java 8 所做的优化</h4><p>hash 函数设计得再好，也无法避免冲突的。如何解决冲突也是一门学问。</p>
<p>在 Java 8 之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行 get 时，两步的时间复杂度是 O(1)+O(n)。因此，当碰撞很厉害的时候 n 很大，O(n)的速度显然是影响速度的。</p>
<p>因此在 Java 8 中，当链表长度大于 8 时，就利用红黑树替换链表，这样复杂度就变成了 O(1)+O(logn)了，这样在 n 很大的时候，能够比较理想的解决这个问题，在<a href="http://www.importnew.com/14417.html" target="_blank" rel="noopener">Java 8：HashMap 的性能提升</a>一文中有性能测试的结果。</p>
<h3 id="resize-（扩容）实现"><a href="#resize-（扩容）实现" class="headerlink" title="resize （扩容）实现"></a>resize （扩容）实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 初始化或者扩容一倍</div><div class="line"> * */</div><div class="line"><span class="keyword">final</span> java.util.HashMap.Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//旧长度</span></div><div class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧阈值</span></div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="comment">//这一段代码用于确定新容量,并根据新容量重新确定阈值</span></div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//旧容量大于最大允许容量，将阈值赋值为最大允许容量</span></div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//直接返回旧表</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="comment">//扩容后小于允许的最大容量，且大于默认初始容量（16），则修改 threshold</span></div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// threshold 增大一倍</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 原有阈值大于 0，但是原容量小于 0</span></div><div class="line">        newCap = oldThr;<span class="comment">//将新容量赋值为就旧阈值</span></div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// 原阈值、原容量均为 0 ，使用默认的初始化参数来创建 map</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//默认的初始化容量 （16）</span></div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//新的阈值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新阈值为 0</span></div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;<span class="comment">//重新计算</span></div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE); <span class="comment">//如果阈值大于最大容量，修改阈值为 int 的最大值(2^31-1)，这样以后就不会扩容了</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt;[] newTab = (java.util.HashMap.Node&lt;K,V&gt;[])<span class="keyword">new</span> java.util.HashMap.Node[newCap];<span class="comment">//按照新容量 创建数组</span></div><div class="line">    table = newTab;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原有的 map 上的元素不为空，将原有 map 上面的数据复制到新的 map 上面</span></div><div class="line">        <span class="comment">//遍历旧元素</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            java.util.HashMap.Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;<span class="comment">//释放，防止内存泄漏</span></div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//该桶中只有一个元素，获取的 hash 值并与（新容量 -1）进行 与运算</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> java.util.HashMap.TreeNode)<span class="comment">//如果该元素是一个树节点（说明该桶对应有一棵红黑树），将树存储到新数组上</span></div><div class="line">                    ((java.util.HashMap.TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 保持顺序</span></div><div class="line">                    <span class="comment">//因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位 = low 位+原哈希桶容量</span></div><div class="line">                    <span class="comment">//低位链表的头结点、尾节点</span></div><div class="line">                    java.util.HashMap.Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    <span class="comment">//高位链表的头结点、尾节点</span></div><div class="line">                    java.util.HashMap.Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    <span class="comment">//临时结点</span></div><div class="line">                    java.util.HashMap.Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//根据 hash 值与 oldCap 的运算结果，将链表中集结的元素分开，可认为结果是随机的</span></div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//在原索引处存放 「低位链表」</span></div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//在原索引加上原容量处，存放「高位链表」</span></div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置</strong>。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="hashMap 1.8 哈希算法例图 1"></p>
<p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="hashMap 1.8 哈希算法例图 2"></p>
<p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，<strong>是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap</strong>，可以看看下图为 16 扩充为 32 的 resize 示意图：</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="jdk1.8 hashMap 扩容例图"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。</p>
<h3 id="树化与链表化"><a href="#树化与链表化" class="headerlink" title="树化与链表化"></a>树化与链表化</h3><p>当冲突链表长度达到 8 的时候，会调用 <code>treeifyBin</code> 尝试将链表转换为树。</p>
<p>如果当前数组的长度小于 64 的话，只会触发扩容，而不会将链表转换为红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<span class="comment">//在「树化」之前先判断，当前的容量</span></div><div class="line">        resize();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</div><div class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</div><div class="line">                hd = p;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                p.prev = tl;</div><div class="line">                tl.next = p;</div><div class="line">            &#125;</div><div class="line">            tl = p;</div><div class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</div><div class="line">            hd.treeify(tab);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当移除元素或者是扩容的时候，如果树的大小&lt;=6，会调用 HashMap.TreeNode#untreeify 方法将红黑树转换为链表。</p>
<h4 id="为什么要进行「树化」呢？"><a href="#为什么要进行「树化」呢？" class="headerlink" title="为什么要进行「树化」呢？"></a>为什么要进行「树化」呢？</h4><p>一方面是为了保证性能，如果同一个桶上面的冲突都通过链表连接，链表的查询是线性的，同一个桶上冲突较多的时候，会严重影响存取的性能。</p>
<p>另一个原因其实也是由性能问题引发的哈希碰撞拒绝服务攻击，因为构造哈希冲突的数据并不是困难的事情，恶意代码可以构造这样的数据大量与服务端交互，导致服务端CPU 大量占用。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>此部分内容参考自<a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">HashMap 的工作原理</a></p>
<p><strong>1. 什么时候会使用 HashMap？他有什么特点？</strong><br>是基于 Map 接口的实现，存储键值对时，它可以接收 null 的键值，是非同步的，HashMap 存储着 Entry(hash, key, value, next)对象。</p>
<p><strong>2. 你知道 HashMap 的工作原理吗？</strong><br>通过 hash 的方法，通过 put 和 get 存储和获取对象。存储对象时，我们将 K/V 传给 put 方法时，它调用 hashCode 计算 hash 从而得到 bucket 位置，进一步存储，HashMap 会根据当前 bucket 的占用情况自动调整容量(超过 Load Facotr 则 resize 为原来的 2 倍)。获取对象时，我们将 K 传给 get，它调用 hashCode 计算 hash 从而得到 bucket 位置，并进一步调用 equals()方法确定键值对。如果发生碰撞的时候，Hashmap 通过链表将产生碰撞冲突的元素组织起来，在 Java 8 中，如果一个 bucket 中碰撞冲突的元素超过某个限制(默认是 8)，则使用红黑树来替换链表，从而提高速度。</p>
<p><strong>3. 你知道 get 和 put 的原理吗？equals()和 hashCode()的都有什么作用？</strong><br>通过对 key 的 hashCode()进行 hashing，并计算下标( n-1 &amp; hash)，从而获得 buckets 的位置。如果产生碰撞，则利用 key.equals()方法去链表或树中去查找对应的节点</p>
<p><strong>4. 你知道 hash 的实现吗？为什么要这样实现？</strong><br>在 Java 1.8 的实现中，是通过 hashCode()的高 16 位异或低 16 位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在 bucket 的 n 比较小的时候，也能保证考虑到高低 bit 都参与到 hash 的计算中，同时不会有太大的开销。</p>
<p><strong>5. 如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认 0.75)，则会重新 resize 一个原来长度两倍的 HashMap，并且重新调用 hash 方法。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://blog.csdn.net/zxt0601/article/details/77413921" target="_blank" rel="noopener">面试必备：HashMap 源码解析（JDK8）</a></li>
<li><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">HashMap 的 hash 函数原理</a></li>
<li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">重新认识 HashMap</a></li>
<li><a href="http://yikun.github.io/2015/04/01/Java-HashMap 工作原理及实现/" target="_blank" rel="noopener">HashMap 的工作原理</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> java集合框架 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM 垃圾收集器与内存分配策略]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/08/JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h2 id="确定回收的对象"><a href="#确定回收的对象" class="headerlink" title="确定回收的对象"></a>确定回收的对象</h2><p><strong>「死去」的对象</strong>即不可能再被任何途径使用的对象。</p>
<p>几乎所有对象的实例都存在堆中。（部分 String 对象存在于字符串常量池中，JDK1.7 以前，字符串常量池存放在方法区中）。</p>
<p>进行回收的第一步就是确定哪些对象还活着，哪些已经死亡。</p>
<a id="more"></a>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，</p>
<ul>
<li>每当有一个地方引用它时，计数器值就加 1；</li>
<li>当引用失效时，计数器值就减 1；</li>
<li>任何时刻计数器为 0 的对象就是不可能再被使用的。</li>
</ul>
<p><strong>缺点</strong>：很难解决对象之间<strong>相互循环引用的问题</strong>。因此 Java 虚拟机中没有采用引用计数算法来管理内存。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>主流的商用程序语言的主流实现中，都是通过<strong>可达性分析</strong>来判断对象是否存活的。</p>
<p>算法的基本思路：</p>
<ul>
<li>通过一系列的称为 GC Root 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为『引用链』（Reference Chain）</li>
<li><p><strong>当一个对象到 GC Root 没有任何引用链相连时，则证明此对象是不可用的</strong>。</p>
<p>GC Root 对象的定义是什么？  <a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;cp=37_2_3" target="_blank" rel="noopener">Help - Eclipse Platform</a> 上给的定义是这样的：</p>
</li>
</ul>
<blockquote>
<p>  A garbage collection root is an object that is accessible from outside the heap</p>
</blockquote>
<p>也就是说 <strong>GC Roots 是可以从堆外访问的对象</strong>。由 Java 运行时数据区可以知道，堆外的空间有虚拟机栈、本地方法栈以及方法区。而java 1.8 将整个方法区被移到一个叫元空间的地方（使用本地内存存储）</p>
<p>所以GC Roots 对象包含以下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象，也就是局部变量引用的对象。</li>
<li>本地方法栈中 JNI 引用的对象，包括<ul>
<li>本地方法栈中的局部变量或者参数</li>
<li>JNI全局引用</li>
</ul>
</li>
<li>方法区中<strong>类静态属性引用的对象</strong>。<strong>由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载</strong>。它们可以通过静态属性的方式持有对象的引用。注意，一般情况下由自定义的类加载器加载的类不能成为GC Roots</li>
<li>方法区中<strong>常量引用的对象</strong></li>
</ul>
<h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>JDK 1.2 之后对，Java 对引用的概念进行了扩充（不再是仅有被引用或者没有被引用两种）：</p>
<p>共有四种：</p>
<ul>
<li><strong>强引用</strong><ul>
<li>只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
</ul>
</li>
<li><strong>软引用</strong> SoftReference <ul>
<li>内存不够时被回收<ul>
<li>在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
</ul>
</li>
</ul>
</li>
<li><strong>弱引用</strong> WeakReference<ul>
<li>只要一执行 GC 就会被回收</li>
</ul>
</li>
<li><strong>虚引用</strong>，也称为<strong>幽灵引用、幻影引用</strong>  PhantomReference<ul>
<li>『形同虚设』。一个对象被持有虚引用对其生命周期毫无影响</li>
<li>虚引用的作用仅仅是在该对象被回收时，收到一个系统通知而已</li>
</ul>
</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>一个对象的 finalize 方法最多只会被系统调用一次。</p>
<p>即使在可达性分析算法中不可达的对象，也并非是「非死不可」的，<strong>要真正宣告一个对象死亡，至少要经历两次标记过程</strong>：</p>
<ul>
<li>如果对象在进行<strong>可达性分析</strong>后发现没有与 GCRoots 相连接的引用链，那它将会被<strong>第一次标记并且进行一次筛选</strong>，<ul>
<li><strong>筛选的条件</strong>是此对象<strong>是否有必要执行 finalize 方法</strong>。当对象<strong>没有覆盖 finalize 方法</strong>，或者 <strong>finalize 方法已经被虚拟机调用过</strong>，虚拟机将这两种情况都视为「<strong>没有必要执行</strong>」。</li>
<li>如果这个对象被判定为<strong>有必要执行 finalize 方法</strong>，那么这个对象将会放置在一个叫做 <strong>F-Queue 的队列</strong>之中，并在稍后由一个由虚拟机自动建立的、低优先级的 <strong>Finalizer 线程</strong>去执行它。</li>
</ul>
</li>
</ul>
<p>这里所谓的「<strong>执行</strong>」是指虚拟机 <strong>会触发</strong>这个方法，但并<strong>不承诺会等待它运行结束</strong>，为什么要这么做？</p>
<ul>
<li>因为如果承诺得到 finalize 方法执行结束，那么当一个对象在 finalize 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。</li>
</ul>
<p>finalize 方法是<strong>对象逃脱死亡命运的==最后一次机会==</strong>，稍后 GC 将对 F-Queue 中的对象进行<strong>第二次小规模的标记</strong>，</p>
<ul>
<li>如果对象要在 finalize 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在<strong>第二次标记时它将被移除出「即将回收」的集合</strong>；</li>
<li>如果对象这时候还没有逃脱，那基本上它就真的被回收了。</li>
</ul>
<p>任何一个对象的 finalize 方法只会被系统调用一次。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久代的垃圾回收主要回收两部分的内容：</p>
<ul>
<li>废弃常量</li>
<li>无用的类</li>
</ul>
<h4 id="回收废弃常量"><a href="#回收废弃常量" class="headerlink" title="回收废弃常量"></a>回收废弃常量</h4><p>回收废弃常量与回收 Java 堆中对象很相似。以常量池中字面量的回收为例，假如一个字符串「abc」已经进入了常量池中，它<strong>没有被引用</strong>，如果这时<strong>发生内存回收，而且必要的话</strong>，这个「abc」常量<strong>就会被系统清理出常量池</strong>。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<h4 id="回收无用类"><a href="#回收无用类" class="headerlink" title="回收无用类"></a>回收无用类</h4><p>类需要<strong>同时满足下面 3 个条件才能算是「无用的类</strong>」：</p>
<ol>
<li>该类所有的<strong>实例都已经被回收</strong>，也就是 Java 堆中不存在该类的任何实例。</li>
<li><strong>加载该类的 ClassLoader 已经被回收</strong>。</li>
<li>该类<strong>对应的 java.lang.Class 对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<p>虚拟机<strong>可以</strong>对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。 而且因为由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。所以正常情况下回收无用类收效甚微。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><strong>标记-清除</strong> (Mark-Sweep) 算法是<strong>最基础的收集算法</strong>，分为标记和清除两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象，</li>
<li>在标记完成后统一回收所有被标记的对象</li>
</ul>
<p>之所以说它基础，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</p>
<p>主要不足有两个：</p>
<ul>
<li><strong>效率问题</strong>：标记和清除两个过程的效率都不高；</li>
<li><strong>空间问题</strong>（确切而言是空间碎片问题）：标记清除之后会<strong>产生大量不连续的内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要<strong>分配较大对象时，无法找到足够的连续内存</strong>而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/30166872-34869854-9417-11e7-9586-95308fa7820c.png" alt="mark-sweep"></p>
<p>仅有 CMS 收集器使用了标记-清除算法。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法主要是为了解决效率问题，它<strong>将可用内存按容量划分为大小相等的两块</strong>，<strong>每次只使用其中的一块</strong>。  当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得<strong>每次都是对整个半区进行内存回收</strong>，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p><strong>商业虚拟机</strong>都采用复制收集算法来<strong>回收新生代</strong>，但并不是按照 1:1 的比例来划分内存空间，而是<strong>将内存分为一块较大的 Eden 空间和==两块==较小的 ==Survivor==</strong> 空间，<strong>每次使用 Eden 和其中一块 Survivor</strong>，当回收时，将 Eden 和 Survivor 中还存活着的对象<strong>一次性地复制到==另外一块==Survivor 空间上</strong>，最后清理掉 Eden 和刚才用过的 Survivor 空间。</p>
<ul>
<li>HotSpot 虚拟机<strong>默认 Eden 和两块 Survivor 的大小比例是 8:1:1</strong>，也就是<strong>每次新生代中可用内存空间为整个新生代容量的</strong> 90%（80%+10%），只有 10%的内存会被「浪费」。当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保</strong>（Handle Promotion）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用<strong>空间换取时间</strong>，这种算法<strong>将内存缩小为了原来的一半</strong>。</li>
<li>复制收集算法在<strong>对象存活率较高时</strong>就要进行<strong>较多的复制操作</strong>，效率将会变低。更关键的是，如果不想浪费 50%的空间，就需要有<strong>额外的空间进行分配担保</strong>，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在<strong>老年代一般不能直接选用这种复制算法</strong>。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/30166943-6af312e6-9417-11e7-8b7a-8a53bb607625.png" alt="copy sweep"></p>
<h3 id="标记-整理-算法"><a href="#标记-整理-算法" class="headerlink" title="标记-==整理==算法"></a>标记-==整理==算法</h3><p>「<strong>标记-整理」算法</strong>的<strong>标记过程</strong>仍然与「标记-清除」算法一样，但<strong>后续步骤不是直接对可回收对象进行清理</strong>，而是<strong>让所有存活的对象都向一端移动</strong>，然后直接清理掉端边界以外的内存。(先移动到『安全位置』再清除掉安全区域边界外的无用位置)</p>
<p><img src="https://user-images.githubusercontent.com/16668676/30166870-34829cb8-9417-11e7-99ae-276d0e6cd96c.png" alt="mark-compact"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>目前商业虚拟机的垃圾收集<strong>都采用「分代收集」（Generational  Collection）算法</strong>，</p>
<p>只是<strong>根据对象存活周期的不同将内存划分为几块</strong>。一般是把 Java 堆分为新生代和老年代，这样就可以<strong>根据各个年代的特点采用最适当的收集算法</strong>。可以通过 <code>-XX:NewRatio</code>调整新生代与老年代的内存空间比例（指定老年代所占的「份数」）。默认情况下 <code>NewRatio = 2</code>，即： 新生代约占整个堆空间的 1/3 ,老年代约占 2/3 。</p>
<ul>
<li>在<strong>新生代</strong>中，因为对象存活率比较低，只需要付出少量存活对象的复制成本就可以完成收集。选用<strong>复制算法</strong>。</li>
<li>而<strong>老年代</strong>中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用「标记-清理」或者「标记-整理」算法来进行回收。</li>
</ul>
<h2 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h2><p>如何发起内存回收？首先要知道回收的哪些对象。</p>
<h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p>
<h4 id="分析期间引用不可变导致-GC-停顿"><a href="#分析期间引用不可变导致-GC-停顿" class="headerlink" title="分析期间引用不可变导致 GC 停顿"></a>分析期间引用不可变导致 GC 停顿</h4><p>可达性分析对执行时间的敏感还体现在 <strong>GC 停顿</strong> 上，因为这项分析工作必须在一个能确保一致性的快照中进行。</p>
<ul>
<li>「<strong>一致性</strong>」的意思是指在<strong>整个分析期间</strong>，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程（Sun 将这件事情称为「<strong>Stop The World</strong>」）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li>
</ul>
<p>由于目前的主流 Java 虚拟机使用的都是<strong>准确式 GC</strong>，也就是说，虚拟机可以准确的知道内存中某个位置的数据类型是什么。所以当执行系统停顿下来后，并<strong>不需要一个不漏地检查完所有执行上下文和全局的引用位置</strong>，虚拟机只要直接扫描存放对象引用的区域。</p>
<ul>
<li>在 HotSpot 的实现中，使用一组称为 <strong>OopMap</strong> 的数据结构来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在<strong>特定的位置记录</strong>下栈和寄存器中哪些位置是引用。这样，GC 在扫描时就可以直接得知这些信息了。</li>
</ul>
<p>使用空间换时间。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>从线程角度看，safepoint 可以理解成是在代码执行过程中的<strong>一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的</strong>，（就好像高速公路上的服务区，可以安全地停下来休息）</p>
<ul>
<li>如果有需要，可以在这个位置暂停，比如发生 GC 时，需要暂停暂停所以活动线程，</li>
<li>但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待 GC 结束。（还在马路上，就不能休息，要到下一个服务区才能休息）</li>
</ul>
<h4 id="安全的选取"><a href="#安全的选取" class="headerlink" title="安全的选取"></a>安全的选取</h4><p>安全点是怎么选的？基本上是以程序「<strong>是否具有让程序长时间执行的特征」为标准</strong>进行选定的。</p>
<ul>
<li>「<strong>长时间执行</strong>」的<strong>最明显特征就是指令序列复用</strong>，例如：方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint。 </li>
</ul>
<h4 id="GC-时让线程停止的方式"><a href="#GC-时让线程停止的方式" class="headerlink" title="GC 时让线程停止的方式"></a>GC 时让线程停止的方式</h4><p>如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都「跑」到最近的安全点上再停顿下来？</p>
<p>这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），</p>
<ul>
<li><strong>抢先式中断</strong><br>在 GC 发生时，首先把所有线程全部中断，如果<strong>发现有线程中断的地方不在安全点上</strong>，就恢复线程，<strong>让它「跑」到安全点上</strong>。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。</li>
<li><strong>主动式中断</strong><br>主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，<strong>仅仅简单地设置一个标志</strong>，<strong>各个线程执行时主动去轮询这个标志</strong>，发现中断标志为真时就自己中断挂起。<ul>
<li>轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ul>
</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域是一个安全点连续的代码段。</p>
<p>安全区域是指在<strong>一段代码片段</strong>之中，<strong>引用关系不会发生变化</strong>。在这个区域中的任意地方开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p>
<p>在线程<strong>执行到 Safe Region 中的代码时</strong>，首先<strong>标识</strong>自己<strong>已经进入了 Safe Region</strong>，</p>
<ul>
<li>那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。<ul>
<li>（那些没标记为安全区域的怎么处理？）</li>
</ul>
</li>
<li>在线程要离开 Safe Region 时，它要<strong>检查系统是否已经完成了==根节点枚举==（或者是整个 GC 过程</strong>）[因为其他步骤可能不需要 stop the world ]<ul>
<li>如果完成了，那线程就继续执行，</li>
<li>否则它就必须等待直到<strong>收到可以安全离开 Safe Region 的信号</strong>为止。</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>内存回收如何进行是由虚拟机所采用的 GC 收集器决定的，而通常虚拟机中往往不止有一种 GC 收集器。</p>
<p>如果说<strong>收集算法是内存回收的方法论</strong>，那么垃圾回收器就是<strong>内存回收的具体实现</strong>。</p>
<p>虚拟机规范中对于垃圾回收器应该如何实现并没有任何规定。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28901528-5469b7bc-782b-11e7-856b-62c876707344.png" alt="hotspot"></p>
<p>图 3-5 展示了 7 种作用于不同分代的收集器，<strong>如果两个收集器之间存在连线，就说明它们可以搭配使用</strong>。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p>
<p>我们选择的只是对具体应用最合适的收集器。</p>
<p>以下分析的关注点：</p>
<ul>
<li>收集器的特点：<ul>
<li>工作线程数?</li>
<li>工作过程中需不需要 stop the word？<ul>
<li>需要的话具体是哪个过程需要？</li>
</ul>
</li>
</ul>
</li>
<li>能与哪个收集器搭配使用?</li>
</ul>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>一个单线程的收集器。单线程指的是它用<strong>单条线程</strong>去完成垃圾收集工作</p>
<ul>
<li>重点：在它进行垃圾收集时，必须<strong>暂停其他所有工作线程</strong>，直到它收集结束。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/28901652-5c798f30-782c-11e7-9394-6944abe6a65e.png" alt="serial serial old"></p>
<p>实际上到现在为止，它依然是<strong>虚拟机运行在 Client 模式下的默认新生代收集器</strong>。</p>
<p>优点：简单而高效（与其他收集器的单线程比），对于<strong>限定单个 CPU 的环境</strong>来说，Serial 收集器专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<p><strong>Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择</strong><br>因为在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本</strong></p>
<p><img src="https://user-images.githubusercontent.com/16668676/28901651-5c7621ec-782c-11e7-8feb-b98516448962.png" alt="parnew serial old"></p>
<p><strong>是许多运行在 Server 模式下的虚拟机中首选的新生代收集器</strong>，其中有一个与性能无关但<br>很重要的原因是，<strong>除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作</strong>。</p>
<p>两个名词：并发和并行。</p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程<strong>并行工作</strong>，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程<strong>同时执行</strong>（但<strong>不一定是并行的，可能会交替执行</strong>），用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。</li>
<li>二者关系：并行是并发的一个子集</li>
</ul>
<h3 id="ParallelScavenge-收集器"><a href="#ParallelScavenge-收集器" class="headerlink" title="ParallelScavenge 收集器"></a>ParallelScavenge 收集器</h3><p>Parallel Scavenge 收集器是一个新生代收集器， 与 ParNew 很相似。但它的<strong>关注点与其他收集器不同</strong>，CMS 等收集器的关注点是<strong>尽可能地缩短垃圾收集时用户线程的停顿时间</strong>，而 Parallel Scavenge 收集器的目标是达到<strong>一个==可控制==的吞吐量</strong>（Throughput）。实际上二者概念存在重叠的地方。因为 GC 过程中用户线程停顿时间缩短，那么吞吐量也就上去了，只不过要考虑用户代码执行时间与停顿时间的比例。</p>
<p><strong>吞吐量</strong>就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即</p>
<ul>
<li><code>吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）</code>，假设虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</li>
<li>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<strong>适合在后台运算</strong>而不需要太多交互的任务。</li>
</ul>
<p><code>MaxGCPauseMillis</code> 参数允许的值是一个大于 0 的毫秒数，收集器将<strong>尽可能地保证内存回收花费的时间不超过设定值</strong>。注意：GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：<strong>系统把新生代调小一些，这也直接导致垃圾收集发生得更频繁一些</strong>。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p>GCTimeRatio 参数的值是一个大于 0 且小于 100 的整数，也就是<strong>垃圾收集时间占总时间的比率</strong>，相当于是<strong>吞吐量的倒数</strong>。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1/（1+19）），默认值为 99，就是允许最大 1 %（即 1/（1+99））的垃圾收集时间。</p>
<p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为「<strong>吞吐量优先」收集器</strong>。</p>
<p>Parallel Scavenge 收集器还有一个开关参数 <code>-XX：+UseAdaptiveSizePolicy</code>当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，<strong>虚拟机会根据当前系统的运行情况</strong>收集性能监控信息，<strong>动态调整这些参数</strong>以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 ==<strong>GC 自适应的调节策略</strong>==（GC Ergonomics）。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</p>
<h3 id="SerialOld-收集器"><a href="#SerialOld-收集器" class="headerlink" title="SerialOld 收集器"></a>SerialOld 收集器</h3><p>Serial  Old 是 Serial 收集器的老年代版本，使用「标记-整理」算法。</p>
<ul>
<li><p>这个收集器的主要意义也是在于<strong>给 Client 模式下的虚拟机使用</strong>。</p>
</li>
<li><p>如果在 Server 模式下，那么它主要还有两大用途：</p>
<ul>
<li><p>一种用途是在 JDK 1.5 以及之前的版本中<strong>与 Parallel Scavenge 收集器</strong>搭配使用</p>
</li>
<li><p>另一种用途就是<strong>作为 CMS 收集器的后备预案</strong>，在并发收集发生 Concurrent Mode Failure 时使用。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28901652-5c798f30-782c-11e7-9394-6944abe6a65e.png" alt="serial serial old"></p>
</li>
</ul>
</li>
</ul>
<p>Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集，<strong>并非直接使用了 Serial Old 收集器，但是这个 PS MarkSweep 收集器与 Serial Old 的实现非常接近</strong>。</p>
<h3 id="ParallelOld-收集器"><a href="#ParallelOld-收集器" class="headerlink" title="ParallelOld 收集器"></a>ParallelOld 收集器</h3><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和「标记-整理」算法。</p>
<p>这个收集器是在 JDK 1.6 中才开始提供的，此前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。因为 JDK1.6 以前只能选择 serial old 作为老年代收集器。（唯一能选择的队友不行）</p>
<p>直到 Parallel  Old 收集器出现后，「吞吐量优先」收集器终于有了比较名副其实的应用组合，在<strong>注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器</strong>。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28902291-989d0c04-7830-11e7-8c0f-68559b75a4d4.png" alt="parallel scavenge parallel old"></p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS 收集器（Concurrent Mark Sweep）在 JDK1.5 时期被推出，这款收集器是 HotSpot 虚拟机中<strong>第一款真正意义上的==并发==收集器</strong>，它<strong>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。</p>
<p>CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作。</p>
<p><strong>CMS（Concurrent Mark Sweep</strong>）收集器是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。适合于交互型的应用。希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。<br>从名字（包含「Mark Sweep」）上就可以看出，CMS 收集器是<strong>基于「标记—==清除==」算法</strong>实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤，包括：</p>
<ul>
<li><strong>初始</strong>标记（CMS initial mark） ,需要「<em>Stop The World</em>」<br>仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快</li>
<li><strong>并发</strong>标记（CMS concurrent mark）<br>进行 GC RootsTracing </li>
<li><strong>重新</strong>标记（CMS remark）,需要「<em>Stop The World</em>」<br><strong>为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li>
<li><strong>并发</strong>清除（CMS concurrent sweep）</li>
</ul>
<p>由于整个过程中<strong>耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作</strong>，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。通过图 3-10 可以比较清楚地看到 CMS 收集器的运作步骤中并发和需要停顿的时间。<br><img src="https://user-images.githubusercontent.com/16668676/28902476-a8394528-7831-11e7-8fae-73813a57bc06.png" alt="concurrent mark sweep"></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>对 CPU 资源非常敏感</strong><br>其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是<strong>会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢</strong>，总吞吐量会降低。<ul>
<li>CMS 默认启动的回收线程数是（<code>CPU 数量 + 3）/ 4</code>，<ul>
<li>也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25%的 CPU 资源，并且随着 CPU 数量的增加而下降。</li>
<li>但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大.</li>
</ul>
</li>
<li>用户程序在 GC 过程中执行 缓慢的问题，推出了<strong>增量式 CMS</strong>（i-CMS），在并发标记、清除时让 GC 线程与用户线程交替执行，尽量减少 GC 线程独占资源的时间，虽然这样会导致整个垃圾回收过程变长。但是效果不明显，目前版本中已经不再推荐使用。</li>
</ul>
</li>
<li><strong>无法处理浮动垃圾</strong>（Floating  Garbage）<br>可能出现「Concurrent  Mode Failure」失败而导致另一次 Full GC 的产生。<ul>
<li>由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为「<strong>浮动垃圾</strong>」。</li>
</ul>
</li>
<li><strong>收集结束时会产生大量空间碎片</strong>。（因为使用了「标记-清除」算法）<br>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC 。<ul>
<li>为了解决这个问题，CMS 收集器提供了一个<code>-XX：+UseCMSCompactAtFullCollection</code> 开关参数（默认就是开启的），用于在 CMS 收集器<strong>顶不住要进行 FullGC 时开启内存碎片的合并整理过程</strong>，内存整理的过程是无法并发的，<strong>空间碎片问题没有了，但停顿时间不得不变长</strong>。</li>
<li>另外一个参数<code>-XX：CMSFullGCsBeforeCompaction</code>，这个参数是用于设置<strong>执行多少次不压缩的 Full GC 后，跟着来一次带压缩的</strong>（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</li>
</ul>
</li>
</ul>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>G1（<strong>Garbage-First</strong>）是一款<strong>面向服务端应用</strong>的垃圾收集器。它有以下几个优点：</p>
<ul>
<li><strong>并行与并发</strong>：<br>G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短<code>Stop-The-World</code>停顿的时间</li>
<li><strong>分代收集</strong>：<br><strong>不需要其他收集器配合就能独立管理整个 GC 堆</strong>，能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。</li>
<li>空间整合：无内存碎片。<br>与 CMS 的「标记—清理」算法不同，G1<ul>
<li>从<strong>整体</strong>来看是<strong>基于「标记—整理」算法实现</strong>的收集器</li>
<li>从<strong>局部</strong>（两个 Region 之间）上来看是<strong>基于「复制」算法</strong>实现的</li>
<li>这两种算法都意味着<strong>G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存</strong>。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。</li>
</ul>
</li>
<li><strong>可预测的停顿</strong>：<br>降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，<strong>还能建立可预测的停顿时间模型</strong>，能让使用者<strong>明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒</strong>。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别（其他收集器都是对整一个老年代或者新生代进行操作），它<strong>将整个 Java  堆划分为多个大小相等的独立区域</strong>（Region），虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合</strong>。</li>
</ul>
<p>之所以能建立可预测的停顿时间模型，是因为它<strong>可以有计划地避免</strong>在整个 Java 堆中<strong>进行全区域的垃圾收集</strong>。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表</strong>，<strong>每次根据允许的收集时间，优先回收价值最大的 Region</strong>（这也就是 Garbage-First 名称的来由）。这种<strong>使用 Region 划分内存空间以及有优先级的区域回收方式</strong>，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<p>Region 不可能是孤立的。一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。那在做可达性判定确定对象是否存活的时候，岂不是还得扫描整个 Java 堆才能保证准确性？在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象<br>引用，虚拟机都是<strong>使用 ==Remembered Set== 来避免全堆扫描</strong>的。</p>
<ul>
<li>G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在<strong>对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作</strong>，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 <strong>CardTable</strong> 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。</li>
<li>当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</li>
</ul>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li><strong>筛选回收</strong>（Live Data Counting and Evacuation）<ul>
<li>哪一块回收的收益大就选哪一块。</li>
</ul>
</li>
</ul>
<p>G1 的前几个步骤的运作过程和 CMS 有很多相似之处。</p>
<ul>
<li><strong>初始标记阶段</strong><br>仅仅只是标记一下 GC Roots <strong>能直接关联到的对象</strong>，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段<strong>需要停顿线程，但耗时很短</strong>。</li>
<li><strong>并发标记阶段</strong><br>是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但<strong>可与用户程序并发执行</strong>。</li>
<li><strong>最终标记阶段</strong><br>是为了<strong>修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</strong>，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 <strong>Remembered Set Logs 的数据合并到 Remembered Set 中</strong>，这阶段<strong>需要停顿线程</strong>，但是<strong>可并行执行</strong>。</li>
<li><strong>筛选回收阶段</strong><br>对各个 Region 的<strong>回收价值和成本进行排序</strong>，根据用户所期望的 GC 停顿时间来制定回收计划。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/28903495-d71fceb0-7837-11e7-8e8e-6f26da762c22.png" alt="g1"></p>
<h3 id="组合策略"><a href="#组合策略" class="headerlink" title="组合策略"></a>组合策略</h3><p>在进行 JVM 调优的过程中，并非任何一种新生代 GC 策略都可以和另一种年老代 GC 策略进行配合工作，所以，我们应该知道，哪些种组合可以有效地进行 GC，而且应该在什么样的应用场景下选择哪一种组合，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left"><strong>新生代 GC 策略</strong></th>
<th><strong>年老代 GC 策略</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">组合 1</td>
<td style="text-align:left">Serial</td>
<td>Serial Old</td>
<td style="text-align:left">Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。</td>
</tr>
<tr>
<td style="text-align:center">组合 2</td>
<td style="text-align:left">Serial</td>
<td>CMS+Serial Old</td>
<td style="text-align:left">CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。</td>
</tr>
<tr>
<td style="text-align:center">组合 3</td>
<td style="text-align:left">ParNew</td>
<td>CMS</td>
<td style="text-align:left">使用-XX:+UseParNewGC 选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用-XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC 选项，则新生代默认使用 ParNew GC 策略。</td>
</tr>
<tr>
<td style="text-align:center">组合 4</td>
<td style="text-align:left">ParNew</td>
<td>Serial Old</td>
<td style="text-align:left">使用-XX:+UseParNewGC 选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。</td>
</tr>
<tr>
<td style="text-align:center">组合 5</td>
<td style="text-align:left">Parallel Scavenge</td>
<td>Serial Old</td>
<td style="text-align:left">Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td>
</tr>
<tr>
<td style="text-align:center">组合 6</td>
<td style="text-align:left">Parallel Scavenge</td>
<td>Parallel Old</td>
<td style="text-align:left">Parallel Old 是 Parallel Scavenge 收集器的老年代版本。适用于注重吞吐量以及 CPU 资源敏感的场合</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">G1</td>
<td></td>
<td style="text-align:left">G1 是 Garbage First 垃圾收集器。</td>
</tr>
</tbody>
</table>
<h3 id="理解-GC-日志"><a href="#理解-GC-日志" class="headerlink" title="理解 GC 日志"></a>理解 GC 日志</h3><p>GC 日志开头的 「[GC」和「[Full  GC」<strong>说明了这次垃圾收集的==停顿类型==，而不是用来区分新生代 GC 还是老年代 GC 的</strong>。</p>
<ul>
<li>如果有「Full」，<strong>说明这次 GC 是发生了 Stop-The-World 的</strong>，这段新生代收集器 ParNew 的日志也会出现「[Full GC」（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW）。</li>
<li>如果是调用 System.gc（）方法所触发的收集，那么在这里将显示「[Full GC（System）」。</li>
</ul>
<p>接下来的「[DefNew」、「[Tenured」、「[Perm」表示 <strong>GC 发生的区域</strong>，这里显示的区域名称与使用的 GC 收集器是密切相关的，</p>
<ul>
<li>Serial 收集器中的新生代名为 「Default New  Generation」，所以显示的是「[DefNew」。</li>
<li>如果是 ParNew 收集器，新生代名称就会变为「[ParNew」，意为 「Parallel New Generation」。</li>
<li>如果采用 Parallel Scavenge 收集器，那它配套的新生代称为「PSYoungGen」</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地栈上分配），<strong>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配*。少数情况下也可能会直接分配在老年代中</strong>，</p>
<ul>
<li>注: TLAB 全称为 Thread Local Allocation Buffered</li>
</ul>
<p>分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。以下为几条最普遍的内存分配规则。</p>
<ul>
<li>对象优先在 Eden 分配、 </li>
<li>大对象直接进入老年代、 </li>
<li>长期存活的对象将进入老年代 、</li>
<li>动态对象年龄判定 、</li>
<li>空间分配担保</li>
</ul>
<h3 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 <strong>Minor GC</strong>。</p>
<h4 id="Minor-GC-和-Full-major-GC-有什么不一样吗？"><a href="#Minor-GC-和-Full-major-GC-有什么不一样吗？" class="headerlink" title="Minor GC 和 Full/major GC 有什么不一样吗？"></a>Minor GC 和 Full/major GC 有什么不一样吗？</h4><ul>
<li><strong>新生代 GC</strong>（Minor GC）：指发生在<strong>新生代的垃圾收集动作</strong>，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li>
<li><strong>老年代 GC</strong>（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，<strong>经常会伴随至少一次的 Minor GC</strong>（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。<strong>Major GC 的速度一般会比 Minor GC 慢 10 倍以上</strong>。</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象是指，<strong>需要大量连续内存空间的 Java 对象</strong>，最典型的大对象就是那种很长的字符串以及数组。</p>
<p>虚拟机提供了一个<code>-XX：PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是<strong>避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制</strong>（复习一下：新生代采用复制算法收集内存）。</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>为了做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>。</p>
<ul>
<li>如果对象在 Eden 出生并<strong>经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话</strong>，将被移动到 Survivor 空间中，并且对象年龄设为 1。</li>
<li><strong>对象在 Survivor 区中每「熬过」一次 Minor GC，年龄就增加 1 岁</strong>，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。<ul>
<li>对象晋升老年代的年龄阈值，可以通过参数 <code>-XX：MaxTenuringThreshold</code> 设置。</li>
</ul>
</li>
</ul>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了 <code>MaxTenuringThreshold</code>才能晋升老年代，<strong>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到 <code>MaxTenuringThreshold</code>中要求的年龄。</p>
<p>也就是说，同龄的小伙伴的内存大于总内存的一半。那么 &gt;= 该年龄的就算老了。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生 Minor GC 之前，</p>
<ul>
<li>虚拟机会先<strong>检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，<ul>
<li>如果这个条件成立，那么 Minor GC 可以确保是安全的。</li>
<li>如果不成立，则虚拟机会查看  HandlePromotionFailure 设置值是否允许担保失败。<ul>
<li>如果允许，那么会继续检查<strong>老年代最大可用的连续空间</strong>是否大于<strong>历次晋升到老年代对象容量</strong>的==平均大小==，<ul>
<li>如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；</li>
<li>如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 <code>Full GC</code>。</li>
</ul>
</li>
<li>如果不允许，改为进行一次 <code>Full GC</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>「冒险」是冒了什么风险？  </p>
<ul>
<li>一句话就是：老年代的最大可用连续空间可能小于新生代所有存活对象总空间，就会导致 Full GC，本来是应该直接执行 Full GC 的，但是没有直接执行，导致浪费了时间。</li>
<li>具体而言：<br>新生代使用复制收集算法，但为了内存利用率，<strong>只使用其中一个 Survivor 空间来作为轮换备份</strong>，因此当出现<strong>大量对象在 Minor GC 后仍然存活的情况</strong>（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。<strong>老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间</strong>，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。</li>
</ul>
<p>取平均值进行比较其实仍然是<strong>一种动态概率的手段</strong>，也就是说，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。<br>如果出现了 HandlePromotionFailure 失败，那就只好在失败后重新发起一次 Full GC。</p>
<p>虽然担保失败时绕的圈子是最大的，但<strong>大部分情况下都还是会将 HandlePromotionFailure 开关打开，避免 Full GC 过于频繁</strong>。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="你能不能谈谈，GC-是在什么时候，对什么东西，做了什么事情？"><a href="#你能不能谈谈，GC-是在什么时候，对什么东西，做了什么事情？" class="headerlink" title="你能不能谈谈，GC 是在什么时候，对什么东西，做了什么事情？"></a>你能不能谈谈，GC 是在什么时候，对什么东西，做了什么事情？</h3><p>此问题摘自《深入理解 Java 虚拟机》作者的一篇博文，详见 <a href="http://icyfenix.iteye.com/blog/715301" target="_blank" rel="noopener">一个面试官对面试问题的分析</a></p>
<h3 id="java的gc为什么要分代？"><a href="#java的gc为什么要分代？" class="headerlink" title="java的gc为什么要分代？"></a>java的gc为什么要分代？</h3><p>答案可参考 R 大的这个<a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="noopener">回答</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。</p>
<p>学习虚拟机内存知识，如果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《深入理解 Java 虚拟机》</li>
</ul>
<p>本文大部分内容都出自《深入理解 Java 虚拟机》 第三章，若文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM 运行时数据区域与对象创建布局]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/07/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h2 id="java-运行时数据区域"><a href="#java-运行时数据区域" class="headerlink" title="java 运行时数据区域"></a>java 运行时数据区域</h2><p>根据《Java 虚拟机规范》规定，Java 虚拟机锁管理的内存包含以下以下几个运行时数据区域，如下图所示：<br><img src="https://user-images.githubusercontent.com/16668676/30062052-64dd918e-927c-11e7-9ec8-a82e507dc3ce.png" alt="java runtime memory"></p>
<a id="more"></a>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是<strong>线程私有的</strong>，各线程独立存储，以便线程切换后能恢复到正确的执行位置。可以看作是<strong>当前线程</strong>所执行的<strong>字节码的行号指示器</strong>。</p>
<ul>
<li>如果正在执行的是一个 Java 方法，该计数器记录的是正在执行的虚拟机字节码指令的地址。</li>
<li>如果正在执行的是一个 Native 方法，则该计数器值为空。</li>
</ul>
<p>==此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域==</p>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈是==线程私有的==。生命周期与线程相同。</p>
<p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）。每一个方法从调用到执行都对应着一个栈帧在虚拟机栈中入栈和出栈的过程。</p>
<p>注：栈帧（Stack Frame ）是方法运行时基础数据结构，其中存储了局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>平时所讲的栈内存，就是现在讲的 Java 虚拟机栈，或者说是<strong>虚拟机栈中局部变量表部分</strong>。</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 SOF（Stack Over Flow） 异常</li>
<li>如果扩展时，无法申请到足够的内存，就会抛 OOMError 异常</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>发挥的作用与虚拟机栈相似。只不过一个是针对 Java 方法，一个是针对本地方法。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>对于大多数应用而言，Java 堆是 Java 虚拟机所管理的内存中最大的一块。同时它也是==所有线程共享==的一块内存区域。Java 虚拟机规定，Java 堆<strong>可以是物理上不连续的</strong>内存空间，只要逻辑上连续即可。</p>
<p>按照虚拟机规范中的描述，<strong>所有对象实例以及数组都要在堆上分配</strong>。不过随着 JIT 编译器的发展和逃逸分析技术的逐渐成熟，未来或许会有所改变。</p>
<p>从内存分配角度来看，线程共享的 Java 堆中可能会划分出多个<strong>线程私有的分配缓冲区</strong>（Thread Local Allocation Buffer，TLAB）。<strong>不管怎么划分，其中存储的都是对象</strong>，进行划分的目的只是为了更好地回收/分配内存。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区有一个别名：non-heap，与 Java 堆区分开来。它是==所有线程共享==的，用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。</p>
<p>Hotspot 虚拟机设计团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区。因为这样就不用专门为方法区编写内存管理的代码的工作。对于其他虚拟机而言是不存在永久代这个概念的。</p>
<p>使用永久代来实现方法区的<strong>好处</strong>在于可以直接像管理 Java 堆那样管理这部分内存，而不需要再专门为方法区编写内存管理代码。<strong>坏处</strong>在于这样<strong>更容易导致 OOM</strong>，因为永久代有 <code>-XX：MaxPermSize</code> 的上限。在 JDK 1.8  HotSpot 虚拟机的实现中已经将整个永久代移除，取而代之的是一个叫元空间（Metaspace）的区域。</p>
<p>当方法区无法满足内存分配需求时，将抛出 <code>java.lang.OutOfMemoryError: PermGen space</code> 。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是<strong>常量池</strong>，用于存放<strong>编译期生成的</strong>各种<strong>字面量和符号引用</strong>。JDK 1.8 前运行时常量池是方法区的一部分。</p>
<p>虚拟机规范中对 Class 文件中的每一个部分的<strong>格式</strong>都有严格规定。但是<strong>对于运行时常量池，并没有做任何细节的要求</strong>。一般而言，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的的另一特征在于<strong>具备动态性</strong>。java <strong>运行期间也可以把新的常量放入池中</strong>。比如使用 String.intern() 将堆中的字符串加入常量池中。</p>
<p>JDK1.7 中把原本放在永久代的字符串常量池移到 Java 堆中。<strong>常量池位置的不同影响到了 String 的 intern()方法的表现</strong>。不同版本的 JDK  使用「==」去比较 String 字符串的结果会有不同。具体情况可参考这篇文章——<a href="http://blog.csdn.net/seu_calvin/article/details/52291082" target="_blank" rel="noopener">Java 技术——你真的了解 String 类的 intern()方法吗</a></p>
<h3 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a>Metaspace（元空间）</h3><p>介绍元空间之前先说点题外话。其实，移除永久代的工作从 JDK1.7 就开始了。JDK1.7 中，存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。譬如符号引用(Symbols)转移到了 native heap、字面量(interned strings)转移到了 java heap、类的静态变量(class statics)转移到了 java heap。但 JDK1.7 并没有完全移除将永久代完全移除。直到 JDK1.8 才将永久代完整地移除。</p>
<p>元空间的本质和永久代类似，<strong>都是对 JVM 规范中方法区的实现</strong>。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是<strong>使用本地内存</strong>。因此，<strong>默认情况下，元空间的大小仅受本地内存限制</strong>，但可以通过以下参数来指定元空间的大小：</p>
<ul>
<li><code>-XX:MetaspaceSize</code>，<strong>初始空间大小</strong>，<strong>达到该值就会触发垃圾收集进行类型卸载</strong>，同时 <strong>GC 会对该值进行调整</strong>：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 MaxMetaspaceSize 时，适当提高该值。</li>
<li><code>-XX:MaxMetaspaceSize</code>，<strong>最大空间</strong>，默认是没有限制的。</li>
</ul>
<p>如果本地空间的内存用尽了会收到<code>java.lang.OutOfMemoryError: Metadata space</code> 的错误信息。<br>JDK1.8 中持久代相关的 JVM 参数 <code>-XX:PermSize</code> 及 <code>-XX:MaxPermSize</code> 将会被忽略掉。</p>
<h4 id="为什么移除持久代？"><a href="#为什么移除持久代？" class="headerlink" title="为什么移除持久代？"></a>为什么移除持久代？</h4><ul>
<li>它的大小只能在启动时指定，运行时无法修改——很难进行调优。-XX:MaxPermSize，设置成多少好呢？</li>
<li>HotSpot 的内部类型也是 Java 对象：它可能会在 Full GC 中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。</li>
<li>简化 Full GC：每一个回收器有专门的元数据迭代器。</li>
<li>可以在 GC 不进行暂停的情况下并发地释放类数据。</li>
<li>使得原来受限于持久代的一些改进未来有可能实现</li>
</ul>
<h4 id="元空间的内存分配模型"><a href="#元空间的内存分配模型" class="headerlink" title="元空间的内存分配模型"></a>元空间的内存分配模型</h4><ul>
<li>绝大多数的类元数据的空间都从本地内存中分配</li>
<li>用来描述类元数据的类（klasses)也被删除了</li>
<li>分元数据分配了多个虚拟内存空间</li>
<li>给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些</li>
<li>归还内存块，释放内存块列表</li>
<li>一旦元空间的数据被清空了，虚拟内存的空间会被回收掉</li>
<li>减少碎片的策略</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并<strong>不是虚拟机运行时数据区的一部分</strong>，也不是虚拟机规范中定义的内存区域。</p>
<p>JDK 1.4 新添加的 NIO（New Input/Output） 可以使用 Native 函数库直接分配堆外存，然后通过一个存储在 Java 堆中的 DireByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场合能够显著提高性能。</p>
<p>本机直接内存<strong>不受 Java 堆大小的限制</strong>，但是受到本机总内存的大小以及处理器寻址空间的限制。</p>
<h2 id="HotSpot-虚拟机中对象创建、初始化与布局"><a href="#HotSpot-虚拟机中对象创建、初始化与布局" class="headerlink" title="HotSpot 虚拟机中对象创建、初始化与布局"></a>HotSpot 虚拟机中对象创建、初始化与布局</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="类加载检查、判断"><a href="#类加载检查、判断" class="headerlink" title="类加载检查、判断"></a>类加载检查、判断</h4><p>遇到一条 new 指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载。</p>
<h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>类加载检查通过后，将<strong>为新生对象分配内存</strong>。也就是划分出一块内存区域。</p>
<ul>
<li>如果 java 堆中的内存是绝对规整的，那么会使用<strong>指针碰撞</strong>的分配方式</li>
<li>如果 java 堆中的内存不规整的，虚拟机必须维护一个列表，记录哪些内存块可用，在分配时从列表中，找到一块足够大的空间划分给对象。即，使用<strong>空闲列表</strong>的分配方式。</li>
</ul>
<p>选择哪种分配方式由 java 堆是否规整决定，而 <strong>Java 堆是否规整</strong>又由所采用的<strong>垃圾收集器</strong>是否带有<strong>压缩整理功能</strong>决定。</p>
<ul>
<li>在使用 Serial、ParNew 等<strong>带 Compact 过程</strong>的收集器时，系统采用的分配算法是<strong>指针碰撞</strong></li>
<li>而使用 CMS 这种<strong>基于 Mark-Sweep 算法</strong>的收集器时，通常采用<strong>空闲列表</strong>。</li>
</ul>
<p><strong>线程安全问题</strong>：<br>另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有<strong>两种方案</strong>：</p>
<ul>
<li>一种是<strong>对分配内存空间的动作进行同步处理</strong>——实际上虚拟机采用 <strong>CAS 配上失败重试的方式</strong>保证更新操作的原子性；</li>
<li>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即<strong>每个线程在 Java 堆中预先分配一小块内存</strong>，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer,TLAB）。<ul>
<li>哪个线程要分配内存，就在哪个线程的 TLAB 上分配，<strong>只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定</strong>。<ul>
<li>虚拟机是否使用 TLAB，可以通过<code>-XX：+/-UseTLAB</code> 参数来设定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>此处的初始化指的是将分配到的内存空间初始化为<strong>零值</strong>。（不包括对象头）。如果使用 TLAB，该过程也可以提前至 TLAB 分配时进行。初始化为零值的操作保证了对象的<strong>实例字段</strong>在 Java 代码中可不赋初值就使用。</p>
<p>对象头的设置：</p>
<ul>
<li>对象是哪个类的实例</li>
<li>如何才能找到类的元数据信息</li>
<li>对象的哈希码</li>
<li>对象的 GC 分代年龄等信息。</li>
<li>…</li>
</ul>
<p>从虚拟机的视角来看，一个新的对象已经创建完毕。  </p>
<ul>
<li>但从 Java 程序视角来看，对象的创建才刚刚开始——<init> 方法还没有执行、所有字段都还为零.<ul>
<li>一般来说（由字节码中是否跟随 invokespecial 指令所决定），执行 <strong>new 指令</strong>之后会接着执行 <strong><init> 方法</init></strong>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ul>
</init></li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot 中，对象在内存中存储的布局可以<strong>分为 3 块区域</strong>：</p>
<ul>
<li>对象头 Header</li>
<li>实例数据 Instance Data</li>
<li>对齐填充 Padding (并不是必然存在)</li>
</ul>
<h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1. 对象头"></a>1. 对象头</h4><p><strong>对象头包括两部分信息</strong>：第一部分为存储对象自身得运行时数据，第二部分为类型指针。</p>
<ol>
<li><strong>存储对象自身的运行时数据</strong>。如：<ul>
<li>哈希码（HashCode）</li>
<li>GC 分代年龄、</li>
<li>锁状态标志、</li>
<li>线程持有的锁、</li>
<li>偏向线程 ID、</li>
<li>偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit，官方称它为「<strong>Mark Word</strong>」。</li>
<li>对象头信息是<strong>与对象自身定义的数据无关的额外存储成本</strong>，考虑到虚拟机的空间效率，Mark Word 被设计成一个<strong>非固定的数据结构以便在极小的空间内存储尽量多的信息</strong>，它会根据对象的状态复用自己的存储空间。</li>
</ul>
</li>
<li><strong>类型指针</strong>，即对象指向它的<strong>类元数据的指针</strong>，虚拟机通过该指针来确定这个对象是哪个类的实例。<ul>
<li>如果对象是一个数组，那么对象头中还需要有一块用于记录数据长度的数据<ul>
<li>因为从数据的元数据无法确定数组的大小</li>
</ul>
</li>
<li>注意：并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，<strong>查找对象的元数据信息并不一定要经过对象本身</strong><ul>
<li>比如：通过句柄访问对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-实例数据"><a href="#2-实例数据" class="headerlink" title="2. 实例数据"></a>2. 实例数据</h4><p>接下来的<strong>实例数据部分</strong>是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
<ul>
<li>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>这部分的<strong>存储顺序</strong>会<strong>受到虚拟机分配策略参数</strong>（FieldsAllocationStyle）和<strong>字段在 Java 源码中定义顺序的影响</strong>。<ul>
<li>HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），<ul>
<li>可以看出，<strong>相同宽度的字段总是被分配到一起</strong>。</li>
<li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</li>
<li>如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-对齐填充"><a href="#3-对齐填充" class="headerlink" title="3. 对齐填充"></a>3. 对齐填充</h4><p><strong>对齐填充</strong>并不是必然存在的，也没有特别的含义，它仅仅<strong>起着占位符的作用</strong>。</p>
<p>由于 HotSpot VM 的自动内存管理系统<strong>要求对象起始地址必须是 8 字节的整数倍</strong>，换句话说，就是<strong>对象的大小必须是 8 字节的整数倍</strong>。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>由于 reference 类型在 Java 虚拟机规范中<strong>只规定了一个指向对象的引用</strong>，并<strong>没有定义这个引用应该通过何种方式去定位</strong>、访问堆中的对象的具体位置，所以<strong>对象访问方式也是取决于虚拟机实现而定的</strong>。</p>
<p>主流的访问方式有两种：1. 使用句柄，2. 使用直接指针</p>
<h4 id="使用句柄访问："><a href="#使用句柄访问：" class="headerlink" title="使用句柄访问："></a>使用句柄访问：</h4><ul>
<li>Java 堆中将会划分出来一块内存作为句柄池，reference 中就是存储了<strong>对象的句柄地址</strong>，而句柄中包含了对象<strong>实例数据</strong>和<strong>类型数据</strong>各自的<strong>具体地址</strong>信息。<br><img src="https://user-images.githubusercontent.com/16668676/30117448-d342779e-9352-11e7-8d1e-5d4c44308d8f.png" alt="visit obj with handle"></li>
</ul>
<h4 id="直接指针访问："><a href="#直接指针访问：" class="headerlink" title="直接指针访问："></a>直接指针访问：</h4><ul>
<li>采用这种方式，那么 Java 堆<strong>对象的布局中就必须考虑如何放置访问类型数据的相关信息</strong>，reference 中存储的直接就是对象地址，而<strong>对象中包含</strong>了对象<strong>类型数据的地址信息</strong>。<br><img src="https://user-images.githubusercontent.com/16668676/30117447-d31537ac-9352-11e7-980c-d56f667070e4.png" alt="visit obj with pointer"></li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>使用<strong>句柄</strong>访问优点：是 <strong>reference 中存储的是稳定的句柄地址</strong>，在<strong>对象被移动时</strong>，只会改变句柄中的实例数据指针，而 <strong>reference 本身不需要被修改</strong>。</li>
<li>使用<strong>直接指针</strong>的最大好处就是<strong>速度更快</strong>，节省了一次指针定位需要的时间开销，由于 Java 对象访问十分频繁，这类开销积小成多后也是一项非常可观的执行成本。<ul>
<li>Sun HotSpot 虚拟机使用的就是这种访问方式。</li>
</ul>
</li>
</ul>
<h2 id="OutOfMemoryError-异常简析"><a href="#OutOfMemoryError-异常简析" class="headerlink" title="OutOfMemoryError 异常简析"></a>OutOfMemoryError 异常简析</h2><h3 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h3><p>不断创建对象，并且保证 GC Roots 到对象之间有可达路径来<strong>避免垃圾回收机制清除这些对象</strong>。在对象总内存达到 <code>-XmX:heapSize</code>指定的值之后就会 OOM。</p>
<p>一般出现这种情况都是通过 MAT 工具来分析。确定是出现了内存泄漏，还是的最大堆空间的设置不合理。</p>
<ul>
<li>如果是内存泄漏，可进一步通过工具来查看对象到   GC Roots 的引用链，找出内存泄漏的原因</li>
<li>如果不存在内存泄漏，即对象确实必须存活着，那就要检查虚拟机的堆参数（-Xmx 与 -Xms）与机器物理内存比较看是否还可以调大；同时也可以通过检查代码中是否存在一些对象的生命周期过长、持有状态时间过长的情况，尝试·减少程序运行期的内存消耗。</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈。栈容量只由 <code>-Xss</code> 参数设定。</p>
<p>关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
</ul>
<p>导致 SOF 的常见原因有递归、定义大量的局部变量等。</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>可以通过在运行时产生大量的<strong>类</strong>去填满方法区。</p>
<p>由于 JDK1.7 把字符串常量池从方法区移到堆中，在不同的版本的 JDK中<code>String.intern()</code>方法的表现不一。</p>
<ul>
<li>JDK1.6 中调用 <code>String.intern()</code> 方法时，会把<strong>首次遇到的字符串复制到永久代中</strong>。</li>
<li>JDK1.7 中调用 <code>String.intern()</code>方法时，不会再复制实例，只是在常量池中<strong>记录首次出现的实例引用</strong></li>
</ul>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>可以通过 <code>-XX:MaxDirectMemorySize</code> 指定，如果不指定，默认与 Java 堆最大值（<code>-Xmx</code>指定）一样</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">Java8 内存模型—永久代(PermGen)和元空间(Metaspace)</a></li>
<li><a href="http://it.deepinmind.com/gc/2014/05/14/metaspace-in-java-8.html" target="_blank" rel="noopener">Java 8 的元空间</a></li>
<li>Java 8 的元空间<a href="http://java-latte.blogspot.sg/2014/03/metaspace-in-java-8.html" target="_blank" rel="noopener">英文原文</a></li>
<li><a href="http://caoyaojun1988-163-com.iteye.com/blog/1969853" target="_blank" rel="noopener">JAVA 8 ：从永久区（PermGen）到元空间（Metaspace）</a></li>
<li><a href="http://liuwangshu.cn/java/jvm/1-runtime-data-area.html" target="_blank" rel="noopener">Java虚拟机（一）结构原理与运行时数据区域</a></li>
<li>《深入理解 Java 虚拟机(第 2 版)》</li>
</ul>
<p>若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> jvm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 集合框架之 ArrayList]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/06/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BArrayList/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>ArrayList 是一个动态数组，它是线程不安全的，允许元素为 null。它的底层数据结构是数组，ArrayList 实现了 <code>List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code> 接口，其中 RandomAccess 代表了其拥有随机快速访问的能力，<code>ArrayList</code> 可以以 O(1) 的时间复杂度去根据下标访问元素。</p>
<h3 id="时间、空间效率"><a href="#时间、空间效率" class="headerlink" title="时间、空间效率"></a>时间、空间效率</h3><p>因为数组内存的连续，可以根据下标以 O1 的时间改查元素，因此<strong>时间效率很高</strong></p>
<p>同样也因为数组要占据一块连续的内存空间，所以它也有数组的缺点——<strong>空间效率不高</strong>。</p>
<a id="more"></a>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当集合中的元素超出容量时，会进行<strong>扩容操作</strong>，扩容操作是一个性能消耗较大的地方，所以如果能预知数据的规模，最好在初始化时通过 <code>public ArrayList(int initialCapacity)</code> 构造方法指定 ArrayList 的大小，来构造 ArrayList 实例，以<strong>减少扩容次数，提高效率</strong>。</p>
<p>在添加大量元素前，应用程序也可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量，这可以减少递增式再分配的数量。 不过该方法是 ArrayList 中添加的，List 中没有该方法。所以如果声明的类型为 List 的话，需要进行强转。<code>((ArrayList)list).ensureCapacity(number);</code></p>
<p>当每次修改结构时(添加或者删除元素)，都会修改 modCount。</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//空对象数据，用于空对象，如果指定初始容量为 0 就给元素附一个空对象</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Shared empty array instance used for default sized empty instances. We</div><div class="line"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line"> * first element is added.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//共享的空数组对象，使用该对象用以区分 EMPTY_ELEMENTDATA，从而知道第一次添加元素时，应该初始化的数组长度。</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 之所以不声明为 private 是为了简化内部类访问，</span></div><div class="line"><span class="comment">// 所有原本为默认容量的空数组，在第一次添加元素的时候都会被初始化为长度为默认容量的数组</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//包含元素的数量</span></div></pre></td></tr></table></figure>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ArrayList 提供了三种方式的构造器，可以构造一个默认初始容量为 10 的空列表、构造一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//按照指定的初始容量初始化</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//创建数组</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//如果指定初始容量为 0 就给元素附一个空对象</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> +</div><div class="line">                initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化一个初始容量为 10 的 ArrayList</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//从给定的容器中构建一个 ArrayList</span></div><div class="line">    elementData = c.toArray();<span class="comment">//将容器对象中的元素转换为数组</span></div><div class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;<span class="comment">//长度不为 0，进行判断操作</span></div><div class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);<span class="comment">//如果返回的数组不是 Object[].class 类型的，则进行将数组元素复制到类型为 Object 数组上</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// replace with empty array.</span></div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//长度为 0，则将空数组对象赋值给元素数组</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要注意的是第三个构造方法中对数组元素类型的判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (elementData.getClass() != Object[].class)&#123;</div><div class="line">    elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125; <span class="keyword">else</span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 虽然表面上看起来，c.toArray() 会返回一个  Object[]  对象数组，但是它指向的实际类型并不一定是 Object[]，这样当我们调用 objList[i] =  new Object(); 就会报错   。 比如说如果我们有 1 个 List<string> stringList 对象，当我们调用<code>Object[] objectArray = stringList.toArray()</code>的时候，  objectArray 只能存放 String 类型的数据而不能存储其他类型的对象。</string></p>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p> ArrayList 提供了 add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加元素到列表尾部。</div><div class="line"> * 先确认 ArrayList 的容量</div><div class="line"> * 每次 add 之前，都会判断 add 后的容量，是否需要扩容。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!! 确保容量足以容纳原有元素加上新增的元素</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加元素到列表指定位置。需要将该位置右端的所有元素都往右移动一个单位</div><div class="line"> * 先确认 ArrayList 的容量</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);<span class="comment">//上下界判断</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!! 判断 add 之后的容量，根据情况进行扩容</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,<span class="comment">// 将 index ~ size-1 范围内的元素复制到 index+1 ~ size 范围中。也就是将 index 及其以后的元素后移一个位置</span></div><div class="line">            size - index);</div><div class="line">    elementData[index] = element;<span class="comment">//将给定元素添加到指定元素中</span></div><div class="line">    size++;<span class="comment">//元素数量 + 1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加给定集合中的所有元素到 ArrayList 中</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = c.toArray();<span class="comment">//先转换为数组</span></div><div class="line">    <span class="keyword">int</span> numNew = a.length;<span class="comment">//要添加的元素数量</span></div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount，确保容量足够容纳新添加的所有元素</span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);<span class="comment">//将元素添加到列表尾部</span></div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。  </div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);<span class="comment">//检查上下界</span></div><div class="line"></div><div class="line">    Object[] a = c.toArray();<span class="comment">//转换为数组</span></div><div class="line">    <span class="keyword">int</span> numNew = a.length;<span class="comment">//增加的数量</span></div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index;<span class="comment">//要移动的元素数</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                numMoved);<span class="comment">//移动数组中需要移动的元素</span></div><div class="line"></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);<span class="comment">//插入元素</span></div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>ArrayList 提供了<strong>根据下标</strong>或者<strong>指定对象</strong>两种方式的删除功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除指定位置的元素</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);<span class="comment">//上界判断</span></div><div class="line"></div><div class="line">    modCount++;<span class="comment">//结构修改次数 + 1</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//移动的元素总数</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,<span class="comment">//</span></div><div class="line">                numMoved);<span class="comment">//将要删除的元素的后面的所有元素往前移一个单位</span></div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work 将末元素置为 null，以免内存泄漏</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;<span class="comment">//返回删除掉的值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除此列表中首次出现的指定元素（如果存在的话）。</div><div class="line"> * 先找到指定元素在数组中的位置，然后再调用 fastRemove 删除</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 由于 ArrayList 中允许存放 null，因此下面通过两种情况来分别处理。  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  删除 [fromIndex，toIndex) 范围中的所有元素 </div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</div><div class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</div><div class="line">            numMoved);</div><div class="line"></div><div class="line">    <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="keyword">int</span> newSize = size - (toIndex - fromIndex);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</div><div class="line">        elementData[i] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    size = newSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除 ArrayList 中给定指定集合中的所有元素。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(c);</div><div class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 批量删除</div><div class="line"> * complement 为 false 时，删除指定集合 c 中所有的元素。</div><div class="line"> * complement 为 true 时，删除指定集合 c 中以外的所有的元素。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;<span class="comment">// complement 为 true 时为补集</span></div><div class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;<span class="comment">//将数组引用赋给 elementdata,节省空间</span></div><div class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//遍历，把要保存的元素存在前面</span></div><div class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</div><div class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)<span class="comment">//存储要保留的元素。集合 c 中是否包括该元素 == 删除补集？</span></div><div class="line">                elementData[w++] = elementData[r];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></div><div class="line">        <span class="comment">// even if c.contains() throws.</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (r != size) &#123;<span class="comment">// 此段代码作用为：当 c.contains 抛出异常时（此时 r &lt; size ），保持与 AbstractCollection 的行为兼容性</span></div><div class="line">            System.arraycopy(elementData, r,</div><div class="line">                    elementData, w,</div><div class="line">                    size - r);<span class="comment">//将后面的元素移动到 w 后面</span></div><div class="line">            w += size - r;<span class="comment">//加上移动的元素数，获取「最后的元素」的下标</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (w != size) &#123;<span class="comment">//清除引用，防止内存泄漏</span></div><div class="line">            <span class="comment">// clear to let GC do its work</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)<span class="comment">//将 w 之后的元素都置为 null</span></div><div class="line">                elementData[i] = <span class="keyword">null</span>;</div><div class="line">            modCount += size - w;</div><div class="line">            size = w;</div><div class="line">            modified = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> modified;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h3><p>注意：从数组中移除元素的操作，也会<strong>导致被移除的元素以后的所有元素的向左移动一个位置</strong>。</p>
<h2 id="查-获取"><a href="#查-获取" class="headerlink" title="查/获取"></a>查/获取</h2><p> 获取此列表中指定位置上的元素。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    checkForComodification();</div><div class="line">    <span class="keyword">return</span> java.util.ArrayList.<span class="keyword">this</span>.elementData(offset + index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结、对比"><a href="#小结、对比" class="headerlink" title="小结、对比"></a>小结、对比</h3><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    checkForComodification();</div><div class="line">    E oldValue = java.util.ArrayList.<span class="keyword">this</span>.elementData(offset + index);</div><div class="line">    java.util.ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h2 id="调整数组容量"><a href="#调整数组容量" class="headerlink" title="调整数组容量"></a>调整数组容量</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">            <span class="comment">// any size if not default element table</span></div><div class="line">            ? <span class="number">0</span></div><div class="line">            <span class="comment">// larger than default for default empty table. It's already</span></div><div class="line">            <span class="comment">// supposed to be at default size.</span></div><div class="line">            : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 内部保证容量，如果 ArrayList 是通过无参构造函数创建的，</div><div class="line"> * 那么第一次 add 元素的时候就会调用该方法扩容</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 确保分配指定的容量</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">//如果指明的最小容量超过数组的长度，就增大容量</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次数组容量的增长大约是其原容量的 1.5 倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造 ArrayList 实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用 ensureCapacity 方法来手动增加 ArrayList 实例的容量。</p>
<h3 id="「压缩」"><a href="#「压缩」" class="headerlink" title="「压缩」"></a>「压缩」</h3><p>   ArrayList 还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过 trimToSize 方法来实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将 ArrayList 的容量压缩到当前元素数量，这样可以最大限度节省空间</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;<span class="comment">//定义与父类 AbstractList 中，记录发生结构化修改的次数。如果不打算提供「快速失败的迭代器」，可忽略此域</span></div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">        elementData = (size == <span class="number">0</span>)</div><div class="line">                ? EMPTY_ELEMENTDATA</div><div class="line">                : Arrays.copyOf(elementData, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h2><p>ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考我之前的文章<a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="noopener">深入 Java 集合学习系列：HashMap 的实现原理</a> 中的 Fail-Fast 机制。</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。   <ul>
<li>在 java.util 包下的都是快速失败。</li>
</ul>
</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。<ul>
<li>在 java.util.concurrent 包下的全是安全失败的。</li>
</ul>
</li>
</ul>
<p>即 抛异常是快速失败（util 包下都是快速失败），不抛异常是安全失败。 Java 版本越往后越「安全」，concurrent 包下面全部为<strong>安全失败</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到核心操作在于增加和删除元素。</p>
<ol>
<li>增删改查中， 增导致<strong>扩容</strong>，则<strong>会修改 modCount</strong>，<strong>删一定会修改</strong>。 <strong>改和查一定不会修改 modCount</strong>。</li>
<li>扩容操作会导致数组复制，<strong>批量删除会导致找出两个集合的交集，以及数组复制操作</strong>，因此，增、删都相对低效。 而 改、查都是很高效的操作。</li>
<li>因此，结合特点，在使用中，以 Android 中最常用的展示列表为例，列表滑动时需要展示每一个 Item（element）的数组，<strong>所以 查 操作是最高频的</strong>。相对来说，<strong>增操作只有在列表加载更多时才会用到</strong> ，而且是在列表尾部插入，所以也不需要移动数据的操作。而删操作则更低频。 故选用 ArrayList 作为保存数据的结构。</li>
<li>和<code>Vector</code>的区别，Vector<code>内部也是数组实现的，区别在于</code>Vector<code>在 API 上都加了</code>synchronized<code>所以它是线程安全的，以及</code>Vector<code>扩容时，是翻倍 size，而</code>ArrayList`是扩容 50%。</li>
</ol>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://blog.csdn.net/zxt0601/article/details/77281231" target="_blank" rel="noopener">面试必备：ArrayList 源码解析（JDK8）</a></li>
<li><a href="http://zhangshixi.iteye.com/blog/674856" target="_blank" rel="noopener">深入 Java 集合学习系列：ArrayList 的实现原理</a></li>
<li><a href="http://yikun.github.io/2015/04/04/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java ArrayList 工作原理及实现</a></li>
</ul>
<p>若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> java集合框架 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> java集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的装饰者模式]]></title>
      <url>https://timlin-pro.github.io/blog/2017/09/05/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="装饰者模式的定义"><a href="#装饰者模式的定义" class="headerlink" title="装饰者模式的定义"></a>装饰者模式的定义</h2><p>装饰模式（Decorator Pattern） 也称<strong>包装模式</strong>（Wrapper Pattern），是结构型设计模式之一，使用一种对客户端透明的方式来<strong>动态地拓展对象的功能</strong>，同时它也是继承关系的一种替代方案之一。</p>
<p>通过装饰者模式可以动态地给一个对象添加一些额外的职责。就增加功能而言，装饰模式相比生成子类更灵活。因为它装饰者持有一个被装饰者的引用，因此可以方便地调用具体被装饰者对象中的方法，因此可以在不破坏原类层次结构的情况下为类增加一些功能，我们只需要在被装饰者对象的相应方法前后增加相应的功能逻辑即可。</p>
<a id="more"></a>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要透明且动态地拓展类的功能时。</p>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/30046081-a4423c2c-923a-11e7-9dad-170e000c5ece.png" alt="decorator uml"></p>
<ul>
<li>Component  抽象组件<ul>
<li>可以是接口或者抽象类，充当一个被装饰的原始对象。（在该模式中位于继承结构的顶部，大家都直接/间接地继承它）</li>
</ul>
</li>
<li>ConcreteComponent 组件具体实现类<ul>
<li>该类是 Component 类的具体实现，也是我们装饰的具体对象。</li>
</ul>
</li>
<li>Decorator  抽象装饰者<ul>
<li>继承自 Component 并且<strong>必须持有一个指向 Component 的引用</strong></li>
<li>通常会在其方法中调用 ConcreteComponent 的方法。</li>
<li>如果装饰逻辑单一，可以直接省略该类，直接写一个具体的装饰者对象即可。</li>
</ul>
</li>
<li>ConcreteDecoratorA,B,C<ul>
<li>继承自 Decoration， 在父类对 Component 的方法调用基础上上，增加自己的一些功能。（通常都是在基础方法执行前或者后调用自己新增的方法）</li>
</ul>
</li>
</ul>
<p>使用时经常会把 ComponentImpl 或者说 ConcreteComponent 传入给具体的 Decorator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Compoent component = <span class="keyword">new</span> ConponentImpl();</div><div class="line">DecoratorImpl decoratorImpl = <span class="keyword">new</span> DecoratorImpl(component);</div><div class="line">decoratorImpl.xxOperation();</div></pre></td></tr></table></figure>
<h2 id="Android-源码中的模式实现"><a href="#Android-源码中的模式实现" class="headerlink" title="Android 源码中的模式实现"></a>Android 源码中的模式实现</h2><p><img src="https://user-images.githubusercontent.com/16668676/30047048-b4aeb6e2-9241-11e7-9a04-b11bb1acdc44.png" alt="context"></p>
<p>角色简介：</p>
<ul>
<li>Context ：抽象组件</li>
<li>ComtextImpl ：Context 的具体实现类</li>
<li>ContextWrapper ：装饰者的父类（其中的所有方法都只是调用了 ContextImpl 中对应的方法）</li>
<li>ContextThemeWrapper ：继承自 ContextWrapper  的装饰者</li>
<li>Activity ：继承自 ContextThemeWrapper 的装饰者</li>
</ul>
<p>我们以常用的方法为例，看看装饰者模式在其中的具体实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    Context mBase;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="comment">//启动 Activity</span></div><div class="line">   <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</div><div class="line">        mBase.startActivity(intent, options);</div><div class="line">    &#125;</div><div class="line">  	</div><div class="line">    <span class="comment">//发送广播</span></div><div class="line">    <span class="meta">@SystemApi</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent, String receiverPermission, Bundle options)</span> </span>&#123;</div><div class="line">        mBase.sendBroadcast(intent, receiverPermission, options);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">//注册监听器</span></div><div class="line">      <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></div><div class="line">        BroadcastReceiver receiver, IntentFilter filter) &#123;</div><div class="line">        <span class="keyword">return</span> mBase.registerReceiver(receiver, filter);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上的代码中可以看出，ContextWrapper 作为装饰者的父类，持有 Context 的引用 mBase（mBase 的实际类型为 ContextImpl），其中的所有方法都只是调用了 ContextImpl 中对应的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">     <span class="comment">//启动 Activity 的逻辑实现</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        startActivity(intent, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line"></div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line">        <span class="comment">//调用 Instrumentation.execStartActivity() 方法</span></div><div class="line">        mMainThread.getInstrumentation().execStartActivity(</div><div class="line">                getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</div><div class="line">                (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent, String receiverPermission)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</div><div class="line">        String[] receiverPermissions = receiverPermission == <span class="keyword">null</span> ? <span class="keyword">null</span></div><div class="line">                : <span class="keyword">new</span> String[] &#123;receiverPermission&#125;;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            intent.prepareToLeaveProcess(<span class="keyword">this</span>);</div><div class="line">          	<span class="comment">//调用 AMS 的 broadcastIntent 方法</span></div><div class="line">            ActivityManagerNative.getDefault().broadcastIntent(</div><div class="line">                    mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</div><div class="line">                    Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, receiverPermissions, AppOpsManager.OP_NONE,</div><div class="line">                    <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, getUserId());</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//注册广播的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;  </div><div class="line">   <span class="comment">//注册广播</span></div><div class="line">  	<span class="meta">@Override</span></div><div class="line">  	<span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter,</span></span></div><div class="line">            String broadcastPermission, Handler scheduler) &#123;</div><div class="line">        <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</div><div class="line">                filter, broadcastPermission, scheduler, getOuterContext());</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//注册广播的具体实现</span></div><div class="line">    <span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span></span></div><div class="line">            IntentFilter filter, String broadcastPermission,</div><div class="line">            Handler scheduler, Context context) &#123;</div><div class="line">        IIntentReceiver rd = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = mPackageInfo.getReceiverDispatcher(</div><div class="line">                    receiver, context, scheduler,</div><div class="line">                    mMainThread.getInstrumentation(), <span class="keyword">true</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</div><div class="line">                        receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          	<span class="comment">//调用 AMS 的 registerReceiver 方法</span></div><div class="line">            <span class="keyword">final</span> Intent intent = ActivityManagerNative.getDefault().registerReceiver(</div><div class="line">                    mMainThread.getApplicationThread(), mBasePackageName,</div><div class="line">                    rd, filter, broadcastPermission, userId);</div><div class="line">            <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</div><div class="line">                intent.setExtrasClassLoader(getClassLoader());</div><div class="line">                intent.prepareToEnterProcess();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> intent;</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，ContextImpl 中提供了具体的方法实现。</p>
<p>ContextWrapper 的子类，例如 Activity 会根据需要对具体方法的实现进行装饰或者修改。</p>
<p>比如 startActivity() 方法，Activity 没有使用被装饰者的实现，而是自己实现了一套逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory2</span>,</div><div class="line">        <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</div><div class="line">        <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks2</span>,</div><div class="line">        <span class="title">Window</span>.<span class="title">OnWindowDismissedCallback</span>, <span class="title">WindowControllerCallback</span> &#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">         <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</div><div class="line">                startActivityForResult(intent, -<span class="number">1</span>, options);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Note we want to go through this call for compatibility with</span></div><div class="line">                <span class="comment">// applications that may have overridden the method.</span></div><div class="line">                startActivityForResult(intent, -<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;   </div><div class="line">             </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,@Nullable Bundle options)</span> </span>&#123;</div><div class="line">              <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</div><div class="line">                  options = transferSpringboardActivityOptions(options);</div><div class="line">                  <span class="comment">//调用 Instrumentation.execStartActivity() 方法</span></div><div class="line">                  Instrumentation.ActivityResult ar =</div><div class="line">                      mInstrumentation.execStartActivity(</div><div class="line">                          <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</div><div class="line">                          intent, requestCode, options);</div><div class="line">                <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ContextImpl-的创建"><a href="#ContextImpl-的创建" class="headerlink" title="ContextImpl 的创建"></a>ContextImpl 的创建</h2><p>从上面解析中我们知道 Context 的实现中使用了装饰者模式也知道了 ContextImpl 是 Context 具体实现类，但是 ContextImpl 是在上面地方被初始化的呢？</p>
<p>因为 Activity 启动之后我们便可以调用 Context 中的方法了，我们猜想 ContextImpl 是在 Activity 创建过程中初始化的。</p>
<p>对 Android Framework 层有所了解同学应该知道 Activity 是由 AMS 管理的，AMS 会通过调用 ApplicationThread 与间接地控制 Activity。 ApplicationThread 的 scheduleXxx 方法中会调用 sendMessage 方法将相应的 Message 发送给 H，H 根据不同的 Message 调用 ActivityThread 中相应的 handleXxx 方法。</p>
<p>ActivityThread#H</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</div><div class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</div><div class="line">                <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</div><div class="line">                r.packageInfo = getPackageInfoNoCheck(</div><div class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</div><div class="line">              	<span class="comment">//调用 handleLaunchActivity</span></div><div class="line">                handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</div><div class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">            &#125; <span class="keyword">break</span>;       </div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当需要启动新的 Activity 时，ApplicationThread 的  scheduleLaunchActivity 方法会先被调用，该方法会通过 H 调用 handleLaunchActivity 方法，而 handleLaunchActivity 方法又会调用  performLaunchActivity 方法。</p>
<p>ActivityThread#performLaunchActivity </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">//代码省略</span></div><div class="line">    Activity activity = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">      	<span class="comment">//创建 Activity</span></div><div class="line">        activity = mInstrumentation.newActivity(</div><div class="line">                cl, component.getClassName(), r.intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">          	<span class="comment">//获取 Context</span></div><div class="line">            Context appContext = createBaseContextForActivity(r, activity);</div><div class="line">			<span class="comment">//将前面准备的值关联到 Activity 中</span></div><div class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window);</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ActivityThread#createBaseContextForActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">final</span> Activity activity)</span> </span>&#123;</div><div class="line">    ContextImpl appContext = ContextImpl.createActivityContext(<span class="comment">//调用 ContextImpl 的静态方法创建 Activity Context</span></div><div class="line">            <span class="keyword">this</span>, r.packageInfo, r.token, displayId, r.overrideConfig);</div><div class="line">    appContext.setOuterContext(activity);<span class="comment">//外部的 context（此处为 Activity）设置给 ContextImpl</span></div><div class="line">    Context baseContext = appContext;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    <span class="keyword">return</span> baseContext;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContextImpl#createActivityContext()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createActivityContext</span><span class="params">(ActivityThread mainThread,</span></span></div><div class="line">        LoadedApk packageInfo, IBinder activityToken, <span class="keyword">int</span> displayId,</div><div class="line">        Configuration overrideConfiguration) &#123;</div><div class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"packageInfo"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread, packageInfo, activityToken, <span class="keyword">null</span>, <span class="number">0</span>,</div><div class="line">            <span class="keyword">null</span>, overrideConfiguration, displayId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过上面的分析，我们可以得出结论，Activity 的 Context 是在 performLaunchActivity 方法中通过调用 createBaseContextForActivity  初始化的。在 createBaseContextForActivity 方法中，通过调用 ContextImpl 的静态方法 createActivityContext 创建 获取一个 ContextImpl 的实例对象，并通过 setOuterContext 方法将两者建立关联。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学过代理模式的同学可能觉得装饰模式与代理模式有点像（因为同样持有引用）。但是既然是它们是两个不同的设计模式，先看看它们各自的定义。</p>
<p>装饰模式：以对客户端透明的方式<strong>扩展对象的功能</strong>，是<strong>继承关系的一个替代方案</strong>；<br>代理模式：给一个对象提供一个代理对象，并<strong>由代理对象来控制对原有对象的引用</strong>；</p>
<p>光看定义可能还是比较模糊。二者<strong>区别</strong>在哪里呢？</p>
<ul>
<li>装饰模式应该为所装饰的对象<strong>增强功能</strong></li>
<li>代理模式对代理的对象施加控制，但<strong>不对对象本身的功能进行增强</strong>。</li>
</ul>
<p>可以简单地理解为：你在一个地方写装饰，大家就知道这是在增加功能，你写代理，大家就知道是在限制。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> Android 进阶 </category>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android 进阶 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的享元模式——Message 复用原理]]></title>
      <url>https://timlin-pro.github.io/blog/2017/08/26/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Message%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>享元模式是对象池的一种实现，它的英文名为 Flyweight，代表轻量级的意思。</p>
<p>享元模式用来尽可能==减少内存使用量==，它适合用于可能存在大量对象的场景，来==缓存可共享的对象==（例如 Message、Java 中的字符串常量池）,从而实现对象共享、避免创建过多对象的效果，这样一来就可以提升性能，避免内存移除等。</p>
<p>享元模式中的部分状态是可以共享的，</p>
<ul>
<li>可以共享的状态称为<strong>内部状态</strong>。内部状态不会随着环境变化</li>
<li>不可共享的状态则称之为<strong>外部状态</strong>，他们会随着环境的改变而改变。</li>
</ul>
<p>享元模式会建立一个<strong>对象容器</strong>，在经典的享元模式中，该容器为一个 Map，它的键是享元对象的内部状态，它的值就是享元对象本身。</p>
<a id="more"></a>
<h2 id="享元模式的定义"><a href="#享元模式的定义" class="headerlink" title="享元模式的定义"></a>享元模式的定义</h2><p>享元模式是一种结构型设计模式，以共享的方式高效地支持大量的细粒度对象。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>系统中存在<strong>大量的相似对象</strong></li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要<strong>缓冲池</strong>的场景。</li>
</ol>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29702859-ac3f4f5c-89a5-11e7-92cd-2c26051b399f.png" alt="flyweight uml"></p>
<ul>
<li><strong>Flyweight</strong> ：享元对象抽象基类或者接口。</li>
<li><strong>ConcreteFlyweight</strong>：具体享元对象。</li>
<li><strong>FlyweightFactory</strong> ：享元工厂，负责创建享元对象和管理享元对象池。</li>
</ul>
<h2 id="Android-源码中的享元模式"><a href="#Android-源码中的享元模式" class="headerlink" title="Android 源码中的享元模式"></a>Android 源码中的享元模式</h2><p>在使用 Handler 发送消息之前，我们一般都会使用如下代码调用 <code>mHandler.obtainMessage()</code> 方法获取一个 Message 对象。这其中究竟是怎么实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Handler mHandler = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//do sth</span></div><div class="line">            Message message = mHandler.obtainMessage();</div><div class="line">            message.what = <span class="number">1</span>;</div><div class="line">            message.obj = result;</div><div class="line">            mHandler.sendMessage(message);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Handler.otainMessage()方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Handler.obtainMessage() 实际上调用的是 Message 的 obtain 方法，我们顺着源码看下去。</p>
<p>先看看 Message 类部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sometimes we store linked lists of these things</span></div><div class="line">Message next;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//作为锁对象</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//虽然名称为 sPool 但是实际上是一个指向消息队列队首的指针</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//「对象池」中的最大数量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</div><div class="line">    Message m = obtain();<span class="comment">//调用 obtain 方法获取 message 对象</span></div><div class="line">    m.target = h;<span class="comment">//指定 message 的目标对象</span></div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从消息对象池中取出一个 Message 对象，如果没有就创建一个</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</div><div class="line">            Message m = sPool;</div><div class="line">            sPool = m.next;</div><div class="line">            m.next = <span class="keyword">null</span>;</div><div class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清空 in-use flag</span></div><div class="line">            sPoolSize--;</div><div class="line">            <span class="keyword">return</span> m;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">//消息池中没有可复用的 Message 就创建一个新的 Message</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，从对象池中获取对象的大致流程。无论是 Handler.obtainMessage(参数列表) 方法，还是 Message 的 obtain(参数列表) 方法，最终都会调用 Message.obtain() 方法。在 Message.obtain() 方法的实现中，会先从对象池中获取 Message 对象，如果获取不到，则创建一个新的 Message 对象，然后返回。该对象在后续的执行过程中会被回收到对象池，以便复用。</p>
<p>但是 Message 对象是如何被回收到「对象池」中的呢？    从 Message 类的部分代码中我们看到 sPool 的实际类型是一个 Message 对象，而不是一个容器。另外从 obtain 方法中我们不难看到链表的踪影。难道消息池是使用链表实现的吗？</p>
<p>在 AS 中打开 Message 类的结构图，可以看到其中有一个 recycle 方法，我们看看里面是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isInUse()) &#123;<span class="comment">//判断消息是否还在使用</span></div><div class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;<span class="comment">//如果消息处在使用状态时被 gc 回收，就抛出异常</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span> + <span class="string">"is still in use."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;<span class="comment">//直接返回，取消回收操作</span></div><div class="line">    &#125;</div><div class="line">    recycleUnchecked();<span class="comment">//调用回收方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 回收一个可能还在使用的对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 只要该对象还在回收对象池中，就标记该对象为正在使用状态。</span></div><div class="line">    <span class="comment">// 清空其他状态</span></div><div class="line">    flags = FLAG_IN_USE;</div><div class="line">    what = <span class="number">0</span>;</div><div class="line">    arg1 = <span class="number">0</span>;</div><div class="line">    arg2 = <span class="number">0</span>;</div><div class="line">    obj = <span class="keyword">null</span>;</div><div class="line">    replyTo = <span class="keyword">null</span>;</div><div class="line">    sendingUid = -<span class="number">1</span>;</div><div class="line">    when = <span class="number">0</span>;</div><div class="line">    target = <span class="keyword">null</span>;</div><div class="line">    callback = <span class="keyword">null</span>;</div><div class="line">    data = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//回收消息到消息池中</span></div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">            next = sPool;</div><div class="line">            sPool = <span class="keyword">this</span>;</div><div class="line">            sPoolSize++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>recycle 方法首先会判断 Message 对象是否处在使用状态。如果处在使用状态会直接返回（如果此时 GC 回收该对象会抛出异常），否则调用 recycleUnchecked 方法，具体的回收逻辑是在 recycleUnchecked  方法中实现的。首先会标记 Message 处于使用状态，然后清空对象中的其他状态。将消息存入回收池，主要是链表的操作。大致如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29739978-6c03d780-8a7e-11e7-8aad-3da3590c2ea1.png" alt="msg"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Message 通过在内部构建一个链表来维护一个被会受到  Message 对象的对象池，当用户调用 obtain 方法时，会优先从池中获取。如果池中没有可以复用的对象就创建一个新的对象，该对象使用完之后，会被缓存到对象池中，当下次调用 obtain 方法时，他们就会被复用。</p>
<p>此处 Message 扮演了三个角色。既是 FlyWeight 抽象，又是 ConcreteFlyWeight 对象，同时还担任 FlyWeightFactory 角色，承担着管理对象池的职责。</p>
<p>想进一步了解 Android 消息机制的同学可参考<a href="https://ivanljt.github.io/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Android 消息机制解析</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>享元模式的优点：</p>
<ul>
<li>大幅度降低了内存中对象的数量。从而降低了内存的占用，提高了程序的性能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使得系统更加复杂。为了使应用能够共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li>
<li>享元模式将状态外部化，而读取外部状态使得<strong>运行时间稍微变长</strong></li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" target="_blank" rel="noopener">《JAVA 与模式》之享元模式</a></li>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="https://ivanljt.github.io/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Android 消息机制解析</a></li>
</ul>
<p>若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> Android 进阶 </category>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android 进阶 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的模板方法模式——AsyncTask解析]]></title>
      <url>https://timlin-pro.github.io/blog/2017/08/24/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AsyncTask%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，<strong>某些步骤的具体实现是未知的</strong>，或者说某些步骤的实现是会<strong>随着环境的变化而改变的</strong>。<br>就好像执行程序的流程：</p>
<ol>
<li>检查代码的正确性</li>
<li>链接相关代码</li>
<li>编译相关代码</li>
<li>执行程序</li>
</ol>
<p>对于不同的语言，上述 4 个步骤都是不一样的，但是它们的执行流程是固定的，这类问题的解决方案就是我们介绍的模板方法模式。</p>
<a id="more"></a>
<h2 id="模板方法模式的定义"><a href="#模板方法模式的定义" class="headerlink" title="模板方法模式的定义"></a>模板方法模式的定义</h2><p>定义一个操作中的<strong>算法的框架</strong>，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<h2 id="模板方法模式的使用场景"><a href="#模板方法模式的使用场景" class="headerlink" title="模板方法模式的使用场景"></a>模板方法模式的使用场景</h2><ol>
<li>多个子类有公有的方法，并且逻辑基本相同时。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，把相同的代码抽取到父类中，然后通过<strong>钩子方法</strong>约束其行为。</li>
</ol>
<h3 id="注：何谓钩子方法？"><a href="#注：何谓钩子方法？" class="headerlink" title="注：何谓钩子方法？"></a>注：何谓钩子方法？</h3><p>基本方法又可以分为三种：抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。</p>
<p>这是《java与模式》书里的一种说法，三种方法也是在书中的模板方法模式中提及到的。</p>
<p>先说这个三个方法的基本定义：</p>
<ul>
<li>抽象方法：由抽象类声明，由具体子类实现。在java语言里一个抽象方法以abstract关键字标示出来。</li>
<li>具体方法：由抽象类声明并实现，而子类并不实现或覆盖。其实就是<strong>一般的方法</strong>，但是不需要子类来实现。</li>
<li>钩子方法：由抽象类<strong>声明并实现</strong>，而子类也会加以扩展。通常抽象类给出的是一个空的钩子方法，也就是方法体为空的方法（也可以根据需要实现部分逻辑）。其实它和具体方法在代码上没有区别，不过是意识上的一种区别。</li>
</ul>
<p>详见<a href="https://www.the5fire.com/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95-%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">抽象方法 具体方法 钩子方法</a></p>
<h2 id="模板方法模式的-UML-类图"><a href="#模板方法模式的-UML-类图" class="headerlink" title="模板方法模式的 UML 类图"></a>模板方法模式的 UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29603702-be32185a-8817-11e7-95f3-9cf7ee08c644.png" alt="template method pattern"></p>
<ul>
<li>AbsTemplate：抽象类，定义一套算法框架</li>
<li>ConcreteImplA：具体实现类 A</li>
<li>ConcreteImplB：具体实现类 B</li>
</ul>
<h2 id="模板方法模式的简单示例"><a href="#模板方法模式的简单示例" class="headerlink" title="模板方法模式的简单示例"></a>模板方法模式的简单示例</h2><p>实际上是封装一个固定流程，就像是一套执行模板一样，第一步该做什么，第二步该做什么都已经在抽象类中定义好。而子类可以有不同的算法实现，在框架不被修改的情况下实现某些步骤的算法替换。</p>
<h2 id="Android-源码中的模板方法模式"><a href="#Android-源码中的模板方法模式" class="headerlink" title="Android 源码中的模板方法模式"></a>Android 源码中的模板方法模式</h2><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>使用过 AsyncTask 的同学都知道，我们调用 execute 之后，（如果没有调用 cancel 方法的话）以下三个方法会依次执行：</p>
<ul>
<li>onPreExecute</li>
<li>doInBackground </li>
<li>onPostExecute</li>
</ul>
<p>为什么能让它们依次执行呢？其内部是怎么实现的？我们看看源码，一探究竟。</p>
<p>首先看看异步任务的入口方法 execute。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上两个构造方法中主要做了如下几件事：</p>
<ul>
<li>状态判断</li>
<li>判断之后执行 <code>onPreExecute();</code></li>
<li>使用线程池执行 mFuture<ul>
<li>什么样的线程池？<ul>
<li>默认为 SerialExecutor 即单线程的线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Result result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);<span class="comment">//设置进程优先级</span></div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                result = doInBackground(mParams);<span class="comment">//调用 doInBackground 方法</span></div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">                mCancelled.set(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">throw</span> tr;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postResult(result);<span class="comment">//调用 postResult 方法</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());<span class="comment">//任务完成</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div></pre></td></tr></table></figure>
<ul>
<li>mWorker 类型为 <code>WorkerRunnable&lt;Params, Result&gt;</code> ， WorkerRunnable 实现了 Callable</li>
<li>mFuture 类型为 <code>FutureTask&lt;Result&gt;</code></li>
</ul>
<p>简而言之，这个 mFuture 包装了这个 mWorker 对象，而 mFuture 是在线程池中执行的，会调用 mFuture 的 run 方法，该 run 方法中调用了 mWorker 的 call 方法，mWorker 的 call 方法又调用了 doInBackground 方法，所以 doInBackground 是在工作线程执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</div><div class="line">    <span class="keyword">if</span> (!wasTaskInvoked) &#123;</div><div class="line">        postResult(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doInBackground</code> 执行完成后会通过 <code>postResult(result)</code> 方法将结果传递给主线程。</p>
<ul>
<li><code>postResult(result)</code> 可能通过 call 方法的 finally 块直接调用或者通过 FutureTask 中的 done 方法里面的 <code>postResultIfNotInvoked(get());</code> 来间接调用。</li>
</ul>
<p>接下来我们看看 <code>postResult(result)</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// 调用 AsyncTask 的 finish 方法</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>postResult(result)</code>  方法就是通过发送一条消息（msg.what == MESSAGE_POST_RESULT）给 sHandler，sHandler 为 InternalHanlder。当 InternalHanlder 接收到 MESSAGE_POST_RESULT 时，就会调用 <code>result.mTask.finish(result.mData[0])</code> 方法，result 的类型为 AsyncTaskResult</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">    <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">        mTask = task;</div><div class="line">        mData = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 AsyncTaskResult 的具体实现中吗，我们知道 mTask 就是 AsyncTask，finish 方法中又调用了 <code>onPostExecute</code> ，此时整个执行流程就完成了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>execute 方法内部封装了 onPreExecute、doInBackGround、onPostExecute 这个逻辑流程。<br>通过这种方式，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时的操作及更新 UI。实际上就是通过线程池来执行耗时的任务，得到结果之后，通过 Handler 将结果传递给 UI 线程执行。</p>
<h3 id="Activity-的生命周期函数"><a href="#Activity-的生命周期函数" class="headerlink" title="Activity 的生命周期函数"></a>Activity 的生命周期函数</h3><p>除了 AsyncTask 以外，Android 源码中还有不少地方有模板方法的身影，比如说 Activity 的生命周期方法—— onCreate 、onStart、onResume 等，都是按照顺序调用的，我们会在对应的方法中执行合适的操作。</p>
<p>其内部实现涉及到进程间通信，限于篇幅，本文不作深入介绍。有兴趣的同学可以看看 ActivityThread 的 main 方法，以之作为入口，对生命周期方法的调用时机做进一步研究。</p>
<h2 id="模板方法总结"><a href="#模板方法总结" class="headerlink" title="模板方法总结"></a>模板方法总结</h2><p>简单概括模板方法模式就是流程封装。把某一个固定的流程封装到一个固定的 final 方法中。并且让子类能够定制这个过程中的某些甚至所有步骤，这就要求父类提取共用的代码，提升代码的复用率，同时也带来了更高的可扩展性。</p>
<ul>
<li>优点：<ul>
<li>封装不变的部分，扩展可变的部分</li>
<li>提取公共部分代码，便于维护。</li>
</ul>
</li>
<li>缺点：<ul>
<li>提高了代码阅读的难度，会让用户觉得难以理解</li>
</ul>
</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="https://www.the5fire.com/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95-%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95.html" target="_blank" rel="noopener">抽象方法 具体方法 钩子方法</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> Android 进阶 </category>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android 进阶 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[行为型设计模式之备忘录模式]]></title>
      <url>https://timlin-pro.github.io/blog/2017/08/21/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="备忘录模式的定义"><a href="#备忘录模式的定义" class="headerlink" title="备忘录模式的定义"></a>备忘录模式的定义</h2><p>备忘录模式是一种<strong>行为型设计模式</strong>，该模式用于保存对象当前的状态，并且在之后可以再次恢复到此状态。</p>
<p>实现效果为：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便后续将对象恢复到原来的状态。</p>
<h2 id="备忘录模式的使用场景"><a href="#备忘录模式的使用场景" class="headerlink" title="备忘录模式的使用场景"></a>备忘录模式的使用场景</h2><ol>
<li>需要保存一个对象在某一个时刻的状态或部分状态</li>
<li>一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。（如果使用接口来让其他对象获取对象的状态，会破坏封装性）</li>
</ol>
<a id="more"></a>
<h2 id="备忘录模式的UML类图"><a href="#备忘录模式的UML类图" class="headerlink" title="备忘录模式的UML类图"></a>备忘录模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29518826-890e58e8-86ad-11e7-9ce8-90ff79fcc071.png" alt="memoto pattern"></p>
<p>三个角色：</p>
<ul>
<li>Originator：需要保存状态的对象。负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。</li>
<li>Memento（类似于 pojo 类）备忘录角色。用于存储 Originator 内部状态，并且可以防止 Originator 以外的对象访问 Memento</li>
<li>Caretaker：负责存储备忘录，不能对<strong>备忘录的内容</strong>进行操作和访问，只能将备忘录传递给其他对象。</li>
</ul>
<h2 id="Android源码中的备忘录模式"><a href="#Android源码中的备忘录模式" class="headerlink" title="Android源码中的备忘录模式"></a>Android源码中的备忘录模式</h2><p>日常开发中如果需要保存什么数据以防止 Activity 意外销毁，第一时间会想到 Activity 中的这两个方法——<code>onSaveInstanceState</code>、<code>onRestoreInstanceState</code>。其内部具体是如何实现数据保存的呢？</p>
<p>先透漏一下，这里面使用到了备忘录模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 存储窗口的视图树的状态</span></div><div class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</div><div class="line">    <span class="comment">//2. 存储 Fragment 中的状态    </span></div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//3. 若用户设置了 Activity 的 ActivityLifeCycleCallbacks，</span></div><div class="line">    <span class="comment">//则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。</span></div><div class="line">    getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Activity.onSaveInstanceState 方法中主要做了三件事</p>
<ol>
<li>存储窗口的视图树的状态</li>
<li>存储 Fragment 中的状态</li>
<li>若用户设置了 Activity 的 ActivityLifeCycleCallbacks，则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。</li>
</ol>
<p>首先看看步骤 1，该步骤将 Window 对象中的视图树中的各个 View 状态存储到 Bundle 中。</p>
<p>Window 的具体实现在 <code>PhoneWindow</code> 中.以下为 <code>PhoneWindow.saveHierarchyState</code> 的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">saveHierarchyState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Bundle outState = <span class="keyword">new</span> Bundle();</div><div class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> outState;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// SparseArray 相当于一个 key 为 整型的 map</span></div><div class="line">    SparseArray&lt;Parcelable&gt; states = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">    <span class="comment">//此处的 mContentParent 就是我们 setContentView 时设置的 View</span></div><div class="line">    mContentParent.saveHierarchyState(states);</div><div class="line">    outState.putSparseParcelableArray(VIEWS_TAG, states);</div><div class="line"></div><div class="line">    <span class="comment">// 持有焦点的 View 必须设置 id，否则重新进入该界面时不会恢复它的焦点状态</span></div><div class="line">    <span class="keyword">final</span> View focusedView = mContentParent.findFocus();</div><div class="line">    <span class="keyword">if</span> (focusedView != <span class="keyword">null</span> &amp;&amp; focusedView.getId() != View.NO_ID) &#123;</div><div class="line">        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 存储整个面板的状态</span></div><div class="line">    SparseArray&lt;Parcelable&gt; panelStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">    savePanelState(panelStates);</div><div class="line">    <span class="keyword">if</span> (panelStates.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">        outState.putSparseParcelableArray(PANELS_TAG, panelStates);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 保存 actionbar 的状态</span></div><div class="line">    <span class="keyword">if</span> (mDecorContentParent != <span class="keyword">null</span>) &#123;</div><div class="line">        SparseArray&lt;Parcelable&gt; actionBarStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</div><div class="line">        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> outState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看步骤 2 中的 <code>mContentParent.saveHierarchyState</code> 方法，mContentParent 是一个 ViewGroup 但是 saveHierarchyState 方法并不是定义在 ViewGroup 中，而是定义在它的父类——View 中，查看下该方法在 View 中的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveHierarchyState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    dispatchSaveInstanceState(container);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 只有含有 id 的 View，状态才会被存储</span></div><div class="line">    <span class="keyword">if</span> (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == <span class="number">0</span>) &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">        <span class="comment">//2. 调用 onSaveInstanceState 方法获取自身状态</span></div><div class="line">        Parcelable state = onSaveInstanceState();</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Derived class did not call super.onSaveInstanceState()"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//3. 将自身状态存放到 container 中</span></div><div class="line">        <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">            container.put(mID, state);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>View.onSaveInstanceState</code> 方法默认存储的状态为空状态。但是它的子类通常都有定义自身的覆盖方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</div><div class="line">    <span class="keyword">if</span> (mStartActivityRequestWho != <span class="keyword">null</span>) &#123;</div><div class="line">        BaseSavedState state = <span class="keyword">new</span> BaseSavedState(AbsSavedState.EMPTY_STATE);</div><div class="line">        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> BaseSavedState.EMPTY_STATE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤 2 中的 View 的调用大致如下：saveHierarchyState ==》 dispatchSaveInstanceState ==》 onSaveInstanceState</p>
<ul>
<li>其中要注意的是 只有含有 id 的 View，状态才会被存储，如果没有给 view 赋一个 id，那么系统是不会帮忙保存该 view 的状态的。</li>
</ul>
<p>View 类中的 saveHierarchyState 方法调用了dispatchSaveInstanceState 方法用来存储自身状态。 ViewGroup 覆写了 dispatchSaveInstanceState 来存储自身以及子视图的状态。 </p>
<p><code>ViewGroup.dispatchSaveInstanceState</code>具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.dispatchSaveInstanceState(container);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;<span class="comment">//遍历调用子 View 的 dispatchSaveInstanceState 方法</span></div><div class="line">        View c = children[i];</div><div class="line">        <span class="keyword">if</span> ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</div><div class="line">            c.dispatchSaveInstanceState(container);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 ViewGroup 的 <code>dispatchSaveInstanceState</code> 方法会先调用 <code>super.dispatchSaveInstanceState(container);</code> 存储自身的状态。然后遍历调用所有子视图的 <code>dispatchSaveInstanceState(container)</code> 方法来保存它们的状态，如果子 View 也是一个 ViewGroup，则会再次执行这个过程。</p>
<hr>
<p>我们以 TextView 的 saveInstanceState 方法为例，看看具体的控件是如何保存自身状态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</div><div class="line"></div><div class="line">    <span class="comment">// Save state if we are forced to</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> freezesText = getFreezesText();</div><div class="line">    <span class="keyword">boolean</span> hasSelection = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> start = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = -<span class="number">1</span>;</div><div class="line">    <span class="comment">//存储 TextView 的 start、end </span></div><div class="line">    <span class="keyword">if</span> (mText != <span class="keyword">null</span>) &#123;</div><div class="line">        start = getSelectionStart();</div><div class="line">        end = getSelectionEnd();</div><div class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span> || end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 是否存存在选项</span></div><div class="line">            hasSelection = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (freezesText || hasSelection) &#123;</div><div class="line">        SavedState ss = <span class="keyword">new</span> SavedState(superState);</div><div class="line">        <span class="comment">//保存 TextView 的文本内容</span></div><div class="line">        <span class="keyword">if</span> (freezesText) &#123;</div><div class="line">            <span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spanned) &#123;</div><div class="line">                <span class="keyword">final</span> Spannable sp = <span class="keyword">new</span> SpannableStringBuilder(mText);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">                    removeMisspelledSpans(sp);</div><div class="line">                    sp.removeSpan(mEditor.mSuggestionRangeSpan);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ss.text = sp;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ss.text = mText.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储 TextView 的 start、end </span></div><div class="line">        <span class="keyword">if</span> (hasSelection) &#123;</div><div class="line">            <span class="comment">// XXX Should also save the current scroll position!</span></div><div class="line">            ss.selStart = start;</div><div class="line">            ss.selEnd = end;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isFocused() &amp;&amp; start &gt;= <span class="number">0</span> &amp;&amp; end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            ss.frozenWithFocus = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ss.error = getError();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">            ss.editorState = mEditor.saveInstanceState();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回状态对象</span></div><div class="line">        <span class="keyword">return</span> ss;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> superState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 View 的 onSaveInstance 函数之后就得到了 View 要存储的数据，此时执行到 View 的  dispatchSaveInstanceState 方法中的注释 3。这里以 View 的 id 为 key，以状态为 value，存储到 container（ SparseArray 类型）中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3. 将自身状态存放到 container 中</span></div><div class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">    container.put(mID, state);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>存储完 Window 的视图状态信息之后，便会执行存储 Fragment 中的状态信息、回退栈等。Fragment  也是通过调用自身的 onSaveInstaceState 方法来存储自身的 View 视图树状态的。</li>
<li>最后就是调用用户设置的 ActivityLifecycleCallbacks 的 onSaveInstaceState 方法，让用户做一些额外的处理</li>
</ul>
<p>前面我们所提及到的只是备忘录模式中的 Originator 角色，即需要保存备忘录的对象。不过也有涉及到 CareTaker 角色——Activity。下面我们再看看另外两个角色——Memoto 和 CareTaker。</p>
<p>存了状态信息的 Bundle 数据存储在哪？</p>
<ul>
<li>onSaveInstance 方法是在 onStop 方法之前调用的。Activity.onStop 方法是通过 Activity 的 performStopActivity 间接调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</div><div class="line">    <span class="comment">//获取 ActivityClientRecord</span></div><div class="line">    ActivityClientRecord r = mActivities.get(token);</div><div class="line">    <span class="comment">// saveState 表示是否保存状态</span></div><div class="line">    performStopActivityInner(r, <span class="keyword">null</span>, <span class="keyword">false</span>, saveState, reason);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r,</span></span></div><div class="line">        StopInfo info, <span class="keyword">boolean</span> keepShown, <span class="keyword">boolean</span> saveState, String reason) &#123;</div><div class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!keepShown &amp;&amp; r.stopped) &#123;</div><div class="line">            <span class="keyword">if</span> (r.activity.mFinished) &#123;</div><div class="line">                <span class="comment">// 如果正在执行销毁过程，是用户主动销毁。 activity 不打算恢复，我们也没必要调用 onStop 方法</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 在调用 onStop 之前必须先调用 onPause </span></div><div class="line">        performPauseActivityIfNeeded(r, reason);</div><div class="line"></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="comment">// 接下来让 activity 保存它目前的状态和它所管理的 dialogs </span></div><div class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; saveState) &#123;</div><div class="line">            <span class="keyword">if</span> (r.state == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 间接调用 Activity.onSaveInstance()</span></div><div class="line">                callCallActivityOnSaveInstanceState(r);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!keepShown) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 执行 onStop 方法</span></div><div class="line">                r.activity.performStop(<span class="keyword">false</span> <span class="comment">/*preserveWindow*/</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//将 stop 字段置为 true 表示已经调用了 stop 方法。</span></div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callCallActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</div><div class="line">    r.state = <span class="keyword">new</span> Bundle();<span class="comment">//内容就存储在该 Bundle 中</span></div><div class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</div><div class="line">                r.persistentState);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//该方法实际调用了 Activity.onSaveInstanceState 方法</span></div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(Activity activity, Bundle outState,</span></span></div><div class="line">        PersistableBundle outPersistentState) &#123;</div><div class="line">    activity.performSaveInstanceState(outState, outPersistentState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 performStopActivity 与 performStopActivityInner 方法中，首先通过 token 从 mActivities 中获取一个 ActivityClientRecord 对象，状态信息就是存储在这里面的。获取该对象之后，调用了 performStopActivityInner 方法，对于保存状态而言，该方法大概有如下三步</p>
<ol>
<li>判断 Activity 是否需要保存状态</li>
<li>如果需要，则调用 onSaveInstance 方法，该方法会将状态信息存储到 ActivityClientRecord 中</li>
<li>调用 <code>Activity.onStop()</code> 方法</li>
</ol>
<p>执行 onStop 方法之前，系统会根据情况来选择是否存储 Activity 的状态，并且将这些状态（简介地）存储到 mActivities 中。</p>
<p>mActivities 是一个 <code>ArrayMap&lt;IBinder, ActivityClientRecord&gt;</code> ，它维护了一个 Activity 的信息表，当 Activity 重新启动时，会从 mActivities 中查询对应的 ActivityClientRecord，如果这个记录对象中含有状态信息就调用 Activity 的 onRestoreInstanceState 方法。开发人员可以从这个方法中做一些状态恢复操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    Activity activity = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">        <span class="comment">//1. 构建 Activity </span></div><div class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//2. 创建一个 Application 对象</span></div><div class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//创建 appContext，类型为 ContextImpl</span></div><div class="line">            Context appContext = createBaseContextForActivity(r, activity);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            <span class="comment">//3. 关联 appContext、Application 等对象到 Activity 中</span></div><div class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            activity.mCalled = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//4. 调用 Activity.onCreate 方法</span></div><div class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            r.activity = activity;</div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</div><div class="line">                <span class="comment">//调用 onStart 方法</span></div><div class="line">                activity.performStart();</div><div class="line">                r.stopped = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">             <span class="comment">//5. 如果有保存状态的话，调用 Activity.onRestoreInstanceState 方法恢复状态</span></div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</div><div class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">                    <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</div><div class="line">   </div><div class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</div><div class="line">                                r.persistentState);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</div><div class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line">        r.paused = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//6. 将 Activity 的信息记录对象——ActivityClientRecord 存储到 mActivities 中。 </span></div><div class="line">        mActivities.put(r.token, r);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的注释 5 处，系统会判断 Activity 是否调用过了 <code>Activity.finish()</code> 方法、是否是「永久的」以及 ActivityClientRecord 对象中的 state 是否为空，</p>
<ul>
<li>如果满足条件，就会获取存储的状态信息传递给 <code>Activity.onRestoreInstanceState</code> 方法，也会将这些数据传递给 onCreate 方法的 bundle 参数 。</li>
<li>不过 Google 官方推荐调用 onRestoreInstanceState 方法来恢复状态，因为只有在存储有状态信息的时候才会调用该方法，而在 onCreate 方法中还需要先进行判空处理。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上述过程中备忘录模式的三种关键角色分别由什么类扮演？</p>
<ul>
<li><strong>CareTaker</strong>：Activity 负责存储、恢复 UI 的态信息。</li>
<li><strong>Originator</strong>：Activity、Fragment、View、ViewGroup ，是需要存储状态的对象</li>
<li><strong>Memoto</strong>：由 Bundle 类扮演</li>
</ul>
<ul>
<li>Activity 会在停止之前根据 Activity 的退出情景来选择是否需要存储状态</li>
<li>在<strong>重新启动</strong>该 Activity 时会判断 ActivityClientRecord 对象中是否存储了 Activity 的状态<ul>
<li>如果含有状态，调用 <code>Activity.onRestoreInstanceState()</code> 方法恢复状态。从而使得 Activity 的 UI 可以恢复至异常退出前的状态。</li>
</ul>
</li>
</ul>
<h2 id="你可能会问的问题"><a href="#你可能会问的问题" class="headerlink" title="你可能会问的问题"></a>你可能会问的问题</h2><h3 id="onSaveInstanceState-何时被调用"><a href="#onSaveInstanceState-何时被调用" class="headerlink" title="onSaveInstanceState 何时被调用"></a>onSaveInstanceState 何时被调用</h3><p>onSaveInstanceState() 方法会在什么时候被执行？<br>有这么几种情况：</p>
<ol>
<li>当用户按下 HOME 键时。<ul>
<li>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</li>
</ul>
</li>
<li>长按HOME键，选择运行其他的程序时。</li>
<li>按下电源按键（关闭屏幕显示）时。</li>
<li>从 Activity A 中启动一个新的 Activity 时。</li>
<li>屏幕方向切换时，例如从竖屏切换到横屏时。</li>
</ol>
<p>onSaveInstanceState 的调用在 onStop 方法之前，但是与 onPause 方法之间没有既定关系。</p>
<ul>
<li>总而言之，当系统存在「==未经用户许可==」时销毁了我们的 Activity，则 <code>onSaveInstanceState()</code> 会被系统调用，这是系统的责任，因此它必须提供一个机会让用户保存数据。</li>
<li>「经用户许可」的情况不多，通常只有用户按下回退键这一种。这种情况下是用户主动退出某个 Activity，系统不会调用  <code>onSaveInstanceState()</code> 方法。</li>
</ul>
<h3 id="各个-「Originator-」-的-onSaveInstanceState-方法的默认实现是怎么样的？"><a href="#各个-「Originator-」-的-onSaveInstanceState-方法的默认实现是怎么样的？" class="headerlink" title="各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？"></a>各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？</h3><p>在前面的分析中我们知道即使没有覆写 onSaveInstanceState()方法, ViewGroup、View、Fragment、Activity 内部都有自己的默认实现，它们的默认实现也会<strong>保存某些状态数据</strong>。 </p>
<ul>
<li>比如 activity 中各种 UI 控件的状态。android 应用框架中定义的几乎所有 UI 控件都恰当的实现了 onSaveInstanceState() 方法,因此当 Activity 被销毁和重建时, 这些 UI 控件会自动保存和恢复状态数据.<ul>
<li>EditText 控件会自动保存和恢复输入的数据</li>
<li>CheckBox 控件会自动保存和恢复选中状态</li>
<li>…</li>
</ul>
</li>
<li>开发者只<strong>需要为这些控件指定一个唯一的 id</strong>(通过设置 <code>android:id</code> 属性即可), 剩余的事情就可以自动完成了<ul>
<li>注意：如果没有为控件指定ID, 则这个控件就不会进行自动的数据保存和恢复操作。</li>
</ul>
</li>
</ul>
<p>由上所述, 如果我们需要覆写 onSaveInstanceState() 方法, 一般会在第一行代码中调用该方法的默认实现:super.onSaveInstanceState(outState)。</p>
<h3 id="有默认实现，还需要重写-onSaveInstanceState-方法吗？"><a href="#有默认实现，还需要重写-onSaveInstanceState-方法吗？" class="headerlink" title="有默认实现，还需要重写 onSaveInstanceState() 方法吗？"></a>有默认实现，还需要重写 onSaveInstanceState() 方法吗？</h3><p>既然该方法的默认实现可以自动的保存UI控件的状态数据, 那什么时候需要覆写该方法呢? </p>
<p>如果<strong>需要保存额外的数据时</strong>, 就需要覆写 onSaveInstanceState() 方法。大家需要注意的是：onSaveInstanceState()方法<strong>只适合保存瞬态数据</strong>, 比如 UI 控件的状态，成员变量的值等，而不应该用来保存持久化数据，持久化数据应该当用户离开当前的 activity时，在 onPause() 中保存（比如将数据保存到数据库或文件中）。说到这里，还要说一点的就是在onPause()中不适合用来保存比较费时的数据，所以这点要理解。</p>
<p>另外由于 <code>onSaveInstanceState()</code> 方法方法不一定会被调用, 因此<strong>不适合在该方法中保存持久化数据</strong>, 例如向数据库中插入记录等。 保存持久化数据的操作应该放在 onPause() 中。若是永久性值，则在 onPause() 中保存；若有大量要保存的数据，则另开线程，以免阻塞 UI 线程。 </p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/28/2420515.html" target="_blank" rel="noopener">Android 开发之 instanceState详解</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> Android 原理分析 </category>
            
            <category> Android 进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android 进阶 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> Android 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 ThreadLocal]]></title>
      <url>https://timlin-pro.github.io/blog/2017/08/21/%E7%90%86%E8%A7%A3%20ThreadLocal/</url>
      <content type="html"><![CDATA[<h2 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a>ThreadLocal 是什么？</h2><p>ThreadLocal 是一个<strong>线程内部</strong>的<strong>数据存储类</strong>，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<h2 id="为什么要使用-ThreadLocal？"><a href="#为什么要使用-ThreadLocal？" class="headerlink" title="为什么要使用 ThreadLocal？"></a>为什么要使用 ThreadLocal？</h2><p>从定义我们知道 ThreadLocal 是一个用于存储本线程内部数据的类。假设没有 ThreadLocal 的话，每个 Thread 中可以输入自己的一个本地变量，但是在整个 Thread 的生命周期中，如果要穿梭很多 class 的很多 method 来使用这个本地变量的话，就要一直一直向下传送这个变量，显然很麻烦。<br>那么怎么才能在这个 Thread 的生命中，在任何地方都能够方便的访问到这个变量呢，这时候 ThreadLocal 就诞生了。</p>
<a id="more"></a>
<p>ThreadLocal 就是这么个作用，除此之外和通常使用的本地变量没有任何区别。<br>也就是说，没有 ThreadLocal 也是可以解决问题的，但是会比较麻烦，ThreadLocal 的作用便是简化线程内部数据的使用流程。</p>
<h2 id="ThreadLocal-的内部实现"><a href="#ThreadLocal-的内部实现" class="headerlink" title="ThreadLocal 的内部实现"></a>ThreadLocal 的内部实现</h2><p>既然是线程的本地变量，那自然与线程有着密切的联系。</p>
<p>打开 Thread 的源码可以看到，源码中有一个类型为 <code>ThreadLocal.ThreadLocalMap</code> 的变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<h3 id="ThreadLocal-get-流程"><a href="#ThreadLocal-get-流程" class="headerlink" title="ThreadLocal#get 流程"></a>ThreadLocal#get 流程</h3><p>我们以 ThreadLocal#get 方法作为分析的源头。这些方法的逻辑都比较简单，因此直接在注释中说明。可参考小结部分的调用流程图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);<span class="comment">//获取存储该 ThreadLocal 的 Entry</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)e.value;<span class="comment">//获取目标值并返回</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();<span class="comment">//设置初始值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#getMap，该方法返回当前线程的 ThreadLocalMap  对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Entry 类继承自弱引用，防止内存泄漏。其中存储了 ThreadLocal 以及对应的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#setInitialValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    T value = initialValue();<span class="comment">//获取默认的初始值</span></div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);<span class="comment">//当前线程的 ThreadLocalMap 对象不为空，直接设置给目标对象。</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);<span class="comment">//为当前线程创建 ThreadLocalMap 对象。</span></div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#initialValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该方法的调用时机：</span></div><div class="line"><span class="comment">//1. 通常该方法只会被调用一次，也就是在第一次初始化时</span></div><div class="line"><span class="comment">//2. 调用了 ThreadLocal#remove 方法之后（使得 Entry 被回收），再调用 ThreadLocal#get 方法</span></div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//；默认实现为返回 null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#createMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);<span class="comment">//调用构造方法初始化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ThreadLocal-set-流程"><a href="#ThreadLocal-set-流程" class="headerlink" title="ThreadLocal#set 流程"></a>ThreadLocal#set 流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);<span class="comment">//当前线程的 ThreadLocalMap 对象 已经存在直接设置值</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);<span class="comment">//为当前线程创建 ThreadLocalMap </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 ThreadLocal#set 方法的逻辑与 ThreadLocal#setInitialValue 方法中的逻辑如出一辙，这里不再赘述。</p>
<h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类。其中以键值对的形式存储数据。可以将它简单理解为一个 HashMap。ThreadLocal#createMap 方法通过调用 ThreadLocalMap 的构造方法为当前线程创建一个 ThreadLocalMap 对象。</p>
<h4 id="ThreadLocalMap-的构造方法"><a href="#ThreadLocalMap-的构造方法" class="headerlink" title="ThreadLocalMap 的构造方法"></a>ThreadLocalMap 的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];<span class="comment">//创建一个长度为 16 的 Entry 数组</span></div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);<span class="comment">//计算 key 的哈希值</span></div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);<span class="comment">//将 Entry 存到指定位置。</span></div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ThreadLocalMap</code> 的构造方法主要做了下面几件事：</p>
<ul>
<li>首先创建了一个 <code>Entry</code> 数组，<ul>
<li><code>Entry</code> 是 <code>ThreadLocalMap</code> 中的一个静态内部类,它以 <code>ThreadLocal</code> 为 key，以要存储的值为 value。</li>
</ul>
</li>
<li>然后根据 key 计算 Hash 值</li>
<li>接着创建一个 Entry 对象存储在数组中</li>
<li>最后设置大小和阈值。</li>
</ul>
<h4 id="ThreadLocalMap-Entry"><a href="#ThreadLocalMap-Entry" class="headerlink" title="ThreadLocalMap.Entry"></a>ThreadLocalMap.Entry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Entry 作为 ThreadLocalMap 的元素，表示的是一个键值对：ThreadLocal 的弱引用为键，将要用 ThreadLocal 存储的对象为值。</p>
<h3 id="解决冲突的方式"><a href="#解决冲突的方式" class="headerlink" title="解决冲突的方式"></a>解决冲突的方式</h3><p>线性探测法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/*ThreadLocals 依赖于附加到每个线程（Thread.threadLocals和inheritableThreadLocals）的线性探测 HashMap。 ThreadLocal对象作为键，通过threadLocalHashCode进行搜索。这是一个自定义的 hash code（仅在ThreadLocalMaps中有用），可以消除常见情况下的冲突，而在不常见的情况下也能表现良好。</span></div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</div><div class="line"><span class="comment">/**</span></div><div class="line"> * The difference between successively generated hash codes - turns</div><div class="line"> * implicit sequential thread-local IDs into near-optimally spread</div><div class="line"> * multiplicative hash values for power-of-two-sized tables.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;<span class="comment">//（1640531527）十进制</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the next hash code.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>java.lang.ThreadLocal.ThreadLocalMap#getEntryAfterMiss</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == key)</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</div><div class="line">            expungeStaleEntry(i);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            i = nextIndex(i, len);</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>java.lang.ThreadLocal.ThreadLocalMap#nextIndex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadLocal-会造成内存泄漏？"><a href="#ThreadLocal-会造成内存泄漏？" class="headerlink" title="ThreadLocal 会造成内存泄漏？"></a>ThreadLocal 会造成内存泄漏？</h2><p>因为作为 key 的 ThreadLocal 是弱引用，所以一发生 GC ，ThreadLocal 就会被回收，这个时候 Map 中存在一个 Key 为 null 的键值对，但是 <strong>value 仍然被线程强引用着</strong>，那么如果用完ThreadLocal后不主动移除（调用 ThreadLocal#remove 方法），就会造成<strong>短期的内存泄漏</strong>。但事实上，ThreadLocal <strong>用完后主动调 remove</strong> 就能规避这个问题。</p>
<p>注：上面说 value 被线程强引用是因为存在这样一条引用链：栈帧中持有一个当前线程的引用，ThreadLocalMap 被当前线程引用着，ThreadLocalMap 中有指向 Entry 的强引用，Entry 有持有 value 的强引用。具体可参考下图。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/31853072-84517b72-b6b5-11e7-84f1-0a51baaa05a2.png" alt="image"></p>
<p>当前 Thread 结束以后, Current Thread 就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收。</p>
<p>前面提到不调用 remove 方法 ThreadLocal 会造成短期的内存泄漏，下面就来证明下这个说法是否正确。</p>
<h3 id="为什么说是「短期的内存泄漏」呢？"><a href="#为什么说是「短期的内存泄漏」呢？" class="headerlink" title="为什么说是「短期的内存泄漏」呢？"></a>为什么说是「短期的内存泄漏」呢？</h3><p>以 ThreadLocal#get 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);<span class="comment">//调用 ThreadLcoalMap#getEntry 方法</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</div><div class="line">    Entry e = table[i];</div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)<span class="comment">//命中</span></div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);<span class="comment">//不在数组的相应位置上（可能是冲突）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ThreadLocal.ThreadLocalMap#getEntryAfterMiss</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocal k = e.get();</div><div class="line">        <span class="keyword">if</span> (k == key)</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</div><div class="line">            expungeStaleEntry(i);<span class="comment">//移除「过期的」Entry，也就是移除 key 为 null 的 Entry</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            i = nextIndex(i, len);<span class="comment">//加 1 「取模」，获得下一个地址</span></div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ThreadLocal.ThreadLocalMap#expungeStaleEntry</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//移除指定下标对应的的「过期的」Entry，</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line"></div><div class="line">    <span class="comment">// 删除过期的 slot 上的 entry</span></div><div class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</div><div class="line">    tab[staleSlot] = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    <span class="comment">// 不断尝试，直到遇到 e 为 null为止。</span></div><div class="line">    Entry e;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);<span class="comment">//（staleSlot +1）% len</span></div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = nextIndex(i, len)) &#123;<span class="comment">//(i+1)%len</span></div><div class="line">        ThreadLocal k = e.get();<span class="comment">//待清除的 entry</span></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;<span class="comment">//key 为 null，说明该 entry 已经过期，需要被移除</span></div><div class="line">            e.value = <span class="keyword">null</span>;<span class="comment">//将 value 置为 null，方便 GC</span></div><div class="line">            tab[i] = <span class="keyword">null</span>;<span class="comment">//解除对 entry 的应用</span></div><div class="line">            size--;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//key 不为 null 的情况。这一步的操作主要是方便查找，提高命中率</span></div><div class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);<span class="comment">//通过 hash 值计算下标</span></div><div class="line">            <span class="keyword">if</span> (h != i) &#123;<span class="comment">//下标不相等，说明之前setValue 时发生冲突，往后面存储了。</span></div><div class="line">                tab[i] = <span class="keyword">null</span>;<span class="comment">//将</span></div><div class="line">				<span class="comment">//与Knuth 6.4算法R 不同，我们必须扫描直到null，因为可能有多个entry已经过期。</span></div><div class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)<span class="comment">//从「本应该对应的下标」开始往后探测，直到有空位</span></div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                tab[h] = e;<span class="comment">//将 e 存储在当前情况下，最接近自己计算得出位置的那个下标。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>ThreadLocal#get</code> 方法（set 方法也有类似的实现）的调用链中可以看到：在没有主动调用 ThreadLocal#remove 的情况下，ThreadLocalMap后续的get/set中也会探测到那些key为 null的entry，然后将其 value 设置为 null 以帮助GC，因此 <strong>value 在 key 被 GC 后可能还会存活一段时间（也就是说会造成短期的内存泄漏），但最终也会被回收</strong>。这个过程和 <code>java.util.WeakHashMap</code> 的实现几乎是一样的。不过为了避免潜在的内存泄漏还是要养成一个习惯，使用完 ThreadLocal 中的value 之后要调用 <code>ThreadLocal#remove</code> 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h4 id="get-方法调用的主要流程"><a href="#get-方法调用的主要流程" class="headerlink" title="get 方法调用的主要流程"></a>get 方法调用的主要流程</h4><p><img src="https://user-images.githubusercontent.com/16668676/30096800-004b9f36-930d-11e7-9c27-c7f17619c3a7.png" alt="threadlocal get"></p>
<p>get 方法中会尝试获取当前线程的 ThreadLocalMap</p>
<ul>
<li>如果 ThreadLocalMap 非空，并且以当前 ThreadLocal 对象为 key 去获取到的 Entry 不为空，就返回该 ThreadLocal 对应的值；</li>
<li>否则，先获取默认的初始值（默认实现为空，可以自己重写 initialValue 方法来设置需要的值）<ul>
<li>然后判断 ThreadLocalMap 是否为空<ul>
<li>如果为空创建一个 ThreadLocalMap 同时将初始值设置进去。</li>
<li>如果不为空，直接把初始值存储在其中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="set-方法的调用流程"><a href="#set-方法的调用流程" class="headerlink" title="set 方法的调用流程"></a>set 方法的调用流程</h4><p><img src="https://user-images.githubusercontent.com/16668676/30096799-0047aeee-930d-11e7-8ac5-1927aadeab2d.png" alt="threadlocal set"></p>
<h2 id="你可能存在的疑问"><a href="#你可能存在的疑问" class="headerlink" title="你可能存在的疑问"></a>你可能存在的疑问</h2><h3 id="每个-ThreadLocal-只能放一个对象吗？"><a href="#每个-ThreadLocal-只能放一个对象吗？" class="headerlink" title="每个 ThreadLocal 只能放一个对象吗？"></a>每个 ThreadLocal 只能放一个对象吗？</h3><p>每个 ThreadLocal 只能放一个对象。要是需要放其他的对象，就再 new 一个新的 ThreadLocal 出来，这个新的 ThreadLocal 将作为 key,需要放的对象作为value，放在 ThreadLocalMap 中。也就是说一个线程可以含有多个 ThreadLocal 类。</p>
<p>当然也可以根据需要在 ThreadLocal 存放一些容器对象，比如 List、Set、Map，一个 ThreadLocal 存放一个容器对象，借助该容器对象也可以实现存储多个对象。 </p>
<h3 id="为什么-ThreadLocal-只存储一个对象却要用一个-ThreadLocalMap-来存储值？"><a href="#为什么-ThreadLocal-只存储一个对象却要用一个-ThreadLocalMap-来存储值？" class="headerlink" title="为什么 ThreadLocal  只存储一个对象却要用一个 ThreadLocalMap 来存储值？"></a>为什么 ThreadLocal  只存储一个对象却要用一个 ThreadLocalMap 来存储值？</h3><p>实际上每个线程中都有一个 ThreadLocal.ThreadLocalMap，真正存储数据的类是 ThreadLocalMap ，可以将它看作是一个 HashMap，而 ThreadLocal 是一个<strong>维护类</strong>。我们知道，存储的时候，都是以 ThreadLocal 实例作为 key，然后和 value 一起作为键值对存储到 ThreadLocalMap 中。当我们调用不同 ThreadLocal 的 set 方法时，如果 ThreadLocalMap 不为空，那么直接在里面存储键值对就可以了，不需要再创建新的值。也就是说，<strong>同一个线程上的不同 ThreadLocal 对象，存储的值是在同一个 ThreadLocalMap 上</strong>。</p>
<h3 id="没有-ThreadLocal-能不能解决问题？"><a href="#没有-ThreadLocal-能不能解决问题？" class="headerlink" title="没有 ThreadLocal 能不能解决问题？"></a>没有 ThreadLocal 能不能解决问题？</h3><p>能。</p>
<p>可以自己定义一个静态的 map，将当前 thread 作为 key，将目标值作为 value，put 到 map 中，这也是一般人的想法。</p>
<p>ThreadLocal 的实现刚好相反，它是在每个线程中有一个 map，而将 ThreadLocal 实例作为 key，这样每个 map 中的项数很少，而且当线程销毁时相应的东西也一起销毁了。<br>因为各线程访问的 map 是各自不同的 map，所以不需要同步，速度会快些；而如果把所有线程要用的对象都放到一个静态 map中的话 多线程并发访问需要进行同步。</p>
<p>所以说 ThreadLocal 只是实现线程私有变量的一种方式。但是综合来看这种方式相比其他实现方式要更好。</p>
<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>我们通常会用下面的方式为普通线程创建一个 Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> Handler mHandler;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Looper.prepare();<span class="comment">//为当前线程创建一个 Looper</span></div><div class="line">            mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                    <span class="comment">// process incoming messages here</span></div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Looper.loop();<span class="comment">//开启消息循环</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Android 中每个线程中最多只能有一个 Looper，这种限制就是通过 ThreadLocal 来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</div><div class="line">  	<span class="comment">//创建一个 ThreadLocal 对象，其泛型类型为 Looper，在调用 prepare 之前 sThreadLocal.get() 都返回空。</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div><div class="line">  	<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建 Looper 时会同时创建一个泛型类型为 Looper 的 ThreadLocal 对象。</p>
<p>Looper#prepare()，通过 prepare 方法可以为当前线程创建一个 Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;<span class="comment">//如果线程已经存在 Looper 了</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//为当前线程创建一个 Looper 对象，并将它存储在当前线程的 ThreadLocalMap 中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Looper#myLooper() ，通过该方法可以获取当前线程的 Looper 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果一个对象的引用被多个线程持有，那么即使该对象存在 ThreadLocalMap 中也不是线程的本地变量。</p>
<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过 <code>ThreadLocal.set()</code> 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。 </p>
<p>也就是说，其他线程能否访问，还要看你的 set 进去的对象引用是否被其他线程持有。 如果两个线程都存入同一个对象引用，那就会有线程共享问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>ThreadLocal 通过操作 Thread 中的一个 map（ <code>ThreadLocal.ThreadLocalMap</code>），来实现在 Therad 中添加一个逻辑上的成员变量。</p>
</blockquote>
<p>我们总结 ThreadLocal 具体是怎么一步一步去为每一个线程创建一个~线程私有变量~的：</p>
<ul>
<li>首先，在每个线程 Thread 内部有一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的成员变量 threadLocals，这个 threadLocals 就是用来存储~线程私有变量的~，键值（key）为当前 ThreadLocal 变量，值 value 为~线程的私有变量~（即 T 类型的变量）。</li>
<li>初始时，在 Thread 里面，threadLocals 为空，当通过 ThreadLocal 变量调用 get() 方法或者 set() 方法，就会对 Thread 类中的 threadLocals 进行初始化，并且以当前 ThreadLocal 变量为 key，以 ThreadLocal 要保存的~线程私有变量~为 value，存到 threadLocals 中。<ul>
<li>注意，如果是 先调用 get() 方法而不是 set() 方法的话，会返回 null</li>
</ul>
</li>
<li>然后在当前线程里面，如果要使用~该线程私有变量~，就可以通过 get 方法在 当前线程的<code>ThreadLocal.ThreadLocalMap</code>  中查找。</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="noopener">正确理解 ThreadLocal</a></li>
<li><a href="http://www.iteye.com/topic/82984" target="_blank" rel="noopener">ThreadLocal and synchronized 补充</a></li>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="noopener">ThreadLocal</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java并发编程：深入剖析ThreadLocal</a></li>
<li><a href="http://www.jianshu.com/p/95291228aff7" target="_blank" rel="noopener">Android关于ThreadLocal的思考和总结</a></li>
<li><a href="http://vence.github.io/2016/05/28/threadlocal-info/" target="_blank" rel="noopener">深入理解ThreadLocal</a></li>
<li><a href="https://www.jianshu.com/p/e0eb1f6a151a" target="_blank" rel="noopener">从需求的角度去理解ThreadLocal及源码解析</a></li>
</ul>
<p>如果本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 并发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[明白原理,轻松解决内存泄漏]]></title>
      <url>https://timlin-pro.github.io/blog/2017/08/19/%E6%98%8E%E7%99%BD%E5%8E%9F%E7%90%86-%E8%BD%BB%E6%9D%BE%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<p>相信「内存泄漏」 问题，是一个挺让开发者头疼的事情，笔者在回顾以为代码时，惊讶发现：初学 Android 时，许多不修边幅的代码习惯，导致了许多内存泄漏问题，借此分析其原因，把自己挖过的坑补一下，也希望奔跑在 Android 开发道路上的你能够优雅避免。</p>
<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><ul>
<li>对于 C++ 来说，内存泄漏就是 new 出来的对象没有 delete，俗称野指针；</li>
<li>而对于 java 而言，就是存放在堆上的 Object 无法被 GC 正常回收；</li>
</ul>
<a id="more"></a>
<p>分析之前我们先来看看三个基础知识点。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="java-的内存分配简述"><a href="#java-的内存分配简述" class="headerlink" title="java 的内存分配简述"></a>java 的内存分配简述</h3><p>运行时数据区域内存模型图<br><img src="http://gityuan.com/images/jvm/jvm_memory_1.png" alt=""></p>
<ul>
<li>方法区（non-heap）：编译时就分配好，在程序<strong>整个运行期间都存在</strong>。它主要存放静态数据和常量；</li>
<li>栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；</li>
<li>堆区（heap）：通常用来存放 new 出来的对象。由 GC 负责回收。</li>
</ul>
<h3 id="四种不同类型的引用"><a href="#四种不同类型的引用" class="headerlink" title="四种不同类型的引用"></a>四种不同类型的引用</h3><p>GC 过程与对象的引用类型有着很大的联系，下面我们就看看 Java 中（Android 中存在差异）的四种引用： </p>
<ul>
<li>强引用（Strong Reference）:JVM 宁愿抛出 OOM，也不会让 GC 回收存在强引用的对象。</li>
<li>软引用（Soft Reference） ：只有内存不足时，才会被 GC 回收。 </li>
<li>弱引用（weak Reference）：在 GC 时，如果一个对象只存在弱引用，将会被回收 </li>
<li>虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为 GC 回收 Object 的标志。 </li>
</ul>
<p>与 Android 中的差异：<strong>在 2.3 以后版本中，即使内存够用，Android 系统会优先将 SoftReference 的对象提前回收掉</strong>, 其他和 Java 中是一样的。<br>因此谷歌官方建议用 LruCache(least recentlly use 最少最近使用算法)。会将内存控制在一定的大小内, 超出最大值时会自动回收, 这个最大值开发者自己定。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>内存泄漏是因为内存无法被正常回收引起。为什么无法被回收？我们前面是这么说的——「因为它的强/软引用被长生命周期的对象持有」。可为什么引用被长生命周期的对象持有就不能进行释放呢？这就涉及到了<a href="https://ivanljt.github.io/blog/2017/09/08/JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">垃圾回收机制</a>。</p>
<p>进行垃圾回收的第一个问题是如何确定哪些对象是可以被回收的垃圾。通常有两种判断方法，一种是引用计数方法，另一种是可达性分析算法。主流的商用程序语言的主流实现中，都是通过<strong>可达性分析</strong>来判断对象是否存活的。</p>
<p>可达性分析算法的基本思路是这样的：</p>
<ul>
<li>通过一系列的称为 GC Root 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为『引用链』（Reference Chain）</li>
<li><strong>当一个对象到 GC Root 没有任何引用链相连时，则证明此对象是不可用的</strong>。</li>
</ul>
<p>问题来了，到底什么是 GC Root 呢？</p>
<p>R 大在知乎中这样答道：所谓“GC roots”，或者说tracing GC的“根集合”，<strong>一组必须活跃的==引用==</strong></p>
<blockquote>
<ul>
<li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前<strong>所有正在被调用的方法的引用类型的参数/局部变量/临时值</strong>。</li>
<li>VM的一些<strong>静态数据结构里指向GC堆里的对象的引用</strong>，例如说HotSpot VM里的Universe里有很多这样的引用。</li>
<li>JNI handles，包括global handles和local handles</li>
<li>（看情况）所有当前被加载的Java类</li>
<li>（看情况）Java类的<strong>运行时常量池里的引用类型常量</strong>（String或Class类型）</li>
<li>（看情况）<strong>String常量池</strong>（StringTable）里的引用</li>
</ul>
</blockquote>
<p>关于 GC 回收机制，可以参考下<a href="https://ivanljt.github.io/blog/2017/09/08/JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="内存泄漏的危害"><a href="#内存泄漏的危害" class="headerlink" title="内存泄漏的危害"></a>内存泄漏的危害</h2><ul>
<li><strong>运行性能的问题</strong>: Android在运行的时候，如果内存泄漏将导致其他组件可用的内存变少，一方面会使得GC的频率加剧，在发生GC的时候，所有进程都必须进行等待，GC的频率越多，从而用户越容易感知到<strong>卡顿</strong>。另一方面，内存变少，将可能使得系统会额外分配给你一些内存，而<strong>影响整个系统的运行状况</strong>。</li>
<li><strong>运行崩溃问题</strong>: 内存泄露是内存溢出(<strong>OOM</strong>)的重要原因之一，会导致 Crash。如果应用程序在消耗光了所有的可用堆空间，那么再试图在堆上分配新对象时就会引起 <code>OOM(Out Of Memory Error)</code> 异常，此时应用程序就会崩溃退出。</li>
</ul>
<h2 id="内存泄漏的典型案例"><a href="#内存泄漏的典型案例" class="headerlink" title="内存泄漏的典型案例"></a>内存泄漏的典型案例</h2><p>要想避免内存泄漏，首先要知道导致内存泄漏的原因。<br><strong>内存泄漏本质原因</strong>:==长生命周期的对象持有短生命周期对象的强/软引用。导致本应该被回收的短生命周期的对象无法被正常回收==。</p>
<p>这么讲可能比较抽象。举个常见的栗子：单例模式中，我们常常在获取单例对象时需要传一个 Context 。单例对象是一个长生命周期的对象（应用程序结束时才终结），而如果我们传递的是某一个 Activity 作为 context,那么这个 Activity 就会因为引用被持有而无法销毁，从而导致内存泄漏。</p>
<p>下面我们来看看导致内存泄漏的常见例子。</p>
<h3 id="永远的-Singleton"><a href="#永远的-Singleton" class="headerlink" title="永远的 Singleton"></a>永远的 Singleton</h3><p>单例的使用在我们的程序中随处可见，因为使用它可以解决我们在程序中重复创建对象的问题。但是<strong>由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏</strong>。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li>应该把传入的 Context 改为同应用生命周期一样长的 Application 中的 Context。</li>
<li>也可以通过重写 Application，提供 getContext 方法,那样就不需要在获取单例时传入 context。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext sContext;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        sContext = getApplicationContext();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getApplicationContext</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> sContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Handler-引发的内存泄漏"><a href="#Handler-引发的内存泄漏" class="headerlink" title="Handler 引发的内存泄漏"></a>Handler 引发的内存泄漏</h3><p>由于 Handler 通常会被 Message 所持有，而 Message 通常会间接地被主线程持有，如果创建 Handler 的时候，直接通过 new 的方式创建匿名内部类（默认持有 外部类的强引用，new 操作通常是 Activity 或者是 Fragment 内部直接），在界面退出的时候，又没有调用 <code>android.os.Handler#removeCallbacksAndMessages</code>方法，可能就会导致它的生命周期和 Activity 不一致。进而容易导致内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerBadActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler()&#123;<span class="comment">//非静态内部类，持有外部类的强引用</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler_bad);</div><div class="line">        <span class="comment">// 延迟 5min 发送一个消息</span></div><div class="line">        handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;<span class="comment">//内部会将该 Runable 封装为一个 Message 对象，同时将 Message.target 赋值为 handler</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//do something</span></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>);</div><div class="line">        <span class="keyword">this</span>.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中发送了一个延时 5 分钟执行的 Message，当该 Activity 退出的时候，延时任务（Message）还在主线程的 MessageQueue 中等待，此时的 <strong>Message 持有 Handler 的强引用</strong>（创建时通过 Message.target 进行指定），并且由于 Handler 是 HandlerBadActivity 的<strong>非静态内部类，所以 Handler 会持有一个指向 HandlerBadActivity 的强引用</strong>，同时 Message 被 MessageQueue 所持有，MessageQueue 又被主线程 Looper 持有，主线程 Looper 被主线程的 looper 所持有（引用链为： 主Thread —&gt; Looper—&gt; MessageQueue —&gt; Message —&gt;  Handler 实例 —&gt;  Activity ） 所以虽然此时 HandlerBadActivity 调用了 finish 也无法进行内存回收，造成内存泄漏。</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>将 Handler 声明为<strong>静态内部类</strong>，但是要注意如果用到 Context 等外部类的 非static 对象，还是应该使用 ApplicationContext 或者通过弱引用来持有这些外部对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerGoodActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;<span class="comment">//声明为静态内部类（避免持有外部类的强引用）</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;HandlerGoodActivity&gt; mActivity;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(HandlerGoodActivity activity)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.mActivity = <span class="keyword">new</span> WeakReference&lt;HandlerGoodActivity&gt;(activity);<span class="comment">//使用弱引用</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            HandlerGoodActivity activity = mActivity.get();</div><div class="line">            <span class="keyword">if</span> (activity == <span class="keyword">null</span> || activity.isFinishing() || activity.isDestroyed()) &#123;<span class="comment">//判断 activity 是否为空，以及是否正在被销毁、或者已经被销毁</span></div><div class="line">              removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// do something</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyHandler myHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="慎用-static-成员变量"><a href="#慎用-static-成员变量" class="headerlink" title="慎用 static 成员变量"></a>慎用 static 成员变量</h3><p>从前面的介绍我们知道，static 修饰的变量位于内存的方法区，<strong>其生命周期与 App 的生命周期一致</strong>。<br>这必然会导致一系列问题，如果你的 app 进程设计上是长驻内存的，那即使 app 切到后台，这部分内存也不会被释放。</p>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>不要在类初始时初始化静态成员，也就是可以考虑懒加载。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p>
<p>当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/727790-afde094317e73842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同 Context 的应用场景"></p>
<p>说明： </p>
<ul>
<li>NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要==创建一个新的 task 任务队列==。</li>
<li>对于 Dialog 而言，只有在 Activity 中才能创建</li>
</ul>
<p>下面举一个隐蔽的栗子</p>
<h3 id="使用系统服务引发的内存泄漏"><a href="#使用系统服务引发的内存泄漏" class="headerlink" title="使用系统服务引发的内存泄漏"></a>使用系统服务引发的内存泄漏</h3><p>为了方便我们使用一些常见的系统服务，Activity 做了一些封装。比如说，可以通过 getPackageManager 在 Activtiy 中获取 PackageManagerService，但是，里面实际上调用了 Activity 对应的 ContextImpl 中的 getPackageManager 方法</p>
<p><code>ContextWrapper#getPackageManager</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mBase.getPackageManager();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ContextImpl#getPackageManager</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> mPackageManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    IPackageManager pm = ActivityThread.getPackageManager();</div><div class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Doesn't matter if we make more than one instance.</span></div><div class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));<span class="comment">//创建 ApplicationPackageManager</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ApplicationPackageManager#ApplicationPackageManager</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ApplicationPackageManager(ContextImpl context,</div><div class="line">                          IPackageManager pm) &#123;</div><div class="line">    mContext = context;<span class="comment">//保存 ContextImpl 的强引用</span></div><div class="line">    mPM = pm;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">UserManagerService</span><span class="params">(Context context, PackageManagerService pm,</span></span></div><div class="line">        Object packagesLock, File dataDir) &#123;</div><div class="line">    mContext = context;<span class="comment">//持有外部 Context 引用</span></div><div class="line">    mPm = pm;</div><div class="line"> 	<span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PackageManagerService#PackageManagerService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageManagerService</span> <span class="keyword">extends</span> <span class="title">IPackageManager</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> UserManagerService sUserManager;<span class="comment">//持有 UMS 静态引用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span></span></div><div class="line">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore) &#123;</div><div class="line">          sUserManager = <span class="keyword">new</span> UserManagerService(context, <span class="keyword">this</span>, mPackages);<span class="comment">//初始化 UMS</span></div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>笔者遇到的内存泄漏问题是因为在 Activity 中调用了 getPackageManger 方法获取 PMS ，该方法调用的是 ContextImpl，此时如果ContextImpl 中  PackageManager 为 null，就会创建一个 PackageManger（ContextImpl 会将自己传递进去，而 ContextImpl 的  mOuterContext 为 Activity），创建 PackageManager 实际上会创建 PackageManagerService（简称 PMS），而 PMS 的构造方法中会创建一个 UserManger（UserManger 初始化之后会持有 ContextImpl 的强引用）。</p>
<p>只要 PMS 的 class 未被销毁，那么就会一直引用着 UserManger ，进而导致其关联到的资源无法正常释放。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本例的引用链大致如下：</p>
<p>方法区中（1.8 后移到了 元空间）含有已经加载的 PMS class，PMS 静态引用 –&gt; UserManger（mContext） –&gt; ContextImpl（mOuterContext） –&gt; Activity (资源无法被正常回收)</p>
<p>通常这种内存泄漏总是比较隐蔽，不使用检测工具，根本就想不到，原来那一行代码竟然会引发内存泄漏。</p>
<h4 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h4><p>将getPackageManager() 改为 getApplication()#getPackageManager() 。这样引用的就是 Application Context，而非 Activity 了。</p>
<h3 id="远离非静态内部类和匿名类，有需要时请使用静态内部类"><a href="#远离非静态内部类和匿名类，有需要时请使用静态内部类" class="headerlink" title="远离非静态内部类和匿名类，有需要时请使用静态内部类"></a>远离非静态内部类和匿名类，有需要时请使用静态内部类</h3><p>为什么要怎么做呢?因为使用非静态内部类和匿名类都会默认持有外部类的引用，如果生命周期不一致，就会导致内存泄漏。</p>
<p>看一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedClassLeakActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;<span class="comment">//非静态内部类</span></div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InnerClass sInner;<span class="comment">//指向非静态内部类的静态引用</span></div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_nested_class);</div><div class="line">        <span class="keyword">if</span> (sInner == <span class="keyword">null</span>) &#123;</div><div class="line">           sInner = <span class="keyword">new</span> InnerClass();<span class="comment">//创建非静态内部类的实例</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本例中，因为<strong>非静态内部类默认会持有外部类的引用</strong>，而外部类中又有一个该非静态内部类的静态实例，该静态实例的生命周期和应用的一样长，而静态实例又持有 Activity 的引用，因此导致 Activity 的内存资源不能正常回收。</p>
<h4 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h4><ol>
<li>将该内部类设为静态内部类</li>
<li>也可以将该内部类抽取出来封装成一个单例</li>
</ol>
<h3 id="集合引发的内存泄漏"><a href="#集合引发的内存泄漏" class="headerlink" title="集合引发的内存泄漏"></a>集合引发的内存泄漏</h3><p>我们通常会把一些对象的引用加入到集合容器（比如ArrayList）中，当我们不再需要该对象时（通常会调用 remove 方法），并没有把它的引用从集合中清理掉（其中的一种情况就是 remove 方法没有将不再需要的引用赋值为 null），下面以 ArrayList 的 remove 方法为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">( <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 数组越界检查</span></div><div class="line">    RangeCheck(index);</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 取出要删除位置的元素，供返回使用</span></div><div class="line">    E oldValue = (E) elementData[index];</div><div class="line">   <span class="comment">// 计算数组要复制的数量</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">   <span class="comment">// 数组复制，就是将index之后的元素往前移动一个位置</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">       System. arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                      numMoved);</div><div class="line">   <span class="comment">// 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收</span></div><div class="line">    elementData[--size ] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>elementData[--size ] = null; // Let gc do its work</code> 如果替换为 <code>--size</code>，就会导致已经「移除」的对象因为强引用被集合持有，而无法正常被 gc 回收。</p>
<h3 id="WebView-引发的内存泄漏"><a href="#WebView-引发的内存泄漏" class="headerlink" title="WebView 引发的内存泄漏"></a>WebView 引发的内存泄漏</h3><p>WebView 解析网页时会申请<strong>Native堆内存</strong>用于保存页面元素，当页面较复杂时会有很大的内存占用。如果页面包含图片，内存占用会更严重。并且打开新页面时，为了能快速回退，<strong>之前页面占用的内存也不会释放</strong>。有时浏览十几个网页，都会占用几百兆的内存。这样加载网页较多时，会导致系统不堪重负，最终强制关闭应用，也就是出现应用闪退或重启。</p>
<p>由于占用的都是 <strong>Native 堆内存</strong>，所以<strong>实际占用的内存大小不会显示在常用的 DDMS Heap 工具中</strong>（ DMS Heap 工具看到的只是Java虚拟机分配的内存，即使Native堆内存已经占用了几百兆，这里显示的还只是几兆或十几兆）。只有使用 adb shell 中的一些命令比如 dumpsys meminfo 包名，或者在程序中使用 <code>Debug.getNativeHeapSize()</code> 才能看到 Native 堆内存信息。</p>
<p>据说由于 WebView 的一个 BUG，即使它所在的 Activity(或者Service) 结束也就是 onDestroy() 之后，或者直接调用 WebView.destroy()之后，它所占用这些内存也不会被释放。</p>
<h4 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h4><p>把使用了 WebView 的 Activity (或者 Service) 放在单独的进程里。</p>
<ul>
<li>系统在检测到应用占用内存过大有可能被系统干掉 </li>
<li>也可以在它所在的 Activity(或者 Service) 结束后，调用 <code>System.exit(0)</code>，主动Kill掉进程。由于系统的内存分配是以进程为准的，进程关闭后，系统会自动回收所有内存。</li>
</ul>
<p>使用 WebView 的页面（Activity），在生命周期结束页面退出（onDestory）的时候，主动调用<strong>WebView.onPause()==以及==WebView.destory()</strong>以便让系统释放 WebView 相关资源。</p>
<h3 id="其他常见的引起内存泄漏原因"><a href="#其他常见的引起内存泄漏原因" class="headerlink" title="其他常见的引起内存泄漏原因"></a>其他常见的引起内存泄漏原因</h3><ul>
<li>Android 3.0 以下，Bitmap 在不使用的时候没有使用 recycle() 释放内存。</li>
<li><strong>非静态内部类的静态实例</strong>容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。</li>
<li>警惕<strong>线程未终止造成的内存泄露</strong>；譬如在 Activity 中关联了一个生命周期超过 Activity 的 Thread，在退出 Activity 时切记结束线程。<ul>
<li>一个典型的例子就是 HandlerThread 的 run 方法。该方法在这里是一个死循环，它不会自己结束，线程的生命周期超过了 Activity 生命周期，我们必须手动在 Activity 的销毁方法中中调用 <code>thread.getLooper().quit()</code> 才不会泄露。</li>
</ul>
</li>
<li><strong>对象的注册与反注册没有成对出现</strong>造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。</li>
<li><strong>创建与关闭没有成对出现造成的泄露</strong>；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。</li>
<li>避免代码设计模式的错误造成内存泄露；譬如循环引用，A 持有 B，B 持有 C，C 持有 A，这样的设计谁都得不到释放。</li>
</ul>
<h2 id="内存泄漏的检测工具"><a href="#内存泄漏的检测工具" class="headerlink" title="内存泄漏的检测工具"></a>内存泄漏的检测工具</h2><ul>
<li>LeakCanary 是 Apache 开源的一个自动检测内存泄漏的框架。具体用法可以参考 <a href="https://mp.weixin.qq.com/s/0bO5BZ4CMYJbRuY_xf_osw" target="_blank" rel="noopener">LeakCanary——如何检测 Activity 是否泄漏</a></li>
<li>使用 AS Monitor + MAT 自己分析内存泄漏原因。虽然MAT不会准确告诉你你的代码哪泄漏了，但是它会给你发现哪泄露的数据和线索。</li>
<li>AS 3.0 中提供了 Profiler 工具，这里简述一下使用流程：手动点击 GC 按钮（图标是一个垃圾桶）—&gt; 选择 Dump 内存（等待20秒左右）—&gt; 下方会弹出分析结果窗口—&gt;  下拉选择 app heap ，下拉选择 Arrange by package—&gt;到包下寻找自己认为可能发生内存泄漏的类，单击选中类 —&gt; 右边弹出 Instance View 窗口，显示该类的所有实例 —&gt; 选中某一个实例 –&gt; 下方会弹出 Reference 窗口（显示该实例的所有引用），然后分析一下到底是谁强引用了该实例，导致内存无法释放。</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/XILFalxJsbGJjx-ZOEDi7g" target="_blank" rel="noopener">Android 性能优化 详解内存优化的来龙去脉</a></li>
<li><a href="http://www.cnblogs.com/liushilin/p/5900089.html" target="_blank" rel="noopener">内存泄漏全解析，从此拒绝ANR，让OOM远离你的身边，跟内存泄漏say byebye</a></li>
<li><a href="https://goo-yao.github.io/2017/02/11/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/#more" target="_blank" rel="noopener">明白原理，轻松应对Android内存泄漏</a></li>
</ul>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> 性能优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的代理模式]]></title>
      <url>https://timlin-pro.github.io/blog/2017/08/18/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h2><p>代理模式也称为委托模式，为其他对象提供一种代理以控制对这个对象的访问。</p>
<h2 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h2><p>当无法或不想访问某个对象或者访问某个对象存在困难时可以<strong>通过一个代理对象来间接访问</strong>。</p>
<p>为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口（或继承相同的抽象类）</p>
<a id="more"></a>
<h2 id="代理模式的UML类图"><a href="#代理模式的UML类图" class="headerlink" title="代理模式的UML类图"></a>代理模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29449202-6aed8b00-842c-11e7-8e3f-362ead423f2d.png" alt="proxy uml"></p>
<p>角色介绍：</p>
<ul>
<li>Subject 抽象主题类<ul>
<li>主要职责是声明真实主题类与代理的共同接口方法，该类可以是一个抽象类也可以是一个接口</li>
</ul>
</li>
<li>RealSubject 真实主题类<ul>
<li>也称为被委托类或被代理理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。</li>
</ul>
</li>
<li>ProxySubject 代理类<ul>
<li>也称为委托类，持有一个对真实主题类的引用，在其实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。</li>
</ul>
</li>
<li>Client 使用代理类的类</li>
</ul>
<h2 id="代理模式的简单实现"><a href="#代理模式的简单实现" class="headerlink" title="代理模式的简单实现"></a>代理模式的简单实现</h2><p>代理模式大致可分为两大部分，<strong>静态代理和动态代理</strong>。</p>
<p><strong>动态代理</strong>通过反射机制动态地生成代理者的对象，code 阶段不需要知道代理谁，代理的真正对象会在执行阶段确定。</p>
<p>Java 提供一个便捷的动态代理接口 InvocationHandler，实现该接口需要重写其调用方法 invoke。</p>
<p>动态代理通过一个代理类来代理 N 多个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的的耦合关系。</p>
<p>代理可以看作是 对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是代理完成。（观点：大部分动态代理的场景可以看作是 装饰器模式的应用。）</p>
<h3 id="静态代理-vs-动态代理"><a href="#静态代理-vs-动态代理" class="headerlink" title="静态代理 vs 动态代理"></a>静态代理 vs 动态代理</h3><p>相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂。</p>
<ul>
<li>但是静态代理更符合面向对象的原则。</li>
</ul>
<p>实际开发中具体使用哪种方式来实现代理，看自己的偏好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>静态代理和动态代理是从 code 方面来区分代理模式的。</p>
<p>也可以<strong>从其使用范围来区分</strong>不同类型的代理实现：</p>
<ul>
<li><strong>远程代理</strong>（Remote Proxy）为某个对象<strong>在不同的内存地址空间</strong>提供局部代理。使系统可以将 Server 部分的实现隐藏，以便 Client 可以不考虑 Server 的存在。</li>
<li><strong>虚拟代理</strong>（Virtual Proxy）使用一个代理对象<strong>表示一个十分耗资源的对象并在真正需要时才创建</strong>。</li>
<li><strong>保护代理</strong>(Protection Proxy)：使用代理<strong>控制对原始对象的访问</strong>。该类型的代理常被<strong>用于原始对象具有不同访问权限</strong>的情况。</li>
<li><strong>智能引用</strong>(Smart Reference)：在访问原始对象时执行一些自己的<strong>附加操作并对指向原始对象的引用计数</strong>。</li>
</ul>
<p>静动态代理都可以应用于上述 4 种情形。</p>
<h2 id="Android源码中的代理模式实现"><a href="#Android源码中的代理模式实现" class="headerlink" title="Android源码中的代理模式实现"></a>Android源码中的代理模式实现</h2><p>以 ActivityManager 为例。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29449446-6771e5ce-842d-11e7-935f-d1e5685d43af.png" alt="source code proxy"></p>
<ul>
<li>抽象接口: IActivityManager</li>
<li>代理类 ActivityManagerProxy</li>
<li>被代理类<ul>
<li>ActivityManagerNative(抽象类，并不处理太多的逻辑，大部分逻辑由其子类——ActivityManagerService 承担)</li>
<li>ActivityManagerService(真实部分)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>ActivityManagerService 是系统级的 Service 并且运行于独立的进程空间中，可以通过 ServiceManger 获取到它。</li>
<li>ActivityManagerProxy 运行于自己所处的进程空间中（也就是说，与 ActivityManagerService 运行在不同的进程中）</li>
<li>所以此处源码所实现的代理实质为==远程代理==。</li>
</ul>
<p>ActivityManagerProxy 在实际的逻辑处理并<strong>没有过多地被外部类</strong>使用，Android 中管理与维护 Activity 相关信息的类是另一个叫做 ActivityManager 的类。不过实质上 ActivityManager 大多数逻辑还是由 ActivityManagerProxy 承担。（注意：ActivityManager 并没有实现 <strong>I</strong>ActivityManager 接口，它直接继承自 Object）</p>
<p>以 ActivityManager 的 getAppTasks() 方法为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123;</div><div class="line">    ArrayList&lt;AppTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;AppTask&gt;();</div><div class="line">    List&lt;IAppTask&gt; appTasks;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());</div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> numAppTasks = appTasks.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAppTasks; i++) &#123;</div><div class="line">        tasks.add(<span class="keyword">new</span> AppTask(appTasks.get(i)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ActivityManagerNative.getDefault();</code>方法 返回一个 <code>IActivityManager</code> 类型的对象，通过该对象调用其 getAppTasks 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> gDefault.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gDefault 到底是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);<span class="comment">//获取 AMS</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        IActivityManager am = asInterface(b);<span class="comment">//完成创建一个 AMS 的客户端端代理对象—— ActivityManagerProxy</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">return</span> am;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述代码中构造了一个 <code>Singleton&lt;IActivityManager&gt;</code> 类型的 gDefault 对象，其中通过 <code>ServiceManager.getService(&quot;activity&quot;);</code> 获取一个系统级的 Service，而该 Service 实质上就是 AMS，接着调用 asInterface 方法，创建一个 ActivityManagerProxy 对象。</p>
<p>ActivityManagerNative.asInterface 方法的具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static public IActivityManager asInterface(IBinder obj) &#123;</div><div class="line">    if (obj == null) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);</div><div class="line">    if (in != null) &#123;</div><div class="line">        return in;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new ActivityManagerProxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ActivityManagerProxy 的 <code>getTasks</code> 方法，将数据打包跨进程传递给 Server 端的 AMS 处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.RunningTaskInfo&gt; getTasks(<span class="keyword">int</span> maxNum, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException &#123;</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        data.writeInt(maxNum);</div><div class="line">        data.writeInt(flags);</div><div class="line">        mRemote.transact(GET_TASKS_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        reply.readException();</div><div class="line">        ArrayList&lt;ActivityManager.RunningTaskInfo&gt; list = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> N = reply.readInt();</div><div class="line">        <span class="keyword">if</span> (N &gt;= <span class="number">0</span>) &#123;</div><div class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</div><div class="line">                ActivityManager.RunningTaskInfo info =</div><div class="line">                        ActivityManager.RunningTaskInfo.CREATOR</div><div class="line">                                .createFromParcel(reply);</div><div class="line">                list.add(info);</div><div class="line">                N--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        data.recycle();</div><div class="line">        reply.recycle();</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看看 AMS 中的 getTasks 方法的具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;IAppTask&gt; <span class="title">getAppTasks</span><span class="params">(String callingPackage)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> callingUid = Binder.getCallingUid();</div><div class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        ArrayList&lt;IAppTask&gt; list = <span class="keyword">new</span> ArrayList&lt;IAppTask&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"getAppTasks"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mRecentTasks.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                TaskRecord tr = mRecentTasks.get(i);</div><div class="line">                <span class="comment">// Skip tasks that do not match the caller.  We don't need to verify</span></div><div class="line">                <span class="comment">// callingPackage, because we are also limiting to callingUid and know</span></div><div class="line">                <span class="comment">// that will limit to the correct security sandbox.</span></div><div class="line">                <span class="keyword">if</span> (tr.effectiveUid != callingUid) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                Intent intent = tr.getBaseIntent();</div><div class="line">                <span class="keyword">if</span> (intent == <span class="keyword">null</span> ||</div><div class="line">                        !callingPackage.equals(intent.getComponent().getPackageName())) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                ActivityManager.RecentTaskInfo taskInfo =</div><div class="line">                        createRecentTaskInfoFromTaskRecord(tr);</div><div class="line">                AppTaskImpl taskImpl = <span class="keyword">new</span> AppTaskImpl(taskInfo.persistentId, callingUid);</div><div class="line">                list.add(taskImpl);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(ident);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Android-中的-Binder-跨进程通信机制与-AIDL"><a href="#Android-中的-Binder-跨进程通信机制与-AIDL" class="headerlink" title="Android 中的 Binder 跨进程通信机制与 AIDL"></a>Android 中的 Binder 跨进程通信机制与 AIDL</h2><p>四个重要类：</p>
<ul>
<li>Binder Client 类比 PC、终端设备</li>
<li>Binder Server 类比 服务器</li>
<li>Binder Driver（实现在内核中） 类比 路由器</li>
<li>Binder Manager 类比 DNS 服务器</li>
</ul>
<p>因为依赖于抽象，加上本地代理类的存在，所以调用远程方法时，还是与调用本地的普通的方法一样。但是代理类内部需要对参数什么的进行打包处理，然后再通过 Binder 机制，跨进程将数据传递给远程方法，远程方法执行完毕再返回数据。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29453380-021cc0ea-843c-11e7-901d-a7490d12f9ea.jpg" alt="binder 通信大致模型图"></p>
<p>Binder Driver 实现在内核中，主要负责 Binder 通信的建立，以及 Binder数据在进程间的传递和 Binder 引用计数管理/数据包的传输等。</p>
<p>Binder Client 和 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发，</p>
<ul>
<li>对于 Binder Client 而言，它只需要知道自己要使用的 Binder 的名字以及该 <strong>Binder 实体</strong>在 ServerManager 中的 0 号引用即可。<ul>
<li>访问原理：<ul>
<li>通过 0 号引用去访问 ServerManager <strong>获取该 Binder 的引用</strong>，</li>
<li>得到引用后就可以像普通方法调用那样调用 Binder 实体的方法</li>
</ul>
</li>
</ul>
</li>
<li>ServerManager 用来管理 Binder Server（Android 中通常是一个 Service）<ul>
<li>Binder Client 通过它来查询 Binder Server 的引用</li>
<li>ServerManager <strong>是一个标准的 Binder Server</strong>，并且在 Android 中约定其在 Binder 通信过程中的唯一标识（类似于 IP 地址）永远为 0。<ul>
<li>在 IServiceManager 接口中定义有对外开放的接口方法，供客户端访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong>匿名 Binder</strong>。很多时候 Binder Server 会将一个 Binder 实体封装进数据包传递给 Binder Client，而此时 Binder Server 会在该数据包中标注 Binder 实体的位置，Binder Driver 会为该匿名的 Binder 生成实体结点和实体引用，并将该引用传递给 Binder Client。</li>
</ul>
<p>IServiceManager 接口(声明 ServerManger 对外提供的方法、数据 )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IServiceManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">checkService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line"></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></div><div class="line">                <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> String[] listServices() <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPermissionController</span><span class="params">(IPermissionController controller)</span></span></div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String descriptor = <span class="string">"android.os.IServiceManager"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">4</span>;</div><div class="line">    <span class="keyword">int</span> SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Andorid 源码设计模式解析与实战》</p>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> Android 进阶 </category>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android 进阶 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 LayoutInflater]]></title>
      <url>https://timlin-pro.github.io/blog/2017/08/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20LayoutInflater/</url>
      <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p> <code>View rootView  = LayoutInflater.from(getContext()).inflate(R.layout.bitable_grid_view, this, false);</code></p>
<p>Android 开发者对上面这行代码应该不陌生，我们通常用这个方法来渲染一个布局。其中的原理是怎么样的呢？<br>本文主要分析 LayoutInflater 的创建过程以及 inflate 方法的原理。</p>
<a id="more"></a>
<h2 id="二、LayoutInflater-是如何创建的"><a href="#二、LayoutInflater-是如何创建的" class="headerlink" title="二、LayoutInflater 是如何创建的"></a>二、LayoutInflater 是如何创建的</h2><p>从 <code>LayoutInflater#from</code> 方法看起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    LayoutInflater LayoutInflater =</div><div class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</div><div class="line">    <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> LayoutInflater;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，<code>LayoutInflater</code> 是通过 <code>Context#getSystemService</code> 的方式获取的。</p>
<p>Context 是一个抽象类，它的具体实现类为 <code>ContextImpl</code>。所以应该看 ContextImpl 的 getSystemService 是如何实现的。</p>
<p><code>ContextImpl#getSystemService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ContextImpl#getSystemService</code> 方法又委托了 SystemServiceRegistry。</p>
<p><code>SystemServiceRegistry</code> 中有一个 <code>HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;</code> ，该 HashMap 以服务名称为 key，以服务相对应的 ServiceFetcher 作为 value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</div><div class="line">        <span class="keyword">new</span> HashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p>具体的获取方法为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Gets a system service from a given context.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</div><div class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</div><div class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据服务名称去获取相应的 ServiceFetcher，</p>
<ul>
<li>如果 <code>ServiceFetcher</code> 不为空，则调用 <code>ServiceFetcher.getService</code> 方法获取相应服务的引用。<ul>
<li>如果是第一次调用会先创建，然后直接返回</li>
<li>否则直接返回缓存的值</li>
</ul>
</li>
<li>如果 <code>ServiceFetcher</code> 为空，则返回 null。</li>
</ul>
<h3 id="SYSTEM-SERVICE-FETCHER-数据初始化"><a href="#SYSTEM-SERVICE-FETCHER-数据初始化" class="headerlink" title="SYSTEM_SERVICE_FETCHER 数据初始化"></a>SYSTEM_SERVICE_FETCHER 数据初始化</h3><p><code>SYSTEM_SERVICE_FETCHERS</code> 是一个键为 String, 值为 <code>ServiceFetcher&lt;?&gt;</code> 的静态 HashMap 常量，其中的数据是在静态代码块中插入的。</p>
<p>LayoutInflater 对应的 ServiceFetcher 就是在这个时候存储进去的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="comment">//省略一些代码</span></div><div class="line">    registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">    &#125;&#125;);</div><div class="line">    <span class="comment">//省略一些代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="为什么要放在-CachedServiceFetcher-中而不是直接创建呢？"><a href="#为什么要放在-CachedServiceFetcher-中而不是直接创建呢？" class="headerlink" title="为什么要放在 CachedServiceFetcher 中而不是直接创建呢？"></a>为什么要放在 CachedServiceFetcher 中而不是直接创建呢？</h3><p>ServiceFetcher 是一个抽象类，系统使用的一个具体实现类为 CachedServiceFetcher。从名字来看，主要是为了实现懒加载，当首次需要使用才触发初始化，避免浪费资源。</p>
<p>CachedServiceFetcher#getService 方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object[] cache = ctx.mServiceCache;</div><div class="line">    <span class="keyword">synchronized</span> (cache) &#123;</div><div class="line">        <span class="comment">// Fetch or create the service.</span></div><div class="line">        Object service = cache[mCacheIndex];<span class="comment">//先从 ContextImpl 的缓存列表中获取，如果没有缓存再调用 CachedServiceFetcher#createService 方法创建 PhoneLayoutInflater</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                service = createService(ctx);<span class="comment">//创建对应的 service</span></div><div class="line">                cache[mCacheIndex] = service;<span class="comment">//存储到缓存数组中</span></div><div class="line">            &#125; <span class="keyword">catch</span> (ServiceNotFoundException e) &#123;</div><div class="line">                onServiceNotFound(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (T)service;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过 from 的方式获取 LayoutInflater，最终调用的是 SystemServiceRegistry 的 getService 方法，该方法会从 ContextImpl 中维护的缓存数组中获取服务，如果不存在，则调用 createService 方法创建一个 PhoneLayoutInflater。（注：LayoutInflater 是一个抽象类，系统创建的是它的子类—— <code>PhoneLayoutInflater</code>）</p>
<p>onCreateView 是 PhoneLayoutInflater 中最重要的方法。为什么说它重要，后面会提到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Override onCreateView to instantiate names that correspond to the</span></div><div class="line">    widgets known to the Widget factory. If we don't find a match,</div><div class="line">    call through to our super class.</div><div class="line">*/</div><div class="line"><span class="comment">//为系统内置的控件添加前缀。比如为 TextView 添加前缀，结果为 android.widget.TextView</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">    <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            View view = createView(name, prefix, attrs);</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> view;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            <span class="comment">// In this case we want to let the base class take a crack</span></div><div class="line">            <span class="comment">// at it.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三、布局创建过程"><a href="#三、布局创建过程" class="headerlink" title="三、布局创建过程"></a>三、布局创建过程</h2><p>一般我们在渲染 ListView 或者 RecyclerView 中的列表项时，都会调用 <code>inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code> 方法（有时也会使用两个参数的方法）。可以看到该方法内部会调用 <code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    <span class="comment">//获取 xml 解析器</span></div><div class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        parser.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Context inflaterContext = mContext;</div><div class="line">        <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">        Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</div><div class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</div><div class="line">        <span class="comment">//存储传入的父视图</span></div><div class="line">        View result = root;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> type;</div><div class="line">            <span class="comment">// 变量查找根节点</span></div><div class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line">                <span class="comment">// Empty</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> String name = parser.getName();</div><div class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</div><div class="line">                <span class="comment">//1. 解析 merge 标签</span></div><div class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 2. 不是 merge 元素就直接解析布局中的视图</span></div><div class="line"> <span class="comment">// Temp is the root view that was found in the xml</span></div><div class="line">                    <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                    ViewGroup.LayoutParams params = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// 生成布局参数</span></div><div class="line">                        params = root.generateLayoutParams(attrs);</div><div class="line">                        <span class="keyword">if</span> (!attachToRoot) &#123;</div><div class="line">                            <span class="comment">//如果 attachToRoot 为 false，就给 temp 设置布局参数</span></div><div class="line">                            temp.setLayoutParams(params);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// 解析 temp 视图下的所有子 View</span></div><div class="line">                    rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">                    <span class="comment">// 如果 root 不为空并且 attachToRoot 为 true，那么将 temp 添加到 父视图中</span></div><div class="line">                    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</div><div class="line">                        root.addView(temp, params);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">//如果 root 为空 或者 attachToRoot 为 false，返回 xml 中的 root，而不是父视图</span></div><div class="line">                    <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</div><div class="line">                        result = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的 inflate 方法主要有以下几步</p>
<ol>
<li>解析 xml 的根标签</li>
<li>如果根标签是 merge，调用 rInflate 进行解析，rInflate 会将 merge 标签下的所有子 View <strong>直接添加到根标签中</strong></li>
<li>如果标签是普通元素，调用 createFromTag，生成相应的 view。</li>
<li>调用 rInflate 解析 temp 根元素下的所有子 View，并且将这些子 View 都添加到 temp 下</li>
<li>返回解析到的根视图。</li>
</ol>
<p>我们先从解析单个元素的 <code>createViewFromTag</code> 方法看起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span></div><div class="line">        <span class="keyword">boolean</span> ignoreThemeAttr) &#123;</div><div class="line">    <span class="keyword">if</span> (name.equals(<span class="string">"view"</span>)) &#123;</div><div class="line">        name = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Apply a theme wrapper, if allowed and one is specified.</span></div><div class="line">    <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</div><div class="line">        <span class="keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</div><div class="line">            context = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        View view;</div><div class="line">        <span class="comment">//用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段</span></div><div class="line">        <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</div><div class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</div><div class="line">            view = mFactory.onCreateView(name, context, attrs);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            view = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</div><div class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</div><div class="line">            mConstructorArgs[<span class="number">0</span>] = context;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123;</div><div class="line">                    <span class="comment">// 解析内置 View 控件</span></div><div class="line">                    view = onCreateView(parent, name, attrs);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 解析自定义控件</span></div><div class="line">                    view = createView(name, <span class="keyword">null</span>, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//代码省略</span></div></pre></td></tr></table></figure>
<p><strong>onCreateView 方法和 createView 方法有何不同</strong>？<br>前面的介绍中，我们有提到 LayoutInlflater 创建的实际类型为 <code>PhoneLayoutInlflater</code> ，PhoneLayoutInlflater 覆写了 onCreateView 方法，该方法就是在 View 的标签名前添加一个 <code>&quot;android.widget.&quot; 或 &quot;android.webkit.&quot; 或 &quot;android.app.&quot;</code>前缀。然后再传递给 createView 解析。</p>
<ul>
<li>也就是说<strong>内置 View 和自定义 View 最终都调用了 createView 进行解析</strong>。</li>
</ul>
<p><strong>为什么要这么设计呢</strong>？<br>这是为了方便开发者在 xml 文件中更方便使用系统内置的 View（只需要写 View 名称而不需要写完整的路径），如果是自定义控件或者第三方库，写完整路径。</p>
<p>createView 的具体实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据完整路径的类名通过反射机制构造 View 对象</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span></div><div class="line">        <span class="keyword">throws</span> ClassNotFoundException, InflateException &#123;</div><div class="line">    <span class="comment">//从缓存中获取构造函数</span></div><div class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</div><div class="line">    <span class="keyword">if</span> (constructor != <span class="keyword">null</span> &amp;&amp; !verifyClassLoader(constructor)) &#123;</div><div class="line">        constructor = <span class="keyword">null</span>;</div><div class="line">        sConstructorMap.remove(name);</div><div class="line">    &#125;</div><div class="line">    Class&lt;? extends View&gt; clazz = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</div><div class="line"></div><div class="line">        <span class="comment">// 缓存中找不到构造函数</span></div><div class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//如果前缀（prefix）不为空，构造完整路径，并且加载该类</span></div><div class="line">            clazz = mContext.getClassLoader().loadClass(</div><div class="line">                    prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            <span class="comment">//从 class 对象中获取构造函数</span></div><div class="line">            constructor = clazz.getConstructor(mConstructorSignature);</div><div class="line">            constructor.setAccessible(<span class="keyword">true</span>);</div><div class="line">            sConstructorMap.put(name, constructor);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Object[] args = mConstructorArgs;</div><div class="line">        args[<span class="number">1</span>] = attrs;</div><div class="line">        <span class="comment">//通过反射构造 View</span></div><div class="line">        <span class="keyword">final</span> View view = constructor.newInstance(args);</div><div class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewStub) &#123;</div><div class="line">            <span class="comment">// Use the same context when inflating ViewStub later.</span></div><div class="line">            <span class="keyword">final</span> ViewStub viewStub = (ViewStub) view;</div><div class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line"></div><div class="line">    &#125; </div><div class="line">    <span class="comment">//省略各种 catch、finally 代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>createView 方法中，如果控件名有前缀就先构造 View 的完整路径，并且将该类加载到虚拟机中</p>
<ul>
<li>然后获取该类的构造函数并缓存起来，再通过构造函数来创建该 View 的对象，</li>
<li>最后将 View 对象返回，这就是解析单个 View 的过程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span></div><div class="line">        AttributeSet attrs, <span class="keyword">boolean</span> finishInflate) <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</div><div class="line">    <span class="comment">//获取树的深度</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> depth = parser.getDepth();</div><div class="line">    <span class="keyword">int</span> type;</div><div class="line">    <span class="comment">//逐个元素解析</span></div><div class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> String name = parser.getName();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</div><div class="line">            parseRequestFocus(parser, parent);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123;</div><div class="line">            parseViewTag(parser, parent, attrs);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;<span class="comment">//解析 include 标签</span></div><div class="line">            <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;include /&gt; cannot be the root element"</span>);</div><div class="line">            &#125;</div><div class="line">            parseInclude(parser, context, parent, attrs);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;解析 merge 标签</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; must be the root element"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//根据元素名进行解析</span></div><div class="line">            <span class="keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);</div><div class="line">            <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;</div><div class="line">            <span class="keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div class="line">            <span class="comment">//递归调用进行解析，即深度优先遍历</span></div><div class="line">            rInflateChildren(parser, view, attrs, <span class="keyword">true</span>);</div><div class="line">            <span class="comment">//将解析到的 View 添加到它的父视图中</span></div><div class="line">            viewGroup.addView(view, params);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (finishInflate) &#123;</div><div class="line">        parent.onFinishInflate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rInflate() 通过深度优先遍历来构造视图树。每解析到一个 View 元素就会递归调用 rInflate，直到这条路径下的最后一个元素，<br>然后在回溯过来将每个 View 元素添加到它们的 parent 中。</p>
<ul>
<li>通过 rInflate 的解析之后，整棵视图树就构建完毕。当调用了 Activity 的 onResume 之后，之前通过 setContentView 设置的内容就会出现在我们的视野中。</li>
</ul>
<h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><h3 id="inflate-方法有多种重载，它们的区别在哪里？"><a href="#inflate-方法有多种重载，它们的区别在哪里？" class="headerlink" title="inflate 方法有多种重载，它们的区别在哪里？"></a>inflate 方法有多种重载，它们的区别在哪里？</h3><p>三个参数的 infalte 方法的各个参数的含义是什么？</p>
<p><code>LayoutInflater#inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code></p>
<p>resource 参数为布局资源。是一个 xml 文件。</p>
<p>若 root 不为空时</p>
<ul>
<li>如果 attachToRoot 为 true，则它是 xml 文件的根布局的父布局。（也就是说，渲染出来的布局被 add root 中。同时，inflate 方法的返回值为 root）</li>
<li>如果 attachToRoot 为 false，它只是为 xml 文件的根布局 提供一组 LayoutParams 值。同时 inflate 方法返回的 xml 文件的根布局。</li>
</ul>
<p>两个参数的 inflate 方法，内部也是调用三个参数的 infalte 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 root 不为空的时候，inflate(@LayoutRes int resource, @Nullable ViewGroup root) 方法默认将渲染后的布局 add 到 root 中。</p>
<p>还有另外两种重载，区别仅在于它们的第一个参数都是 XmlPullParser，root 和 attachToRoot 参数表现与上述一致。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>创建流程大致如下：</p>
<p>首先查找根标签</p>
<ul>
<li>如果是 merge，调用 rInflate</li>
<li>否则，调用 <code>createViewFromTag</code><ul>
<li>如果是系统内置控件（通过名称中是否含有「.」来判断），调用 <code>PhoneLayoutInflater.onCreateView()</code> 方法添加前缀，<ul>
<li>处理后将完整路径传给 <code>LayoutInflater.createView()</code> 方法，该方法内部会通过反射的方式创建出对应的 view 实例。</li>
</ul>
</li>
<li>否则，直接调用 <code>LayoutInflater.createView()</code> 进行解析。该方法内部会通过反射的方式创建出对应的 view 实例。</li>
</ul>
</li>
</ul>
<h2 id="五、拓展用法"><a href="#五、拓展用法" class="headerlink" title="五、拓展用法"></a>五、拓展用法</h2><p>前面提到在布局创建过程中，会调用 createViewFromTag 方法。</p>
<p>createViewFromTag 方法中，有下一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">View view;</div><div class="line"><span class="comment">//用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段</span></div><div class="line"><span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</div><div class="line">    view = mFactory2.onCreateView(parent, name, context, attrs);<span class="comment">//如果Factory2不为空，调用 mFactory2 创建 view</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</div><div class="line">    view = mFactory.onCreateView(name, context, attrs);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    view = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Version of &#123;<span class="doctag">@link</span> #onCreateView(String, Context, AttributeSet)&#125;</div><div class="line">     * that also supplies the parent that the view created view will be</div><div class="line">     * placed in.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> parent The parent that the created view will be placed</div><div class="line">     * in; &lt;em&gt;note that this may be null&lt;/em&gt;.</div><div class="line">     * <span class="doctag">@param</span> name Tag name to be inflated.</div><div class="line">     * <span class="doctag">@param</span> context The context the view is being created in.</div><div class="line">     * <span class="doctag">@param</span> attrs Inflation attributes as specified in XML file.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> View Newly created view. Return null for the default</div><div class="line">     *         behavior.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以自己实现 Factory 中的  onCreateView 方法。系统在填充 view 前会回调该方法，可以返回什么样的 view 已经其中的属性。</p>
<h3 id="1-全局替换字体属性"><a href="#1-全局替换字体属性" class="headerlink" title="1.全局替换字体属性"></a>1.全局替换字体属性</h3><p>因为字体是 TextView 的一个属性，为了加一个属性，我们就没必要去全部的布局中进行更改，只需要上我们的 onCreateView 中，发现是 TextView，就去设置我们对应的字体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Typeface typeface;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (typeface == <span class="keyword">null</span>)&#123;</div><div class="line">        typeface = Typeface.createFromAsset(getAssets(), <span class="string">"xxxx.ttf"</span>);</div><div class="line">    &#125;</div><div class="line">    LayoutInflaterCompat.setFactory2(LayoutInflater.from(<span class="keyword">this</span>), <span class="keyword">new</span> LayoutInflater.Factory2() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">            AppCompatDelegate delegate = getDelegate();</div><div class="line">            View view = delegate.createView(parent, name, context, attrs);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ( view!= <span class="keyword">null</span> &amp;&amp; (view <span class="keyword">instanceof</span> TextView))&#123;</div><div class="line">                ((TextView) view).setTypeface(typeface);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> view;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-动态换肤功能"><a href="#2-动态换肤功能" class="headerlink" title="2.动态换肤功能"></a>2.动态换肤功能</h3><p>基本原理和上面的更换字体类似，我们可以对做了标记的 View 进行识别，然后在 onCreateView 遍历到它的时候，更改它的一些属性，比如背景色等，然后再交给系统去生成 View。</p>
<h3 id="3-无需编写-shape、selector，直接在-xml-设置值"><a href="#3-无需编写-shape、selector，直接在-xml-设置值" class="headerlink" title="3.无需编写 shape、selector，直接在 xml 设置值"></a>3.无需编写 shape、selector，直接在 xml 设置值</h3><p><a href="https://juejin.im/post/5b9682ebe51d450e543e3495" target="_blank" rel="noopener">无需自定义 View，彻底解放 shape，selector 吧</a></p>
<p>文章中讲到我们如果要设置控件的角度等属性值，不需要再去写特定的 shape 或者 selector 文件，直接在 xml 中写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Button</div><div class="line">      android:id=&quot;@+id/btn&quot;</div><div class="line">      android:layout_width=&quot;130dp&quot;</div><div class="line">      android:layout_height=&quot;36dp&quot;</div><div class="line">      android:layout_marginTop=&quot;5dp&quot;</div><div class="line">      android:gravity=&quot;center&quot;</div><div class="line">      android:padding=&quot;0dp&quot;</div><div class="line">      android:text=&quot;跳转到列表&quot;</div><div class="line">      android:textColor=&quot;#4F94CD&quot;</div><div class="line">      android:textSize=&quot;20sp&quot;</div><div class="line">      app:bl_corners_radius=&quot;20dp</div><div class="line">      app:bl_gradient_angle=&quot;0&quot;</div><div class="line">      app:bl_gradient_endColor=&quot;#4F94CD&quot;</div><div class="line">      app:bl_gradient_startColor=&quot;#63B8FF&quot;</div><div class="line">      app:bl_shape=&quot;rectangle&quot; /&gt;</div></pre></td></tr></table></figure>
<p>其原理也是通过自定义 Factory，在<code>Factory2#onCreateView</code>方法里面，判断 attrs 的参数名字，比如发现名字是我们制定的 stroke_color 属性，就去通过代码手动帮他去设置这个值,我们来查看下它的 onCreateView 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">	<span class="comment">//省略一些代码</span></div><div class="line">    <span class="keyword">if</span> (typedArray.getBoolean(R.styleable.background_ripple_enable, <span class="keyword">false</span>) &amp;&amp;</div><div class="line">        typedArray.hasValue(R.styleable.background_ripple_color)) &#123;</div><div class="line">        <span class="keyword">int</span> color = typedArray.getColor(R.styleable.background_ripple_color, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class="line">                Drawable contentDrawable = (stateListDrawable == <span class="keyword">null</span> ? drawable : stateListDrawable);</div><div class="line">                RippleDrawable rippleDrawable = <span class="keyword">new</span> RippleDrawable(ColorStateList.valueOf(color), contentDrawable, contentDrawable);</div><div class="line">                view.setClickable(<span class="keyword">true</span>);</div><div class="line">                view.setBackground(rippleDrawable);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                StateListDrawable tmpDrawable = <span class="keyword">new</span> StateListDrawable();</div><div class="line">                GradientDrawable unPressDrawable = DrawableFactory.getDrawable(typedArray);</div><div class="line">                unPressDrawable.setColor(color);</div><div class="line">                tmpDrawable.addState(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-android.R.attr.state_pressed&#125;, drawable);</div><div class="line">                tmpDrawable.addState(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;android.R.attr.state_pressed&#125;, unPressDrawable);</div><div class="line">                view.setClickable(<span class="keyword">true</span>);</div><div class="line">                view.setBackground(tmpDrawable);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="六、参考资料与学习资源推荐"><a href="#六、参考资料与学习资源推荐" class="headerlink" title="六、参考资料与学习资源推荐"></a>六、参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="https://www.jianshu.com/p/8d8ada21ab82" target="_blank" rel="noopener">Android 技能树 — LayoutInflater Factory 小结</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> Android 进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android 进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的观察者模式]]></title>
      <url>https://timlin-pro.github.io/blog/2017/08/09/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="解决、解耦的钥匙——观察者模式"><a href="#解决、解耦的钥匙——观察者模式" class="headerlink" title="解决、解耦的钥匙——观察者模式"></a>解决、解耦的钥匙——观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式定义了对象间一种<strong>一对多</strong>的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>关联行为场景<ul>
<li>需要注意的是，关联行为是可拆分的，而不是“组合”关系</li>
</ul>
</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>
<a id="more"></a>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p>UML 类图如下所示：<br><img src="https://user-images.githubusercontent.com/16668676/29015194-a1c0db10-7b7f-11e7-99a0-437680f88188.png" alt="uml"></p>
<p>四个角色：</p>
<ul>
<li>Subject 抽象主题（抽象的被观察者）。把所有观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，提供接口供添加和删除观察者对象。</li>
<li>ConcreteSubject 具体主题（具体的被观察者）。将有关状态存入具体观察者对象，在具体主题的内部实现发生改变时，给所有注册过的观察者发出通知</li>
<li>Observer 抽象观察者。定义一个更新接口，用来接收主题更改时做出相应的操作（比如更新自身的状态）</li>
<li>ConcreteObserver 具体观察者（实现抽象观察者所定义的更新接口，以便在主题状态更改时更新自身的状态）</li>
</ul>
<h2 id="Android-ListView-的观察者模式"><a href="#Android-ListView-的观察者模式" class="headerlink" title="Android ListView 的观察者模式"></a>Android ListView 的观察者模式</h2><p>ListView 和 RecyclerView 在 Android 中都占据着很重要的地位。</p>
<p>使用这两个组件时，总免不了数据更新的情况：当要更新数据时我们通常都会调用 <code>Adapter.notifyDataSetChanged()</code>，这其中的原理又是怎么样的呢？</p>
<p>下面以 ListView 作为一个栗子，看看其中的具体实现是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void notifyDataSetChanged() &#123;</div><div class="line">    mDataSetObservable.notifyChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void notifyChanged() &#123;</div><div class="line">    synchronized(mObservers) &#123;</div><div class="line">        // since onChanged() is implemented by the app, it could do anything, including</div><div class="line">        // removing itself from &#123;@link mObservers&#125; - and that could cause problems if</div><div class="line">        // an iterator is used on the ArrayList &#123;@link mObservers&#125;.</div><div class="line">        // to avoid such problems, just march thru the list in the reverse order.</div><div class="line">        for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">            mObservers.get(i).onChanged();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>notifyDataSetChanged 方法会调用  <code>DataSetObservable.notifyChanged()</code> 方法,notifyChanged() 内部会遍历调用观察者的 onChanged() 方法。通知数据更新。</li>
<li>但是观察者又是什么时候注册的呢？</li>
</ul>
<p>以下为 setAdapter 的方法的具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setAdapter(ListAdapter adapter) &#123;</div><div class="line">    //如果 已经有 Adapter 存在，先解除注册</div><div class="line">    if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123;</div><div class="line">        mAdapter.unregisterDataSetObserver(mDataSetObserver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resetList();</div><div class="line">    mRecycler.clear();</div><div class="line"></div><div class="line">    if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123;</div><div class="line">        mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter);</div><div class="line">    &#125; else &#123;</div><div class="line">        mAdapter = adapter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mOldSelectedPosition = INVALID_POSITION;</div><div class="line">    mOldSelectedRowId = INVALID_ROW_ID;</div><div class="line"></div><div class="line">    // AbsListView#setAdapter will update choice mode states.</div><div class="line">    super.setAdapter(adapter);</div><div class="line"></div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = mAdapter.getCount();</div><div class="line">        checkFocus();</div><div class="line">        // 构建一个 AdapterDataSetObserver </div><div class="line">        mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">        mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者</div><div class="line"></div><div class="line">        mRecycler.setViewTypeCount(mAdapter.getViewTypeCount());</div><div class="line"></div><div class="line">        int position;</div><div class="line">        if (mStackFromBottom) &#123;</div><div class="line">            position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">        &#125; else &#123;</div><div class="line">            position = lookForSelectablePosition(0, true);</div><div class="line">        &#125;</div><div class="line">        setSelectedPositionInt(position);</div><div class="line">        setNextSelectedPositionInt(position);</div><div class="line"></div><div class="line">        if (mItemCount == 0) &#123;</div><div class="line">            // Nothing selected</div><div class="line">            checkSelectionChanged();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        mAreAllItemsSelectable = true;</div><div class="line">        checkFocus();</div><div class="line">        // Nothing selected</div><div class="line">        checkSelectionChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过源码可以看到，setAdapter 方法内部会构建一个 <code>AdapterDataSetObserver</code> ，然后注册为观察者。我们还可以看到注册的时候是通过 Adapter 来注册的。</p>
<p>Adapter 接口中声明了注册和解注册的方法签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface Adapter &#123;</div><div class="line">    /**</div><div class="line">     * Register an observer that is called when changes happen to the data used by this adapter.</div><div class="line">     *</div><div class="line">     * @param observer the object that gets notified when the data set changes.</div><div class="line">     */</div><div class="line">    void registerDataSetObserver(DataSetObserver observer);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Unregister an observer that has previously been registered with this</div><div class="line">     * adapter via &#123;@link #registerDataSetObserver&#125;.</div><div class="line">     *</div><div class="line">     * @param observer the object to unregister.</div><div class="line">     */</div><div class="line">    void unregisterDataSetObserver(DataSetObserver observer);</div><div class="line">    //代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 BaseAdapter 实现了 ListAdapter 接口，ListAdapter 接口又继承自 Adapter 接口。<br>BaseAdapter 中注册方法和解除注册方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void registerDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.registerObserver(observer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void unregisterDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.unregisterObserver(observer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseAdapter 中注册方法和解除注册方法的具体实现都是通过 mDataSetObservable 来完成的。查看一下 DataSetObservable 的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123;</div><div class="line">    public void notifyChanged() &#123;</div><div class="line">        synchronized(mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void notifyInvalidated() &#123;</div><div class="line">        synchronized (mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onInvalidated();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该类继承了 <code>android.database</code> 包下的 Observable 类，而 Observable 类中存有所有观察者的引用，以及注册和解注册方法。</p>
<p>ListView 中的 onChange 方法具体实现又是什么样的?</p>
<ul>
<li>还记得前面我们说 Observer 是如何注册的吗？注册时，我们构建的是 AdapterDataSetObserver。</li>
<li>该类是 AbsListView 的内部类。<ul>
<li>AbsListView.AdapterDataSetObserver 继承自 AdapterView<listadapter>.AdapterDataSetObserver </listadapter></li>
<li>onChange 方法的主要逻辑都在 AdapterDataSetObserver 中</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class AdapterDataSetObserver extends DataSetObserver &#123;</div><div class="line">    //代码省略 ...</div><div class="line">    @Override</div><div class="line">    public void onChanged() &#123;</div><div class="line">        mDataChanged = true;</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = getAdapter().getCount();</div><div class="line"></div><div class="line">        // Detect the case where a cursor that was previously invalidated has</div><div class="line">        // been repopulated with new data.</div><div class="line">        if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null</div><div class="line">                &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123;</div><div class="line">            AdapterView.this.onRestoreInstanceState(mInstanceState);</div><div class="line">            mInstanceState = null;</div><div class="line">        &#125; else &#123;</div><div class="line">            rememberSyncState();</div><div class="line">        &#125;</div><div class="line">        checkFocus();</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div><div class="line">    //代码省略 ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>onChange 方法中，会获取当前 Adapter 中的数据集的新数量，方法的最后调用 ListView 的 requestLayout() 方法重新进行布局。</p>
<p>从上面的分析中，我们可以看到</p>
<ul>
<li>AbsListView 是抽象的观察者</li>
<li>ListView 是具体的观察者</li>
<li>Adapter 接口是抽象的被观察者</li>
<li>BaseAdapter 是具体的被观察者，其内部实际上是通过 <code>android.database</code> 包下的 Observerable 来实现注册和监听的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>AdapterView 中有一个 AdapterDataSetObserver 内部类，</li>
<li>在 ListView 中设置 Adapter（即调用 ListView 的 setAdapter 方法）时，其内部会构建一个 AdapterDataSetObserver，并注册到 Adapter 中。可见该场景中 ListView 扮演一个观察者角色。</li>
<li>而 Adapter 中有一个数据集可观察者 DataSetObserable。即一个被观察者。</li>
<li>数据集发生变化时，开发者手动调用 Adapter.notifyDataSetChanged 方法，notifyDataSetChanged 会调用 <code>DataSetObserverable.notifyChanged()</code><ul>
<li>notifyChanged() 方法会遍历所有观察者，并调用观察者的 <code>onChanged</code> 方法，</li>
<li>onChanged 会获取 Adapter 中数据集的新数量，同时会调用 View.requestLayout 方法通知 ListView 更新布局，刷新用户界面。</li>
</ul>
</li>
</ul>
<p>虽然 RecyclerView 直接继承自 ViewGroup，而不是 AdapterView ，但是更新列表数据集方法的内部也是通过观察者模式来实现的。只是在其中多提供了单个数据或者指定范围数据更新等回调接口，供开发者使用。感兴趣的同学可以去看看 RecyclerView 中观察者模式的实现。</p>
<p>作者水平有限，疏漏之处，恳请指出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Android 源码设计模式解析与实战》 第十二章 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> Android 进阶 </category>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android 进阶 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Toast 原理]]></title>
      <url>https://timlin-pro.github.io/blog/2017/07/28/Toast%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p><code>Toast.makeText(context,&quot;msg&quot;,Toast.Length_SHORT).show();</code></p>
<p>我们都知道调用了这行代码，便会触发显示 Toast 信息，但是从调用开始到显示出来的具体过程是怎么样的，里面具体实现又是怎么样的呢？</p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在 Toast 内部有两类 IPC 过程。</p>
<ul>
<li>第一类： Toast 访问 NotificationManagerService</li>
<li>第二类：NotificationManagerService 回调 Toast 里的 TN 接口。</li>
</ul>
<p>Toast 属于系统 Window，它内部的视图由两种方式指定，一种是系统默认的样式，另一种是自定义一个 view 然后通过 setView 方法将 view 设置进去。<br>不管哪一种方式，它们都对应 Toast 的一个 View 类型的内部成员 mNextView。</p>
<p>Toast 提供 show 和 cancel 方法分别用于显示和隐藏 view，它们的内部都是一个 IPC 过程。</p>
<p>Toast 有定时取消功能，所以系统采用了 Handler（利用其中的 sendMessageDelayed() 方法）</p>
<p>Toast.show() 调用流程大致如下：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28705462-7393612a-73a2-11e7-92b0-5d0ebfb237f0.jpg" alt="toast show"></p>
<p>先来看看 Toast.makeText 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</div><div class="line">    Toast result = new Toast(context);//创建一个新的 Toast 对象</div><div class="line"></div><div class="line">    LayoutInflater inflate = (LayoutInflater)</div><div class="line">            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取 LayoutInflater</div><div class="line">    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); //渲染出系统默认的布局</div><div class="line">    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</div><div class="line">    tv.setText(text);//将我们的信息设置到 TextView 中去</div><div class="line">    </div><div class="line">    result.mNextView = v;//把 view 赋给 Toast 内部的View</div><div class="line">    result.mDuration = duration;//设置 toast 时长</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再瞧一瞧 Toast.show(); 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void show() &#123;</div><div class="line">    if (mNextView == null) &#123;//判断，如果没有设置 Toast 的 view，就抛出异常</div><div class="line">        throw new RuntimeException(&quot;setView must have been called&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INotificationManager service = getService();//获取 INotificationManager </div><div class="line">    String pkg = mContext.getOpPackageName();// 获取调用者的包名</div><div class="line">    TN tn = mTN;//给 TN 赋值</div><div class="line">    tn.mNextView = mNextView;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        service.enqueueToast(pkg, tn, mDuration);</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        // Empty</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面有几个地方看起来比较陌生 INotificationManager 是什么，TN 又是什么？</p>
<p>INotificationManager 的值是从 getService() 方法中得来的。我们先查看下 getService() 的内部实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static private INotificationManager getService() &#123;</div><div class="line">    if (sService != null) &#123;</div><div class="line">        return sService;</div><div class="line">    &#125;</div><div class="line">    sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;));</div><div class="line">    return sService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>了解 Binder 的同学应该一看便知道，这里用到了 Binder。</li>
<li>INotificationManager 的具体实现在 NotificationManagerService 中，简便起见，后续内容将 NotificationManagerService 称为 NMS。</li>
</ul>
<p>TN 又是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TN</span> <span class="keyword">extends</span> <span class="title">ITransientNotification</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable mHide = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            handleHide();</div><div class="line">            <span class="comment">// Don't do this in handleHide() because it is also invoked by handleShow()</span></div><div class="line">            mNextView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManager.LayoutParams mParams = <span class="keyword">new</span> WindowManager.LayoutParams();</div><div class="line">    <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            IBinder token = (IBinder) msg.obj;</div><div class="line">            handleShow(token);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mGravity;</div><div class="line">    <span class="keyword">int</span> mX, mY;</div><div class="line">    <span class="keyword">float</span> mHorizontalMargin;</div><div class="line">    <span class="keyword">float</span> mVerticalMargin;</div><div class="line"></div><div class="line"></div><div class="line">    View mView;</div><div class="line">    View mNextView;</div><div class="line">    <span class="keyword">int</span> mDuration;</div><div class="line"></div><div class="line">    WindowManager mWM;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SHORT_DURATION_TIMEOUT = <span class="number">5000</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LONG_DURATION_TIMEOUT = <span class="number">1000</span>;</div><div class="line"></div><div class="line">    TN() &#123;</div><div class="line">        <span class="comment">// XXX This should be changed to use a Dialog, with a Theme.Toast</span></div><div class="line">        <span class="comment">// defined that sets up the layout params appropriately.</span></div><div class="line">        <span class="keyword">final</span> WindowManager.LayoutParams params = mParams;</div><div class="line">        params.height = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.width = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.format = PixelFormat.TRANSLUCENT;</div><div class="line">        params.windowAnimations = com.android.internal.R.style.Animation_Toast;</div><div class="line">        params.type = WindowManager.LayoutParams.TYPE_TOAST;</div><div class="line">        params.setTitle(<span class="string">"Toast"</span>);</div><div class="line">        params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleShow into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"SHOW: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.obtainMessage(<span class="number">0</span>, windowToken).sendToTarget();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleHide into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HIDE: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.post(mHide);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE SHOW: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView</div><div class="line">                + <span class="string">" mNextView="</span> + mNextView);</div><div class="line">        <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">            <span class="comment">// remove the old view if necessary</span></div><div class="line">            handleHide();</div><div class="line">            mView = mNextView;</div><div class="line">            Context context = mView.getContext().getApplicationContext();</div><div class="line">            String packageName = mView.getContext().getOpPackageName();</div><div class="line">            <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</div><div class="line">                context = mView.getContext();</div><div class="line">            &#125;</div><div class="line">            mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">            <span class="comment">// We can resolve the Gravity here by using the Locale for getting</span></div><div class="line">            <span class="comment">// the layout direction</span></div><div class="line">            <span class="keyword">final</span> Configuration config = mView.getContext().getResources().getConfiguration();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</div><div class="line">            mParams.gravity = gravity;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</div><div class="line">                mParams.horizontalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</div><div class="line">                mParams.verticalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            mParams.x = mX;</div><div class="line">            mParams.y = mY;</div><div class="line">            mParams.verticalMargin = mVerticalMargin;</div><div class="line">            mParams.horizontalMargin = mHorizontalMargin;</div><div class="line">            mParams.packageName = packageName;</div><div class="line">            mParams.hideTimeoutMilliseconds = mDuration ==</div><div class="line">                Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</div><div class="line">            mParams.token = windowToken;</div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeView(mView);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"ADD! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.addView(mView, mParams);</div><div class="line">            trySendAccessibilityEvent();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trySendAccessibilityEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">        AccessibilityManager accessibilityManager =</div><div class="line">                AccessibilityManager.getInstance(mView.getContext());</div><div class="line">        <span class="keyword">if</span> (!accessibilityManager.isEnabled()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// treat toasts as notifications since they are used to</span></div><div class="line">        <span class="comment">// announce a transient piece of information to the user</span></div><div class="line">        AccessibilityEvent event = AccessibilityEvent.obtain(</div><div class="line">                AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);</div><div class="line">        event.setClassName(getClass().getName());</div><div class="line">        event.setPackageName(mView.getContext().getPackageName());</div><div class="line">        mView.dispatchPopulateAccessibilityEvent(event);</div><div class="line">        accessibilityManager.sendAccessibilityEvent(event);</div><div class="line">    &#125;        </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE HIDE: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView);</div><div class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// note: checking parent() just to make sure the view has</span></div><div class="line">            <span class="comment">// been added...  i have seen cases where we get here when</span></div><div class="line">            <span class="comment">// the view isn't yet added, so let's try not to crash.</span></div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeViewImmediate(mView);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TN 是 Toast 的一个私有的静态内部类，继承自 ITransientNotification.Stub </p>
<ul>
<li>也是用到了 Binder 机制。</li>
</ul>
<p>在回到 show 方法。该方法最后调用了 <code>service.enqueueToast(pkg, tn, mDuration);</code> 方法。我们到 NMS 看看该方法的主要实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueToast</span><span class="params">(String pkg, ITransientNotification callback, <span class="keyword">int</span> duration)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="comment">//....</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isSystemToast = isCallerSystem() || (<span class="string">"android"</span>.equals(pkg));<span class="comment">//是否是 android 系统的 toast</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPackageSuspended =</div><div class="line">            isPackageSuspendedForUser(pkg, Binder.getCallingUid());</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">synchronized</span> (mToastQueue) &#123;</div><div class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">        <span class="keyword">long</span> callingId = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ToastRecord record;</div><div class="line">            <span class="keyword">int</span> index = indexOfToastLocked(pkg, callback);<span class="comment">//根据包名和回调来获取的对应包名的 Toast 的在 mToastQueue 中的位置（如果有的话）</span></div><div class="line">            <span class="comment">//如果对应包名的 Toast 已经存在了，则直接在原位更新，不会把它排到队尾</span></div><div class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">                record = mToastQueue.get(index);</div><div class="line">                record.update(duration);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//限制非系统应用的数量（不能超过 50），防止 DOS 攻击同时也是为了解决内存泄漏问题</span></div><div class="line">                <span class="keyword">if</span> (!isSystemToast) &#123;</div><div class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = mToastQueue.size();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">                         <span class="keyword">final</span> ToastRecord r = mToastQueue.get(i);</div><div class="line">                         <span class="keyword">if</span> (r.pkg.equals(pkg)) &#123;</div><div class="line">                             count++;</div><div class="line">                             <span class="keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;</div><div class="line">                                 Slog.e(TAG, <span class="string">"Package has already posted "</span> + count</div><div class="line">                                        + <span class="string">" toasts. Not showing more. Package="</span> + pkg);</div><div class="line">                                 <span class="keyword">return</span>;</div><div class="line">                             &#125;</div><div class="line">                         &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Binder token = <span class="keyword">new</span> Binder();</div><div class="line">                mWindowManagerInternal.addWindowToken(token,</div><div class="line">                        WindowManager.LayoutParams.TYPE_TOAST);</div><div class="line">                record = <span class="keyword">new</span> ToastRecord(callingPid, pkg, callback, duration, token);<span class="comment">//将 Toast 包装为 ToastRecord</span></div><div class="line">                mToastQueue.add(record);<span class="comment">//加入 mToastQueue</span></div><div class="line">                index = mToastQueue.size() - <span class="number">1</span>;</div><div class="line">                keepProcessAliveIfNeededLocked(callingPid);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</div><div class="line">                showNextToastLocked();<span class="comment">//显示下一条 Toast</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(callingId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会将 Toast 请求封装为 ToastRecord 并将其添加进 mToastQueue 队列中。</p>
<ul>
<li>mToastQueue 是一个 ArrayList</li>
<li>注意：每个非系统应用最多只能有 50 个ToastRecord。如果超出了最大值，就会出错。<ul>
<li>这样做主要是为了 防止 DOS（Denial Of Service）</li>
</ul>
</li>
</ul>
<blockquote>
<p>拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
</blockquote>
<p>将 ToastRecord 加入队列之后， <code>enqueueToast</code> 还调用了 <code>showNextToastLocked();</code> 方法, 该方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void showNextToastLocked() &#123;</div><div class="line">    ToastRecord record = mToastQueue.get(0);</div><div class="line">    while (record != null) &#123;</div><div class="line">        if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback);</div><div class="line">        try &#123;</div><div class="line">            record.callback.show(record.token);//调用 record 对象中 callback 的 show 方法</div><div class="line">            scheduleTimeoutLocked(record); //超时提醒，控制显示时间</div><div class="line">            return;</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            //...代码省略</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 callBack 是什么？</p>
<ul>
<li>它是在 ToastRecord 中的，瞅瞅 ToastRecord 的构造方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ToastRecord(<span class="keyword">int</span> pid, String pkg, ITransientNotification callback, <span class="keyword">int</span> duration,</div><div class="line">            Binder token) &#123;</div><div class="line">    <span class="keyword">this</span>.pid = pid;</div><div class="line">    <span class="keyword">this</span>.pkg = pkg;</div><div class="line">    <span class="keyword">this</span>.callback = callback;</div><div class="line">    <span class="keyword">this</span>.duration = duration;</div><div class="line">    <span class="keyword">this</span>.token = token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在 enqueueToast 方法中，将 Toast 包装为 ToastRecord ，创建了 ToastRecord 对象。</p>
<ul>
<li><code>record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord</code> </li>
<li>callBack 是 enqueueToast 中的一个参数，我们的调用如下： <code>service.enqueueToast(pkg, tn, mDuration);</code> </li>
<li><p>没错，callBack 实际上就是前面讲到的 Toast 的内部类 TN。</p>
<ul>
<li>回到前面看看，TN 确实继承了 <code>ITransientNotification.Stub</code>。</li>
</ul>
</li>
<li><p>showNextToastLocked() 方法调用 callBack 的 show() 方法来显示 Toast。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void show(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</div><div class="line">    mHandler.obtainMessage(0, windowToken).sendToTarget();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final Handler mHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        IBinder token = (IBinder) msg.obj;</div><div class="line">        handleShow(token);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其具体实现又是在 handleShow(token);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">        <span class="comment">// 如果有必要的话，将还在显示的 toast 隐藏掉</span></div><div class="line">        handleHide();</div><div class="line">        mView = mNextView;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);<span class="comment">//获取 windowManager</span></div><div class="line">        <span class="comment">//省略代码，给布局参数赋值</span></div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.removeView(mView);</div><div class="line">        &#125;</div><div class="line">        mWM.addView(mView, mParams);</div><div class="line">        trySendAccessibilityEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码核心在于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">mWM.addView(mView, mParams);</div></pre></td></tr></table></figure></p>
<p>将 Toast 的视图添加到 Window 中。 这样 View 就能顺利显示出来了。</p>
<p>你可能会问，为什么 TN 调用 show 方法要用到的 Handler ？</p>
<ul>
<li>因为该方法是被是被 NMS 以跨进程方式调用的，因此它们运行在 Binder 线程池中。为了将执行环境切换到 Toast 请求所在的线程，在它们内部使用了 Handler。</li>
</ul>
<p>那么时间到了 Toast 又是怎么样取消的呢？</p>
<ul>
<li><p>在令 Toast 显示方法调用过程中 我们也调用了 <code>scheduleTimeoutLocked(record);</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void scheduleTimeoutLocked(ToastRecord r)&#123;</div><div class="line">    mHandler.removeCallbacksAndMessages(r);</div><div class="line">    Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</div><div class="line">    long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;//设置 延迟时间</div><div class="line">    mHandler.sendMessageDelayed(m, delay);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SHORT_DELAY 为 2s</p>
</li>
<li>LONG_DELAY 为 3.5s</li>
</ul>
<p>scheduleTimeoutLocked 会发出消息给 hanlder,收到相应的信息后 handleMessage 方法会调用<code>handleTimeout((ToastRecord)msg.obj);</code>, 该方法又会调用 <code>cancelToastLocked(index);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelToastLocked</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    ToastRecord record = mToastQueue.get(index);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        record.callback.hide();<span class="comment">//</span></div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到隐藏 Toast 的实现也是在 TN 中的。与 handleShow 对应，有一个 handleHide 方法。<br>该方法会将 Toast 的视图从 Window 中移除。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            mWM.removeViewImmediate(mView);</div><div class="line">        &#125;</div><div class="line">        mView = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Toast-的「一个-Bug」"><a href="#Toast-的「一个-Bug」" class="headerlink" title="Toast 的「一个 Bug」"></a>Toast 的「一个 Bug」</h2><p>其实这是一个系统的Bug，谷歌为了让应用的 Toast 能够显示在其他应用上面，所以使用了通知栏相关的 API，但是这个 API 随着用户屏蔽通知栏而变得不可用，系统错误地认为你没有通知栏权限，从而间接导致 Toast 有 show 请求时被系统所拦截</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://www.jianshu.com/p/1d64a5ccbc7c" target="_blank" rel="noopener">Toast通知栏权限填坑指南</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建型模式之单例模式]]></title>
      <url>https://timlin-pro.github.io/blog/2017/07/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、什么是单例模式？"><a href="#一、什么是单例模式？" class="headerlink" title="一、什么是单例模式？"></a>一、什么是单例模式？</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">wiki</a> 给出的定义如下：单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
<ul>
<li>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</li>
</ul>
<a id="more"></a>
<h2 id="二、为什么要使用单例模式？"><a href="#二、为什么要使用单例模式？" class="headerlink" title="二、为什么要使用单例模式？"></a>二、为什么要使用单例模式？</h2><ul>
<li>有一些对象的内存消耗比较大，创建多次会造成很大的资源开支。</li>
<li>方便配置。<ul>
<li>例如 网络请求经常要用到 cookie，如果使用 OkHttp 可以将其封装为一个单例工具类，内部使用 CookJar 对 cookie  进行管理，这样后续的请求就会方便很多。 </li>
</ul>
</li>
<li>安全性。比如 SQLite 数据库的增删查改，通过单例对象对外提供增删查改功能，可以避免一些并发错误。</li>
</ul>
<h2 id="三、单例模式的实现方式"><a href="#三、单例模式的实现方式" class="headerlink" title="三、单例模式的实现方式"></a>三、单例模式的实现方式</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明静态对象时就把它初始化。（因为饿，所以迫不及待先把它 new 出来）</p>
<h3 id="2-懒汉模式"><a href="#2-懒汉模式" class="headerlink" title="2. 懒汉模式"></a>2. 懒汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>getInstance</code> 方法中添加了 <code>synchronized</code> 关键字，也就是 </p>
<ul>
<li>一个问题：即使 instance 已经被初始化，之后的每次调用还是会 进行同步，这样会消耗不必要的资源</li>
</ul>
<p>为什么叫做懒汉呢？其实可以理解为懒加载，有需要的时候，再把它加载出来。</p>
<p>懒汉单例模式的</p>
<ul>
<li>优点：单例只有在使用时才会被实例化，在一定程度上节约了资源。</li>
<li>缺点：第一次加载时需要及时地实例化，反应稍慢，最大的问题是：<strong>每次调用都会进行同步，造成不必要的同步开销</strong>。</li>
</ul>
<h3 id="3-双重校验锁-DCL"><a href="#3-双重校验锁-DCL" class="headerlink" title="3. 双重校验锁 ( DCL )"></a>3. 双重校验锁 ( DCL )</h3><p>DCL 既能够在需要时才初始化实例，又能够保证线程安全，而且单例对象初始化后才调用 getInstance 不进行同步锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="为什么在同步块内还要再进行判空？"><a href="#为什么在同步块内还要再进行判空？" class="headerlink" title="为什么在同步块内还要再进行判空？"></a>为什么在同步块内还要再进行判空？</h4><p>因为<strong>可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了</strong>。</p>
<h4 id="为什么要加-volitale-关键字？"><a href="#为什么要加-volitale-关键字？" class="headerlink" title="为什么要加 volitale 关键字？"></a>为什么要加 volitale 关键字？</h4><p><code>sInstance = new Singleton();</code>这句代码会被编译成多条汇编指令，它大致做了 3 件事情</p>
<ol>
<li>给 Singleton 实例分配内存</li>
<li>调用 Singleton 的构造函数，初始化成员字段</li>
<li>将 sInstance 对象指向分配的内存空间</li>
</ol>
<p>但是由于 Java 编译器允许处理器乱序执行，以及 JDK 1.5 之前 JMM（Java Memory Model， Java 内存模型） 中 cache、寄存器到主内存回写顺序的规定，<br>上面的 2 和 3 的顺序是无法保证的。 如果是 1-3-2，那么当 3 执行完，并且 2 还没有执行的话，被切换到到线程 B，这时 sInstance 已经非空（因为 3 已经被执行了嘛），若 此时线程 B 直接取走 sInstance 使用时就会报错。</p>
<p>解决：JDK 1.5 之后，SUN 官方调整了 JVM，具体化了 volatile 关键字（禁止指令重排序）。 </p>
<ul>
<li>如果是在 JDK 1.5 之后，那么只需要把 sInstance 的声明 改为 <code>private volatile static Singleton sInstance;</code> 即可</li>
</ul>
<h3 id="4-静态内部类单例模式"><a href="#4-静态内部类单例模式" class="headerlink" title="4. 静态内部类单例模式"></a>4. 静态内部类单例模式</h3><p>DCL 在某些情况下会出现失效的问题。这个问题被称为双重检查锁定（DCL）失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123; &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次调用 Singleton 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 SingletonHolder 类，这种方式不仅能够确保线程安全，也能保证单例对象的唯一性。</p>
<p>所以这是推荐使用的单例模式实现方式</p>
<h3 id="5-枚举单例"><a href="#5-枚举单例" class="headerlink" title="5. 枚举单例"></a>5. 枚举单例</h3><p>对枚举不了解可以先看看<a href="https://www.ibm.com/developerworks/cn/java/j-lo-enum/" target="_blank" rel="noopener">枚举</a>这篇文章</p>
<p>写法简单是枚举单例 最大的优点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取对象可以这么写： Singleton singleton = <code>Singleton.INSTANCE</code>;</p>
<p>枚举在 Java 中与普通的类是一样的，不仅能够有字段，还能定义自己的方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    <span class="comment">//枚举内部可以定义成员；</span></div><div class="line">    <span class="keyword">private</span> String mString;</div><div class="line">    <span class="comment">//枚举内部可以定义方法；</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//do sth</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最重要的是<strong>默认枚举实例的创建是线程安全的</strong>，并且任何情况下它都是一个单例。</p>
<p>上述几种方式中，在一个情况下都会重新创建对象的情况，那就是<strong>反序列化</strong>。</p>
<p>即使构造函数是私有的，反序列化是依然可以通过特殊的途径去创建类的一个新的实例，相当于 调用该类的构造函数。</p>
<p>反序列化操作提供了一个很特别的<strong>钩子函数</strong>，类中具有一个私有的、被实例化的方法 <code>readResolve()</code>,这个方法可以让开发人员控制对象的反序列化。</p>
<p>上述几种单例方法中如果要杜绝单例对象在被反序列化时重新生成对象，那必须加入如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">    <span class="keyword">return</span> sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是在 readResolve 方法中将 sInstance 对象返回，而不是默认的重新生成一个新的对象。</p>
<p>而<strong>对于枚举</strong>，并不存在这个问题，因为<strong>即使反序列化也不会重新生成新的实例</strong>。</p>
<h3 id="6-使用容器实现单例模式"><a href="#6-使用容器实现单例模式" class="headerlink" title="6. 使用容器实现单例模式"></a>6. 使用容器实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; sObjectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!sObjectMap.containsKey(key)) &#123;</div><div class="line">            sObjectMap.put(key, instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sObjectMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类型注入到一个统一的管理类中，使用时格根据 key 获取对象对应类型的对象。</p>
<ul>
<li>这种实现方式主要是方便对单例对象进行统一管理。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>不管使用哪一种形式实现单例模式，<strong>核心原理</strong>都是==将构造函数私有化==，并且==通过静态方法获取唯一的的实例==。</li>
<li>在获取的过程中必须保证<strong>线程安全</strong>、<strong>防止反序列化导致重新生成实例对象</strong>等问题。</li>
</ul>
<h2 id="使用时的注意点"><a href="#使用时的注意点" class="headerlink" title="使用时的注意点"></a>使用时的注意点</h2><p>避免内存泄漏</p>
<ul>
<li>Android 开发中使用单例模式，如果获取单例对象需要使用 Context，那么尽量使用 ApplicationContext(只要用 <code>context.getApplicationContext()</code> 即可获取)。<br>因为如果使用其他 Context（如 Activity)  可能会造成 Activiity 生命周期 执行完成之后，因为其引用被单例所持有，而无法被回收。</li>
<li>多进程环境下，单例模式会失效。</li>
</ul>
<h2 id="Android-源码中的单例模式简述"><a href="#Android-源码中的单例模式简述" class="headerlink" title="Android 源码中的单例模式简述"></a>Android 源码中的单例模式简述</h2><p>我们经常会通过 Context 去获取系统服务，如 LayoutInflater、NetworkStatsManager，这些服务在创建时会以键值对的形式缓存到 HashMap 中，便于管理。</p>
<p>需要时就通过调用  <code>context.getSystemService(String name)</code> 方法获取 。首先会以 name 作为 key，到 hashMap 中查找中相应的服务，如果对应的服务为 null 就创建一个实例，并将该实例缓存到 HashMap 中；如果对应的服务已经存在，则直接返回。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">wiki 单例模式</a></li>
<li><a href="">Android 源码设计模式 单例模式</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPC 机制]]></title>
      <url>https://timlin-pro.github.io/blog/2017/05/04/Android%20IPC-%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="Android-IPC简介"><a href="#Android-IPC简介" class="headerlink" title="Android IPC简介"></a>Android IPC简介</h2><p>IPC 是 Inter-Process Communication 的缩写，含义为 进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。<br>a<br>IPC 不是 Android 所独有的，任何一个操作系统都需要有相应的 IPC 机制。</p>
<p>在 Android 中最有特色的进程间通信方式就是 Binder 了， <strong>通过 Binder 可以轻松实现进程间通信</strong>。</p>
<p>除了 Binder ，Android 还支持 Socket， 通过 Socket 也可以实现任意<strong>两个终端之间</strong>的通信，当然一个设备的两个进程之间的也可以通过 Socket 进行通信。</p>
<p>多进程的情况分两种：</p>
<ol>
<li>一个应用因为某些原因自身需要采用多进程模式来实现<ul>
<li>可能的原因如下：<ul>
<li>有些模块需要运行在单独的进程中</li>
<li>加大一个应用可使用的内存</li>
</ul>
</li>
</ul>
</li>
<li>当前应用需要向其他应用获取数据。</li>
</ol>
<a id="more"></a>
<h2 id="2-Android中的多进程模式"><a href="#2-Android中的多进程模式" class="headerlink" title="2 Android中的多进程模式"></a>2 Android中的多进程模式</h2><p>通过给四大组件指定 <code>android:process</code>属性，可以轻易地开启多线程模式。</p>
<h3 id="1-开启多进程模式"><a href="#1-开启多进程模式" class="headerlink" title="1 开启多进程模式"></a>1 开启多进程模式</h3><p>一般地，在 Android 中<strong>多进程</strong>是指一个应用中存在多个进程的情况（此处不讨论两个应用之间的多进程情况）</p>
<p>首先，在 Android 中使用多进程只有一种方法， 在 manifest 文件中，给四大组件 指定 <code>android:process</code> 属性。</p>
<ul>
<li>其实还有一种非常规的多进程方法—— 通过 JNI 在 native 层去 fork 一个新的进程。</li>
</ul>
<p>根据 process 的属性值不同，创建不同的进程。</p>
<h4 id="问题：使用-「：xxx」与-使用-「xxx-xxx-xxx」两种方式有区别吗？"><a href="#问题：使用-「：xxx」与-使用-「xxx-xxx-xxx」两种方式有区别吗？" class="headerlink" title="问题：使用 「：xxx」与 使用 「xxx.xxx.xxx」两种方式有区别吗？"></a>问题：使用 「：xxx」与 使用 「xxx.xxx.xxx」两种方式有区别吗？</h4><ol>
<li>「：」的含义是指在当前的进程名前面附上当前的包名，即 这是一种简写的方法</li>
<li>进程名以「：」开头的进程属于<strong>当前应用的私有进程</strong>，其他应用的组件不可以和它跑在同一个进程中，<ul>
<li>而进程名不以「：」开头的进程属于<strong>全局进程</strong>，其他应用通过 ShareUID 方式可以和它跑在同一个进程中。</li>
</ul>
</li>
</ol>
<p>Android 系统会为每个应用分配一个 唯一的 UID，具有相同 UID 的应用才能共享数据。</p>
<ul>
<li>两个应用跑在同一个进程中 需要 <ul>
<li>这两个应用有 <strong>相同的 shareUID</strong></li>
<li>并且 <strong>签名相同</strong>。</li>
</ul>
</li>
<li>这种情况下，可以互相访问对方的私有目录，如 data 目录。</li>
</ul>
<h3 id="2-多进程模式的运行机制"><a href="#2-多进程模式的运行机制" class="headerlink" title="2 多进程模式的运行机制"></a>2 多进程模式的运行机制</h3><p>==一个进程 = 一个 虚拟机==</p>
<p>Android 为每个应用分配了一个独立的虚拟机，或者说为每个进程分配一个独立的虚拟机，<br>不同虚拟机在内存分配上有不同的地址空间，这就导致了不同虚拟机范文同一个类的对象会产生多份副本。</p>
<p>一般来说，使用<strong>多进程</strong>会造成以下几方面问题</p>
<ol>
<li>静态成员和单例模式完全失效</li>
<li>线程同步机制完全失效</li>
<li>SharePreferences 的可靠性下降，好像有多进程模式？有，但是不稳定，所以系统已经不推荐使用了。</li>
<li>Application 会多次创建</li>
</ol>
<p>可以这样理解同一个应用间的多进程：</p>
<ul>
<li>它就相当于两个不同的应用采用了 ShareUID 的模式，这样能够更加直接地理解<strong>多进程模式的本质</strong>。</li>
</ul>
<h2 id="3-IPC基础概念介绍"><a href="#3-IPC基础概念介绍" class="headerlink" title="3 IPC基础概念介绍"></a>3 IPC基础概念介绍</h2><h3 id="3-1-Serializable接口"><a href="#3-1-Serializable接口" class="headerlink" title="3.1 Serializable接口"></a>3.1 Serializable接口</h3><p><strong>Serializable接口</strong> ：Java 所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。</p>
<h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><pre><code>- 只要在类的声明中指明一个类似下面的标识即可自动实现 *默认的* 序列化过程（可以自定义）。
- `private static final long serialVersionUID = 87138828109787189L;`
</code></pre><p>这个 <code>serialVersionUID</code> 可以没有，但是这样会对反序列化过程产生影响。</p>
<ul>
<li><code>serialVersionUID</code> 是用来辅助序列化过程的，原则上序列化后的数据中的 <code>serialVersionUID</code> 只有和当前类的 <code>serialVersionUID</code> 相同才能正常地被反序列化。</li>
</ul>
<h5 id="serialVersionUID-的详细工作机制："><a href="#serialVersionUID-的详细工作机制：" class="headerlink" title="serialVersionUID 的详细工作机制："></a><strong><code>serialVersionUID</code> 的详细工作机制</strong>：</h5><ul>
<li>序列化是把当前类的 <code>serialVersionUID</code> 写入序列化的文件中（也可能是其他中介）当反序列化时会去检测文件中的<code>serialVersionUID</code>，看它是否和当前类的<code>serialVersionUID</code>一致，如果一致就说明序列化的版本与当前类的版本是相同的，这时可以成功反序列化。</li>
<li>否则说明当前类和序列化的类相比发生了 某些变化，例如：成员变量的数量、类型可能发生了改变，这时无法正常序列化，会报如下错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.io.InvalidClassException: projectname.clasname; local class incompatible: stream classdesc serialVersionUID = -6009442170907349114, local class serialVersionUID = 6529685098267757690</div></pre></td></tr></table></figure>
</li>
</ul>
<p>一般而言，我们应该手动指定 <code>serialVersionUID</code> 的值，比如 1L，<br>也可以让 Eclipse <strong>根据当前类的的结构</strong>去自动生成它的 hash 值，这样序列化和反序列化时两者的 <code>serialVersionUID</code>是相同的，可以正常进行反序列化。</p>
<p>如果类的结构发生了改变，比如增加/删除了 某些成员变量，那么系统就会重新计算当前类的 hash 值并把它赋值给 <code>serialVersionUID</code> ，这个时候当前类的 <code>serialVersionUID</code> 就会和序列化数据不一致，于是反序列化失败。</p>
<ul>
<li>如果手动指定了<code>serialVersionUID</code> 就不会有这个问题。</li>
</ul>
<p>但是如果类结构发生了 ==非常规性改变==，比如修改了类名、修改了成员变量类型，这个时候尽管 <code>serialVersionUID</code> 验证通过了，但是反序列化过程还是会失败，因为类结构发生了毁灭性变化，根本无法从老版本的数据中还原出一个新的类结构的对象。</p>
<p>综上，类结构不变且类的版本不变（没有增加或者删除成员变量）的情况下，不指定 serialVersionUID 是没有问题的，但是为了提高稳定性，还是要指定。</p>
<p><strong>两点要注意的</strong>：</p>
<ol>
<li>静态成员变量属于类不属于对象，所以<strong>不会参与</strong>序列化过程。</li>
<li>用 transient 关键字标记的 成员变量不参与序列化过程。</li>
</ol>
<p>系统的默认序列化过程也是可以改变的。只要重新实现 <code>writeObject</code> 和 <code>readObject</code> 方法即可。</p>
<h5 id="如何进行对象的序列化和反序列化？"><a href="#如何进行对象的序列化和反序列化？" class="headerlink" title="如何进行对象的序列化和反序列化？"></a>如何进行对象的序列化和反序列化？</h5><p>采用 <code>ObjectOutputStream</code>  <code>ObjectInputStream</code> 即可轻松实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">User user = new User(name);</div><div class="line">ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;cache.txt&quot;));</div><div class="line">objectOutputStream.writeObject(user);</div><div class="line">objectOutputStream.close();</div><div class="line"></div><div class="line">ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;cache.txt&quot;));</div><div class="line">User newUser = objectInputStream.readObject();</div><div class="line">objectInputStream.close();</div></pre></td></tr></table></figure></p>
<h3 id="3-2-Parcelable接口"><a href="#3-2-Parcelable接口" class="headerlink" title="3.2 Parcelable接口"></a>3.2 Parcelable接口</h3><p>通过实现Parcelable接口序列化对象的步骤：<br>1、声明实现接口Parcelable<br>2、实现Parcelable的方法 <strong>writeToParcel</strong>，将你的对象<strong>序列化</strong>为一个Parcel对象<br>3、实例化静态内部对象CREATOR实现接口Parcelable.Creator  ，实现 反序列化</p>
<p>Parcelable 的方法说明</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>标记位</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>createFromParcel</td>
<td>从序列化后的对象中创建原始对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>newArray</td>
<td>创建指定长度的原始对象数组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>User(Parcel in)</td>
<td>从序列化后的对象中创建原始对象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>writeToParcel(Parcel dest, int flags)</td>
<td>将当前的对象写入序列化结构中，其中 flags 标识有两种值，0 或者 1； 为 1 时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为 0</td>
<td>PARCELABLE_WRITE_RETURN_VALUE</td>
<td></td>
</tr>
<tr>
<td>describeContents</td>
<td>返回当前对象的描述，仅当当前对象中存在 文件描述符，才返回 1，几乎所有情况都返回 0</td>
<td>CONTENT_FILE_DESCRIPTOR</td>
</tr>
</tbody>
</table>
<p>新建一个类，实现 Parcelable 接口，然后写好成员变量，再 <code>alt + enter</code> 自动补全代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String mName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAge;</div><div class="line">    <span class="keyword">private</span> String mAddress;</div><div class="line">    <span class="keyword">private</span> Book mBook;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>&#123;<span class="comment">//从序列化后的对象中创建原始对象</span></div><div class="line">        mName = in.readString();</div><div class="line">        mAge = in.readInt();</div><div class="line">        mAddress = in.readString();</div><div class="line">        mBook = in.readParcelable(Book.class.getClassLoader());<span class="comment">//因为 book 也是一个可序列化对象，所以它的反序列化过程需要传递当前线程的上下文 类加载器</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;<span class="comment">//将当前的对象写入序列化结构中，其中 flags 标识有两种值，0 或者 1； 为 1 时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为 0</span></div><div class="line">        dest.writeString(mName);</div><div class="line">        dest.writeInt(mAge);</div><div class="line">        dest.writeString(mAddress);</div><div class="line">        dest.writeParcelable(mBook, flags); </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;<span class="comment">//如无特殊情况，这个方法都是返回 0，仅当当前对象中存在 文件描述符，才返回 1</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//反序列化</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Creator&lt;User&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123; </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) &#123;<span class="comment">//创建指定长度的原始对象数组</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>Serializable 是 Java 中的序列化接口，使用起来简单但是==开销很大==，序列化和反序列化需要大量的 I/O 操作。</li>
<li>而 Parcelable 是 Android 中序列化方式，更适合使用在 Android 平台上，==效率高==。 缺点：使用起来麻烦。<ul>
<li>Parcelable 主要用在<strong>内存序列化</strong>上</li>
</ul>
</li>
<li>通过 Parcelable 将对象序列化到<strong>存储设备</strong>中 或者将对象序列化后存储<strong>通过网络传输</strong>也都是可以的，但是这个过程会稍显复杂，在这两种情况下，建议使用 Serializable 接口。</li>
</ul>
<h3 id="3-3-Binder"><a href="#3-3-Binder" class="headerlink" title="3.3 Binder"></a>3.3 Binder</h3><p>直观来说，Binder 是 Android 的一个类，它实现了 IBinder 接口。</p>
<ul>
<li>从 IPC 角度来说， Binder 是 Android 中的<strong>一种跨进程通信方式</strong></li>
<li>Binder 还可以理解为一种<strong>虚拟的物理设备</strong>，它的设备驱动是 /dev/binder， 该通信方式在 Linux 上没有。</li>
<li>从 Android FrameWork 角度来看， Binder 是 ServiceManager 连接各种 Manager (ActivityManager、 WindowManager， 等等)和相应的 ManagerService 的<strong>桥梁</strong></li>
<li>从 Android 应用层 来说，Binder 是<strong>客户端和服务端进行通信的媒介</strong>，当 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，通过这个 Binder 对象，客户端就可以获取服务端提供的数据或服务（包括普通的服务 和 AIDL服务）</li>
</ul>
<p>Android 开发中，Binder 主要用在 Service 中，包括 AIDL 和 Messenger，</p>
<ul>
<li>普通 Service 中的 Binder 不涉及进程间通信，所以较为简单，无法涉及核心</li>
<li>Messenger 的底层其实是 AIDL</li>
</ul>
<p>示例中，编写代码时，查找 aidl 生成的接口，Project ==》app==》build ==》source==》debug==》com.xxx.xx.xx==》 目标类</p>
<ul>
<li>==注意==：AIDL 的特殊之处：尽管两个类都位于同一个包中，还是需要导入相应的类。</li>
</ul>
<p>==所有==<strong>可以在 Binder 中传输的接口</strong>都需要继承自 IInterface 接口。</p>
<p>栗子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * This file is auto-generated.  DO NOT MODIFY.</div><div class="line"> * Original file: D:\\Android_RDC_project\\AndroidLearning\\app\\src\\main\\aidl\\com\\android\\rdc\\androidlearning\\IBookManager.aidl</div><div class="line"> */</div><div class="line"><span class="keyword">package</span> com.android.rdc.androidlearning;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Local-side IPC implementation stub class.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">android</span>.<span class="title">rdc</span>.<span class="title">androidlearning</span>.<span class="title">IBookManager</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.android.rdc.androidlearning.IBookManager"</span>;<span class="comment">//Binder 的唯一标识，一般用当前 Binder 的全类名表示</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Construct the stub at attach it to the interface.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 将（服务端的 Binder 对象）转换为（客户端所需的 AIDL 类型的对象）</div><div class="line">         * 若服务端与 客户端处在同一个进程，则返回服务端的 Stub 对象本身</div><div class="line">         *                      否则返回系统封装后的 Stub.Proxy</div><div class="line">         * Cast an IBinder object into an com.android.rdc.androidlearning.IBookManager interface,</div><div class="line">         * generating a proxy if needed.</div><div class="line">         */</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.android.rdc.androidlearning.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.android.rdc.androidlearning.IBookManager))) &#123;</div><div class="line">                <span class="keyword">return</span> ((com.android.rdc.androidlearning.IBookManager) iin);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.android.rdc.androidlearning.IBookManager.Stub.Proxy(obj);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 返回当前的 Binder 对象</div><div class="line">         * */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 运行在『服务端』的 Binder 线程池中，客户端发起 ，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理</div><div class="line">         *  通过code 可以确定请求的目标方法</div><div class="line">         *  （如果目标方法有参数的话） 从 data 中取出目标方法所需的参数，然后执行</div><div class="line">         *  当目标方法执行完毕后，（如果有返回值的话）向 reply 中写入返回值</div><div class="line">         *  如果 onTransact 返回 false ，那么客户端的请求失败。因此可以利用这个特性来做权限验证。</div><div class="line">         * */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</div><div class="line">            <span class="keyword">switch</span> (code) &#123;</div><div class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</div><div class="line">                    reply.writeString(DESCRIPTOR);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</div><div class="line">                    data.enforceInterface(DESCRIPTOR);</div><div class="line">                    java.util.List&lt;com.android.rdc.androidlearning.Book&gt; _result = <span class="keyword">this</span>.getBookList();</div><div class="line">                    reply.writeNoException();</div><div class="line">                    reply.writeTypedList(_result);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">case</span> TRANSACTION_addBook: &#123;</div><div class="line">                    data.enforceInterface(DESCRIPTOR);</div><div class="line">                    com.android.rdc.androidlearning.Book _arg0;</div><div class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</div><div class="line">                        _arg0 = com.android.rdc.androidlearning.Book.CREATOR.createFromParcel(data);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        _arg0 = <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">this</span>.addBook(_arg0);</div><div class="line">                    reply.writeNoException();</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">android</span>.<span class="title">rdc</span>.<span class="title">androidlearning</span>.<span class="title">IBookManager</span> </span>&#123;</div><div class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</div><div class="line"></div><div class="line">            Proxy(android.os.IBinder remote) &#123;</div><div class="line">                mRemote = remote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> mRemote;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> DESCRIPTOR;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 此方法运行在『客户端』</div><div class="line">             * */</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> java.util.List&lt;com.android.rdc.androidlearning.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</div><div class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">                java.util.List&lt;com.android.rdc.androidlearning.Book&gt; _result;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);<span class="comment">//调用 transact 发起远程请求。然后当前线程挂起，</span></div><div class="line">                    _reply.readException();<span class="comment">// RPC 过程返回后，当前线程继续执行</span></div><div class="line">                    _result = _reply.createTypedArrayList(com.android.rdc.androidlearning.Book.CREATOR);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    _reply.recycle();</div><div class="line">                    _data.recycle();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> _result;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 执行过程与 getBookList 一样，</div><div class="line">             * */</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.android.rdc.androidlearning.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</div><div class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</div><div class="line">                        _data.writeInt(<span class="number">1</span>);</div><div class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        _data.writeInt(<span class="number">0</span>);</div><div class="line">                    &#125;</div><div class="line">                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</div><div class="line">                    _reply.readException();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    _reply.recycle();</div><div class="line">                    _data.recycle();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> java.util.List&lt;com.android.rdc.androidlearning.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.android.rdc.androidlearning.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-Android中的IPC方式"><a href="#4-Android中的IPC方式" class="headerlink" title="4 Android中的IPC方式"></a>4 Android中的IPC方式</h2><h3 id="4-1-使用Bundle"><a href="#4-1-使用Bundle" class="headerlink" title="4.1 使用Bundle"></a>4.1 使用Bundle</h3><p>四大组件中的三大组件（Activity、Service、Receiver）都是<strong>支持在 Intent 中传递 Bundle 数据</strong>的，Bundle 实现了 Parcelable 接口，所以它可以方便地在不同的进程间 传输。</p>
<p>因此，当我们在一个进程中启动了另一个进程的 Activity、Service、Receiver，我们就可以在 Bundle 中附加我们需要传输给远程进程的信息并通过 Intent 传递出去。</p>
<ul>
<li>当然我们所传输的数据必须能够被序列化，如：<ul>
<li>基本数据类型</li>
<li>实现了 Parcelable 接口的对象。</li>
<li>实现了 Serialiable 接口的对象。</li>
<li>一些 Android 支持的特殊对象。<ul>
<li>Charserquence</li>
<li>StringArrayList</li>
<li>IntegerArrayList</li>
<li>Size</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="特殊的使用场景："><a href="#特殊的使用场景：" class="headerlink" title="特殊的使用场景："></a>特殊的使用场景：</h4><p>进程 A 要进行计算，并将计算结果发送给进程 B，但是该计算结果不支持放入 Bundle 中。</p>
<ul>
<li>解决：在 A 中，通过 Intent 来启动线程 B 的一个 Service 组件（比如 IntentService），让 Service 在后台计算，计算完以后再启动 B 进程中想要启动的目标组件。</li>
</ul>
<p><strong>核心思想</strong>：将原本需要在 A 进程的计算任务转移到 B 进程的服务中，这样就避免了进程间通信的问题，而且代价也不大。</p>
<h3 id="4-2-使用文件共享"><a href="#4-2-使用文件共享" class="headerlink" title="4.2 使用文件共享"></a>4.2 使用文件共享</h3><p>两个进程通过读/写同一个文件交换数据。</p>
<ul>
<li>比如，进程 A 写入，进程 B 读取。</li>
</ul>
<p>背景知识：</p>
<ul>
<li>Window 上，一个文件如果被加了<strong>排斥锁</strong>将会导致其他线程无法对其进行访问（包括读和写）。</li>
<li>Android 基于 Linux，其读/写文件可以无限制地进行，甚至两个线程对同一个文件并行写也是允许的。（尽管这可能会出现一些问题）</li>
</ul>
<p>应用：</p>
<ul>
<li>序列化一个对象到文件系统中的同时，从另一个进程中恢复这个对象。<ul>
<li>另一个进程成功地恢复之前存储的对象的<strong>内容</strong>，但是他们<strong>本质还是两个对象</strong>。</li>
</ul>
</li>
</ul>
<p>可能存在的问题：<br>并发读/写，读出的内容可能不是最新的。</p>
<ul>
<li>解决：<ol>
<li>设法避免</li>
<li>考虑使用线程同步来限制，多个线程的写操作。 </li>
</ol>
</li>
</ul>
<p>文件共享适合<strong>对数据同步要求不高</strong>的进程之间进行通信。</p>
<h4 id="Sharepreference"><a href="#Sharepreference" class="headerlink" title="Sharepreference"></a>Sharepreference</h4><p>SharePreference 是个特例 </p>
<p>底层通过 xml 文件的方式来存储键值对，，一般而言，它位于 <code>/data/data/当前应用的包名/share_prefs</code> 目录下，</p>
<p>由于系统对 SharePreference 的读写操作有一定的<strong>缓存策略</strong>，即<strong>在内存*有一份 SharePreferce 的缓存</strong>。<strong>在多进程模式下</strong>，系统对它的读写操作就变得不可靠。高并发状态下，SharePreference 很大几率会丢失数据。</p>
<ul>
<li>不建议在进程间通信使用 SharePreference</li>
</ul>
<h3 id="4-3-使用Messenger"><a href="#4-3-使用Messenger" class="headerlink" title="4.3 使用Messenger"></a>4.3 使用Messenger</h3><p>『信使』<br>通过它可以在不同进程中传递 Message 对象，在 Message 中放入我们需要传递的数据，就可以实现进程间的数据传递了。</p>
<p>Messenger 一次处理一个请求，所以服务端不用考虑线程同步的问题（因为不存在并发执行的情形）。</p>
<h4 id="1-服务端进程"><a href="#1-服务端进程" class="headerlink" title="1. 服务端进程"></a>1. 服务端进程</h4><h4 id="客户端进程"><a href="#客户端进程" class="headerlink" title="客户端进程"></a>客户端进程</h4><p>在 Messager 中进行数据传递必须将数据放入 Messenger 中，</p>
<ul>
<li>Message 中支持数据类型就是 Messenger 所支持的传输类型</li>
<li>Message 中所能使用的载体只有 <ul>
<li>int what;</li>
<li>int ar1</li>
<li>int arg2</li>
<li>Messenger replyTo</li>
<li>Object obj<ul>
<li>2 之前 obj 字段不支持跨进程传输</li>
<li>2 之后 obj 也仅<strong>系统提供的</strong>实现 Parcelable 接口的的对象<ul>
<li>即 FrameWork class</li>
</ul>
</li>
</ul>
</li>
<li>Bundle <ul>
<li>还好我们有 Bundle ，支持比较多的数据类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果要让『服务端』能够回复信息。</p>
<ul>
<li>那么当客户端发送消息的时候，需要把 接收服务端回复的 Messenger 通过 Message 的 replyTo 参数传递给服务端。<h3 id="4-4-使用AIDL"><a href="#4-4-使用AIDL" class="headerlink" title="4.4 使用AIDL"></a>4.4 使用AIDL</h3></li>
</ul>
<p>Android 接口定义语言(Android Interface  Definition Language)</p>
<p>Messenger 只能传递消息，不能跨进程调用方法。而且只能串行处理客户端发来的请求。</p>
<ul>
<li>虽然它底层也是使用 AIDL 实现的。</li>
</ul>
<p>可以使用 AIDL 来实现跨进程的方法调用。</p>
<p>aidl 文件的作用是 sdk 根据它来生成相应的 java 代码，也就是在编译时有用，在编译完之后，即使删除掉 aidl 文件，也是可以的，但是这样的话如果重新编译就没法生成 java 代码了。</p>
<p>将编写的 <code>.aidl</code> 文件保存在项目的 <code>src/</code> 目录内，当你开发应用时，<strong>SDK 工具</strong>会在项目的 <code>gen/</code> 目录中生成 <code>IBinder</code> 接口文件。生成的文件名与 <code>.aidl</code> 文件名一致，只是使用了 <code>.java</code> 扩展名（例如，<code>IRemoteService.aidl</code> 生成的文件名是 <code>IRemoteService.java</code>）。</p>
<p>如果<strong>使用 Android Studio</strong>，<strong>增量编译几乎会立即生成 Binder 类</strong>。 如果不是使用 Android Studio，则 Gradle 工具会在下一次开发应用时生成 Binder 类 </p>
<p>通常应该在编写完 <code>.aidl</code> 文件后立即用 <code>gradle assembleDebug</code> （或 <code>gradle assembleRelease</code>）编译项目，以便您的代码能够链接到生成的类。</p>
<h4 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h4><p>用一个 Service 来监听客户的连接请求，创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 实现该接口。</p>
<h4 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h4><ul>
<li>绑定服务端 Service，</li>
<li>绑定成功后将服务端返回的 IBinder 转化为 AIDL 接口所属的类型<ul>
<li>注意不是平时那样强转，而是<ul>
<li><code>IBookManager.Stub.asInterface(iBinder);</code></li>
</ul>
</li>
</ul>
</li>
<li>接着就可以使用 AIDL 中的方法了。</li>
</ul>
<p>AIDL 支持的数据类型：</p>
<ul>
<li>基本数据类型</li>
<li>CharSequence </li>
<li>List 只支持 ArrayList</li>
<li>Map 只支持 HashMap</li>
<li>Parcelable </li>
<li><p>AIDL：AIDL 接口本身也可以在 AIDL 文件中使用</p>
<ul>
<li>AIDL 中无法使用普通的接口</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>自定义的 Parcelable对象一定要显式地 import 进来。（不管它们是否与当前的 AIDL 文件位于同一个包中）</li>
<li>如果 AIDL 文件中用到了自定义的 Parcelable 对象，必须使用新建一个和它同名的 aidl 文件，并在其中声明它为 parcelable 类型<ul>
<li>如 Book.java<ul>
<li>Book.aidl<ul>
<li>要在其中声明 pacelable Book;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>基本数据类型以外的参数需要==标上方向==</p>
<ul>
<li>in 输入型参数，类似于普通方法的参数</li>
<li>out 输出型参数， 类似于返回值</li>
<li>inout 输入输入型参数</li>
</ul>
<p>所以说，输入输出是针对这个方法而言的，而不是 C/S 结构中的输入/输出。</p>
<p>AIDL 接口中只支持方法，不支持声明静态变量（==跟传统的接口有区别==）</p>
<ul>
<li>AIDL 包结构在客户端与服务端要保持一致，否则运行会出错。<ul>
<li>因为客户端需要反序列化服务端中和  aidl 接口相关的类。</li>
</ul>
</li>
</ul>
<p>AIDL 接口中所支持的是抽象的 List ，而 List 只是一个接口，虽然服务端使用 CopyOnWriteArrayList ,但是在 Binder 中会按照 List 的规范去访问数据并最终形成一个 ArrayList 传递给客户端。</p>
<ul>
<li>ConcurrentHashMap 同理</li>
</ul>
<p>在<strong>服务端调用客户端</strong>（注册时的使用的接口中)的方法，在客户端的 Binder 线程池中执行。</p>
<p>对象是不能直接跨进程传输的，<strong>对象的跨进程传输本质上都是反序列化过程</strong></p>
<p>RemoteCallBackList 是系统专门用来发删除跨进程的 listener 的接口。</p>
<ul>
<li>它是一个泛型，支持管理任意的 AIDL 接口<ul>
<li><code>public class RemoteCallBackList&lt;E extends IInterface&gt;</code></li>
<li>当客户端进程终止之后， RemoteCallBackList 能够自动溢出客户端所注册的 listener</li>
<li>其内部有一个 <code>ArrayMap&lt;IBinder,CallBack&gt;</code>用来专门保存所有的 AIDL 回调<ul>
<li>CallBack 封装了真正的远程 listener。当客户端注册 listener 的时候，会将其中的信息存入 mCallBack 中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IBinder key = listener.asBinder();</div><div class="line">callBack value = new Callback(listener,cookie);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>多次跨进程传输客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个 共同点，那就是==它们底层的 Binder 对象是同一个==</p>
<p>==注意==:</p>
<ul>
<li>RemoteCallBackList 使用方式比较特别。并不像 list 那样<ul>
<li>beginBroadcast()</li>
<li>finishBroadcast()</li>
<li>这两个方法==一定要配对使用==</li>
<li>getBroadcastItem()<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = mCallBackList.beginBroadcast();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">    IOnNewBookArrivedListener l = mCallBackList.getBroadcastItem(i);</div><div class="line">    <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</div><div class="line">        l.onNewBookArrived(book);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">mCallBackList.finishBroadcast();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>客户端的 <code>onServiceConnected 和  onServiceDisconnected(ComponentName name)</code>都执行在 UI 线程中，不可以在里面调用服务端耗时的方法。</p>
<p>服务端方法本身运行在服务端的 Binder 线程池中，所以服务端方法本身即可执行大量耗时操作。</p>
<ul>
<li>不要在服务端方法中开线程去执行异步任务。</li>
</ul>
<p>服务端也有可能运行在 UI 线程，这时要尽量避免调用耗时方法。</p>
<p>Binder 死亡后</p>
<p>进程空间分为用户空间和内核空间</p>
<ul>
<li>用户空间，数据互相隔离</li>
<li>内核空间 数据共享</li>
</ul>
<p>通过内核 实现跨进程调用</p>
<p>进程 A 调用进程 B 的函数</p>
<ul>
<li>知道调用的是哪一个对象的哪一个方法</li>
<li>传递方法参数</li>
<li>进程 B 执行完之后，返回相应的数据给进程 A。</li>
</ul>
<p>本质上就是 数据的传递。</p>
<p>客户端调用的进程 Binder 对象的引用（一个代理），实际执行还是在服务端的。</p>
<p>Client 进程的的操作实际上对代理对象的操作，代理对象利用 Binder 驱动找到真正的 Binder对象，并通知 Server 进程完成操作。</p>
<p>采用的是 C/S 的架构。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/944365-62fdab905e7d2706.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理图"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/944365-2f530e964ffab8d7.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="流程图"></p>
<h3 id="4-5-使用ContentProvider"><a href="#4-5-使用ContentProvider" class="headerlink" title="4.5 使用ContentProvider"></a>4.5 使用ContentProvider</h3><p>待补充</p>
<h3 id="4-6-使用Socket"><a href="#4-6-使用Socket" class="headerlink" title="4.6 使用Socket"></a>4.6 使用Socket</h3><p>待补充</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android开发艺术探索》</li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！</p>
<p>## </p>
]]></content>
      
        <categories>
            
            <category> Android 进阶 </category>
            
            <category> IPC </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android 进阶 </tag>
            
            <tag> IPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Service 全面总结]]></title>
      <url>https://timlin-pro.github.io/blog/2017/05/03/Service-%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><br>Service 是一种计算型的组件。</p>
<h2 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h2><h3 id="线程还是服务？"><a href="#线程还是服务？" class="headerlink" title="线程还是服务？"></a>线程还是服务？</h3><p>简单地说，服务是一种<strong>不需要用户交互也可在后台运行的组件</strong>。 因此，我们应该仅在必要时才创建服务。</p>
<p>如需在主线程外部（也就是工作线程）执行工作，并且<strong>只是在用户正在与应用交互时才有此需要，则应创建新线程而非服务</strong>。</p>
<p>如果确实要使用服务，则<strong>默认情况下，它仍会在应用的主线程中运行</strong>，因此，如果服务执行的是密集型或阻塞性操作，那么应该在服务内创建新线程。</p>
<blockquote>
<p>注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。<br>为了避免影响应用性能，您应在服务内启动新线程。</p>
</blockquote>
<a id="more"></a>
<p>因为默认情况下，它会在应用不管是否用服务，耗时的操作都是需要另外起一个线程的。</p>
<ol>
<li>从概念上看，服务是一个<strong>组件</strong>，线程是操作系统的最小执行单位。</li>
<li>直接起 Thread 的<strong>可控性</strong>没那么高，它所依附的 Activity finish 掉之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。你没有办法在不同的 Activity 中对同一 Thread 进行控制。</li>
<li>可以<strong>提高进程的优先级</strong>，使得<strong>进程</strong>没那么容易被 kill。如果是一个长期的任务（比如说长轮询），那么用 Service 去做比较合适。<ul>
<li>通过在 manifest 里声明 Service，把需要后台相对长期运行的逻辑放在 Service 里，你便获得了这样的保障：只要系统内存不是极端不够用，你的 Service 一定不会被 kill 掉。对系统而言，当看到一个进程里有 Service 在运行，这个进程就具有较高的优先级，会在内存不足被杀的行列里排得比较靠后。</li>
</ul>
</li>
<li>从交互的角度看，如果是<strong>不需要用户交互也可以在后台运行</strong>，那么可以用服务。如果是在用户与应用交互时（比如说：在设置页面修改用户信息，同步到服务器上面去）那么可以用线程。如果确定要用 Thread，还可以考虑使用 <code>AsyncTask</code> 或 <code>HandlerThread</code>，而非传统的 <code>Thread</code> 类。</li>
</ol>
<p>所以直接用线程还是起一个服务关键得看任务的类型。是否是长期耗时的任务，是否需要跟用户交互？</p>
<h2 id="二、3-种启动方式"><a href="#二、3-种启动方式" class="headerlink" title="二、3 种启动方式"></a>二、3 种启动方式</h2><h3 id="方式一、start-Service"><a href="#方式一、start-Service" class="headerlink" title="方式一、start Service"></a>方式一、start Service</h3><ul>
<li>调用者<strong>只是负责启动它和停止它</strong>，或者在启动它的时候通过 Intent 传递一点数据给它，除此之外，两者没有数据交换、<strong>没有其他的功能调用</strong>，这两个组件之间基本上互不影响。<ul>
<li>如果希望服务返回结果，则启动服务的客户端可以<strong>为广播创建一个 PendingIntent</strong> （使用 getBroadcast()），并==通过启动服务的 Intent 传递给服务==。然后，服务就可以使用广播传递结果。可以获取到 pendingIntent，然后呢？<ul>
<li>服务内部也可以直接构造 PendingIntent 啊。<ul>
<li>如果是通过客户端的传递的，那么有多个客户端，可以根据传递的 intent 分别处理？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果因为系统内存不足被 kill，之后的具体行为与 onStartCommand 方法的返回值相匹配。</li>
</ul>
<h4 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h4><p>多个服务启动请求会导致多次对服务的 onStartCommand() 进行相应的调用。但是，<strong>要停止服务，只需一个服务停止请求（使用 stopSelf() 或 stopService()）即可</strong>。</p>
<h3 id="方式二、bind-Service"><a href="#方式二、bind-Service" class="headerlink" title="方式二、bind Service"></a>方式二、bind Service</h3><ul>
<li>其他组件通过调用 bindService() 绑定 Service，让它运行起来；再通过调用 unbindService()解除绑定。</li>
<li>组件和 Service 之间的调用是通过 Binder 来进行的。我们<strong>可以把 Binder 看作是一个连接其他组件和 Service 的桥梁</strong>。<ul>
<li>需要注意的是，如果是在同一个进程内，可以<strong>直接继承 Binder</strong>,然后在里面实现提供给调用者的功能。</li>
<li>如果是跨进程，可以使用 aidl。 将要提供给调用方的功能接口写在 aidl 文件中。build 之后，继承 Stub ,实现相应的功能。<ul>
<li>调用方在 <code>onServiceConnected</code> 方法中，获取到服务端提供的 IBinder 对象就可以像调用普通函数一样，调用相应的方法了。<ul>
<li>如果是远程调用的话，将对方提供的 IBinder 类 通过 asInterface 方法进行转换。如果是在服务端，返回 binder 实体，如果是在客户端，返回 binder Proxy。</li>
</ul>
</li>
</ul>
</li>
<li>如果需要提供接口给调用方使用，可以通过 onBind 方法中返回一个可供调用者使用的 Binder 对象。</li>
</ul>
</li>
</ul>
<p>需要注意的是，<strong>如果用户主动解除绑定，onServiceDisconnected()是不会被触发的</strong>。</p>
<p>如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。<strong>一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁</strong>。</p>
<p>即使为服务启用了绑定，一旦服务收到对 onStartCommand() 的调用（也就是在 bind 之后又使用 start 的方式去启动应用），则必须手动停止服务。（内部调用 stopSelf 或者 由另一个组件通过调用<code>stopService()</code> 来停止它）</p>
<p><strong>多个客户端先后进行 bindService 只有第一个调用 bindService 时会调用 Service#onBind 方法，后续的都是直接在 ServiceConnection 中返回</strong>。</p>
<p><strong>绑定是异步的</strong>。bindService() 会立即返回，但是「不会」使 IBinder 返回客户端。要接收 IBinder，客户端必须创建一个 ServiceConnection 实例，并将其传递给 bindService()。ServiceConnection 包括一个回调方法，系统通过调用它来传递 IBinder。<br>IBinder 返回是异步的。</p>
<blockquote>
<p>注：只有 Activity、Service 和 ContentProvider 可以绑定到服务 — 无法从广播接收器绑定到服务。</p>
</blockquote>
<p>创建支持 bindService 的 Service 的关键在于，自定义一个直接/间接实现了 IBinder 接口的类（编写功能代码提供相应的功能）然后通过 onBind 方法把该类的实例传递给客户端。</p>
<p>注意：Service.onBind如果返回null，则调用 bindService <strong>会启动 Service，但不会连接上 Service</strong>，因此 ServiceConnection.onServiceConnected 不会被调用，但你任然需要使用 unbindService 函数断开它，这样 Service 才会停止。</p>
<h4 id="创建提供绑定的-Service"><a href="#创建提供绑定的-Service" class="headerlink" title="创建提供绑定的 Service"></a>创建提供绑定的 Service</h4><p>创建提供绑定的服务时，您<strong>必须提供 IBinder</strong>，用以<strong>提供客户端用来与服务进行交互的接口</strong>。 您可以<strong>通过三种方法定义接口</strong>：</p>
<h5 id="1-直接继承-Binder-类"><a href="#1-直接继承-Binder-类" class="headerlink" title="1. 直接继承 Binder 类"></a>1. 直接继承 Binder 类</h5><p><strong>适用场景</strong>：<br>服务是<strong>供单个应用专用，并且在与客户端相同的进程中运行</strong>（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它<strong>直接访问 Binder 实现中乃至 Service 中可用的公共方法</strong>。</p>
<p>如果服务只是 app 的后台工作线程，则优先采用这种方法。 </p>
<h5 id="2-使用-Messenger"><a href="#2-使用-Messenger" class="headerlink" title="2. 使用 Messenger"></a>2. 使用 Messenger</h5><p>如需<strong>让接口跨不同的进程工作</strong>，则可使用 Messenger 为服务创建接口。服务可以这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，后者随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向服务发送命令。此外，客户端还可定义自有 Messenger，以便服务回传消息。</p>
<p>这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在<strong>单一线程</strong>中创建包含所有请求的队列，这意味着开发者无需进行线程安全控制</p>
<h5 id="3-使用-AIDL"><a href="#3-使用-AIDL" class="headerlink" title="3.使用 AIDL"></a>3.使用 AIDL</h5><p>AIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的服务必须<strong>具备多线程处理能力</strong>，并采用<strong>线程安全</strong>式设计。</p>
<p>如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。</p>
<h3 id="方式三、混合型，同时使用-start-和-bind"><a href="#方式三、混合型，同时使用-start-和-bind" class="headerlink" title="方式三、混合型，同时使用 start 和 bind"></a>方式三、混合型，同时使用 start 和 bind</h3><p>Service 并不是只能给一个组件使用，它<strong>可以同时服务于多个组件</strong>。<br>所以一个 Service 既可以是 Start Service，也可以是 Bind Service。只要把两者需要实现的地方都实现了就行。组件 A 可以通过 startService()运行一个 Service，组件 B 可以通过 bindService()再次运行同一个 Service。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>可以绑定到已经使用 startService() 启动的服务。例如，可以通过使用 Intent（标识要播放的音乐）调用 startService() 来启动后台音乐服务。随后，可能在用户需要稍加控制播放器或获取有关当前播放歌曲的信息时，Activity 可以通过调用 bindService() 绑定到服务。在这种情况下，除非所有客户端均取消绑定，否则 stopService() 或 stopSelf() 不会实际停止服务。</p>
<ol>
<li>先 startService 然后 bindSerive</li>
<li>先 bindService 然后 startService </li>
</ol>
<p>在混合模式下，只有等到调用了 stopSelf 或 stopService 以及 所有的客户端都取消绑定，服务才会停止</p>
<p>官方流程图<br><img src="https://user-images.githubusercontent.com/16668676/35767586-324e8d7a-092a-11e8-9e83-088d73808553.png" alt="image"></p>
<p>onRebind（Intent intent） 方法与 Activity#onNewIntent 方法类似。<br>该方法是否被调用取决于 onUnbind 方法是否返回 true。当所有的客户端都调用了 unBindService，而没有调用 stopService 的时候，可以避免这种情况。</p>
<ul>
<li>如果是 true，当有新的调用过来的时候，可以在 onReBind 方法中拿到 intent。</li>
<li>如果为 false，当有新的调用过来的时候，会走 onBind<br>onRebind() 返回空值，但客户端仍在其 onServiceConnected() 回调中接收 IBinder。</li>
</ul>
<p>如果要同时支持 start 和 bind，需要同时实现两套方法。</p>
<ul>
<li>onStartCommand</li>
<li>onBind </li>
</ul>
<p>这两个方法都含有一个 Intent 参数</p>
<h3 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h3><ul>
<li>应该始终捕获 DeadObjectException 异常，它们是在连接中断时引发的。这是远程方法引发的唯一异常。</li>
<li>对象是跨进程计数的引用。</li>
<li>通常应该在客户端生命周期的匹配引入 (bring-up) 和退出 (tear-down) 时刻期间配对绑定和取消绑定。 例如：<br>如果您只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。<br>如果您希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。请注意，这意味着您的 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当您提高该进程的权重时，系统终止该进程的可能性会增加。</li>
</ul>
<blockquote>
<p>注：通常情况下，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，您应该<strong>使发生在这些转换期间的处理保持在最低水平</strong>。此外，如果您的应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一个 Activity 绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务。 （Activity 文档中介绍了这种有关 Activity 如何协调其生命周期的 Activity 转换。）</p>
</blockquote>
<h3 id="manifest-文件中声明服务"><a href="#manifest-文件中声明服务" class="headerlink" title="manifest 文件中声明服务"></a>manifest 文件中声明服务</h3><p>android:name 属性是唯一必需的属性，用于指定服务的类名。</p>
<h2 id="三、创建服务"><a href="#三、创建服务" class="headerlink" title="三、创建服务"></a>三、创建服务</h2><p>从传统上讲，您可以扩展两个类来创建启动服务：</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>所有服务的基类。扩展此类时，<strong>必须创建一个用于执行所有服务工作的新线程</strong>，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>Service 的子类，它使用<strong>工作线程逐一处理</strong>（<strong>串行</strong>处理）所有启动请求。如果您不要求服务同时处理多个请求，这是最好的选择。 您只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，使您能够执行后台工作。</p>
<p>IntentService 执行以下操作：</p>
<ul>
<li>自动创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</li>
<li>创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。</li>
<li>在处理完<strong>所有启动请求后停止服务，因此您永远不必调用 stopSelf()</strong>。</li>
<li>提供 onBind() 的默认实现（返回 null）。</li>
<li>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。</li>
</ul>
<h3 id="在前台中显示、移除"><a href="#在前台中显示、移除" class="headerlink" title="在前台中显示、移除"></a>在前台中显示、移除</h3><p>要从前台移除服务，请调用 stopForeground()。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果在服务正在前台运行时将其停止，则通知也会被移除</p>
<p><a href="http://www.anddle.com/?p=173" target="_blank" rel="noopener">Start Service 和 Bind Service</a></p>
<h2 id="四、LocalService-还是-RemoteService？"><a href="#四、LocalService-还是-RemoteService？" class="headerlink" title="四、LocalService 还是 RemoteService？"></a>四、LocalService 还是 RemoteService？</h2><p>什么时候选择 local service（即不指定额外的进程），什么时候选择 remote service（额外的进程）？</p>
<p>通常我们会把真的<strong>需要长期运行的 Service（例如 IM 之类）放在单独的进程里</strong>，这样 UI 所在的进程在必要的时候仍然可以被系统 kill 掉来腾出内存。</p>
<p>而 local service 通常用来处理一些<strong>需要短期运行但仍然超出 activity 活动周期的任务</strong>，打个比方，发送短信或彩信。这样的任务执行完以后，service 就可以 stop 自己，仍然不妨碍整个 UI 进程被回收掉。</p>
<h2 id="五、何时会被-kill？"><a href="#五、何时会被-kill？" class="headerlink" title="五、何时会被 kill？"></a>五、何时会被 kill？</h2><ul>
<li>当且仅当内存不足，而此时有<strong><em>其他进程</em>的 Activty 具有用户焦点</strong>（或者说，在于用户交互）时，android 系统会强制 stop 服务。</li>
<li>如果将<strong>服务绑定到具有用户焦点的 Activity</strong>，则它不太可能会终止；</li>
<li>如果<strong>将服务声明为在前台运行</strong>，则它<strong>几乎永远不会终止</strong>。</li>
<li>如果服务已启动并要长时间运行，则系统会<strong>随着时间的推移降低服务在后台任务列表中的位置</strong>，而服务也将随之变得非常容易被终止；</li>
<li>如果服务是通过 startService 启动的，需要通过重写 onStartCommand 方法妥善处理系统对它的重启。     <ul>
<li>因为如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务（不过这还<strong>取决于从 onStartCommand() 返回的值</strong>）。</li>
<li>Q:如果仅通过 bindService 启动，服务被 kill 之后，是否重启仍然取决于 onStartCommand 的返回值吗？<ul>
<li>不会，onStartCommand 方法都没有被调用，怎么知道它的返回值呢？</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.anddle.com/?p=173" target="_blank" rel="noopener">Start Service 和 Bind Service</a></li>
<li><a href="https://developer.android.com/guide/components/services.html?hl=zh-cn#Lifecycle" target="_blank" rel="noopener">Service</a></li>
<li><a href="https://developer.android.com/guide/components/bound-services.html?hl=zh-cn" target="_blank" rel="noopener">Bind Service</a></li>
<li><a href="https://www.zhihu.com/question/19591125" target="_blank" rel="noopener">Android 中 Local Service 最本质的作用是什么？</a></li>
<li><a href="https://www.cnblogs.com/newcj/archive/2011/05/30/2061370.html" target="_blank" rel="noopener">Android 中的 Service 全面总结</a></li>
</ul>
<p>由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！</p>
]]></content>
      
        <categories>
            
            <category> Android 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android 基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 消息机制解析]]></title>
      <url>https://timlin-pro.github.io/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>提起 Handler，相信大家都不会陌生，日常开发中不可避免地要使用到它。今天要讲的是消息机制。消息机制？咋听起来有点抽象。其实我们在使用 Handler 的时候，就使用了 Android 的消息机制。</p>
<p>从开发的角度来看，Handler 是 Android 消息机制的<strong>上层接口</strong>，这使得开发过程中只需要设计这方面的内容即可。但是作为一名合格的开发者，弄清它的实现原理是很有必要的。</p>
<a id="more"></a>
<p>俗话说得好，一图胜千言，我们先来看下 Android 消息机制简单示意图（图片参考自<a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="noopener">这篇文章</a>）。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/44624139-24697380-a918-11e8-819a-82c87c7f7566.png" alt="image"></p>
<p>我们把 Thread 比作是一个 发动机，MessageQueue 看作是一条流水线，Message 就像是流水线上的工人，Looper 是流水线下的滚筒，Handler 像是一个工人，它负责把 Message 这个产品送到流水线上，最后又负责把它取走。</p>
<p>这幅图中的各个组件的说明如下：</p>
<ul>
<li>Looper ==》 滚轮</li>
<li>MessageQueue ==》 流水线</li>
<li>Message ==&gt; 流水线上的产品</li>
<li>Handler ==》 扮演把『产品』送进流水线，完了以后又把『产品』取走的角色</li>
<li>Thread ==》 动力</li>
</ul>
<p>另外还有一个重要概念 ——ThreadLocal 图中没有标明出来。下面对各个部分进行详细介绍。</p>
<h1 id="Android-的消息机制分析"><a href="#Android-的消息机制分析" class="headerlink" title="Android 的消息机制分析"></a>Android 的消息机制分析</h1><h2 id="从-Handler-出发"><a href="#从-Handler-出发" class="headerlink" title="从 Handler 出发"></a>从 Handler 出发</h2><p>相信很多做 Android 开发的同学都写过与下面相似的代码。在子线程中做一些耗时操作，比如网络请求，操作完成之后，将返回的数据包装为 Message 对象然后调用 sendMessageXxx 方法，最后在 handleMessage 方法中对结果进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            	<span class="comment">//handle </span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//do sth</span></div><div class="line">            Message message = mHandler.obtainMessage();</div><div class="line">            message.what = <span class="number">1</span>;</div><div class="line">            message.obj = result;</div><div class="line">            mHandler.sendMessage(message);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>Handler.sendMessage(message)</code>  到 <code>Handler.handlerMessage</code>方法经历了什么样的过程？</p>
<p>我们先看看 sendMessage 方法内部是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">        delayMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">      msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个调用流程是这样的 <code>sendMessage ==》 sendMessageDelayed ==》 sendMessageAtTime ==》 enqueueMessage ==》  MessageQueue.enqueueMessage</code></p>
<p>我们可能还会调用 <code>Handler.post(Runnable)</code>方法到目标线程中执行 run 方法。post 方法会先调用 <code>getPostMessage</code>方法将 Runable 包装为 一个 Message 对象，（Runnable 就存储在 callback 中）。其他的 <code>postXxx(Runnable)</code>方法内部实现也是这样的流程，首先将 Runnable 包装为一个 Message 对象然后调用相应的 sendXxx 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;<span class="comment">//将 Runnable 包装为一个 Message 对象</span></div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.callback = r;</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述的调用流程可以看出 sendXxx  或者 postXxx 方法最终都会调用 MessageQueue 的 <code>enqueueMessage</code>方法，将 Message 追加到 MessageQueue 中。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>Handler 的消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。<ul>
<li>post 系列方法最终是通过 send 的一系列方法来实现的。</li>
</ul>
</li>
</ul>
<p><strong>Handler 的发送消息的过程仅仅是向消息队列插入了一条消息</strong>。</p>
<h3 id="MessageQueue-对象是从哪里来的？"><a href="#MessageQueue-对象是从哪里来的？" class="headerlink" title="MessageQueue 对象是从哪里来的？"></a>MessageQueue 对象是从哪里来的？</h3><p>mQueue 是 Handler 的一个成员变量，它是在哪里初始化的呢？先看看 Handler 的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    mLooper = Looper.myLooper();<span class="comment">//获取当前线程的 Looper </span></div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="comment">//抛出异常，不能在没有 Looper 的线程创建 Handler </span></div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;<span class="comment">//从本线程的 Looper 中获取 MessageQueue</span></div><div class="line">    mCallback = callback;<span class="comment">//回调</span></div><div class="line">    mAsynchronous = async;<span class="comment">//是否异步</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到 mQueue 是从 Looper 中取出的。在解说 Looper 之前，我们先看看前面提到的 MessageQueue 。</p>
<h2 id="MessageQueue-的工作原理"><a href="#MessageQueue-的工作原理" class="headerlink" title="MessageQueue 的工作原理"></a>MessageQueue 的工作原理</h2><p>MessageQueue 主要包含两个操作：插入和读取（分别对应 enqueueMessage 和 next 方法）。</p>
<ul>
<li>顾名思义，enqueueMessage 的作用是往队列中插入一条信息。</li>
<li>next() 的作用是从队列中取出一条信息并将其从消息队列中移除。</li>
</ul>
<p>虽然 MessageQueue 名为消息队列，但是它的<strong>内部实现并不是用队列</strong>，而是通过一个<strong>单链表的数据结构</strong>来维护消息列表。</p>
<ul>
<li>为什么选择使用单链表结构？ 因为 Message 是可以定时发送的，若使用普通的队列，当插入一个发送时间晚于队首 Message  发送时间的新 Message，那么就需要插队，实现起来不方便，而使用优先队列又显得比较复杂。因此就采用了单链表实现。</li>
</ul>
<p>接下来我们重点看看 enqueueMessage 方法和 next 方法。</p>
<h3 id="enqueueMessage-方法："><a href="#enqueueMessage-方法：" class="headerlink" title="enqueueMessage 方法："></a>enqueueMessage 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 要进入队列的消息对象的目标 handler 不能为空</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">        <span class="comment">// 要进入队的消息不能处在使用状态</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//入队需要先获取内置锁</span></div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">            <span class="comment">// 已经调用过 Looper.quit / Looper.quitSafely 方法。 MessageQueue 中不能再追加 Message 对象</span></div><div class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();<span class="comment">//回收消息</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//返回 false 表示入队失败</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 标记消息为使用状态；设置消息发送的时间；是否需要唤醒</span></div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            <span class="comment">//将消息插入到队首</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">          	<span class="comment">//通过该循环找到合适的插入位置（以发送的时间作为排序的标准）</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">//插入队列的指定位置中</span></div><div class="line">            msg.next = p; </div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);<span class="comment">//当前处于阻塞状态，通过「写描述符」唤醒线程，从而使得 MessageQueue#next 方法中的 nativePollOnce 能够返回。（实际上运用了 Linux 的 epoll 机制）</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中不难看出，enqueueMessaege 虽然有点长，但是逻辑还是比较清晰的。它先做了一些状态判断以及一些边界检测，完了以后再进行单链表的插入操作。</p>
<h3 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">      <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>; </div><div class="line">      &#125; </div><div class="line"><span class="comment">//代码省略</span></div><div class="line">      <span class="keyword">for</span> (;;) &#123; </div><div class="line">          <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">              Binder.flushPendingCommands();</div><div class="line">          &#125; </div><div class="line">		<span class="comment">//处理 native 层事件（内部使用 Linux 的 epoll 机制），可能会阻塞</span></div><div class="line">          nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"> </div><div class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">              <span class="comment">// Try to retrieve the next message.  Return if found. </span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">              Message prevMsg = <span class="keyword">null</span>;</div><div class="line">              Message msg = mMessages;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//如果消息的目标 Handler 为空</span></div><div class="line">                  <span class="keyword">do</span> &#123; <span class="comment">// 找出队列中下一个异步 Message 对象</span></div><div class="line">                      prevMsg = msg;</div><div class="line">                      msg = msg.next;</div><div class="line">                  &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">              &#125; </div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                      <span class="comment">// 计算下一条消息的执行时间，设置一个唤醒的延迟</span></div><div class="line">                      nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123; </div><div class="line">                      <span class="comment">// 队首 Message 执行的时机到了，获取一条消息 </span></div><div class="line">                      mBlocked = <span class="keyword">false</span>; </div><div class="line">                      <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                          prevMsg.next = msg.next;</div><div class="line">                      &#125; <span class="keyword">else</span> &#123; </div><div class="line">                          mMessages = msg.next;</div><div class="line">                      &#125; </div><div class="line">                      msg.next = <span class="keyword">null</span>;</div><div class="line">                      <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                      msg.markInUse();<span class="comment">//标记 Message 为正在使用状态</span></div><div class="line">                      <span class="keyword">return</span> msg;<span class="comment">//返回消息</span></div><div class="line">                  &#125; </div><div class="line">              &#125; <span class="keyword">else</span> &#123; </div><div class="line">                  <span class="comment">// 队列中没有消息了</span></div><div class="line">                  nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">              &#125; </div><div class="line"> </div><div class="line">              <span class="comment">// 外部调用了 quit 方法。退出</span></div><div class="line">              <span class="keyword">if</span> (mQuitting) &#123; </div><div class="line">                  dispose(); <span class="comment">//处理底层消息队列。实际上移除了 native 层的消息队列</span></div><div class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>; </div><div class="line">              &#125; </div><div class="line"> </div><div class="line"></div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                      &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                  pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">              &#125; </div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// 没有可运行的闲置 handler。跳出本次循环再等待。</span></div><div class="line">                  mBlocked = <span class="keyword">true</span>; </div><div class="line">                  <span class="keyword">continue</span>; </div><div class="line">              &#125; </div><div class="line">		<span class="comment">//代码省略</span></div><div class="line">          &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>next 方法中有一个死循环，其主要逻辑如下:</p>
<ul>
<li>如果消息队列中没有消息，那么 next 会一直阻塞在那里。<ul>
<li>当队首的消息设置了延迟执行时，会造成短时间的阻塞。</li>
</ul>
</li>
<li>当有新消息到来时，next 方法会返回这条信息并将其从单链表中移除。</li>
</ul>
<p>当调用了 quit 方法之后，mQuitting 为 true ，next 方法会移除 native 层的消息队列并返回 null。</p>
<p>整个 next 方法的逻辑如下： 从消息队列中依次取出消息。如果这个消息到了执行时间，那么就将该消息返回给 Looper，并且将消息队列链表的指针后移。实际上消息队列维护着一个<strong>分发屏障</strong>(dispatch barrier)，当一个 Message 的时间戳低于这个值的时候，消息就会被分发给 Handler 进行处理。形象一点？看看下面这张图（图片来自 <a href="https://medium.com/@jagsaund/android-handler-internals-b5d49eba6977" target="_blank" rel="noopener">Android Handler Internals</a>，侵删）</p>
<p><img src="https://user-images.githubusercontent.com/16668676/32033334-a880e7ee-ba3e-11e7-8294-da929cc7bea0.png" alt="image"></p>
<p>位于 dispatch barrier 左边的 Message 都被阻塞着，位于其右边的是即将分发的 Message。</p>
<p>我们是不是该说下 Looper 了，下下个就到它了，在此之前需要先看看 ThreadLocal 相关知识。</p>
<h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><p>ThreadLocal  是一个<strong>线程内部的数据存储类</strong>，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>使用场景：</p>
<ol>
<li>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑采用 ThrradLocal。<ul>
<li>在 Android 中，Looper 类就是利用了 ThreadLocal 的特性，保证<strong>每个线程只存在一个 Looper 对象</strong>。</li>
</ul>
</li>
<li>复杂逻辑下的对象传递。<ul>
<li>比如监听器的传递。</li>
</ul>
</li>
</ol>
<p>从 ThreadLocal 的 set 和 get 方法 可以看出，它们所操作的对象都是<strong>当前线程的 localValues 对象的 table 数组</strong>，因此在不同的线程中访问同一个 ThreadLocal 的 get 和 set 方法，他们对 ThreadLocal 所做的读/写操作仅限于各自线程的内部。</p>
<p>关于 ThreadLocal 的具体介绍请见 <a href="https://ivanljt.github.io/blog/2017/08/21/谈谈-ThreadLocal/#more" target="_blank" rel="noopener">这篇文章</a></p>
<p>理解 ThreadLocal 对后面理解 Looper 有很大的帮助，建议先细看 ThreadLocal  的内容再看后面的内容。</p>
<h2 id="Looper-的工作原理"><a href="#Looper-的工作原理" class="headerlink" title="Looper 的工作原理"></a>Looper 的工作原理</h2><p>Android 的官方文档中是这么介绍 Looper 的：</p>
<blockquote>
<p>  Looper 是一个用来为单个线程运行消息循环的类。<strong>默认情况下线程是没有一个 Looper 跟他们相关联的</strong>。如果一个线程需要 looper 的话，可以通过先调用 prepare() 方法初始化一个本线程的 Looper 实例。然后调用 loop 方法让它开始处理信息，一直到循环结束。</p>
<p>  我们通常通过 Handler 类与 Looper 的打交道。</p>
</blockquote>
<p>一个 线程最多只能有一个 Looper，一个 Looper 中有一个消息队列（前面 Hanlder 中的 MessageQueue 对象就是从 Looper 中取出的），并且持有它所在线程的引用。Looper 就像一个「死循环」（通过 quit 或者 quitSafely 方法可以退出），它会不断地从 MessageQueue 中查看是否有新消息。如果有，就调用 handler.dispatchMessage 方法进行处理；如果没有，就一直阻塞在那里。</p>
<h3 id="创建-Looper"><a href="#创建-Looper" class="headerlink" title="创建 Looper"></a>创建 Looper</h3><p>我们先看看 Looper 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建一个消息队列</span></div><div class="line">    mThread = Thread.currentThread(); <span class="comment">//把当前线程的对象保存起来</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Looper 构造方法中创建了一个消息队列，并且会保存当前线程对象。</p>
<h4 id="创建普通线程上的-Looper"><a href="#创建普通线程上的-Looper" class="headerlink" title="创建普通线程上的 Looper"></a>创建普通线程上的 Looper</h4><p>Looper 的构造方法是私有的，那么要创建一个 Looper。？<br><strong>调用 <code>Looper.prepare()</code>即可为当前线程创建一个 Looper 对象，接着通过 <code>Looper.loop()</code> 方法开启消息循环</strong>。要注意的是：在子线程中，如果手动为其创建了 Looper，那么在所有的任务完成之后，需要调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待状态。</p>
<p>我们看下 prepare 方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);<span class="comment">//一个线程最多只能有一个 Looper</span></div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//为当前线程创建一个 Looper </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;<span class="comment">//获取当前线程的 Looper 对象</span></div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建主线程上的-Looper"><a href="#创建主线程上的-Looper" class="headerlink" title="创建主线程上的 Looper"></a>创建主线程上的 Looper</h4><p>有一个要注意的地方就是 Looper 的另一个创建方法 —— prepareMainLooper。</p>
<p>prepareMainLooper 在应用的入口方法（ActivityThread.main() ）中被调用，用来启动主线程的消息循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line"></div><div class="line">    Looper.prepareMainLooper();<span class="comment">//创建主线程的 Looper</span></div><div class="line"></div><div class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">    thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();<span class="comment">//创建主线程的 Handler</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    Looper.loop();<span class="comment">//开启主线程消息循环</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法使得在任何地方都可以获得主线程的消息循环</span></div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">return</span> sMainLooper;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>在应用启动时会开启一个主线程（UI 线程），并且<strong>开启消息循环</strong>，应用不断地从该消息队列中取出、处理消息达到程序运行的结果。</p>
<h3 id="loop-方法"><a href="#loop-方法" class="headerlink" title="loop 方法"></a>loop 方法</h3><p>前面所讲都是 Looper 自身的一些特性，没有提到它是怎么跟其他部分交互的。Looper 与其他 MessageQueue 、Hanlder 的交互主要在 loop 方法中。下面我们来看看 loop 方法的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//获取本线程的 Looper</span></div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);<span class="comment">//调用 loop 方法之前必须先调用 Looper.prepare() 方法创建 Looper</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//获取所在线程的消息队列</span></div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123; </div><div class="line">        Message msg = queue.next(); <span class="comment">// 阻塞方法，如果没有获取到消息，就一直阻塞在这里</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;  <span class="comment">//只有当 msg == null 时才会退出循环</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            msg.target.dispatchMessage(msg);<span class="comment">// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 代码省略</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">        msg.recycleUnchecked();<span class="comment">//调用 Message 的回收方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由源码可见 loop 方法是一个死循环，<strong>唯一跳出循环的方式是 MessageQueue 的 next 方法返回了 null</strong>。</p>
<p>当我们调用 Looper 的 quit 方法时，Looper 会调用 MessageQueue 的 quit 或 quitSafely 方法来通知消息队列退出，否则 loop 方法会一直循环下去。</p>
<p>另外，代码中可以看到，loop 调用了 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 方法会一直阻塞在那里，这也导致了 loop 方法一直阻塞在那里。</p>
<p><code>msg.target.dispatchMessage(msg);</code>// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 <strong>Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理</strong>了。</p>
<p>绕了这么一个大圈意义何在？<br>通常我们都会在子线程中调用 Handler.sendMessageXxx 或者 Handler.postXxx 方法， 而<strong>Handler 的 dispatchMessage 方法是在创建 Handler 的那个线程中执行的，这样就顺利地将代码切换到目标线程中去执行了</strong>。</p>
<h3 id="退出-Looper"><a href="#退出-Looper" class="headerlink" title="退出 Looper"></a>退出 Looper</h3><p>Looper 也是可以退出的（这里的退出 Looper 主要是指跳出 loop 方法中的死循环）。通过调用 Looper 的 quit 方法或者 quitSafely 方法即可。那么这二者有什么区别？</p>
<ul>
<li>调用 Looper 的 quit 方法可以<strong>直接退出</strong>Looper。</li>
<li>调用 Looper 的 quitSafely 方法只是设定了一个<strong>退出标记</strong>，然后把消息队列中<strong>已有的消息处理完才退出</strong> Looper。</li>
</ul>
<p>我们来看看这两个方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Looper.quit</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</div><div class="line">    mQueue.quit(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//Looper.quitSafely</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</div><div class="line">    mQueue.quit(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mQueue 的实际类型为 MessageQueue，Looper 的两个 quit 方法都是通过调用 MessageQueue 的 quit 方法来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);<span class="comment">//主线程的  Looper 无法退出。主线程的 Looper 是通过 prepareMainLooper 方法创建的，创建时调用了 prepare（false），也就是令 mQuitAllowed = false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//是否正在退出</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mQuitting = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (safe) &#123;</div><div class="line">          	<span class="comment">//安全退出,不会取消执行时机早于或等于当前时间的 Message</span></div><div class="line">            removeAllFutureMessagesLocked();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            removeAllMessagesLocked();<span class="comment">//移除 MessageQueue 中所有的消息</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></div><div class="line">        nativeWake(mPtr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MessageQueue.next()</code> 方法片段。当调用了 quit 方法之后会使得 mQuitting 为 true，从而导致  next 方法返回 null，一旦 next 方法返回 null， <code>Looper.loop</code> 就跳出了死循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">    dispose();<span class="comment">//销毁 native 层的消息队列。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>MessageQueue.enqueueMessage</code> 方法片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">    IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">            msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">    Log.w(TAG, e.getMessage(), e);</div><div class="line">    msg.recycle();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里实现可以看到，调用了 Looper.quit / quitSafely 方法之后，再通过 Handler 发送的消息无法添加到 MessageQueue 中，此时 Handler 的 send 方法会返回 false。</p>
<p><code>android.os.MessageQueue#dispose</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 销毁底层的消息队列</span></div><div class="line"><span class="comment">// Must only be called on the looper thread or the finalizer.</span></div><div class="line"><span class="comment">//只能在不 looper 线程或者 finalizer 中调用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</div><div class="line">        nativeDestroy(mPtr);</div><div class="line">        mPtr = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="回到-Handler"><a href="#回到-Handler" class="headerlink" title="回到 Handler"></a>回到 Handler</h2><p> Looper 的 loop 方法中有这样一行代码 <code>msg.target.dispatchMessage(msg);</code>该方法调用的就是 Handler.dispatchMessage 方法。dispatchMessage 方法会根据情况对 Message 进行分发。</p>
<p><code>Handler.class</code> 代码片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);<span class="comment">//回调执行 Runnable 的 run 方法</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;<span class="comment">//执行创建 Handler 时指定的 Callback#handleMessage 方法。</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);<span class="comment">//执行 handleMessage(msg) 方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;<span class="comment">//空实现，需要由子类覆写</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">    message.callback.run(); <span class="comment">// callback 的实际类型为 Runnable，这行代码的作用就是回调 Runnable 的 run 方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Callback interface you can use when instantiating a Handler to avoid</div><div class="line"> * having to implement your own subclass of Handler.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</div><div class="line">     * <span class="doctag">@return</span> True if no further handling is desired</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>dispatchMessage 方法的逻辑：如果 <strong>Message 自身</strong>设置了 callback，那么事件会直接分派给 msg#callback#run  方法处理。否则，如果给 Handler 设置了 Callback 的话，会先将事件分派给 Callback#handleMessage 方法处理，如果返回值为 true，说明不需要再做进一步的处理，如果返回 false或者是没有给 Handler 设置callback 的 话，则会执行 Handler#handleMessage 方法。</p>
<p>Handler 的 Callback 有什么作用呢？</p>
<ol>
<li>提供了另一种使用 handler 处理消息的方式，在实例化 Handler 时可以使用Callback ，而不是自己实现一个 handler 子类。</li>
<li>可以做一些消息过滤。</li>
</ol>
<h3 id="Handler-小结"><a href="#Handler-小结" class="headerlink" title="Handler 小结"></a>Handler 小结</h3><p>Handler 的工作主要包含<strong>消息的发送</strong>和<strong>接收</strong>过程（还有一个「分发过程」）。  </p>
<ul>
<li>消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。<ul>
<li>post 系列方法最终是通过 send 的一系列方法来实现的。</li>
</ul>
</li>
</ul>
<p>查看源码不难发现，Handler 的发送消息的过程仅仅是向 MessageQueue 插入了一条 Message，MessageQueue 的 next 方法就会返回此 Message 给 Looper， Looper 在 loop 方法中对 Message 进行处理，最终由 Looper 交回给 Handler 处理（调用 Handler 的 dispatchMessage 方法）。</p>
<h2 id="数量关系"><a href="#数量关系" class="headerlink" title="数量关系"></a>数量关系</h2><p>一个线程最多只能有一个 Looper ，一个 MessageQueue，可以有多个 Handler。</p>
<p>MessageQueue 封装在 Looper 中。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么主线程不会因为-Looper-loop-里的死循环卡死？"><a href="#为什么主线程不会因为-Looper-loop-里的死循环卡死？" class="headerlink" title="为什么主线程不会因为 Looper.loop()里的死循环卡死？"></a>为什么主线程不会因为 Looper.loop()里的死循环卡死？</h3><p>阻塞是有的，但是不会卡住<br>主要原因有 2 个：</p>
<h4 id="1-Linux-的-epoll-机制"><a href="#1-Linux-的-epoll-机制" class="headerlink" title="1.Linux 的 epoll 机制"></a>1.Linux 的 epoll 机制</h4><p>当<strong>没有消息</strong>的时候会 <strong>epoll.wait</strong>，<strong>等待句柄写的时候再唤醒</strong>，这个时候其实是阻塞的。</p>
<h4 id="2-所有的-ui-操作都通过-handler-来发消息操作。"><a href="#2-所有的-ui-操作都通过-handler-来发消息操作。" class="headerlink" title="2.所有的 ui 操作都通过 handler 来发消息操作。"></a>2.所有的 ui 操作都通过 handler 来发消息操作。</h4><p>比如屏幕刷新 16ms 一个消息，你的各种点击事件，就会有<strong>句柄写操作</strong>，<strong>唤醒上文的 wait 操作</strong>，所以不会被卡死了。</p>
<h4 id="一个比较形象的比喻："><a href="#一个比较形象的比喻：" class="headerlink" title="一个比较形象的比喻："></a>一个比较形象的比喻：</h4><blockquote>
<p>  就像一辆车在圆形赛车道上跑，一边跑(一边执行任务)，比如开到市中心买瓶水，任务完成又回到刚刚离开的地方，继续各种执行买水的任务，直到没有任务了（msg 为空），行了，跑一圈回到起点。睡觉（epoll_wait），有任务叫醒你（唤醒 wait），你又开始跑一圈。边跑边接单。</p>
</blockquote>
<p>想进一步了解的同学可以看下知乎上对该问题的<a href="https://www.zhihu.com/question/34652589" target="_blank" rel="noopener">讨论</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Looper 对象封装了消息队列，Looper 对象被封装在 ThreadLocal 中，是线程私有的，不同线程之间的 Looper 无法共享。Handler 通过与 Looper 之间的绑定来实现与执行线程之间的绑定，handler 发送消息时会将 Message 对象追加到与线程相关的消息队列中，然后由 Looper 回调它的分发消息方法，根据情况处理消息。</p>
<p>最后我们看一张完整的流程图（图片参考自<a href="http://www.jianshu.com/p/9fe944ee02f7" target="_blank" rel="noopener">Handler 异步通信机制全面解析</a>），笔者修改了原图中的 Handler dispatchMessage  方法描述。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29739304-0513811c-8a6d-11e7-8a78-510d3c98feb7.png" alt=""></p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="noopener">理解 Java 中的 ThreadLocal </a></li>
<li><a href="https://ivanljt.github.io/blog/2017/08/21/%E8%B0%88%E8%B0%88-ThreadLocal/#more" target="_blank" rel="noopener">谈谈 ThreadLocal</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47115879" target="_blank" rel="noopener">Android 中 Handler 的使用</a></li>
<li><a href="http://www.jianshu.com/p/9fe944ee02f7" target="_blank" rel="noopener">Handler 异步通信机制全面解析</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="noopener">深入源码解析 Android 中的 Handler,Message,MessageQueue,Looper</a></li>
<li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/android-handler-internals.md" target="_blank" rel="noopener">探索 Android 大杀器—— Handler</a></li>
<li>《Android 开发艺术探索》</li>
<li>《Android 源码设计模式解析与实战》</li>
</ul>
<p>如果本文中有不正确的结论、说法或者表述不清晰的地方，恳请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
            <category> Android 进阶 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android 进阶 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
