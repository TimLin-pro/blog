<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[行为型设计模式之备忘录模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/21/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="备忘录模式的定义"><a href="#备忘录模式的定义" class="headerlink" title="备忘录模式的定义"></a>备忘录模式的定义</h2><p>备忘录模式是一种<strong>行为模式</strong>，该模式用于保存对象当前的状态，并且在之后可以再次恢复到此状态。</p>
<p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便后续将对象恢复到原来的状态。</p>
<h2 id="备忘录模式的使用场景"><a href="#备忘录模式的使用场景" class="headerlink" title="备忘录模式的使用场景"></a>备忘录模式的使用场景</h2><ol>
<li>需要保存一个对象在某一个时刻的状态或部分状态</li>
<li>一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。（如果使用接口来让其他对象获取对象的状态，会破坏封装性）</li>
</ol>
<a id="more"></a>
<h2 id="备忘录模式的UML类图"><a href="#备忘录模式的UML类图" class="headerlink" title="备忘录模式的UML类图"></a>备忘录模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29518826-890e58e8-86ad-11e7-9ce8-90ff79fcc071.png" alt="memoto pattern"></p>
<p>三个角色：</p>
<ul>
<li>Originator：需要保存状态的对象。负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。</li>
<li>Memento（类似于 pojo 类）备忘录角色。用于存储 Originator 内部状态，并且可以防止 Originator 以外的对象访问 Memento</li>
<li>Caretaker：负责存储备忘录，不能对<strong>备忘录的内容</strong>进行操作和访问，只能将备忘录传递给其他对象。</li>
</ul>
<h2 id="Android源码中的备忘录模式"><a href="#Android源码中的备忘录模式" class="headerlink" title="Android源码中的备忘录模式"></a>Android源码中的备忘录模式</h2><p>日常开发中如果需要保存什么数据以防止 Activity 意外销毁，第一时间会想到 Activity 中的这两个方法——<code>onSaveInstanceState</code>、<code>onRestoreInstanceState</code>。其内部具体是如何实现数据保存的呢？</p>
<p>先透漏一下，这里面使用到了备忘录模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 存储窗口的视图树的状态</span></div><div class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</div><div class="line">    <span class="comment">//2. 存储 Fragment 中的状态    </span></div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//3. 若用户设置了 Activity 的 ActivityLifeCycleCallbacks，</span></div><div class="line">    <span class="comment">//则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。</span></div><div class="line">    getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Activity.onSaveInstanceState 方法中主要做了三件事</p>
<ol>
<li>存储窗口的视图树的状态</li>
<li>存储 Fragment 中的状态</li>
<li>若用户设置了 Activity 的 ActivityLifeCycleCallbacks，则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。</li>
</ol>
<p>首先看看步骤 1，该步骤将 Window 对象中的视图树中的各个 View 状态存储到 Bundle 中。</p>
<p>Window 的具体实现在 <code>PhoneWindow</code> 中.以下为 <code>PhoneWindow.saveHierarchyState</code> 的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">saveHierarchyState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Bundle outState = <span class="keyword">new</span> Bundle();</div><div class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> outState;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// SparseArray 相当于一个 key 为 整型的 map</span></div><div class="line">    SparseArray&lt;Parcelable&gt; states = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">    <span class="comment">//此处的 mContentParent 就是我们 setContentView 时设置的 View</span></div><div class="line">    mContentParent.saveHierarchyState(states);</div><div class="line">    outState.putSparseParcelableArray(VIEWS_TAG, states);</div><div class="line"></div><div class="line">    <span class="comment">// 持有焦点的 View 必须设置 id，否则重新进入该界面时不会恢复它的焦点状态</span></div><div class="line">    <span class="keyword">final</span> View focusedView = mContentParent.findFocus();</div><div class="line">    <span class="keyword">if</span> (focusedView != <span class="keyword">null</span> &amp;&amp; focusedView.getId() != View.NO_ID) &#123;</div><div class="line">        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 存储整个面板的状态</span></div><div class="line">    SparseArray&lt;Parcelable&gt; panelStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">    savePanelState(panelStates);</div><div class="line">    <span class="keyword">if</span> (panelStates.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">        outState.putSparseParcelableArray(PANELS_TAG, panelStates);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 保存 actionbar 的状态</span></div><div class="line">    <span class="keyword">if</span> (mDecorContentParent != <span class="keyword">null</span>) &#123;</div><div class="line">        SparseArray&lt;Parcelable&gt; actionBarStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</div><div class="line">        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> outState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看步骤 2 中的 <code>mContentParent.saveHierarchyState</code> 方法，mContentParent 是一个 ViewGroup 但是 saveHierarchyState 方法并不是定义在 ViewGroup 中，而是定义在它的父类——View 中，查看下该方法在 View 中的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveHierarchyState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    dispatchSaveInstanceState(container);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 只有含有 id 的 View，状态才会被存储</span></div><div class="line">    <span class="keyword">if</span> (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == <span class="number">0</span>) &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">        <span class="comment">//2. 调用 onSaveInstanceState 方法获取自身状态</span></div><div class="line">        Parcelable state = onSaveInstanceState();</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Derived class did not call super.onSaveInstanceState()"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//3. 将自身状态存放到 container 中</span></div><div class="line">        <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">            container.put(mID, state);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>View.onSaveInstanceState</code> 方法默认存储的状态为空状态。但是它的子类通常都有定义自身的覆盖方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</div><div class="line">    <span class="keyword">if</span> (mStartActivityRequestWho != <span class="keyword">null</span>) &#123;</div><div class="line">        BaseSavedState state = <span class="keyword">new</span> BaseSavedState(AbsSavedState.EMPTY_STATE);</div><div class="line">        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> BaseSavedState.EMPTY_STATE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤 2 中的 View 的调用大致如下：saveHierarchyState ==》 dispatchSaveInstanceState ==》 onSaveInstanceState</p>
<ul>
<li>其中要注意的是 只有含有 id 的 View，状态才会被存储，如果没有给 view 赋一个 id，那么系统是不会帮忙保存该 view 的状态的。</li>
</ul>
<p>View 类中的 saveHierarchyState 方法调用了dispatchSaveInstanceState 方法用来存储自身状态。 ViewGroup 覆写了 dispatchSaveInstanceState 来存储自身以及子视图的状态。 </p>
<p><code>ViewGroup.dispatchSaveInstanceState</code>具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.dispatchSaveInstanceState(container);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;<span class="comment">//遍历调用子 View 的 dispatchSaveInstanceState 方法</span></div><div class="line">        View c = children[i];</div><div class="line">        <span class="keyword">if</span> ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</div><div class="line">            c.dispatchSaveInstanceState(container);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 ViewGroup 的 <code>dispatchSaveInstanceState</code> 方法会先调用 <code>super.dispatchSaveInstanceState(container);</code> 存储自身的状态。然后遍历调用所有子视图的 <code>dispatchSaveInstanceState(container)</code> 方法来保存它们的状态，如果子 View 也是一个 ViewGroup，则会再次执行这个过程。</p>
<hr>
<p>我们以 TextView 的 saveInstanceState 方法为例，看看具体的控件是如何保存自身状态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</div><div class="line"></div><div class="line">    <span class="comment">// Save state if we are forced to</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> freezesText = getFreezesText();</div><div class="line">    <span class="keyword">boolean</span> hasSelection = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> start = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = -<span class="number">1</span>;</div><div class="line">    <span class="comment">//存储 TextView 的 start、end </span></div><div class="line">    <span class="keyword">if</span> (mText != <span class="keyword">null</span>) &#123;</div><div class="line">        start = getSelectionStart();</div><div class="line">        end = getSelectionEnd();</div><div class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span> || end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 是否存存在选项</span></div><div class="line">            hasSelection = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (freezesText || hasSelection) &#123;</div><div class="line">        SavedState ss = <span class="keyword">new</span> SavedState(superState);</div><div class="line">        <span class="comment">//保存 TextView 的文本内容</span></div><div class="line">        <span class="keyword">if</span> (freezesText) &#123;</div><div class="line">            <span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spanned) &#123;</div><div class="line">                <span class="keyword">final</span> Spannable sp = <span class="keyword">new</span> SpannableStringBuilder(mText);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">                    removeMisspelledSpans(sp);</div><div class="line">                    sp.removeSpan(mEditor.mSuggestionRangeSpan);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ss.text = sp;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ss.text = mText.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储 TextView 的 start、end </span></div><div class="line">        <span class="keyword">if</span> (hasSelection) &#123;</div><div class="line">            <span class="comment">// XXX Should also save the current scroll position!</span></div><div class="line">            ss.selStart = start;</div><div class="line">            ss.selEnd = end;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isFocused() &amp;&amp; start &gt;= <span class="number">0</span> &amp;&amp; end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            ss.frozenWithFocus = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ss.error = getError();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">            ss.editorState = mEditor.saveInstanceState();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回状态对象</span></div><div class="line">        <span class="keyword">return</span> ss;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> superState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 View 的 onSaveInstance 函数之后就得到了 View 要存储的数据，此时执行到 View 的  dispatchSaveInstanceState 方法中的注释 3。这里以 View 的 id 为 key，以状态为 value，存储到 container（ SparseArray 类型）中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3. 将自身状态存放到 container 中</span></div><div class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">    container.put(mID, state);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>存储完 Window 的视图状态信息之后，便会执行存储 Fragment 中的状态信息、回退栈等。Fragment  也是通过调用自身的 onSaveInstaceState 方法来存储自身的 View 视图树状态的。</li>
<li>最后就是调用用户设置的 ActivityLifecycleCallbacks 的 onSaveInstaceState 方法，让用户做一些额外的处理</li>
</ul>
<h2 id="前面我们所提及到的只是备忘录模式中的-Originator-角色，即需要保存备忘录的对象。不过也有涉及到-CareTaker-角色——Activity。下面我们再看看另外两个角色——Memoto-和-CareTaker。"><a href="#前面我们所提及到的只是备忘录模式中的-Originator-角色，即需要保存备忘录的对象。不过也有涉及到-CareTaker-角色——Activity。下面我们再看看另外两个角色——Memoto-和-CareTaker。" class="headerlink" title="前面我们所提及到的只是备忘录模式中的 Originator 角色，即需要保存备忘录的对象。不过也有涉及到 CareTaker 角色——Activity。下面我们再看看另外两个角色——Memoto 和 CareTaker。"></a>前面我们所提及到的只是备忘录模式中的 Originator 角色，即需要保存备忘录的对象。不过也有涉及到 CareTaker 角色——Activity。下面我们再看看另外两个角色——Memoto 和 CareTaker。</h2><p>存了状态信息的 Bundle 数据存储在哪？</p>
<ul>
<li>onSaveInstance 方法是在 onStop 方法之前调用的。Activity.onStop 方法是通过 Activity 的 performStopActivity 间接调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</div><div class="line">    <span class="comment">//获取 ActivityClientRecord</span></div><div class="line">    ActivityClientRecord r = mActivities.get(token);</div><div class="line">    <span class="comment">// saveState 表示是否保存状态</span></div><div class="line">    performStopActivityInner(r, <span class="keyword">null</span>, <span class="keyword">false</span>, saveState, reason);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r,</span></span></div><div class="line">        StopInfo info, <span class="keyword">boolean</span> keepShown, <span class="keyword">boolean</span> saveState, String reason) &#123;</div><div class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!keepShown &amp;&amp; r.stopped) &#123;</div><div class="line">            <span class="keyword">if</span> (r.activity.mFinished) &#123;</div><div class="line">                <span class="comment">// 如果正在执行销毁过程，是用户主动销毁。 activity 不打算恢复，我们也没必要调用 onStop 方法</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 在调用 onStop 之前必须先调用 onPause </span></div><div class="line">        performPauseActivityIfNeeded(r, reason);</div><div class="line"></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="comment">// 接下来让 activity 保存它目前的状态和它所管理的 dialogs </span></div><div class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; saveState) &#123;</div><div class="line">            <span class="keyword">if</span> (r.state == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 间接调用 Activity.onSaveInstance()</span></div><div class="line">                callCallActivityOnSaveInstanceState(r);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!keepShown) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 执行 onStop 方法</span></div><div class="line">                r.activity.performStop(<span class="keyword">false</span> <span class="comment">/*preserveWindow*/</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//将 stop 字段置为 true 表示已经调用了 stop 方法。</span></div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callCallActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</div><div class="line">    r.state = <span class="keyword">new</span> Bundle();<span class="comment">//内容就存储在该 Bundle 中</span></div><div class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</div><div class="line">                r.persistentState);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//该方法实际调用了 Activity.onSaveInstanceState 方法</span></div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(Activity activity, Bundle outState,</span></span></div><div class="line">        PersistableBundle outPersistentState) &#123;</div><div class="line">    activity.performSaveInstanceState(outState, outPersistentState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 performStopActivity 与 performStopActivityInner 方法中，首先通过 token 从 mActivities 中获取一个 ActivityClientRecord 对象，状态信息就是存储在这里面的。获取该对象之后，调用了 performStopActivityInner 方法，对于保存状态而言，该方法大概有如下三步</p>
<ol>
<li>判断 Activity 是否需要保存状态</li>
<li>如果需要，则调用 onSaveInstance 方法，该方法会将状态信息存储到 ActivityClientRecord 中</li>
<li>调用 <code>Activity.onStop()</code> 方法</li>
</ol>
<p>执行 onStop 方法之前，系统会根据情况来选择是否存储 Activity 的状态，并且将这些状态（简介地）存储到 mActivities 中。</p>
<p>mActivities 是一个 <code>ArrayMap&lt;IBinder, ActivityClientRecord&gt;</code> ，它维护了一个 Activity 的信息表，当 Activity 重新启动时，会从 mActivities 中查询对应的 ActivityClientRecord，如果这个记录对象中含有状态信息就调用 Activity 的 onRestoreInstanceState 方法。开发人员可以从这个方法中做一些状态恢复操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    Activity activity = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">        <span class="comment">//1. 构建 Activity </span></div><div class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//2. 创建一个 Application 对象</span></div><div class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//创建 appContext，类型为 ContextImpl</span></div><div class="line">            Context appContext = createBaseContextForActivity(r, activity);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            <span class="comment">//3. 关联 appContext、Application 等对象到 Activity 中</span></div><div class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            activity.mCalled = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//4. 调用 Activity.onCreate 方法</span></div><div class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            r.activity = activity;</div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</div><div class="line">                <span class="comment">//调用 onStart 方法</span></div><div class="line">                activity.performStart();</div><div class="line">                r.stopped = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">             <span class="comment">//5. 如果有保存状态的话，调用 Activity.onRestoreInstanceState 方法恢复状态</span></div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</div><div class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">                    <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</div><div class="line">   </div><div class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</div><div class="line">                                r.persistentState);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</div><div class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line">        r.paused = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//6. 将 Activity 的信息记录对象——ActivityClientRecord 存储到 mActivities 中。 </span></div><div class="line">        mActivities.put(r.token, r);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的注释 5 处，系统会判断 Activity 是否调用过了 <code>Activity.finish()</code> 方法、是否是「永久的」以及 ActivityClientRecord 对象中的 state 是否为空，</p>
<ul>
<li>如果满足条件，就会获取存储的状态信息传递给 <code>Activity.onRestoreInstanceState</code> 方法，也会将这些数据传递给 onCreate 方法的 bundle 参数 。</li>
<li>不过 Google 官方推荐调用 onRestoreInstanceState 方法来恢复状态，因为只有在存储有状态信息的时候才会调用该方法，而在 onCreate 方法中还需要先进行判空处理。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上述过程中备忘录模式的三种关键角色分别由什么类扮演？</p>
<ul>
<li><strong>CareTaker</strong>：Activity 负责存储、恢复 UI 的态信息。</li>
<li><strong>Originator</strong>：Activity、Fragment、View、ViewGroup ，是需要存储状态的对象</li>
<li><strong>Memoto</strong>：由 Bundle 类扮演</li>
</ul>
<ul>
<li>Activity 会在停止之前根据 Activity 的退出情景来选择是否需要存储状态</li>
<li>在<strong>重新启动</strong>该 Activity 时会判断 ActivityClientRecord 对象中是否存储了 Activity 的状态<ul>
<li>如果含有状态，调用 <code>Activity.onRestoreInstanceState()</code> 方法恢复状态。从而使得 Activity 的 UI 可以恢复至异常退出前的状态。</li>
</ul>
</li>
</ul>
<h2 id="你可能会问的问题"><a href="#你可能会问的问题" class="headerlink" title="你可能会问的问题"></a>你可能会问的问题</h2><h3 id="onSaveInstanceState-何时被调用"><a href="#onSaveInstanceState-何时被调用" class="headerlink" title="onSaveInstanceState 何时被调用"></a>onSaveInstanceState 何时被调用</h3><p>onSaveInstanceState() 方法会在什么时候被执行？<br>有这么几种情况：</p>
<ol>
<li>当用户按下 HOME 键时。<ul>
<li>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</li>
</ul>
</li>
<li>长按HOME键，选择运行其他的程序时。</li>
<li>按下电源按键（关闭屏幕显示）时。</li>
<li>从 Activity A 中启动一个新的 Activity 时。</li>
<li>屏幕方向切换时，例如从竖屏切换到横屏时。</li>
</ol>
<p>onSaveInstanceState 的调用在 onStop 方法之前，但是与 onPause 方法之间没有既定关系。</p>
<ul>
<li>总而言之，当系统存在「==未经用户许可==」时销毁了我们的 Activity，则 <code>onSaveInstanceState()</code> 会被系统调用，这是系统的责任，因此它必须提供一个机会让用户保存数据。</li>
<li>「经用户许可」的情况不多，通常只有用户按下回退键这一种。这种情况下是用户主动退出某个 Activity，系统不会调用  <code>onSaveInstanceState()</code> 方法。</li>
</ul>
<h3 id="各个-「Originator-」-的-onSaveInstanceState-方法的默认实现是怎么样的？"><a href="#各个-「Originator-」-的-onSaveInstanceState-方法的默认实现是怎么样的？" class="headerlink" title="各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？"></a>各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？</h3><p>在前面的分析中我们知道即使没有覆写 onSaveInstanceState()方法, ViewGroup、View、Fragment、Activity 内部都有自己的默认实现，它们的默认实现也会<strong>保存某些状态数据</strong>。 </p>
<ul>
<li>比如 activity 中各种 UI 控件的状态。android 应用框架中定义的几乎所有 UI 控件都恰当的实现了 onSaveInstanceState() 方法,因此当 Activity 被销毁和重建时, 这些 UI 控件会自动保存和恢复状态数据.<ul>
<li>EditText 控件会自动保存和恢复输入的数据</li>
<li>CheckBox 控件会自动保存和恢复选中状态</li>
<li>…</li>
</ul>
</li>
<li>开发者只<strong>需要为这些控件指定一个唯一的 id</strong>(通过设置 <code>android:id</code> 属性即可), 剩余的事情就可以自动完成了<ul>
<li>注意：如果没有为控件指定ID, 则这个控件就不会进行自动的数据保存和恢复操作。</li>
</ul>
</li>
</ul>
<p>由上所述, 如果我们需要覆写 onSaveInstanceState() 方法, 一般会在第一行代码中调用该方法的默认实现:super.onSaveInstanceState(outState)。</p>
<h3 id="有默认实现，还需要重写-onSaveInstanceState-方法吗？"><a href="#有默认实现，还需要重写-onSaveInstanceState-方法吗？" class="headerlink" title="有默认实现，还需要重写 onSaveInstanceState() 方法吗？"></a>有默认实现，还需要重写 onSaveInstanceState() 方法吗？</h3><p>既然该方法的默认实现可以自动的保存UI控件的状态数据, 那什么时候需要覆写该方法呢? </p>
<p>如果<strong>需要保存额外的数据时</strong>, 就需要覆写 onSaveInstanceState() 方法。大家需要注意的是：onSaveInstanceState()方法<strong>只适合保存瞬态数据</strong>, 比如 UI 控件的状态，成员变量的值等，而不应该用来保存持久化数据，持久化数据应该当用户离开当前的 activity时，在 onPause() 中保存（比如将数据保存到数据库或文件中）。说到这里，还要说一点的就是在onPause()中不适合用来保存比较费时的数据，所以这点要理解。</p>
<p>另外由于 <code>onSaveInstanceState()</code> 方法方法不一定会被调用, 因此<strong>不适合在该方法中保存持久化数据</strong>, 例如向数据库中插入记录等。 保存持久化数据的操作应该放在 onPause() 中。若是永久性值，则在 onPause() 中保存；若有大量要保存的数据，则另开线程，以免阻塞 UI 线程。 </p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/28/2420515.html" target="_blank" rel="external">Android 开发之 instanceState详解</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式，原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式，原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈 ThreadLocal]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/21/%E8%B0%88%E8%B0%88-ThreadLocal/</url>
      <content type="html"><![CDATA[<h2 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a>ThreadLocal 是什么？</h2><p>ThreadLocal 是一个<strong>线程内部</strong>的<strong>数据存储类</strong>，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<h2 id="为什么要使用-ThreadLocal？"><a href="#为什么要使用-ThreadLocal？" class="headerlink" title="为什么要使用 ThreadLocal？"></a>为什么要使用 ThreadLocal？</h2><p>从定义我们知道 ThreadLocal 是一个用于存储本线程内部数据的类。假设没有 ThreadLocal 的话，每个 Thread 中可以输入自己的一个本地变量，但是在整个 Thread 的生命周期中，如果要穿梭很多 class 的很多 method 来使用这个本地变量的话，就要一直一直向下传送这个变量，显然很麻烦。<br>那么怎么才能在这个 Thread 的生命中，在任何地方都能够方便的访问到这个变量呢，这时候 ThreadLocal 就诞生了。</p>
<a id="more"></a>
<p>ThreadLocal 就是这么个作用，除此之外和通常使用的本地变量没有任何区别。<br>也就是说，没有 ThreadLocal 也是可以解决问题的，但是会比较麻烦，ThreadLocal 的作用便是简化线程内部数据的使用流程。</p>
<h2 id="ThreadLocal-内部是怎么实现的？"><a href="#ThreadLocal-内部是怎么实现的？" class="headerlink" title="ThreadLocal 内部是怎么实现的？"></a>ThreadLocal 内部是怎么实现的？</h2><p>既然是线程的本地变量，那自然与线程有着密切的联系。</p>
<p>打开 Thread 的源码可以看到，源码中有一个实例变量 threadLocals。该变量的实际类型为 <code>ThreadLocal.ThreadLocalMap</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</div></pre></td></tr></table></figure></p>
<p>这里我们主要关注三个问题</p>
<ol>
<li>threadLocals 是如何创建的？</li>
<li>怎么设置值？</li>
<li>怎么获取值？</li>
</ol>
<h4 id="ThreadLocals-是如何创建的？"><a href="#ThreadLocals-是如何创建的？" class="headerlink" title="ThreadLocals 是如何创建的？"></a>ThreadLocals 是如何创建的？</h4><p>ThreadLocal.createMap 方法中，会以当前的 ThreadLocal 对象作为 key，将初始值设置进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类。其中以键值对的形式存储数据。可以简单但是不严谨的将它理解为一个 HashMap。</p>
<p>先看看 <code>ThreadLocalMap</code> 的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);<span class="comment">//计算哈希值</span></div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);<span class="comment">//将 Entry 存到指定位置。</span></div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ThreadLocalMap</code> 的构造函数主要做了下面几件事</p>
<ul>
<li>首先创建了一个 <code>Entry</code> 数组，<ul>
<li><code>Entry</code> 是 <code>ThreadLocalMap</code> 中的一个静态内部类,它以 <code>ThreadLocal</code> 为 key，以要存储的值为 value。</li>
</ul>
</li>
<li>然后根据 key 计算 Hash 值</li>
<li>接着创建一个 Entry 对象存储在数组中</li>
<li>最后设置大小和阈值。</li>
</ul>
<h4 id="怎么设置值？"><a href="#怎么设置值？" class="headerlink" title="怎么设置值？"></a>怎么设置值？</h4><ul>
<li>首先通过 <code>getMap</code> 方法，获取当前线程的 ThreadLocalMap，<ul>
<li>如果 map 不为空，则调用 <code>ThreadLocalMap.set</code> 方法，以当前的 ThreadLocal 对象 作为 key，将目标值设置进去。</li>
<li>如果 map 为空，就创建一个（创建的时候会设初始值）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="怎么获取值？"><a href="#怎么获取值？" class="headerlink" title="怎么获取值？"></a>怎么获取值？</h4><ul>
<li>与 set 方法一样，首先通过 getMap 方法，获取当前线程的 ThreadLocalMap<ul>
<li>如果 map 不为空，就以当前的 ThreadLocal 对象为键去获取值，(值存在 ThreadLocalMap.Entry)</li>
<li>如果 map 为空，会返回调用 setInitialValue 方法之后的返回值。（一般都为 null）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;h</div></pre></td></tr></table></figure>
<h2 id="你可能存在的疑问"><a href="#你可能存在的疑问" class="headerlink" title="你可能存在的疑问"></a>你可能存在的疑问</h2><h3 id="每个-ThreadLocal-只能放一个对象吗？"><a href="#每个-ThreadLocal-只能放一个对象吗？" class="headerlink" title="每个 ThreadLocal 只能放一个对象吗？"></a>每个 ThreadLocal 只能放一个对象吗？</h3><p>每个 ThreadLocal 只能放一个对象。要是需要放其他的对象，就再 new 一个新的 ThreadLocal 出来，这个新的 ThreadLocal 将作为 key,需要放的对象作为value，放在 ThreadLocalMap 中。也就是说一个线程可以含有多个 ThreadLocal 类。</p>
<p>当然也可以根据需要在 ThreadLocal 存放一些容器对象，比如 List、Set、Map，一个 ThreadLocal 存放一个容器对象，借助该容器对象也可以实现存储多个对象。 </p>
<h3 id="为什么只存储一个对象却要创建一个-Entry-数组？"><a href="#为什么只存储一个对象却要创建一个-Entry-数组？" class="headerlink" title="为什么只存储一个对象却要创建一个 Entry 数组？"></a>为什么只存储一个对象却要创建一个 Entry 数组？</h3><p>你也许会觉得奇怪前面明明说一个 ThreadLocal 只能存储一个对象，那这里为什么要创建一个数组，直接使用一个 Entry 不行吗？  </p>
<p>其实 ThreadLocal 有一个子类 InheritableThreadLocal，就是可继承的 ThreadLocal。<br>Thread 中有另一个成员变量——<code>ThreadLocal.ThreadLocalMap inheritableThreadLocals</code>该对象由 InheritableThreadLocal 类负责维护。</p>
<p>在 Thread 的构造方法中间接调用以下代码进行初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(</div><div class="line">                parent.inheritableThreadLocals);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p> <code>createInheritedMap</code> 是一个工厂方法，此方法只能在线程的构造方法中调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用了 <code>ThreadLocal.ThreadLocalMap</code> 的单参数构造方法。</p>
<p>该方法使用给定的父线程的 <code>ThreadLocalMap</code> 创建一个新的 map，可以看到其中可能会有多个值。<br>因此需要创建一个数组来存储而不是单个值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</div><div class="line">    Entry[] parentTable = parentMap.table;<span class="comment">//获取父线程 ThreadLocalMap 的数组</span></div><div class="line">    <span class="keyword">int</span> len = parentTable.length;<span class="comment">//获取长度</span></div><div class="line">    setThreshold(len);<span class="comment">//设置阈值</span></div><div class="line">    table = <span class="keyword">new</span> Entry[len];<span class="comment">//创建新的 Entry 数组</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;<span class="comment">//遍历复制</span></div><div class="line">        Entry e = parentTable[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            ThreadLocal key = e.get();</div><div class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">                Object value = key.childValue(e.value);<span class="comment">// childValue 方法需要由子类覆写。InheritableThreadLocal 中的实现为返回参数中的值</span></div><div class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);<span class="comment">//创建一个新的键值对</span></div><div class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);<span class="comment">//计算哈希值</span></div><div class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)<span class="comment">//发生冲突，尝试获取下一个哈希值</span></div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                table[h] = c;<span class="comment">//赋值给指定位置</span></div><div class="line">                size++;<span class="comment">//元素数量+1</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="没有-ThreadLocal-能不能解决问题？"><a href="#没有-ThreadLocal-能不能解决问题？" class="headerlink" title="没有 ThreadLocal 能不能解决问题？"></a>没有 ThreadLocal 能不能解决问题？</h3><p>能。</p>
<p>可以自己定义一个静态的 map，将当前 thread 作为 key，将目标值作为 value，put 到 map 中，这也是一般人的想法。</p>
<p>ThreadLocal 的实现刚好相反，它是在每个线程中有一个 map，而将 ThreadLocal 实例作为 key，这样每个 map 中的项数很少，而且当线程销毁时相应的东西也一起销毁了。<br>因为各线程访问的 map 是各自不同的 map，所以不需要同步，速度会快些；而如果把所有线程要用的对象都放到一个静态 map中的话 多线程并发访问需要进行同步。</p>
<p>所以说 ThreadLocal 只是实现线程局部变量的一种方式。但是综合来看这种方式相比其他实现方式要更好。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果一个对象的引用被多个线程持有，那么即使该对象存在 ThreadLocalMap 中也不是线程的本地变量。</p>
<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过 <code>ThreadLocal.set()</code> 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。 </p>
<p>也就是说，其他线程能否访问，还要看你的 set 进去的对象引用是否被其他线程持有。 如果两个线程都存入同一个对象引用，那就会有线程共享问题。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们总结 ThreadLocal 具体是怎么一步一步去为每一个线程创建一个~线程私有变量~的：</p>
<ul>
<li>首先，在每个线程 Thread 内部有一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的成员变量 threadLocals，这个 threadLocals 就是用来存储~线程私有变量的~，键值（key）为当前 ThreadLocal 变量，值 value 为~线程的私有变量~（即 T 类型的变量）。</li>
<li>初始时，在 Thread 里面，threadLocals 为空，当通过 ThreadLocal 变量调用 get() 方法或者 set() 方法，就会对 Thread 类中的 threadLocals 进行初始化，并且以当前 ThreadLocal 变量为 key，以 ThreadLocal 要保存的~线程私有变量~为 value，存到 threadLocals 中。<ul>
<li>注意，如果是 先调用 get() 方法而不是 set() 方法的话，会返回 null</li>
</ul>
</li>
<li>然后在当前线程里面，如果要使用~该线程私有变量~，就可以通过 get 方法在 threadLocals 里面查找。</li>
</ul>
<h2 id="参考与学习资源推荐"><a href="#参考与学习资源推荐" class="headerlink" title="参考与学习资源推荐"></a>参考与学习资源推荐</h2><ul>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解 ThreadLocal</a></li>
<li><a href="http://www.iteye.com/topic/82984" target="_blank" rel="external">ThreadLocal and synchronized 补充</a></li>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">ThreadLocal</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">Java并发编程：深入剖析ThreadLocal</a></li>
</ul>
<p>如果本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 并发 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[明白原理,轻松解决内存泄漏]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/19/%E6%98%8E%E7%99%BD%E5%8E%9F%E7%90%86-%E8%BD%BB%E6%9D%BE%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<p>相信「内存泄漏」 问题，是一个挺让开发者头疼的事情，笔者在回顾以为代码时，惊讶发现：初学 Android 时，许多不修边幅的代码习惯，导致了许多内存泄漏问题，借此分析其原因，把自己挖过的坑补一下，也希望奔跑在 Android 开发道路上的你能够优雅避免。</p>
<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><ul>
<li>对于 C++ 来说，内存泄漏就是 new 出来的对象没有 delete，俗称野指针；</li>
<li>而对于 java 而言，就是存放在堆上的 Object 无法被 GC 正常回收；</li>
</ul>
<a id="more"></a>
<p>分析之前我们先来看看两个基础知识点。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="java-的内存分配简述"><a href="#java-的内存分配简述" class="headerlink" title="java 的内存分配简述"></a>java 的内存分配简述</h3><p>运行时数据区域内存模型图<br><img src="http://gityuan.com/images/jvm/jvm_memory_1.png" alt=""></p>
<ul>
<li>方法区（non-heap）：编译时就分配好，在程序<strong>整个运行期间都存在</strong>。它主要存放静态数据和常量；</li>
<li>栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；</li>
<li>堆区（heap）：通常用来存放 new 出来的对象。由 GC 负责回收。</li>
</ul>
<h3 id="四种不同类型的引用"><a href="#四种不同类型的引用" class="headerlink" title="四种不同类型的引用"></a>四种不同类型的引用</h3><p>GC 过程与对象的引用类型有着很大的联系，下面我们就看看 Java 中（Android 中存在差异）的四种引用： </p>
<ul>
<li>强引用（Strong Reference）:JVM 宁愿抛出 OOM，也不会让 GC 回收存在强引用的对象。</li>
<li>软引用（Soft Reference） ：只有内存不足时，才会被 GC 回收。 </li>
<li>弱引用（weak Reference）：在 GC 时，如果一个对象只存在弱引用，将会被回收 </li>
<li>虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为 GC 回收 Object 的标志。 </li>
</ul>
<p>与 Android 中的差异：<strong>在 2.3 以后版本中，即使内存够用，Android 系统会优先将 SoftReference 的对象提前回收掉</strong>, 其他和 Java 中是一样的。<br>因此谷歌官方建议用 LruCache(least recentlly use 最少最近使用算法)。会将内存控制在一定的大小内, 超出最大值时会自动回收, 这个最大值开发者自己定。</p>
<h2 id="内存泄漏的危害"><a href="#内存泄漏的危害" class="headerlink" title="内存泄漏的危害"></a>内存泄漏的危害</h2><p>内存泄露是内存溢出(OOM)的重要原因之一，会导致 Crash。<br>如果应用程序在消耗光了所有的可用堆空间，那么再试图在堆上分配新对象时就会引起 OOM(Out Of Memory Error)异常，此时应用程序就会崩溃退出。</p>
<h2 id="内存泄漏的典型案例"><a href="#内存泄漏的典型案例" class="headerlink" title="内存泄漏的典型案例"></a>内存泄漏的典型案例</h2><p>要想避免内存泄漏，首先要知道导致内存泄漏的原因。<br><strong>内存泄漏本质原因</strong>:==长生命周期的对象持有短生命周期对象的强/软引用。导致本应该被回收的短生命周期的对象无法被正常回收==。</p>
<p>这么讲可能比较抽象。举个常见的栗子：单例模式中，我们常常在获取单例对象时需要传一个 Context 。单例对象是一个长生命周期的对象（应用程序结束时才终结），而如果我们传递的是某一个 Activity 作为 context,那么这个 Activity 就会因为引用被持有而无法销毁，从而导致内存泄漏。</p>
<p>下面我们来看看导致内存泄漏的常见例子。</p>
<h3 id="永远的-Singleton"><a href="#永远的-Singleton" class="headerlink" title="永远的 Singleton"></a>永远的 Singleton</h3><p>单例的使用在我们的程序中随处可见，因为使用它可以解决我们在程序中重复创建对象的问题。但是<strong>由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏</strong>。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li>应该把传入的 Context 改为同应用生命周期一样长的 Application 中的 Context。</li>
<li>也可以通过重写 Application，提供 getContext 方法,那样就不需要在获取单例时传入 context。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext sContext;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        sContext = getApplicationContext();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getApplicationContext</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> sContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Handler-引发的内存泄漏"><a href="#Handler-引发的内存泄漏" class="headerlink" title="Handler 引发的内存泄漏"></a>Handler 引发的内存泄漏</h3><p>由于 Handler 属于 TLS（Thread Local Storage）变量，导致它的生命周期和 Activity 不一致。因此通过 Handler 来更新 UI 一般很难保证跟 View 或者 Activity 的生命周期一致，故很容易导致无法正确释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerBadActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler_bad);</div><div class="line">        <span class="comment">// 延迟 5min 发送一个消息</span></div><div class="line">        handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//do something</span></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>);</div><div class="line">        <span class="keyword">this</span>.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码中发送了了一个延时 5 分钟执行的 Message，当该 Activity 退出的时候，延时任务（Message）还在主线程的 MessageQueue 中等待，此时的 Message 持有 Handler 的强引用，并且由于 Handler 是 HandlerBadActivity 的<strong>非静态内部类，所以 Handler 会持有一个指向 HandlerBadActivity 的强引用</strong>，所以虽然此时 HandlerBadActivity 调用了 finish 也无法进行内存回收，造成内存泄漏。</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>将 Handler 声明为<strong>静态内部类</strong>，但是要注意如果用到 Context 等外部类的 非static 对象，还是应该使用 ApplicationContext 或者通过弱引用来持有这些外部对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class HandlerGoodActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private static final class MyHandler extends Handler&#123;</div><div class="line">        private final WeakReference&lt;HandlerGoodActivity&gt; mActivity;</div><div class="line">        public MyHandler(HandlerGoodActivity activity)&#123;</div><div class="line">            this.mActivity = new WeakReference&lt;HandlerGoodActivity&gt;(activity);//使用弱引用</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            super.handleMessage(msg);</div><div class="line">            HandlerGoodActivity activity = mActivity.get();</div><div class="line">            if (activity != null)&#123;</div><div class="line">                // do something</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private final MyHandler myHandler = new MyHandler(this);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler_good);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="慎用-static-成员变量"><a href="#慎用-static-成员变量" class="headerlink" title="慎用 static 成员变量"></a>慎用 static 成员变量</h3><p>从前面的介绍我们知道，static 修饰的变量位于内存的方法区，<strong>其生命周期与 App 的生命周期一致</strong>。<br>这必然会导致一系列问题，如果你的 app 进程设计上是长驻内存的，那即使 app 切到后台，这部分内存也不会被释放。</p>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>不要在类初始时初始化静态成员，也就是可以考虑懒加载。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p>
<p>当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/727790-afde094317e73842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同 Context 的应用场景"></p>
<p>说明： </p>
<ul>
<li>NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要==创建一个新的 task 任务队列==。</li>
<li>对于 Dialog 而言，只有在 Activity 中才能创建</li>
</ul>
<h3 id="远离非静态内部类和匿名类，有需要时请使用静态内部类"><a href="#远离非静态内部类和匿名类，有需要时请使用静态内部类" class="headerlink" title="远离非静态内部类和匿名类，有需要时请使用静态内部类"></a>远离非静态内部类和匿名类，有需要时请使用静态内部类</h3><p>为什么要怎么做呢?因为使用非静态内部类和匿名类都会默认持有外部类的引用，如果生命周期不一致，就会导致内存泄漏。</p>
<p>看一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class NestedClassLeakActivity extends AppCompatActivity &#123;</div><div class="line">    </div><div class="line">    class InnerClass &#123;//非静态内部类</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static InnerClass sInner;//指向非静态内部类的静态引用</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_nested_class);</div><div class="line">        if (sInner == null) &#123;</div><div class="line">           sInner = new InnerClass();//创建非静态内部类的实例</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本例中，因为非静态内部类默认会持有外部类的引用，而外部类中又有一个该非静态内部类的静态实例，该静态实例的生命周期和应用的一样长，而静态实例又持有 Activity 的引用，因此导致 Activity 的内存资源不能正常回收。</p>
<h4 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h4><ol>
<li>将该内部类设为静态内部类</li>
<li>也可以将该内部类抽取出来封装成一个单例</li>
</ol>
<h3 id="集合引发的内存泄漏"><a href="#集合引发的内存泄漏" class="headerlink" title="集合引发的内存泄漏"></a>集合引发的内存泄漏</h3><p>我们通常会把一些对象的引用加入到集合容器（比如ArrayList）中，当我们不再需要该对象时（通常会调用 remove 方法），并没有把它的引用从集合中清理掉（其中的一种情况就是 remove 方法没有将不再需要的引用赋值为 null），下面以 ArrayList 的 remove 方法为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">( <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 数组越界检查</span></div><div class="line">    RangeCheck(index);</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 取出要删除位置的元素，供返回使用</span></div><div class="line">    E oldValue = (E) elementData[index];</div><div class="line">   <span class="comment">// 计算数组要复制的数量</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">   <span class="comment">// 数组复制，就是将index之后的元素往前移动一个位置</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">       System. arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                      numMoved);</div><div class="line">   <span class="comment">// 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收</span></div><div class="line">    elementData[--size ] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>elementData[--size ] = null; // Let gc do its work</code> 如果替换为 <code>--size</code>，就会导致已经「移除」的对象因为强引用被集合持有，而无法正常被 gc 回收。</p>
<h3 id="WebView-引发的内存泄漏"><a href="#WebView-引发的内存泄漏" class="headerlink" title="WebView 引发的内存泄漏"></a>WebView 引发的内存泄漏</h3><p>WebView 解析网页时会申请<strong>Native堆内存</strong>用于保存页面元素，当页面较复杂时会有很大的内存占用。如果页面包含图片，内存占用会更严重。并且打开新页面时，为了能快速回退，<strong>之前页面占用的内存也不会释放</strong>。有时浏览十几个网页，都会占用几百兆的内存。这样加载网页较多时，会导致系统不堪重负，最终强制关闭应用，也就是出现应用闪退或重启。</p>
<p>由于占用的都是 <strong>Native 堆内存</strong>，所以<strong>实际占用的内存大小不会显示在常用的 DDMS Heap 工具中</strong>（ DMS Heap 工具看到的只是Java虚拟机分配的内存，即使Native堆内存已经占用了几百兆，这里显示的还只是几兆或十几兆）。只有使用 adb shell 中的一些命令比如 dumpsys meminfo 包名，或者在程序中使用 <code>Debug.getNativeHeapSize()</code> 才能看到 Native 堆内存信息。</p>
<p>据说由于 WebView 的一个 BUG，即使它所在的 Activity(或者Service) 结束也就是 onDestroy() 之后，或者直接调用 WebView.destroy()之后，它所占用这些内存也不会被释放。</p>
<h4 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h4><p>把使用了 WebView 的 Activity (或者 Service) 放在单独的进程里。</p>
<ul>
<li>系统在检测到应用占用内存过大有可能被系统干掉 </li>
<li>也可以在它所在的 Activity(或者 Service) 结束后，调用 <code>System.exit(0)</code>，主动Kill掉进程。由于系统的内存分配是以进程为准的，进程关闭后，系统会自动回收所有内存。</li>
</ul>
<p>使用 WebView 的页面（Activity），在生命周期结束页面退出（onDestory）的时候，主动调用<strong>WebView.onPause()==以及==WebView.destory()</strong>以便让系统释放 WebView 相关资源。</p>
<h3 id="其他常见的引起内存泄漏原因"><a href="#其他常见的引起内存泄漏原因" class="headerlink" title="其他常见的引起内存泄漏原因"></a>其他常见的引起内存泄漏原因</h3><ul>
<li>Android 3.0 以下，Bitmap 在不使用的时候没有使用 recycle() 释放内存。</li>
<li><strong>非静态内部类的静态实例</strong>容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。</li>
<li>警惕<strong>线程未终止造成的内存泄露</strong>；譬如在 Activity 中关联了一个生命周期超过 Activity 的 Thread，在退出 Activity 时切记结束线程。<ul>
<li>一个典型的例子就是 HandlerThread 的 run 方法。该方法在这里是一个死循环，它不会自己结束，线程的生命周期超过了 Activity 生命周期，我们必须手动在 Activity 的销毁方法中中调用 <code>thread.getLooper().quit()</code> 才不会泄露。</li>
</ul>
</li>
<li><strong>对象的注册与反注册没有成对出现</strong>造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。</li>
<li><strong>创建与关闭没有成对出现造成的泄露</strong>；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。</li>
<li>避免代码设计模式的错误造成内存泄露；譬如循环引用，A 持有 B，B 持有 C，C 持有 A，这样的设计谁都得不到释放。</li>
</ul>
<h2 id="内存泄漏的检测工具"><a href="#内存泄漏的检测工具" class="headerlink" title="内存泄漏的检测工具"></a>内存泄漏的检测工具</h2><ul>
<li>LeakCanary 是一个检查内存泄漏的优秀框架。具体用法可以参考 <a href="https://mp.weixin.qq.com/s/0bO5BZ4CMYJbRuY_xf_osw" target="_blank" rel="external">LeakCanary——如何检测 Activity 是否泄漏</a></li>
<li>使用 AS Monitor + MAT 自己分析内存泄漏原因。具体请移步 Google 或 Baidu</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/XILFalxJsbGJjx-ZOEDi7g" target="_blank" rel="external">Android 性能优化 详解内存优化的来龙去脉</a></li>
<li><a href="http://www.cnblogs.com/liushilin/p/5900089.html" target="_blank" rel="external">内存泄漏全解析，从此拒绝ANR，让OOM远离你的身边，跟内存泄漏say byebye</a></li>
<li><a href="https://goo-yao.github.io/2017/02/11/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/#more" target="_blank" rel="external">明白原理，轻松应对Android内存泄漏</a></li>
</ul>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的代理模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/18/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h2><p>代理模式也称为委托模式，为其他对象提供一种代理以控制对这个对象的访问。</p>
<h2 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h2><p>当无法或不想访问某个对象或者访问某个对象存在困难时可以<strong>通过一个代理对象来间接访问</strong>。</p>
<p>为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口（或继承相同的抽象类）</p>
<a id="more"></a>
<h2 id="代理模式的UML类图"><a href="#代理模式的UML类图" class="headerlink" title="代理模式的UML类图"></a>代理模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29449202-6aed8b00-842c-11e7-8e3f-362ead423f2d.png" alt="proxy uml"></p>
<p>角色介绍：</p>
<ul>
<li>Subject 抽象主题类<ul>
<li>主要职责是声明真实主题类与代理的共同接口方法，该类可以是一个抽象类也可以是一个接口</li>
</ul>
</li>
<li>RealSubject 真实主题类<ul>
<li>也称为被委托类或被代理理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。</li>
</ul>
</li>
<li>ProxySubject 代理类<ul>
<li>也称为委托类，持有一个对真实主题类的引用，在其实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。</li>
</ul>
</li>
<li>Client 使用代理类的类</li>
</ul>
<h2 id="代理模式的简单实现"><a href="#代理模式的简单实现" class="headerlink" title="代理模式的简单实现"></a>代理模式的简单实现</h2><p>代理模式大致可分为两大部分，<strong>静态代理和动态代理</strong>。</p>
<p><strong>动态代理</strong>通过反射机制动态地生成代理者的对象，code 阶段不需要知道代理谁，代理的真正对象会在执行阶段确定。</p>
<p>Java 提供一个便捷的动态代理接口 InvocationHandler，实现该接口需要重写其调用方法 invoke。</p>
<p>动态代理通过一个代理类来代理 N 多个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的的耦合关系。</p>
<h3 id="静态代理-vs-动态代理"><a href="#静态代理-vs-动态代理" class="headerlink" title="静态代理 vs 动态代理"></a>静态代理 vs 动态代理</h3><p>相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂。</p>
<ul>
<li>但是静态代理更符合面向对象的原则。</li>
</ul>
<p>实际开发中具体使用哪种方式来实现代理，看自己的偏好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>静态代理和动态代理是从 code 方面来区分代理模式的。</p>
<p>也可以<strong>从其使用范围来区分</strong>不同类型的代理实现：</p>
<ul>
<li><strong>远程代理</strong>（Remote Proxy）为某个对象<strong>在不同的内存地址空间</strong>提供局部代理。</li>
<li><strong>虚拟代理</strong>（Virtual Proxy）使用一个代理对象<strong>表示一个十分耗资源的对象并在真正需要时才创建</strong>。</li>
<li><strong>保护代理</strong>(Protection Proxy)：使用代理<strong>控制对原始对象的访问</strong>。该类型的代理常被<strong>用于原始对象具有不同访问权限</strong>的情况。</li>
<li>智能引用(Smart Reference)：在访问原始对象时执行一些自己的<strong>附加操作并对指向原始对象的引用计数</strong>。</li>
</ul>
<p>静动态代理都可以应用于上述 4 种情形。</p>
<h2 id="Android源码中的代理模式实现"><a href="#Android源码中的代理模式实现" class="headerlink" title="Android源码中的代理模式实现"></a>Android源码中的代理模式实现</h2><p>以 ActivityManager 为例。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29449446-6771e5ce-842d-11e7-935f-d1e5685d43af.png" alt="source code proxy"></p>
<ul>
<li>抽象接口: IActivityManager</li>
<li>代理类 ActivityManagerProxy</li>
<li>被代理类<ul>
<li>ActivityManagerNative(抽象类，并不处理太多的逻辑，大部分逻辑由其子类——ActivityManagerService 承担)</li>
<li>ActivityManagerService(真实部分)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>ActivityManagerService 是系统级的 Service 并且运行于独立的进程空间中，可以通过 ServiceManger 获取到它。</li>
<li>ActivityManagerProxy 运行于自己所处的进程空间中（也就是说，与 ActivityManagerService 运行在不同的进程中）</li>
<li>所以此处源码所实现的代理实质为==远程代理==。</li>
</ul>
<p>ActivityManagerProxy 在实际的逻辑处理并<strong>没有过多地被外部类</strong>使用，Android 中管理与维护 Activity 相关信息的类是另一个叫做 ActivityManager 的类。不过实质上 ActivityManager 大多数逻辑还是由 ActivityManagerProxy 承担。</p>
<p>以 ActivityManager 的 getAppTasks() 方法为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123;</div><div class="line">    ArrayList&lt;AppTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;AppTask&gt;();</div><div class="line">    List&lt;IAppTask&gt; appTasks;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());</div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> numAppTasks = appTasks.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAppTasks; i++) &#123;</div><div class="line">        tasks.add(<span class="keyword">new</span> AppTask(appTasks.get(i)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ActivityManagerNative.getDefault();</code>方法 返回一个 <code>IActivityManager</code> 类型的对象，通过该对象调用其 getAppTasks 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> gDefault.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gDefault 到底是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);<span class="comment">//获取 AMS</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        IActivityManager am = asInterface(b);<span class="comment">//完成创建一个 AMS 的客户端端代理对象—— ActivityManagerProxy</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">return</span> am;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述代码中构造了一个 <code>Singleton&lt;IActivityManager&gt;</code> 类型的 gDefault 对象，其中通过 <code>ServiceManager.getService(&quot;activity&quot;);</code> 获取一个系统级的 Service，而该 Service 实质上就是 AMS，接着调用 asInterface 方法，创建一个 ActivityManagerProxy 对象。</p>
<p>ActivityManagerNative.asInterface 方法的具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static public IActivityManager asInterface(IBinder obj) &#123;</div><div class="line">    if (obj == null) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);</div><div class="line">    if (in != null) &#123;</div><div class="line">        return in;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new ActivityManagerProxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ActivityManagerProxy 的 <code>getTasks</code> 方法，将数据打包跨进程传递给 Server 端的 AMS 处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.RunningTaskInfo&gt; getTasks(<span class="keyword">int</span> maxNum, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException &#123;</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        data.writeInt(maxNum);</div><div class="line">        data.writeInt(flags);</div><div class="line">        mRemote.transact(GET_TASKS_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        reply.readException();</div><div class="line">        ArrayList&lt;ActivityManager.RunningTaskInfo&gt; list = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> N = reply.readInt();</div><div class="line">        <span class="keyword">if</span> (N &gt;= <span class="number">0</span>) &#123;</div><div class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</div><div class="line">                ActivityManager.RunningTaskInfo info =</div><div class="line">                        ActivityManager.RunningTaskInfo.CREATOR</div><div class="line">                                .createFromParcel(reply);</div><div class="line">                list.add(info);</div><div class="line">                N--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        data.recycle();</div><div class="line">        reply.recycle();</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看看 AMS 中的 getTasks 方法的具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;IAppTask&gt; <span class="title">getAppTasks</span><span class="params">(String callingPackage)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> callingUid = Binder.getCallingUid();</div><div class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        ArrayList&lt;IAppTask&gt; list = <span class="keyword">new</span> ArrayList&lt;IAppTask&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"getAppTasks"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mRecentTasks.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                TaskRecord tr = mRecentTasks.get(i);</div><div class="line">                <span class="comment">// Skip tasks that do not match the caller.  We don't need to verify</span></div><div class="line">                <span class="comment">// callingPackage, because we are also limiting to callingUid and know</span></div><div class="line">                <span class="comment">// that will limit to the correct security sandbox.</span></div><div class="line">                <span class="keyword">if</span> (tr.effectiveUid != callingUid) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                Intent intent = tr.getBaseIntent();</div><div class="line">                <span class="keyword">if</span> (intent == <span class="keyword">null</span> ||</div><div class="line">                        !callingPackage.equals(intent.getComponent().getPackageName())) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                ActivityManager.RecentTaskInfo taskInfo =</div><div class="line">                        createRecentTaskInfoFromTaskRecord(tr);</div><div class="line">                AppTaskImpl taskImpl = <span class="keyword">new</span> AppTaskImpl(taskInfo.persistentId, callingUid);</div><div class="line">                list.add(taskImpl);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(ident);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Android-中的-Binder-跨进程通信机制与-AIDL"><a href="#Android-中的-Binder-跨进程通信机制与-AIDL" class="headerlink" title="Android 中的 Binder 跨进程通信机制与 AIDL"></a>Android 中的 Binder 跨进程通信机制与 AIDL</h2><p>四个重要类：</p>
<ul>
<li>Binder Client 类比 PC、终端设备</li>
<li>Binder Server 类比 服务器</li>
<li>Binder Driver（实现在内核中） 类比 路由器</li>
<li>Binder Manager 类比 DNS 服务器</li>
</ul>
<p>因为依赖于抽象，加上本地代理类的存在，所以调用远程方法时，还是与调用本地的普通的方法一样。但是代理类内部需要对参数什么的进行打包处理，然后再通过 Binder 机制，跨进程将数据传递给远程方法，远程方法执行完毕再返回数据。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29453380-021cc0ea-843c-11e7-901d-a7490d12f9ea.jpg" alt="binder 通信大致模型图"></p>
<p>Binder Driver 实现在内核中，主要负责 Binder 通信的建立，以及 Binder数据在进程间的传递和 Binder 引用计数管理/数据包的传输等。</p>
<p>Binder Client 和 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发，</p>
<ul>
<li>对于 Binder Client 而言，它只需要知道自己要使用的 Binder 的名字以及该 <strong>Binder 实体</strong>在 ServerManager 中的 0 号引用即可。<ul>
<li>访问原理：<ul>
<li>通过 0 号引用去访问 ServerManager <strong>获取该 Binder 的引用</strong>，</li>
<li>得到引用后就可以像普通方法调用那样调用 Binder 实体的方法</li>
</ul>
</li>
</ul>
</li>
<li>ServerManager 用来管理 Binder Server（Android 中通常是一个 Service）<ul>
<li>Binder Client 通过它来查询 Binder Server 的引用</li>
<li>ServerManager <strong>是一个标准的 Binder Server</strong>，并且在 Android 中约定其在 Binder 通信过程中的唯一标识（类似于 IP 地址）永远为 0。<ul>
<li>在 IServiceManager 接口中定义有对外开放的接口方法，供客户端访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong>匿名 Binder</strong>。很多时候 Binder Server 会将一个 Binder 实体封装进数据包传递给 Binder Client，而此时 Binder Server 会在该数据包中标注 Binder 实体的位置，Binder Driver 会为该匿名的 Binder 生成实体结点和实体引用，并将该引用传递给 Binder Client。</li>
</ul>
<p>IServiceManager 接口(声明 ServerManger 对外提供的方法、数据 )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IServiceManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">checkService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line"></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></div><div class="line">                <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> String[] listServices() <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPermissionController</span><span class="params">(IPermissionController controller)</span></span></div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String descriptor = <span class="string">"android.os.IServiceManager"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">4</span>;</div><div class="line">    <span class="keyword">int</span> SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Andorid 源码设计模式解析与实战》</p>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 LayoutInflater]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20LayoutInflater/</url>
      <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="系统服务的注册"><a href="#系统服务的注册" class="headerlink" title="系统服务的注册"></a>系统服务的注册</h2><p>什么时候初始化 ContextImpl？</p>
<p>ContextImpl 中有这样一个成员变量，缓存系统服务。<br><code>final Object[] mServiceCache = SystemServiceRegistry.createServiceCache();</code></p>
<p>在 <code>SystemServiceRegistry</code> 中的静态代码块中注册。注册方法如下所示。在 static 代码块中，会注册所有的系统服务。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Statically registers a system service with the context.</div><div class="line"> * This method must be called during static initialization only.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></div><div class="line">        ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</div><div class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</div><div class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以 <code>LAYOUT_INFLATER_SERVICE</code> 为例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">    <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">        &#125;&#125;);</div></pre></td></tr></table></figure></p>
<p><code>CachedServiceFetcher</code> 是一个实现了 <code>ServiceFetcher&lt;T&gt;</code> 接口的抽象类 </p>
<ul>
<li><code>createService</code> 为 <code>CachedServiceFetcher</code> 中的抽象方法，当初始化时会调用该方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Base interface for classes that fetch services.</div><div class="line"> * These objects must only be created during static initialization.</div><div class="line"> */</div><div class="line">static abstract interface ServiceFetcher&lt;T&gt; &#123;</div><div class="line">    T getService(ContextImpl ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;</div><div class="line">    private final int mCacheIndex;</div><div class="line"></div><div class="line">    public CachedServiceFetcher() &#123;</div><div class="line">        mCacheIndex = sServiceCacheSize++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public final T getService(ContextImpl ctx) &#123;</div><div class="line">        final Object[] cache = ctx.mServiceCache;</div><div class="line">        synchronized (cache) &#123;</div><div class="line">            // Fetch or create the service.</div><div class="line">            Object service = cache[mCacheIndex];</div><div class="line">            if (service == null) &#123;//使用了延时加载,第一次调用时才初始化，并将相应服务缓存起来。</div><div class="line">                service = createService(ctx);</div><div class="line">                cache[mCacheIndex] = service;</div><div class="line">            &#125;</div><div class="line">            return (T)service;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract T createService(ContextImpl ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="系统服务的获取"><a href="#系统服务的获取" class="headerlink" title="系统服务的获取"></a>系统服务的获取</h2><p>平时我们都是通过 <code>Context.getSystemService(&quot;服务名字&quot;)</code> 来获取服务。</p>
<p>具体为 ContextImpl 中的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Object getSystemService(String name) &#123;</div><div class="line">    return SystemServiceRegistry.getSystemService(this, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 getSystemService 的实际实现是在 <code>SystemServiceRegistry</code> 中的。</p>
<p><code>SystemServiceRegistry</code> 中有一个 <code>HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;</code> ，该 HashMap 以服务名称为 key，以服务相对应的 ServiceFetcher 作为 value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</div><div class="line">        new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</div></pre></td></tr></table></figure>
<p>具体的获取方法为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Gets a system service from a given context.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</div><div class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</div><div class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据服务名称去获取相应的 ServiceFetcher，</p>
<ul>
<li>如果 <code>ServiceFetcher</code> 不为空，则调用 <code>ServiceFetcher.getService</code> 方法获取相应服务的引用。<ul>
<li>如果是第一次调用会先创建，然后直接返回</li>
<li>否则直接返回缓存的值</li>
</ul>
</li>
<li>如果 <code>ServiceFetcher</code> 为空，则返回 null。</li>
</ul>
<h2 id="深入理解-LayoutInflater"><a href="#深入理解-LayoutInflater" class="headerlink" title="深入理解 LayoutInflater"></a>深入理解 LayoutInflater</h2><h2 id="LayoutInflater的创建"><a href="#LayoutInflater的创建" class="headerlink" title="LayoutInflater的创建"></a>LayoutInflater的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">    &#125;&#125;);</div></pre></td></tr></table></figure>
<p>可见实际实现为 <code>PhoneLayoutInflater</code>（继承了 LayoutInflater）</p>
<p>onCreateView 是其中最重要的方法。为什么说它重要，后面会提到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Override onCreateView to instantiate names that correspond to the</span></div><div class="line">    widgets known to the Widget factory. If we don't find a match,</div><div class="line">    call through to our super class.</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">//为系统内置的控件添加前缀。比如为 TextView 添加前缀，结果为 android.widget.TextView</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">    <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            View view = createView(name, prefix, attrs);</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> view;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            <span class="comment">// In this case we want to let the base class take a crack</span></div><div class="line">            <span class="comment">// at it.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="渲染过程解析"><a href="#渲染过程解析" class="headerlink" title="渲染过程解析"></a>渲染过程解析</h2><p>一般我们在渲染 ListView 或者 RecyclerView 中的列表时，都会调用 <code>inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code> 方法（有时也会使用两个参数的方法）。可以看到该方法内部会调用 <code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</div><div class="line">    return inflate(resource, root, root != null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    final Resources res = getContext().getResources();</div><div class="line">    //代码省略</div><div class="line">    //获取 xml 解析器</div><div class="line">    final XmlResourceParser parser = res.getLayout(resource);</div><div class="line">    try &#123;</div><div class="line">        return inflate(parser, root, attachToRoot);</div><div class="line">    &#125; finally &#123;</div><div class="line">        parser.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    synchronized (mConstructorArgs) &#123;</div><div class="line"></div><div class="line">        final Context inflaterContext = mContext;</div><div class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">        Context lastContext = (Context) mConstructorArgs[0];</div><div class="line">        mConstructorArgs[0] = inflaterContext;</div><div class="line">        //存储父视图</div><div class="line">        View result = root;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 查找根标签</div><div class="line">            int type;</div><div class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line">                // Empty</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String name = parser.getName();</div><div class="line">            if (TAG_MERGE.equals(name)) &#123;</div><div class="line">                //1. 解析 merge 标签</div><div class="line">                rInflate(parser, root, inflaterContext, attrs, false);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 2. 不是 merge 元素就直接解析布局中的视图</div><div class="line"> // Temp is the root view that was found in the xml</div><div class="line">                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                    ViewGroup.LayoutParams params = null;</div><div class="line"></div><div class="line">                    if (root != null) &#123;</div><div class="line">                        // 生成布局参数</div><div class="line">                        params = root.generateLayoutParams(attrs);</div><div class="line">                        if (!attachToRoot) &#123;</div><div class="line">                            //如果 attachToRoot 为 false，就给 temp 设置布局参数</div><div class="line">                            temp.setLayoutParams(params);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // 解析 temp 视图下的所有子 View</div><div class="line">                    rInflateChildren(parser, temp, attrs, true);</div><div class="line"></div><div class="line">                    // 如果 root 不为空并且 attachToRoot 为 true，那么将 temp 添加到 父视图中</div><div class="line">                    if (root != null &amp;&amp; attachToRoot) &#123;</div><div class="line">                        root.addView(temp, params);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    //如果 root 为空 或者 attachToRoot 为 false，返回 xml 中的 root，而不是父视图</div><div class="line">                    if (root == null || !attachToRoot) &#123;</div><div class="line">                        result = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的 inflate 方法主要有以下几步</p>
<ol>
<li>解析 xml 的根标签</li>
<li>如果根标签是 merge，调用 rInflate 进行解析，rInflate 会将 merge 标签下的所有子 View 直接添加到根标签中</li>
<li>如果标签是普通元素，调用 createFromTag </li>
<li>调用 rInflate 解析 temp 根元素下的所有子 View，并且将这些子 View 都添加到 temp 下</li>
<li>返回解析到的根视图。</li>
</ol>
<p>我们先从解析单个元素的 <code>createViewFromTag</code> 方法看起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</div><div class="line">        boolean ignoreThemeAttr) &#123;</div><div class="line">    if (name.equals(&quot;view&quot;)) &#123;</div><div class="line">        name = attrs.getAttributeValue(null, &quot;class&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Apply a theme wrapper, if allowed and one is specified.</div><div class="line">    if (!ignoreThemeAttr) &#123;</div><div class="line">        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</div><div class="line">        final int themeResId = ta.getResourceId(0, 0);</div><div class="line">        if (themeResId != 0) &#123;</div><div class="line">            context = new ContextThemeWrapper(context, themeResId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        View view;</div><div class="line">        //用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段</div><div class="line">        if (mFactory2 != null) &#123;</div><div class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125; else if (mFactory != null) &#123;</div><div class="line">            view = mFactory.onCreateView(name, context, attrs);</div><div class="line">        &#125; else &#123;</div><div class="line">            view = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null) &#123;</div><div class="line">            final Object lastContext = mConstructorArgs[0];</div><div class="line">            mConstructorArgs[0] = context;</div><div class="line">            try &#123;</div><div class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class="line">                    // 解析内置 View 控件</div><div class="line">                    view = onCreateView(parent, name, attrs);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // 解析自定义控件</div><div class="line">                    view = createView(name, null, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mConstructorArgs[0] = lastContext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line">    //代码省略</div></pre></td></tr></table></figure></p>
<p><strong>onCreateView 方法和 createView 方法有何不同</strong>？<br>前面的介绍中，我们有提到 LayoutInlflater 创建的实际类型为 <code>PhoneLayoutInlflater</code> ，PhoneLayoutInlflater 覆写了 onCreateView 方法，该方法就是在 View 的标签名前添加一个 <code>&quot;android.widget.&quot; 或 &quot;android.webkit.&quot; 或 &quot;android.app.&quot;</code>前缀。然后再传递给 createView 解析。</p>
<ul>
<li>也就是说<strong>内置 View 和自定义 View 最终都调用了 createView 进行解析</strong>。</li>
</ul>
<p><strong>为什么要这么设计呢</strong>？<br>这是为了方便开发者在 xml 文件中更方便使用系统内置的 View（只需要写 View 名称而不需要写完整的路径），如果是自定义控件或者第三方库，写完整路径。</p>
<p>createView 的具体实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//根据完整路径的类名通过反射机制构造 View 对象</div><div class="line">public final View createView(String name, String prefix, AttributeSet attrs)</div><div class="line">        throws ClassNotFoundException, InflateException &#123;</div><div class="line">    //从缓存中获取构造函数</div><div class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</div><div class="line">    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123;</div><div class="line">        constructor = null;</div><div class="line">        sConstructorMap.remove(name);</div><div class="line">    &#125;</div><div class="line">    Class&lt;? extends View&gt; clazz = null;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</div><div class="line"></div><div class="line">        // 缓存中找不到构造函数</div><div class="line">        if (constructor == null) &#123;</div><div class="line">            //如果前缀（prefix）不为空，构造完整路径，并且加载该类</div><div class="line">            clazz = mContext.getClassLoader().loadClass(</div><div class="line">                    prefix != null ? (prefix + name) : name).asSubclass(View.class);</div><div class="line">            //代码省略</div><div class="line">            //从 class 对象中获取构造函数</div><div class="line">            constructor = clazz.getConstructor(mConstructorSignature);</div><div class="line">            constructor.setAccessible(true);</div><div class="line">            sConstructorMap.put(name, constructor);</div><div class="line">        &#125; else &#123;</div><div class="line">            //代码省略</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Object[] args = mConstructorArgs;</div><div class="line">        args[1] = attrs;</div><div class="line">        //通过反射构造 View</div><div class="line">        final View view = constructor.newInstance(args);</div><div class="line">        if (view instanceof ViewStub) &#123;</div><div class="line">            // Use the same context when inflating ViewStub later.</div><div class="line">            final ViewStub viewStub = (ViewStub) view;</div><div class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));</div><div class="line">        &#125;</div><div class="line">        return view;</div><div class="line"></div><div class="line">    &#125; </div><div class="line">    //省略各种 catch、finally 代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>createView 方法中，如果控件名有前缀就先构造 View 的完整路径，并且将该类加载到虚拟机中</p>
<ul>
<li>然后获取该类的构造函数并缓存起来，再通过构造函数来创建该 View 的对象，</li>
<li>最后将 View 对象返回，这就是解析单个 View 的过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">void rInflate(XmlPullParser parser, View parent, Context context,</div><div class="line">        AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</div><div class="line">    //获取树的深度</div><div class="line">    final int depth = parser.getDepth();</div><div class="line">    int type;</div><div class="line">    //逐个元素解析</div><div class="line">    while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line"></div><div class="line">        if (type != XmlPullParser.START_TAG) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final String name = parser.getName();</div><div class="line">        </div><div class="line">        if (TAG_REQUEST_FOCUS.equals(name)) &#123;</div><div class="line">            parseRequestFocus(parser, parent);</div><div class="line">        &#125; else if (TAG_TAG.equals(name)) &#123;</div><div class="line">            parseViewTag(parser, parent, attrs);</div><div class="line">        &#125; else if (TAG_INCLUDE.equals(name)) &#123;//解析 include 标签</div><div class="line">            if (parser.getDepth() == 0) &#123;</div><div class="line">                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</div><div class="line">            &#125;</div><div class="line">            parseInclude(parser, context, parent, attrs);</div><div class="line">        &#125; else if (TAG_MERGE.equals(name)) &#123;解析 merge 标签</div><div class="line">            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            //根据元素名进行解析</div><div class="line">            final View view = createViewFromTag(parent, name, context, attrs);</div><div class="line">            final ViewGroup viewGroup = (ViewGroup) parent;</div><div class="line">            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div class="line">            //递归调用进行解析，即深度优先遍历</div><div class="line">            rInflateChildren(parser, view, attrs, true);</div><div class="line">            //将解析到的 View 添加到它的父视图中</div><div class="line">            viewGroup.addView(view, params);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (finishInflate) &#123;</div><div class="line">        parent.onFinishInflate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rInflate() 通过深度优先遍历来构造视图树。每解析到一个 View 元素就会递归调用 rInflate，直到这条路径下的最后一个元素，<br>然后在回溯过来将每个 View 元素添加到它们的 parent 中。</p>
<ul>
<li>通过 rInflate 的解析之后，整棵视图树就构建完毕。当调用了 Activity 的 onResume 之后，之前通过 setContentView 设置的内容就会出现在我们的视野中。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>渲染流程大致如下：</p>
<p>inflate 查找根标签</p>
<ul>
<li>如果是 merge，调用 rInflate</li>
<li>否则，调用 <code>createViewFromTag</code><ul>
<li>如果是系统内置控件（通过名称中是否含有「.」来判断），调用 <code>PhoneLayoutInflater.onCreateView()</code> 方法添加前缀，<ul>
<li>处理后将完整路径传给 <code>LayoutInflater.createView()</code> 方法</li>
</ul>
</li>
<li>否则，直接调用 <code>LayoutInflater.createView()</code> 进行解析。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Android 源码设计模式解析与实战》</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 中子线程真的不能更新UI吗？]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/16/Android%20%E4%B8%AD%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97/</url>
      <content type="html"><![CDATA[<h1 id="Android中子线程真的不能更新UI吗？"><a href="#Android中子线程真的不能更新UI吗？" class="headerlink" title="Android中子线程真的不能更新UI吗？"></a>Android中子线程真的不能更新UI吗？</h1><p>先说结论：Android 中子线程在满足一定的条件下可以更新 UI。</p>
<a id="more"></a>
<h2 id="一个栗子："><a href="#一个栗子：" class="headerlink" title="一个栗子："></a>一个栗子：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.btn1)</div><div class="line">    Button mBtn1;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                mBtn1.setText(<span class="string">"worker thread"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上在 onCreate 方法中新建一个线程对 mBtn1 进行了操作，成功从子线程更新了 ui。</p>
<p>但是如果让线程 sleep 一段时间（比如 300ms），<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        mBtn1.setText(<span class="string">"worker thread"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>那么就很可能会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</div><div class="line">    at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:4788)</div><div class="line">    at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:865)</div><div class="line">    at android.view.ViewGroup.invalidateChild(ViewGroup.java:4106)</div><div class="line">    at android.view.View.invalidate(View.java:10386)</div><div class="line">    at android.view.View.invalidate(View.java:10341)</div><div class="line">    at android.widget.TextView.checkForRelayout(TextView.java:6657)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3696)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3554)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3529)</div><div class="line">    at com.android.rdc.androidsamples.MainActivity$1.run(MainActivity.java:63)</div></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么会报这个错误呢？<br>从出错的堆栈信息中可以异常看到是 <code>ViewRootImpl.checkThread()</code> 方法中抛出的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void checkThread() &#123;</div><div class="line">    if (mThread != Thread.currentThread()) &#123;</div><div class="line">        throw new CalledFromWrongThreadException(</div><div class="line">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在访问UI的时候，ViewRootImpl会去检查当前是哪个线程访问的UI，如果不是主线程，那就会抛出异常：</p>
<p>分析到了这里，其实异常信息对我们帮助也不大了，它只告诉了我们子线程中访问UI在哪里抛出异常。 </p>
<p>而我们会思考：当访问UI时，ViewRootImpl 会调用 checkThread 方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，这是没问题的。但是为什么一开始在 MainActivity 的 onCreate 方法中创建一个子线程访问UI，程序还是正常能跑起来呢？<br>答案就是执行 onCreate 方法的那个时候 ViewRootImpl 还没创建，无法去检查当前线程。那么，ViewRootImpl 创建之前的，程序对 UI 的更新操作是如何进行的呢？这个问题我暂时还没有找出答案，希望有了解的同学能指导一下。</p>
<p>回过头看，抛异常的方法既然是 ViewRootImpl 中的方法，那首先应该去看看 ViewRootImpl 是在哪里、在什么时候被创建的。<br>在 AS 中对 ViewRootImpl 进行查找，发现唯一一个初始化了它的地方是 <code>WindowManagerGlobal.addView()</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void addView(View view, ViewGroup.LayoutParams params,</div><div class="line">        Display display, Window parentWindow) &#123;</div><div class="line">    //代码省略</div><div class="line">    root = new ViewRootImpl(view.getContext(), display);</div><div class="line"></div><div class="line">    view.setLayoutParams(wparams);</div><div class="line"></div><div class="line">    mViews.add(view);</div><div class="line">    mRoots.add(root);</div><div class="line">    mParams.add(wparams);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，该方法创建了一个 ViewRootImpl 并将它添加到一个列表中。</p>
<p>该方法又是什么被调用的呢？对 Window 和 WindowManager 有所了解的同学应该知道，Window 的添加过程。</p>
<p>先来看看 ActivityThread 中的 handleResumeActivity 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final void handleResumeActivity(IBinder token,</div><div class="line">            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</div><div class="line">    //代码省略</div><div class="line">    r = performResumeActivity(token, clearHide, reason);</div><div class="line">    //代码省略</div><div class="line">    </div><div class="line">    r.activity.mVisibleFromServer = true;</div><div class="line">    mNumVisibleActivities++;</div><div class="line">    if (r.activity.mVisibleFromClient) &#123;</div><div class="line">        r.activity.makeVisible();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法内部调用了 <code>performResumeActivity</code> 方法，看这个方法名可以揣测该方法最终会调用 Activity 的 onResume 方法，大致流程如下。</p>
<ul>
<li><code>ActivityThread.performResumeActivity</code>  ==》  <code>ActivityClientRecord.Activity.performResume();</code>  ==》 <code>Instrumentation.callActivityOnResume(this);</code> ==》 <code>Activity.onResume();</code></li>
</ul>
<p>回归正题。执行完 performResumeActivity 方法后，会执行 <code>r.activity.makeVisible()</code>，即调用 Activity 的 makeVisible() 。该方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void makeVisible() &#123;</div><div class="line">    if (!mWindowAdded) &#123;</div><div class="line">        ViewManager wm = getWindowManager();</div><div class="line">        wm.addView(mDecor, getWindow().getAttributes());</div><div class="line">        mWindowAdded = true;</div><div class="line">    &#125;</div><div class="line">    mDecor.setVisibility(View.VISIBLE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此处调用了 <code>WindowManager.addView()</code> 方法。而 WindowManger 是一个接口，它的具体实现为 WindowManagerImpl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</div><div class="line">    applyDefaultToken(params);</div><div class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 mGlobal 为 WindowManagerGlobal，也就是说调用了 <code>WindowManagerGlobal.addView()</code> 创建 ViewRootImpl</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>ViewRootImpl 的创建在 onResume 方法回调之后，而我们一开篇是在 onCreate 方法中创建了子线程并访问 UI，在那个时刻，ViewRootImpl 还没有创建，无法检测当前线程是否是 UI 线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了 300 毫秒后，程序就崩了。很明显 300 毫秒后 ViewRootImpl 已经创建了，可以执行 checkThread 方法检查当前线程。</p>
<p>开篇的例子中我们在 onCreate 方法中创建的子线程访问 UI 是一种极端的情况。实际开发中不会这么做。</p>
<p>下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答：</p>
<blockquote>
<p>子线程可以更新UI，但是需要创建子线程的根视图（RootView），并添加到 WindowManager，还要创建子线程的 Looper。以上条件都满足时，它可以修改它自己创建的根视图中的 UI。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/xyh269/article/details/52728861" target="_blank" rel="external">Android中子线程真的不能更新UI吗？</a></li>
<li><a href="http://blog.csdn.net/u010198148/article/details/51779567" target="_blank" rel="external">多线程学习之–真的不能在子线程里更新UI吗？</a></li>
<li><a href="https://www.zybuluo.com/natsumi/note/736165" target="_blank" rel="external">互联网笔记 Android中子线程真的不能更新UI吗？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的观察者模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/09/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="解决、解耦的钥匙——观察者模式"><a href="#解决、解耦的钥匙——观察者模式" class="headerlink" title="解决、解耦的钥匙——观察者模式"></a>解决、解耦的钥匙——观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式定义了对象间一种<strong>一对多</strong>的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>关联行为场景<ul>
<li>需要注意的是，关联行为是可拆分的，而不是“组合”关系</li>
</ul>
</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>
<a id="more"></a>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p>UML 类图如下所示：<br><img src="https://user-images.githubusercontent.com/16668676/29015194-a1c0db10-7b7f-11e7-99a0-437680f88188.png" alt="uml"></p>
<p>四个角色：</p>
<ul>
<li>Subject 抽象主题（抽象的被观察者）。把所有观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，提供接口供添加和删除观察者对象。</li>
<li>ConcreteSubject 具体主题（具体的被观察者）。将有关状态存入具体观察者对象，在具体主题的内部实现发生改变时，给所有注册过的观察者发出通知</li>
<li>Observer 抽象观察者。定义一个更新接口，用来接收主题更改时做出相应的操作（比如更新自身的状态）</li>
<li>ConcreteObserver 具体观察者（实现抽象观察者所定义的更新接口，以便在主题状态更改时更新自身的状态）</li>
</ul>
<h2 id="Android-ListView-的观察者模式"><a href="#Android-ListView-的观察者模式" class="headerlink" title="Android ListView 的观察者模式"></a>Android ListView 的观察者模式</h2><p>ListView 和 RecyclerView 在 Android 中都占据着很重要的地位。</p>
<p>使用这两个组件时，总免不了数据更新的情况：当要更新数据时我们通常都会调用 <code>Adapter.notifyDataSetChanged()</code>，这其中的原理又是怎么样的呢？</p>
<p>下面以 ListView 作为一个栗子，看看其中的具体实现是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void notifyDataSetChanged() &#123;</div><div class="line">    mDataSetObservable.notifyChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void notifyChanged() &#123;</div><div class="line">    synchronized(mObservers) &#123;</div><div class="line">        // since onChanged() is implemented by the app, it could do anything, including</div><div class="line">        // removing itself from &#123;@link mObservers&#125; - and that could cause problems if</div><div class="line">        // an iterator is used on the ArrayList &#123;@link mObservers&#125;.</div><div class="line">        // to avoid such problems, just march thru the list in the reverse order.</div><div class="line">        for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">            mObservers.get(i).onChanged();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>notifyDataSetChanged 方法会调用  <code>DataSetObservable.notifyChanged()</code> 方法,notifyChanged() 内部会遍历调用观察者的 onChanged() 方法。通知数据更新。</li>
<li>但是观察者又是什么时候注册的呢？</li>
</ul>
<p>以下为 setAdapter 的方法的具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setAdapter(ListAdapter adapter) &#123;</div><div class="line">    //如果 已经有 Adapter 存在，先解除注册</div><div class="line">    if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123;</div><div class="line">        mAdapter.unregisterDataSetObserver(mDataSetObserver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resetList();</div><div class="line">    mRecycler.clear();</div><div class="line"></div><div class="line">    if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123;</div><div class="line">        mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter);</div><div class="line">    &#125; else &#123;</div><div class="line">        mAdapter = adapter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mOldSelectedPosition = INVALID_POSITION;</div><div class="line">    mOldSelectedRowId = INVALID_ROW_ID;</div><div class="line"></div><div class="line">    // AbsListView#setAdapter will update choice mode states.</div><div class="line">    super.setAdapter(adapter);</div><div class="line"></div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = mAdapter.getCount();</div><div class="line">        checkFocus();</div><div class="line">        // 构建一个 AdapterDataSetObserver </div><div class="line">        mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">        mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者</div><div class="line"></div><div class="line">        mRecycler.setViewTypeCount(mAdapter.getViewTypeCount());</div><div class="line"></div><div class="line">        int position;</div><div class="line">        if (mStackFromBottom) &#123;</div><div class="line">            position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">        &#125; else &#123;</div><div class="line">            position = lookForSelectablePosition(0, true);</div><div class="line">        &#125;</div><div class="line">        setSelectedPositionInt(position);</div><div class="line">        setNextSelectedPositionInt(position);</div><div class="line"></div><div class="line">        if (mItemCount == 0) &#123;</div><div class="line">            // Nothing selected</div><div class="line">            checkSelectionChanged();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        mAreAllItemsSelectable = true;</div><div class="line">        checkFocus();</div><div class="line">        // Nothing selected</div><div class="line">        checkSelectionChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过源码可以看到，setAdapter 方法内部会构建一个 <code>AdapterDataSetObserver</code> ，然后注册为观察者。我们还可以看到注册的时候是通过 Adapter 来注册的。</p>
<p>Adapter 接口中声明了注册和解注册的方法签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface Adapter &#123;</div><div class="line">    /**</div><div class="line">     * Register an observer that is called when changes happen to the data used by this adapter.</div><div class="line">     *</div><div class="line">     * @param observer the object that gets notified when the data set changes.</div><div class="line">     */</div><div class="line">    void registerDataSetObserver(DataSetObserver observer);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Unregister an observer that has previously been registered with this</div><div class="line">     * adapter via &#123;@link #registerDataSetObserver&#125;.</div><div class="line">     *</div><div class="line">     * @param observer the object to unregister.</div><div class="line">     */</div><div class="line">    void unregisterDataSetObserver(DataSetObserver observer);</div><div class="line">    //代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 BaseAdapter 实现了 ListAdapter 接口，ListAdapter 接口又继承自 Adapter 接口。<br>BaseAdapter 中注册方法和解除注册方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void registerDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.registerObserver(observer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void unregisterDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.unregisterObserver(observer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseAdapter 中注册方法和解除注册方法的具体实现都是通过 mDataSetObservable 来完成的。查看一下 DataSetObservable 的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123;</div><div class="line">    public void notifyChanged() &#123;</div><div class="line">        synchronized(mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void notifyInvalidated() &#123;</div><div class="line">        synchronized (mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onInvalidated();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该类继承了 <code>android.database</code> 包下的 Observable 类，而 Observable 类中存有所有观察者的引用，以及注册和解注册方法。</p>
<p>ListView 中的 onChange 方法具体实现又是什么样的?</p>
<ul>
<li>还记得前面我们说 Observer 是如何注册的吗？注册时，我们构建的是 AdapterDataSetObserver。</li>
<li>该类是 AbsListView 的内部类。<ul>
<li>AbsListView.AdapterDataSetObserver 继承自 AdapterView<listadapter>.AdapterDataSetObserver </listadapter></li>
<li>onChange 方法的主要逻辑都在 AdapterDataSetObserver 中</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class AdapterDataSetObserver extends DataSetObserver &#123;</div><div class="line">    //代码省略 ...</div><div class="line">    @Override</div><div class="line">    public void onChanged() &#123;</div><div class="line">        mDataChanged = true;</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = getAdapter().getCount();</div><div class="line"></div><div class="line">        // Detect the case where a cursor that was previously invalidated has</div><div class="line">        // been repopulated with new data.</div><div class="line">        if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null</div><div class="line">                &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123;</div><div class="line">            AdapterView.this.onRestoreInstanceState(mInstanceState);</div><div class="line">            mInstanceState = null;</div><div class="line">        &#125; else &#123;</div><div class="line">            rememberSyncState();</div><div class="line">        &#125;</div><div class="line">        checkFocus();</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div><div class="line">    //代码省略 ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>onChange 方法中，会获取当前 Adapter 中的数据集的新数量，方法的最后调用 ListView 的 requestLayout() 方法重新进行布局。</p>
<p>从上面的分析中，我们可以看到</p>
<ul>
<li>AbsListView 是抽象的观察者</li>
<li>ListView 是具体的观察者</li>
<li>Adapter 接口是抽象的被观察者</li>
<li>BaseAdapter 是具体的被观察者，其内部实际上是通过 <code>android.database</code> 包下的 Observerable 来实现注册和监听的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>AdapterView 中有一个 AdapterDataSetObserver 内部类，</li>
<li>在 ListView 中设置 Adapter（即调用 ListView 的 setAdapter 方法）时，其内部会构建一个 AdapterDataSetObserver，并注册到 Adapter 中。可见该场景中 ListView 扮演一个观察者角色。</li>
<li>而 Adapter 中有一个数据集可观察者 DataSetObserable。即一个被观察者。</li>
<li>数据集发生变化时，开发者手动调用 Adapter.notifyDataSetChanged 方法，notifyDataSetChanged 会调用 <code>DataSetObserverable.notifyChanged()</code><ul>
<li>notifyChanged() 方法会遍历所有观察者，并调用观察者的 <code>onChanged</code> 方法，</li>
<li>onChanged 会获取 Adapter 中数据集的新数量，同时会调用 View.requestLayout 方法通知 ListView 更新布局，刷新用户界面。</li>
</ul>
</li>
</ul>
<p>虽然 RecyclerView 直接继承自 ViewGroup，而不是 AdapterView ，但是更新列表数据集方法的内部也是通过观察者模式来实现的。只是在其中多提供了单个数据或者指定范围数据更新等回调接口，供开发者使用。感兴趣的同学可以去看看 RecyclerView 中观察者模式的实现。</p>
<p>作者水平有限，疏漏之处，恳请指出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Android 源码设计模式解析与实战》 第十二章 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Toast 原理]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/07/28/Toast%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Toast.makeText(context,”msg”,Toast.Length_SHORT).show();`<br>我们都知道调用了这行代码，便会触发显示 Toast 信息，但是从调用开始到显示出来的具体过程是怎么样的，里面具体实现又是怎么样的呢？</p>
<a id="more"></a>
<p>在 Toast 内部有两类 IPC 过程。</p>
<ul>
<li>第一类： Toast 访问 NotificationManagerService</li>
<li>第二类：NotificationManagerService 回调 Toast 里的 TN 接口。</li>
</ul>
<p>Toast 属于系统 Window，它内部的视图由两种方式指定，一种是系统默认的样式，另一种是自定义一个 view 然后通过 setView 方法将 view 设置进去。<br>不管哪一种方式，它们都对应 Toast 的一个 View 类型的内部成员 mNextView。</p>
<p>Toast 提供 show 和 cancel 方法分别用于显示和隐藏 view，它们的内部都是一个 IPC 过程。</p>
<p>Toast 有定时取消功能，所以系统采用了 Handler（利用其中的 sendMessageDelayed() 方法）</p>
<p>Toast.show() 调用流程大致如下：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28705462-7393612a-73a2-11e7-92b0-5d0ebfb237f0.jpg" alt="toast show"></p>
<p>先来看看 Toast.makeText 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</div><div class="line">    Toast result = new Toast(context);//创建一个新的 Toast 对象</div><div class="line"></div><div class="line">    LayoutInflater inflate = (LayoutInflater)</div><div class="line">            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取 LayoutInflater</div><div class="line">    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); //渲染出系统默认的布局</div><div class="line">    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</div><div class="line">    tv.setText(text);//将我们的信息设置到 TextView 中去</div><div class="line">    </div><div class="line">    result.mNextView = v;//把 view 赋给 Toast 内部的View</div><div class="line">    result.mDuration = duration;//设置 toast 时长</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再瞧一瞧 Toast.show(); 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void show() &#123;</div><div class="line">    if (mNextView == null) &#123;//判断，如果没有设置 Toast 的 view，就抛出异常</div><div class="line">        throw new RuntimeException(&quot;setView must have been called&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INotificationManager service = getService();//获取 INotificationManager </div><div class="line">    String pkg = mContext.getOpPackageName();// 获取调用者的包名</div><div class="line">    TN tn = mTN;//给 TN 赋值</div><div class="line">    tn.mNextView = mNextView;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        service.enqueueToast(pkg, tn, mDuration);</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        // Empty</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面有几个地方看起来比较陌生 INotificationManager 是什么，TN 又是什么？</p>
<p>INotificationManager 的值是从 getService() 方法中得来的。我们先查看下 getService() 的内部实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static private INotificationManager getService() &#123;</div><div class="line">    if (sService != null) &#123;</div><div class="line">        return sService;</div><div class="line">    &#125;</div><div class="line">    sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;));</div><div class="line">    return sService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>了解 Binder 的同学应该一看便知道，这里用到了 Binder。</li>
<li>INotificationManager 的具体实现在 NotificationManagerService 中，简便起见，后续内容将 NotificationManagerService 称为 NMS。</li>
</ul>
<p>TN 又是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TN</span> <span class="keyword">extends</span> <span class="title">ITransientNotification</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable mHide = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            handleHide();</div><div class="line">            <span class="comment">// Don't do this in handleHide() because it is also invoked by handleShow()</span></div><div class="line">            mNextView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManager.LayoutParams mParams = <span class="keyword">new</span> WindowManager.LayoutParams();</div><div class="line">    <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            IBinder token = (IBinder) msg.obj;</div><div class="line">            handleShow(token);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mGravity;</div><div class="line">    <span class="keyword">int</span> mX, mY;</div><div class="line">    <span class="keyword">float</span> mHorizontalMargin;</div><div class="line">    <span class="keyword">float</span> mVerticalMargin;</div><div class="line"></div><div class="line"></div><div class="line">    View mView;</div><div class="line">    View mNextView;</div><div class="line">    <span class="keyword">int</span> mDuration;</div><div class="line"></div><div class="line">    WindowManager mWM;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SHORT_DURATION_TIMEOUT = <span class="number">5000</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LONG_DURATION_TIMEOUT = <span class="number">1000</span>;</div><div class="line"></div><div class="line">    TN() &#123;</div><div class="line">        <span class="comment">// XXX This should be changed to use a Dialog, with a Theme.Toast</span></div><div class="line">        <span class="comment">// defined that sets up the layout params appropriately.</span></div><div class="line">        <span class="keyword">final</span> WindowManager.LayoutParams params = mParams;</div><div class="line">        params.height = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.width = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.format = PixelFormat.TRANSLUCENT;</div><div class="line">        params.windowAnimations = com.android.internal.R.style.Animation_Toast;</div><div class="line">        params.type = WindowManager.LayoutParams.TYPE_TOAST;</div><div class="line">        params.setTitle(<span class="string">"Toast"</span>);</div><div class="line">        params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleShow into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"SHOW: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.obtainMessage(<span class="number">0</span>, windowToken).sendToTarget();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleHide into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HIDE: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.post(mHide);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE SHOW: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView</div><div class="line">                + <span class="string">" mNextView="</span> + mNextView);</div><div class="line">        <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">            <span class="comment">// remove the old view if necessary</span></div><div class="line">            handleHide();</div><div class="line">            mView = mNextView;</div><div class="line">            Context context = mView.getContext().getApplicationContext();</div><div class="line">            String packageName = mView.getContext().getOpPackageName();</div><div class="line">            <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</div><div class="line">                context = mView.getContext();</div><div class="line">            &#125;</div><div class="line">            mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">            <span class="comment">// We can resolve the Gravity here by using the Locale for getting</span></div><div class="line">            <span class="comment">// the layout direction</span></div><div class="line">            <span class="keyword">final</span> Configuration config = mView.getContext().getResources().getConfiguration();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</div><div class="line">            mParams.gravity = gravity;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</div><div class="line">                mParams.horizontalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</div><div class="line">                mParams.verticalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            mParams.x = mX;</div><div class="line">            mParams.y = mY;</div><div class="line">            mParams.verticalMargin = mVerticalMargin;</div><div class="line">            mParams.horizontalMargin = mHorizontalMargin;</div><div class="line">            mParams.packageName = packageName;</div><div class="line">            mParams.hideTimeoutMilliseconds = mDuration ==</div><div class="line">                Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</div><div class="line">            mParams.token = windowToken;</div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeView(mView);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"ADD! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.addView(mView, mParams);</div><div class="line">            trySendAccessibilityEvent();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trySendAccessibilityEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">        AccessibilityManager accessibilityManager =</div><div class="line">                AccessibilityManager.getInstance(mView.getContext());</div><div class="line">        <span class="keyword">if</span> (!accessibilityManager.isEnabled()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// treat toasts as notifications since they are used to</span></div><div class="line">        <span class="comment">// announce a transient piece of information to the user</span></div><div class="line">        AccessibilityEvent event = AccessibilityEvent.obtain(</div><div class="line">                AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);</div><div class="line">        event.setClassName(getClass().getName());</div><div class="line">        event.setPackageName(mView.getContext().getPackageName());</div><div class="line">        mView.dispatchPopulateAccessibilityEvent(event);</div><div class="line">        accessibilityManager.sendAccessibilityEvent(event);</div><div class="line">    &#125;        </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE HIDE: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView);</div><div class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// note: checking parent() just to make sure the view has</span></div><div class="line">            <span class="comment">// been added...  i have seen cases where we get here when</span></div><div class="line">            <span class="comment">// the view isn't yet added, so let's try not to crash.</span></div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeViewImmediate(mView);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TN 是 Toast 的一个私有的静态内部类，继承自 ITransientNotification.Stub </p>
<ul>
<li>也是用到了 Binder 机制。</li>
</ul>
<p>在回到 show 方法。该方法最后调用了 <code>service.enqueueToast(pkg, tn, mDuration);</code> 方法。我们到 NMS 看看该方法的主要实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueToast</span><span class="params">(String pkg, ITransientNotification callback, <span class="keyword">int</span> duration)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="comment">//....</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isSystemToast = isCallerSystem() || (<span class="string">"android"</span>.equals(pkg));<span class="comment">//是否是 android 系统的 toast</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPackageSuspended =</div><div class="line">            isPackageSuspendedForUser(pkg, Binder.getCallingUid());</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">synchronized</span> (mToastQueue) &#123;</div><div class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">        <span class="keyword">long</span> callingId = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ToastRecord record;</div><div class="line">            <span class="keyword">int</span> index = indexOfToastLocked(pkg, callback);<span class="comment">//根据包名和回调来获取的对应包名的 Toast 的在 mToastQueue 中的位置（如果有的话）</span></div><div class="line">            <span class="comment">//如果对应包名的 Toast 已经存在了，则直接在原位更新，不会把它排到队尾</span></div><div class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">                record = mToastQueue.get(index);</div><div class="line">                record.update(duration);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//限制非系统应用的数量（不能超过 50），防止 DOS 攻击同时也是为了解决内存泄漏问题</span></div><div class="line">                <span class="keyword">if</span> (!isSystemToast) &#123;</div><div class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = mToastQueue.size();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">                         <span class="keyword">final</span> ToastRecord r = mToastQueue.get(i);</div><div class="line">                         <span class="keyword">if</span> (r.pkg.equals(pkg)) &#123;</div><div class="line">                             count++;</div><div class="line">                             <span class="keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;</div><div class="line">                                 Slog.e(TAG, <span class="string">"Package has already posted "</span> + count</div><div class="line">                                        + <span class="string">" toasts. Not showing more. Package="</span> + pkg);</div><div class="line">                                 <span class="keyword">return</span>;</div><div class="line">                             &#125;</div><div class="line">                         &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Binder token = <span class="keyword">new</span> Binder();</div><div class="line">                mWindowManagerInternal.addWindowToken(token,</div><div class="line">                        WindowManager.LayoutParams.TYPE_TOAST);</div><div class="line">                record = <span class="keyword">new</span> ToastRecord(callingPid, pkg, callback, duration, token);<span class="comment">//将 Toast 包装为 ToastRecord</span></div><div class="line">                mToastQueue.add(record);<span class="comment">//加入 mToastQueue</span></div><div class="line">                index = mToastQueue.size() - <span class="number">1</span>;</div><div class="line">                keepProcessAliveIfNeededLocked(callingPid);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</div><div class="line">                showNextToastLocked();<span class="comment">//显示下一条 Toast</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(callingId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会将 Toast 请求封装为 ToastRecord 并将其添加进 mToastQueue 队列中。</p>
<ul>
<li>mToastQueue 是一个 ArrayList</li>
<li>注意：每个非系统应用最多只能有 50 个ToastRecord。如果超出了最大值，就会出错。<ul>
<li>这样做主要是为了 防止 DOS（Denial Of Service）</li>
</ul>
</li>
</ul>
<blockquote>
<p>拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
</blockquote>
<p>将 ToastRecord 加入队列之后， <code>enqueueToast</code> 还调用了 <code>showNextToastLocked();</code> 方法, 该方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void showNextToastLocked() &#123;</div><div class="line">    ToastRecord record = mToastQueue.get(0);</div><div class="line">    while (record != null) &#123;</div><div class="line">        if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback);</div><div class="line">        try &#123;</div><div class="line">            record.callback.show(record.token);//调用 record 对象中 callback 的 show 方法</div><div class="line">            scheduleTimeoutLocked(record); //超时提醒，控制显示时间</div><div class="line">            return;</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            //...代码省略</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 callBack 是什么？</p>
<ul>
<li>它是在 ToastRecord 中的，瞅瞅 ToastRecord 的构造方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ToastRecord(<span class="keyword">int</span> pid, String pkg, ITransientNotification callback, <span class="keyword">int</span> duration,</div><div class="line">            Binder token) &#123;</div><div class="line">    <span class="keyword">this</span>.pid = pid;</div><div class="line">    <span class="keyword">this</span>.pkg = pkg;</div><div class="line">    <span class="keyword">this</span>.callback = callback;</div><div class="line">    <span class="keyword">this</span>.duration = duration;</div><div class="line">    <span class="keyword">this</span>.token = token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在 enqueueToast 方法中，将 Toast 包装为 ToastRecord ，创建了 ToastRecord 对象。</p>
<ul>
<li><code>record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord</code> </li>
<li>callBack 是 enqueueToast 中的一个参数，我们的调用如下： <code>service.enqueueToast(pkg, tn, mDuration);</code> </li>
<li><p>没错，callBack 实际上就是前面讲到的 Toast 的内部类 TN。</p>
<ul>
<li>回到前面看看，TN 确实继承了 <code>ITransientNotification.Stub</code>。</li>
</ul>
</li>
<li><p>showNextToastLocked() 方法调用 callBack 的 show() 方法来显示 Toast。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void show(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</div><div class="line">    mHandler.obtainMessage(0, windowToken).sendToTarget();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final Handler mHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        IBinder token = (IBinder) msg.obj;</div><div class="line">        handleShow(token);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其具体实现又是在 handleShow(token);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">        <span class="comment">// 如果有必要的话，将还在显示的 toast 隐藏掉</span></div><div class="line">        handleHide();</div><div class="line">        mView = mNextView;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);<span class="comment">//获取 windowManager</span></div><div class="line">        <span class="comment">//省略代码，给布局参数赋值</span></div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.removeView(mView);</div><div class="line">        &#125;</div><div class="line">        mWM.addView(mView, mParams);</div><div class="line">        trySendAccessibilityEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码核心在于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);`</div><div class="line">`mWM.addView(mView, mParams);`</div></pre></td></tr></table></figure></p>
<p>将 Toast 的视图添加到 Window 中。 这样 View 就能顺利显示出来了。</p>
<p>你可能会问，为什么 TN 调用 show 方法要用到的 Handler ？</p>
<ul>
<li>因为该方法是被是被 NMS 以跨进程方式调用的，因此它们运行在 Binder 线程池中。为了将执行环境切换到 Toast 请求所在的线程，在它们内部使用了 Handler。</li>
</ul>
<p>那么时间到了 Toast 又是怎么样取消的呢？</p>
<ul>
<li><p>在令 Toast 显示方法调用过程中 我们也调用了 <code>scheduleTimeoutLocked(record);</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void scheduleTimeoutLocked(ToastRecord r)&#123;</div><div class="line">    mHandler.removeCallbacksAndMessages(r);</div><div class="line">    Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</div><div class="line">    long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;//设置 延迟时间</div><div class="line">    mHandler.sendMessageDelayed(m, delay);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SHORT_DELAY 为 2s</p>
</li>
<li>LONG_DELAY 为 3.5s</li>
</ul>
<p>scheduleTimeoutLocked 会发出消息给 hanlder,收到相应的信息后 handleMessage 方法会调用<code>handleTimeout((ToastRecord)msg.obj);</code>, 该方法又会调用 <code>cancelToastLocked(index);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelToastLocked</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    ToastRecord record = mToastQueue.get(index);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        record.callback.hide();<span class="comment">//</span></div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到隐藏 Toast 的实现也是在 TN 中的。与 handleShow 对应，有一个 handleHide 方法。<br>该方法会将 Toast 的视图从 Window 中移除。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            mWM.removeViewImmediate(mView);</div><div class="line">        &#125;</div><div class="line">        mView = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建型模式之单例模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/07/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、什么是单例模式？"><a href="#一、什么是单例模式？" class="headerlink" title="一、什么是单例模式？"></a>一、什么是单例模式？</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">wiki</a> 给出的定义如下：单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
<ul>
<li>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</li>
</ul>
<a id="more"></a>
<h2 id="二、为什么要使用单例模式？"><a href="#二、为什么要使用单例模式？" class="headerlink" title="二、为什么要使用单例模式？"></a>二、为什么要使用单例模式？</h2><ul>
<li>有一些对象的内存消耗比较大，创建多次会造成很大的资源开支。</li>
<li>方便配置。<ul>
<li>例如 网络请求经常要用到 cookie，如果使用 OkHttp 可以将其封装为一个单例工具类，内部使用 CookJar 对 cookie  进行管理，这样后续的请求就会方便很多。 </li>
</ul>
</li>
</ul>
<h2 id="三、单例模式的实现方式"><a href="#三、单例模式的实现方式" class="headerlink" title="三、单例模式的实现方式"></a>三、单例模式的实现方式</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton sInstance = new Singleton();</div><div class="line">    </div><div class="line">    private Singleton()&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明静态对象时就把它初始化。（因为饿，所以迫不及待先把它 new 出来）</p>
<h3 id="2-懒汉模式-26"><a href="#2-懒汉模式-26" class="headerlink" title="2. 懒汉模式 26"></a>2. 懒汉模式 26</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton sInstance;</div><div class="line"></div><div class="line">    private Singleton() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static synchronized Singleton getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            sInstance = new Singleton();</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>getInstance</code> 方法中添加了 <code>synchronized</code> 关键字，也就是 </p>
<ul>
<li>一个问题：即使 instance已经被初始化，之后的每次调用还是会 进行同步，这样会消耗不必要的资源</li>
</ul>
<p>懒汉单例模式的</p>
<ul>
<li>优点：单例只有在使用时才会被实例化，在一定程度上节约了资源。</li>
<li>缺点：第一次加载时需要及时地实例化，反应稍慢，最大的问题是：每次调用 都会进行同步，造成不必要的同步开销。</li>
</ul>
<h3 id="3-Double-CheckLock-DCL-实现单例"><a href="#3-Double-CheckLock-DCL-实现单例" class="headerlink" title="3. Double CheckLock ( DCL )实现单例"></a>3. Double CheckLock ( DCL )实现单例</h3><p>DCL 既能够在需要时才初始化实例，又能够保证线程安全，而且单例对象初始化后才调用 getInstance 不进行同步锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static Singleton getInstance()&#123;</div><div class="line">    if (sInstance == null)&#123;</div><div class="line">        synchronized (Singleton.class)&#123;</div><div class="line">            if (sInstance == null)&#123;</div><div class="line">                sInstance = new Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="为什么做双重校验呢？"><a href="#为什么做双重校验呢？" class="headerlink" title="为什么做双重校验呢？"></a>为什么做双重校验呢？</h4><p><code>sInstance = new Singleton();</code>这句代码会被编译成多条汇编指令，它大致做了 3 件事情</p>
<ol>
<li>给 Singleton 实例分配内存</li>
<li>调用 Singleton 的构造函数，初始化成员字段</li>
<li>将 sInstance 对象指向分配的内存空间</li>
</ol>
<p>但是由于 Java 编译器允许处理器乱序执行，以及 JDK 1.5 之前 JMM（Java Memory Model， Java 内存模型） 中cache、寄存器到主内存回写顺序的规定，<br>上面的 2 和 3 的顺序是无法保证的。 如果是 1-3-2，那么当 3 执行完，并且 2 还没有执行的话，被切换到到线程 B，这时 sInstance 已经非空（因为 3 已经被执行了嘛），若 此时线程 B 直接取走 sInstance使用时就会报错。</p>
<p>解决：JDK 1.5 之后，SUN 官方调整了 JVM，具体化了 volatile 关键字（禁止指令重排序）。 </p>
<ul>
<li>如果是在 JDK 1.5 之后，那么只需要把 sInstance 的定义 改为 <code>private volatile static Singleton sInstance;</code> 即可</li>
</ul>
<h3 id="4-静态内部类单例模式"><a href="#4-静态内部类单例模式" class="headerlink" title="4. 静态内部类单例模式"></a>4. 静态内部类单例模式</h3><p>DCL 在某些情况下会出现失效的问题。这个问题被称为双重检查锁定（DCL）失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static volatile Singleton;</div><div class="line">    private Singleton()&#123; &#125;</div><div class="line">    </div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return SingletonHolder.sInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        private static final Singleton sInstance = new Singleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次调用 Singleton 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 SingletonHolder 类，这种方式不仅能够确保线程安全，也能保证单例对象的唯一性。</p>
<p>所以这是推荐使用的单例模式实现方式</p>
<h3 id="5-枚举单例"><a href="#5-枚举单例" class="headerlink" title="5. 枚举单例"></a>5. 枚举单例</h3><p>对枚举不了解可以先看看<a href="https://www.ibm.com/developerworks/cn/java/j-lo-enum/" target="_blank" rel="external">枚举</a>这篇文章</p>
<p>写法简单是枚举单例 最大的优点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public enum Singleton&#123;</div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    //枚举内部可以定义成员；</div><div class="line">    private String mString;</div><div class="line">    //枚举内部可以定义方法；</div><div class="line">    public void doSth() &#123;</div><div class="line">        //do sth</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取对象：只需要 Singleton singleton = <code>Singleton.INSTANCE</code>;</p>
<p>枚举在 Java 中与普通的类是一样的，不仅能够有字段，还能定义自己的方法。<br>最重要的是<strong>默认枚举实例的创建是线程安全的</strong>，并且任何情况下它都是一个单例。</p>
<p>上述几种方式中，在一个情况下都会重新创建对象的情况，那就是<strong>反序列化</strong>。</p>
<p>即使构造函数是私有的，反序列化是依然可以通过特殊的途径去创建类的一个新的实例，相当于 调用该类的构造函数。</p>
<p>反序列化操作提供了一耳光很特别的<strong>钩子函数</strong>，类中具有一个私有的、被实例化的方法 <code>readResolve()</code>,这个方法可以让开发人员控制对象的反序列化。</p>
<p>上述几种单例方法中如果要杜绝单例对象在被反序列化时重新生成对象，那必须加入如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private Object readResolve() throws ObjectStreamException &#123;</div><div class="line">    return sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是在 readResolve 方法中将 sInstance 对象返回，而不是默认的重新生成一个新的对象。</p>
<p>而<strong>对于枚举</strong>，并不存在这个问题，因为<strong>即使反序列化也不会重新生成新的实例</strong>。</p>
<h3 id="6-使用容器实现单例模式"><a href="#6-使用容器实现单例模式" class="headerlink" title="6. 使用容器实现单例模式"></a>6. 使用容器实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; sObjectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!sObjectMap.containsKey(key)) &#123;</div><div class="line">            sObjectMap.put(key, instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sObjectMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类型注入到一个统一的管理类中，使用时格根据 key 获取对象对应类型的对象。</p>
<ul>
<li>这种实现方式主要是方便对单例对象进行统一管理。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>不管使用哪一种形式实现单例模式，核心原理都是==将构造函数私有化==，并且==通过静态方法获取唯一的的实例==。</li>
<li>在获取的过程中必须保证线程安全、<strong>防止反序列化导致重新生成实例对象</strong>等问题。</li>
</ul>
<h2 id="使用时的注意点"><a href="#使用时的注意点" class="headerlink" title="使用时的注意点"></a>使用时的注意点</h2><p>避免内存泄漏</p>
<ul>
<li>Android 开发中使用单例模式，如果获取单例对象需要使用 Context，那么尽量使用 ApplicationContext(只要用 <code>contxt.getApplicationContext()</code> 即可获取)。<br>因为如果使用其他 Context（如 Activity)  可能会造成 Activiity 生命周期 执行完成之后，因为其引用被单例所持有，而无法被回收。</li>
</ul>
<h2 id="Android源码中的单例模式"><a href="#Android源码中的单例模式" class="headerlink" title="Android源码中的单例模式"></a>Android源码中的单例模式</h2><p>经常会通过Context后去系统级别的服务，如 WindowManagerService、ActivityManagerService、LayoutInflater，这些服务会在合适的时候以单例的形式注册在系统。</p>
<p>需要时就通过调用  <code>context.getSystemService(String name)</code> 方法获取 </p>
<h1 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">wiki 单例模式</a></li>
<li><a href="">Android 源码设计模式 单例模式</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 消息机制解析]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>提起 Handler，相信大家都不会陌生，日常开发中不可避免地要使用到它。今天要讲的是消息机制。消息机制？咋听起来有点抽象。其实我们在使用 Handler 的时候，就使用了 Android 的消息机制。</p>
<p>从开发的角度来看，Handler 是 Android 消息机制的<strong>上层接口</strong>，这使得开发过程中只需要设计这方面的内容即可。但是作为一名合格的开发者，弄清它的实现原理是很有必要的。</p>
<ul>
<li>笔者水平有限，部分内容可能基于学习资源，当然也会有个人的一些见解加入其中。如有疏漏之处，恳请指教。</li>
</ul>
<a id="more"></a>
<h1 id="消息机制概述"><a href="#消息机制概述" class="headerlink" title="消息机制概述"></a>消息机制概述</h1><p>很多人认为 Handler 的作用就是更新 UI, 这种想法也没什么大问题，不过，更新 UI <strong>仅仅是 Handler 的一个特殊的使用场景</strong>。</p>
<p>我们都知道，Android 为了保持与用户交互的流畅性，不允许在主线程执行耗时操作（例如：网络请求），那我们就必须要新开一个线程去执行这些操作。任务执行完了怎么样才能更新 UI 呢？子线程是不允许更新 UI 的，这时就需要将更新的操作切换到主线程中执行。Android 中 Handler 就是这样的一个类。</p>
<p>看看官网的定义：</p>
<blockquote>
<p>A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it – from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.</p>
<p>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.</p>
</blockquote>
<p>大意如下：Handler 允许你在一个线程的消息队列上发送和处理 Message 对象 以及 Runnable 对象。每个 Handler 实例都与一个线程以及这个线程的消息队列相关联。当一个新的 Handler 对象的时候被创建的时候，它会与创建它的那个线程上的消息队列绑定。之后，这个 handler 会把 message 和 runnable 发送到该消息队列上，并且在 message 从消息队列中出列的时处理它们。</p>
<p>Handler 有两个主要用途：</p>
<ol>
<li>指定 message 和 Runnable 在将来的某个时刻执行。</li>
<li>让某一个操作转移到另一个线程执行。</li>
</ol>
<p>看到这么一大串文字这里你可能有点晕了。先看一张图吧。</p>
<p><img src="http://img.blog.csdn.net/20150801014511416" alt=""></p>
<p>Android 消息机制示意图（参考自<a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">网络</a>）</p>
<p>类比：</p>
<ul>
<li>Looper ==》 滚轮</li>
<li>MessageQueue ==》 流水线</li>
<li>Message ==&gt; 流水线上的产品</li>
<li>Handler ==》 扮演把『产品』送进流水线，完了以后又把『产品』取走的角色</li>
<li>Thread ==》 动力</li>
</ul>
<p>另外还有一个重要概念 ——ThreadLocal 图中没有标明出来。</p>
<p>下面对各个部分进行详细介绍。</p>
<h1 id="Android-的消息机制分析"><a href="#Android-的消息机制分析" class="headerlink" title="Android 的消息机制分析"></a>Android 的消息机制分析</h1><h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><p>ThreadLocal  是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>使用场景：</p>
<ol>
<li>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑采用 ThrradLocal。<ul>
<li>在Android中，Looper 类就是利用了 ThreadLocal 的特性，保证每个线程只存在一个 Looper 对象。</li>
</ul>
</li>
<li>复杂逻辑下的对象传递。<ul>
<li>监听器的传递。</li>
</ul>
</li>
</ol>
<p>要想弄清楚 ThreadLocal 首先要明白它的 set() 和 get() 方法</p>
<h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h3><p>ThreadLocal 的 set 方法，大致分为 3 步：</p>
<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
</ul>
<p>源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p>当不同线程访问同一个 ThreadLocal 的 get 方法时，ThreadLocal 内部会从各自的线程中取出一个数组，然后在从数组中根据当前 ThreadLocal 的索引去查找对应的 value 值。 不同线程中的数组是不同的。</p>
<p>下面是一个利用Thread对象作为句柄获取 ThreadLocalMap 对象的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码获取的实际上是Thread对象的threadLocals变量，可参考下面代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Thread implements Runnable &#123;</div><div class="line">    /* ThreadLocal values pertaining to this thread. This map is maintained</div><div class="line">     * by the ThreadLocal class. */</div><div class="line"></div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而如果一开始设置，即ThreadLocalMap对象未创建，则新建ThreadLocalMap对象，并设置初始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[==注==]：Android  最新版实现中 ThreadLocal 使用了内部实现的一个 HashMap 以提高优化性能与 Java 中 ThreadLocal 实现有些不同，但是其中的思想并没有太大差异，感兴趣的同学可以看看 Android 中 ThreadLocal 的源码。</p>
<h3 id="ThreadLocal-小结"><a href="#ThreadLocal-小结" class="headerlink" title="ThreadLocal 小结"></a>ThreadLocal 小结</h3><p>从 ThreadLocal 的 set 和 get 方法 可以看出，它们所操作的对象都是<strong>当前线程的 localValues 对象的 table 数组</strong>，因此在不同的线程中访问同一个 ThreadLocal 的 get 和 set 方法，他们对 ThreadLocal 所做的读/写操作仅限于各自线程的内部。</p>
<h2 id="消息队列的工作原理"><a href="#消息队列的工作原理" class="headerlink" title="消息队列的工作原理"></a>消息队列的工作原理</h2><p>MessageQueue 主要包含两个操作：插入和读取（分别对应 enqueueMessage 和 next 方法）。</p>
<ul>
<li>顾名思义，enqueueMessage 的作用是往队列中插入一条信息。</li>
<li>next 的作用是从队列中取出一条信息并将其从消息队列中移除。</li>
</ul>
<p>尽管叫做消息队列，但是它的内部实现并不是用队列，而是通过一个单链表的数据结构来维护消息列表。</p>
<ul>
<li>why？ 学过数据结构的童鞋们都知道，<strong>数组查快改慢，链表查慢改快</strong>，单链表在插入和删除上比较有优势。</li>
</ul>
<p>接下来我们重点看看 enqueueMessage 方法和 next 方法。</p>
<h3 id="enqueueMessage-方法："><a href="#enqueueMessage-方法：" class="headerlink" title="enqueueMessage 方法："></a>enqueueMessage 方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">    if (msg.target == null) &#123;</div><div class="line">        // 要进入队列的消息对象的目标 handler 不能为空</div><div class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">    &#125;</div><div class="line">    if (msg.isInUse()) &#123;</div><div class="line">        // 要进入队的消息不能处在使用状态</div><div class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">        if (mQuitting) &#123;</div><div class="line">            // 要进入队的消息不能发送到一个已经「死亡」的线程上的 Handler</div><div class="line">            IllegalStateException e = new IllegalStateException(</div><div class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        // 标记消息为使用状态；设置消息发送的时间；是否需要唤醒</div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        boolean needWake;</div><div class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">            // New head, wake up the event queue if blocked.</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; else &#123;</div><div class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class="line">            // up the event queue unless there is a barrier at the head of the queue</div><div class="line">            // and the message is the earliest asynchronous message in the queue.</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            for (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                if (p == null || when &lt; p.when) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; // invariant: p == prev.next</div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">        if (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中不难看出，enqueueMessaege 比较简单。它先做了一些状态判断以及一些边界检测，完了以后再进行单链表的插入操作。</p>
<h3 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h3><p><a href="https://gist.github.com/ivanljt/bc298eedb180e6ac67a9613814a4769f" target="_blank" rel="external">next 方法源码</a></p>
<p>部分逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// If first time idle, then get the number of idlers to run.</div><div class="line">// Idle handles only run if the queue is empty or if the first message</div><div class="line">// in the queue (possibly a barrier) is due to be handled in the future.</div><div class="line">if (pendingIdleHandlerCount &lt; 0</div><div class="line">        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</div><div class="line">    pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">&#125;</div><div class="line">if (pendingIdleHandlerCount &lt;= 0) &#123;</div><div class="line">    // No idle handlers to run.  Loop and wait some more.</div><div class="line">    mBlocked = true;</div><div class="line">    continue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由源码可以看出 next 是一个死循环方法</p>
<ul>
<li>如果消息队列中没有消息，那么 next 会一直阻塞在那里。<ul>
<li>当队首的消息设置了延迟执行时，会造成短时间的阻塞。</li>
</ul>
</li>
<li>当有新消息到来时，next 方法会返回这条信息并将其从单链表中移除。</li>
</ul>
<h2 id="Looper-的工作原理"><a href="#Looper-的工作原理" class="headerlink" title="Looper 的工作原理"></a>Looper 的工作原理</h2><p>Looper 可以看作是一个「死循环」。它会不断地从 MessageQueue 中查看是否有新消息</p>
<ul>
<li>如果有，就立刻处理。</li>
<li>如果没有，就一直阻塞在那里。</li>
</ul>
<blockquote>
<p>Looper 是一个用来为单个线程运行消息循环的类。<strong>默认情况下线程是没有一个 Looper 跟他们相关联的</strong>。如果一个线程需要一个 looper 的话，可以通过 调用 prepare() 方法来获取。然后调用 loop 方法让它开始处理信息，一直到循环结束。</p>
<p>我们通常通过 Handler 类与 Looper 的打交道</p>
</blockquote>
<p>Looper的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">    mQueue = new MessageQueue(quitAllowed);//创建一个消息队列</div><div class="line">    mThread = Thread.currentThread(); //把当前线程的对象保存起来</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到构造方法是私有的，那么 Handler 要怎么获取一个 Looper。？<br>通过 <code>Looper.prepare()</code>即可为当前线程创建一个 Looper 对象，接着通过 <code>Looper.loop()</code> 方法开启消息循环。</p>
<p>举个典型的栗子：一个的普通 Thread 如何获得 Looper？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new Thread(&quot;OrdinaryThread&quot;)&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        Looper.prepare();</div><div class="line">        Handler handler = new Handler();</div><div class="line">        Looper.loop();</div><div class="line">    &#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure></p>
<p>除了 <code>Looper.prepare()</code> 还有别的创建方法吗？<br>我们知道主线程（ActivityThread）是比较特殊的，Looper 给它开了小灶，专门为它提供一个 prepareMainLooper() 方法来创建 Looper。</p>
<p>我们更新 UI 的操作都需要在主线程上进行，如果有个方法可以获取主线程的 Looper 就好了。Android 系统很人性化地提供了这么一个方法——<code>Looper.getMainLooper</code>。</p>
<p>只要有了主线程的 Looper，我们就可以利用 Handler 的一个构造方法创建一个依赖于主线程的 Handler，等任务完成之后调用 Handler 的 sendMessage 或者 post 方法来更新 UI 了。</p>
<p>一个应用的小栗子；</p>
<ul>
<li>在封装的一个网络请求类中，保存一个主线程的上 Handler 当请求结果返回时，就可以通过这个 Handler 来对 UI 进行更新。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public class OkHttpUtil &#123;</div><div class="line"></div><div class="line">    private static final String TAG = &quot;OkHttpUtil&quot;;</div><div class="line">    private volatile static OkHttpUtil sInstance;</div><div class="line">    private OkHttpClient mOkHttpClient;</div><div class="line">    private String mCookie;</div><div class="line">    private Handler mMainHandler;</div><div class="line"></div><div class="line">    public interface OkHttpCallBack &#123;</div><div class="line">        void onSuccess(Bundle data);</div><div class="line">        void onError(Exception e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private OkHttpUtil(Context context) &#123;</div><div class="line">        mMainHandler = new Handler(Looper.getMainLooper());</div><div class="line">        mOkHttpClient = new OkHttpClient.Builder()</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static OkHttpUtil getInstance(Context context) &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (OkHttpUtil.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new OkHttpUtil(context);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void get(String url, final OkHttpCallBack callBack) &#123;</div><div class="line">        final Request request = new Request.Builder()</div><div class="line">                .url(url)</div><div class="line">                .build();</div><div class="line"></div><div class="line">        if (mCookie != null) &#123;</div><div class="line">            request.newBuilder().addHeader(&quot;Cookie&quot;, mCookie);</div><div class="line">        &#125;</div><div class="line">        mOkHttpClient.newCall(request).enqueue(new Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void onFailure(final Call call, final IOException e) &#123;</div><div class="line">                mMainHandler.post(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        callBack.onError(e);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onResponse(Call call, final Response response) throws IOException &#123;</div><div class="line">                String cookie = response.header(&quot;Set-Cookie&quot;);</div><div class="line">                if (cookie != null) &#123;</div><div class="line">                    setCookie(cookie);</div><div class="line">                &#125;</div><div class="line">                mMainHandler.post(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        Bundle bundle = new Bundle();</div><div class="line">                        bundle.putString(&quot;responseMsg&quot;,&quot;success&quot;);</div><div class="line">                        callBack.onSuccess(bundle);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>刚刚说 Looper 是一个死循环，其实是不严谨的。Looper 也是可以退出的。通过调用 Looper 的 quit 方法或者 quitSafely 方法即可。那么这二者有什么区别？</p>
<ul>
<li>调用 Looper 的 quit 方法可以<strong>直接退出</strong>Looper。</li>
<li>调用 Looper 的 quitSafely 方法只是设定了一个<strong>退出标记</strong>，然后把消息队列中<strong>已有的消息处理完才退出</strong> Looper。</li>
</ul>
<p>从 MessageQueue 的 enqueueMessage 方法可以看到，Looper 退出后，通过 Handler 发送的消息会失败，此时 Handler 的 send 方法会返回 false。</p>
<p><strong>注意！</strong>：在子线程中，如果手动为其创建了 Looper，那么在所有的任务完成之后，需要调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待状态。</p>
<h3 id="loop-方法"><a href="#loop-方法" class="headerlink" title="loop 方法"></a>loop 方法</h3><p><a href="https://gist.github.com/ivanljt/41c14e7c251c9811895b2e292d81cb44" target="_blank" rel="external">loop 方法源码</a></p>
<p>由源码可见 loop 方法是一个死循环，唯一跳出循环的方式是 MessageQueue 的 next 方法返回了 null。</p>
<p>当我们调用 Looper 的 quit 方法时，Looper 会 调用 MessageQueue 的 quit 或 quitSafely 方法来通知消息队列退出，否则 loop 方法会一直循环下去。</p>
<p>另外，代码中可以看到，loop 调用了 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 方法会一直阻塞在那里，这也导致了 loop 方法一直阻塞在那里。</p>
<p><code>msg.target.dispatchMessage(msg);</code>// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 <strong>Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理</strong>了。</p>
<p>绕了这么一个大圈意义何在？<br><strong>Handler 的 dispatchMessage 方法是在创建 Handler 时所使用的 Looper 中执行的，这样就顺利地将代码切换到指定的线程中去执行了</strong>。</p>
<h2 id="Handler-的工作原理"><a href="#Handler-的工作原理" class="headerlink" title="Handler 的工作原理"></a>Handler 的工作原理</h2><p>系统之所以提供 Handler，主要是为了<strong>解决在子线程无法访问 UI 的矛盾</strong>。</p>
<p>那什么系统不允许在子线程访问 UI 呢？因为负责更新 UI 的主线程是线程不安全的（可以简单地理解为没有加同步锁）。</p>
<p>你可能会问那为什么系统不对 UI 控件的访问加上锁机制呢？</p>
<ul>
<li>如果增加了锁机制会有以下的缺点：<ul>
<li>加上锁机制会让 UI 访问的逻辑变得复杂。</li>
<li>锁机制会降低 UI 访问的效率，因为锁机制会阻塞某些线程的执行。</li>
</ul>
</li>
<li>所以，也是一种取舍。整体而言加锁的弊大于利。</li>
</ul>
<p>Handler 的工作主要包含<strong>消息的发送</strong>和<strong>接收</strong>过程。  </p>
<ul>
<li>消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。<ul>
<li>post 系列方法最终是通过 send 的一系列方法来实现的。</li>
</ul>
</li>
</ul>
<p>查看源码不难发现，Handler 的发送消息的过程仅仅是向消息队列插入了一条消息，MessageQueue 的 next 方法就会返回这条消息给 Looper， Looper 收到消息之后就开始处理了，最终由 Looper 交回给 Handler处理（即 handler 的 dispatchMessage 方法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是开头那张图片。把前面的『消息机制概述』重新浏览一遍，说不定有新收获哦。<img src="http://img.blog.csdn.net/20150801014511416" alt=""></p>
<h2 id="学习资源推荐"><a href="#学习资源推荐" class="headerlink" title="学习资源推荐:"></a>学习资源推荐:</h2><ul>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">理解 Java 中的 ThreadLocal </a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47115879" target="_blank" rel="external">Android 中 Handler 的使用</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">深入源码解析 Android 中的 Handler,Message,MessageQueue,Looper</a></li>
<li>《<a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android 开发艺术探索》 (第十章 Android 的消息机制)</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
