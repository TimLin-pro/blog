<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[拆轮子系列之OkHttp(一)]]></title>
    <url>%2Fblog%2F2017%2F11%2F16%2F%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E4%B9%8BOkHttp-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[概述一款优秀的 HTTP 框架（可用于 Java 和 Android），它 支持 get 请求和 post 请求， 支持基于 Http 的文件上传和下载， 支持加载图片， 支持下载文件透明的 GZIP 压缩， 支持响应缓存避免重复的网络请求， 支持使用连接池来降低响应延迟问题。 预备知识有些网站的登录验证并不会返回网页，直接在 cookie 中生成 id 区分是否登录成功，并且会造成 302 重定位死循环。 解决办法当然是禁止自动跳转，百度各种无解然后翻 api 发现了这个：mOkHttpClient.setFollowRedirects(followRedirects); 怎么发送请求？配置 Request 类 GETrequest 设置好之后，直接调用 client.newCall(Request).execute() ??, 会返回结果对象 Response 类12public boolean isSuccessful()返回 true 如果状态码在 [200,300) response.body() 返回 ResponseBody 类。 可以方便的获取 string 123public final String string() throws IOExceptionReturns the response as a string decoded with the charset of the Content-Type header. If that header is either absent or lacks a charset, this will attempt to decode the response body as UTF-8. Throws:IOException 当然也能获取到流的形式：public final InputStream byteStream() POSTPOST 提交键值对OkHttp 也可以通过 POST 方式把键值对数据传送到服务器 怎么进行对结果进行处理 Synchronous Get（同步 Get）下载一个文件，打印他的响应头，以 string 形式打印响应体。 12响应体的 string()方法对于小文档来说十分方便、高效。但是如果响应体太大（超过 1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。对于超过 1MB 的响应 body，应使用流的方式来处理 body。 OkHttp前言是一个高效的 Http 客户端，有如下特点： 支持 HTTP2/SPDY 协议 socket 自动选择最佳路线、支持自动重连 拥有自动维护的 socket 连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有 Interceptors 轻松请求与响应（比如透明 GZIP 压缩、LOGGING） 基于 Headers 的缓存策略 主要对象 Connections: 对 JDK 中的物理 socket 进行了引用计数封装，用来控制 socket 连接 Streams: 维护 HTTP 的流，用来对 Requset/Response 进行 IO 操作 Calls: HTTP 请求任务封装 StreamAllocation: 用来控制 Connections/Streams 的资源分配与释放 四大核心类： OkHttpClient、 Request、 Call Response。 为什么说他好呢？与普通的 HttpUrlConnection 有什么区别？ 请求需要外部给的数据： url param 指定请求方式一般为 GET/POST 前三者都封装在 Request 中。 日常使用也只会关注这三个点。 但是网络框架的价值在于其内部的对请求的调度方式，策略什么的。 如果某次请求失败了，那么如何重新请求？（多少次、多少） 如果某次请求超时，重新请求是怎么做的？ OkHttpClient在绝大多数的 App 中，我们只应该执行一次 new OkHttpClient()，将其作为全局的实例进行保存，从而在 App 的各处都只使用这一个实例对象，这样 所有的 HTTP 请求都可以共用 Response 缓存、 共用线程池 共用连接池。 可以配置 OkHttpClient 的一些参数，比如超时时间、缓存目录、代理、Authenticator 等，那么就需要用到内部类 OkHttpClient.Builder，设置如下所示 123456OkHttpClient client = new OkHttpClient.Builder(). readTimeout(30, TimeUnit.SECONDS). cache(cache). proxy(proxy). authenticator(authenticator). build(); 有时候我们想单独给某个网络请求设置特别的几个参数，比如只想让某个请求的超时时间设置为一分钟，但是还想保持 OkHttpClient 对象中的其他的参数设置，那么可以调用 OkHttpClient 对象的 newBuilder()方法。 使用 newBuilder ，覆盖上自己想要修改的参数，然后 build() 新返回一个对象（该对象的参数（指那些未覆盖过的）与原来 OhHttpCilent 的参数相同） 1234OkHttpClient client = ...OkHttpClient clientWith60sTimeout = client.newBuilder(). readTimeout(60, TimeUnit.SECONDS). build(); 默认构造方法 123public OkHttpClient() &#123; this(new Builder());&#125; Builder 的默认构造方法 12345678910111213141516171819202122public Builder() &#123; dispatcher = new Dispatcher();//分发器 protocols = DEFAULT_PROTOCOLS;//默认的协议 Http 1.1/2.0 connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); cookieJar = CookieJar.NO_COOKIES;//Cookie socketFactory = SocketFactory.getDefault();//默认的 Socket 工厂 hostnameVerifier = OkHostnameVerifier.INSTANCE;//主机名验证？ certificatePinner = CertificatePinner.DEFAULT;// proxyAuthenticator = Authenticator.NONE;//授权代理 authenticator = Authenticator.NONE;//授权者 connectionPool = new ConnectionPool();//连接池 dns = Dns.SYSTEM;//DNS followSslRedirects = true;//跟随 ssl 重定向 followRedirects = true;//跟随重定向 retryOnConnectionFailure = true;//失败重新连接 connectTimeout = 10_000;//连接超时 readTimeout = 10_000;//读超时 writeTimeout = 10_000;//写超时 pingInterval = 0;//&#125; 2.Requestpost 请求需要先使用 MultiPartBody、FormBody 构造请求体。 二者有什么区别？ Request 类封装了请求报文信息： 请求的 Url 地址、请求的方法（如 GET、POST 等）、 各种请求头（如 Content-Type、Cookie） 可选的请求体。 一般通过内部类Request.Builder的链式调用生成 Request 对象。 Request#Builder 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static class Builder &#123; HttpUrl url;//url String method;//请求方法 Headers.Builder headers;//请求头 RequestBody body;//请求体 Object tag;//标签 //代码省略 public Builder() &#123; this.method = "GET";//默认使用 get 请求方法 this.headers = new Headers.Builder(); &#125; //get 方法 public Builder get() &#123; return method("GET", null); &#125; //head 方法 public Builder head() &#123; return method("HEAD", null); &#125; //post 方法 public Builder post(RequestBody body) &#123; return method("POST", body); &#125; //delete 方法 public Builder delete(@Nullable RequestBody body) &#123; return method("DELETE", body); &#125; //delete 方法 public Builder delete() &#123; return delete(Util.EMPTY_REQUEST); &#125; //put 方法 public Builder put(RequestBody body) &#123; return method("PUT", body); &#125; public Builder patch(RequestBody body) &#123; return method("PATCH", body); &#125; public Builder method(String method, @Nullable RequestBody body) &#123; if (method == null) throw new NullPointerException("method == null");//方法名为空 if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");//方法名为空串 if (body != null &amp;&amp; !HttpMethod.permitsRequestBody(method)) &#123;//对应的方法不能有请求体 throw new IllegalArgumentException("method " + method + " must not have a request body."); &#125; if (body == null &amp;&amp; HttpMethod.requiresRequestBody(method)) &#123;//对应的请求方法必须要有请求体 throw new IllegalArgumentException("method " + method + " must have a request body."); &#125; this.method = method; this.body = body; return this; &#125;&#125; Request#Builder#headers 该方法会移除所在 builder 的所有 headers 1234567891011/** Removes all headers on this builder and adds &#123;@code headers&#125;. */public Builder headers(Headers headers) &#123; this.headers = headers.newBuilder(); return this;&#125;//build 方法，创建一个 Requestpublic Request build() &#123; if (url == null) throw new IllegalStateException("url == null");//如果 url 为空则抛出异常 return new Request(this);&#125; 3. CallCall 代表一个实际的 HTTP 请求，它是连接 Request 和 Response 的桥梁，通过 Request 对象的 newCall 方法可以得到一个 Call 对象。 Call 对象既支持同步获取数据，也支持异步获取数据。 执行 Call 对象的 execute() 方法，会阻塞当前线程去获取数据（也就是同步获取数据），该方法返回一个 Response 对象。 执行 Call 对象的 enqueue() 方法，不会阻塞当前线程（也就是异步获取数据），该方法接收一个 CallBack 对象作为参数。 如果请求成功，则执行 CallBack 对象的 onResponse 方法。 如果请求失败，则执行 CallBack 对象的 onFailure 方法。 RealCallCall 的一个具体实现类 123456private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; this.client = client;//OkHttpClient this.originalRequest = originalRequest;//请求 this.forWebSocket = forWebSocket;//? this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);&#125; 同步请求——execute12345678910111213141516171819public Response execute() throws IOException &#123; synchronized (this) &#123;//如果已经执行过，则抛出异常 if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace();//捕获调用栈。其中具体实现是怎么样的？ eventListener.callStart(this);//开始监听，每一个 Call 仅调用该方法一次 try &#123; client.dispatcher().executed(this);//调用 Dispatcher 的 executed 方法 Response result = getResponseWithInterceptorChain();//根据拦截链获取结果 if (result == null) throw new IOException("Canceled"); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this);//请求完成，将 call 移出队列 &#125;&#125; 1234/** Used by &#123;@code Call#execute&#125; to signal completion. */void finished(RealCall call) &#123; finished(runningSyncCalls, call, false);//因为是同步请求方法，所以 promoteCalls 参数置为 false&#125; 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls();//如果允许 promoteCalls ，则调用 promoteCalls() 方法，执行就绪队列中的任务 runningCallsCount = runningCallsCount();//运行回调总数 idleCallback = this.idleCallback;//延迟/闲置回调 &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 异步请求 client.newCall(request).enqueue(new Callback() {}） RealCall#enqueue 12345678910@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));//将回调包装在 AsyncCall 中，并入队列&#125; 根据生产者消费者模型的理论，当入队请求时，如果满足 if (runningAsyncCalls.size() &lt; 64 &amp;&amp; runningCallsForHost(call) &lt; 5)，那么直接把 AsyncCall 添加到 runningAsyncCalls 队列中，并在线程中执行。如果消费者缓存满了，就放入 readyAsyncCalls 进行缓存等待。 当任务执行完成后,调用finished的promoteCalls()函数，手动移动缓存区也就是 readyAsyncCalls 队列（可以看出这里是主动清理的，因此不会发生死锁 ？？？） Dispatcher#enqueue 123456789synchronized void enqueue(AsyncCall call) &#123; //当前请求数 if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call);//执行 &#125; else &#123; readyAsyncCalls.add(call);// &#125;&#125; RealCall.AsyncCall#execute 123456789101112131415161718192021222324@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain();//从拦截链中获取结果 if (retryAndFollowUpInterceptor.isCanceled()) &#123;// signalledCallback = true; //这里回调是在线程池中 responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response);//回调 onResponse &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e);//回调 onFailure &#125; &#125; finally &#123; client.dispatcher().finished(this);//调用 finish 方法，将该请求移出队列，调用 promoteCalls 方法 &#125;&#125; Dispatcher#finished(RealCall.AsyncCall) 1234/** Used by &#123;@code AsyncCall#run&#125; to signal completion. */void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true);&#125; 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123;//同步 if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; Dispatcher#promoteCalls 12345678910111213141516private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // 当前请求数 &gt;= 允许的最大请求数 if (readyAsyncCalls.isEmpty()) return; // 就绪队列为空，没有 call 需要请求 for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;//遍历异步任务就绪队列 AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call);//将任务添加到「运行中队列」 executorService().execute(call);//执行任务 &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // 达到请求数，退出循环，返回 &#125;&#125; 主动的把缓存队列向前走了一步，premoteCalls 中没有获取锁是因为在 finished 中已经获取了 Dispatcher 的对象锁了 Summary通过上述的分析，我们知道了： OkHttp 采用 Dispatcher 技术，类似于 Nginx，与线程池配合实现了高并发，低阻塞的运行 Okhttp 采用 Deque 作为缓存，按照入队的顺序先进先出 Dispatcher维护了如下变量，用于控制并发的请求 123456789101112131415private int maxRequests = 64;private int maxRequestsPerHost = 5;private @Nullable Runnable idleCallback;/** Executes calls. Created lazily. */private @Nullable ExecutorService executorService;/** Ready async calls in the order they'll be run. */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();///** Running asynchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); maxRequest 64 maxRequestHost 5，每台主机的最大请求数为 5 Dispatcher 分发者（即，生产者）默认在主线程 AsyncCall 队列中需要处理的 Runnable（包装了异步回调接口） ExecutorService 线程池（消费者池） Deque readyAsyncCalls 就绪异步请求 Deque runningAsyncCalls 运行中的异步请求 Deque runningSyncCalls 运行中的同步请求 ExecutorService1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService;&#125; 创建一个线程数在 [0,Integer.MAX_VALUE) 之间的线程池，不保留最小线程数，不设上限的最大线程数。随时创建更多的线程。当线程空闲时只能活 60 秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。 在 RxJava 的Schedulers.io()中，也有类似的设计，只不过是线程池的池，最小的线程数量控制，不设上限的最大线程，以保证 I/O 任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析 RxJava 中 4 种不同场景的 Schedulers ThreadPoolExecutor#executejava.util.concurrent. ThreadPoolExecutor#execute 线程池的执行方法 123456789101112131415161718192021222324252627282930313233343536373839public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command);&#125; 拦截链 12345678910111213141516171819Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache()));//缓存拦截器 interceptors.add(new ConnectInterceptor(client));//连接拦截器 if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket));// Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis());//创建拦截链 return chain.proceed(originalRequest);&#125; RealInterceptorChain#proceed 依次调用上述拦截器的拦截方法。 Q1: 为什么要有这样一个拦截链？a ：实现起来符合认知？有时候数据可以直接从缓存中获取，那么拦截链到此为止。有点像事件分发机制啊？ Q2：拦截链中的拦截器顺序是怎么样的？a：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection);&#125;public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must retain the same host and port"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException("network interceptor " + interceptors.get(index - 1) + " must call proceed() exactly once"); &#125; //调用拦截链中的下一个拦截器 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index);//获取拦截器 Response response = interceptor.intercept(next);//获取拦截结果 // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException("network interceptor " + interceptor + " must call proceed() exactly once"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException("interceptor " + interceptor + " returned null"); &#125; if (response.body() == null) &#123; throw new IllegalStateException( "interceptor " + interceptor + " returned a response with no body"); &#125; return response;&#125; Response封装了响应报文的信息： 状态码 响应头 可选的响应体 可通过 Call 对象的 execute() 方法获得 Response 对象或者 异步回调执行 CallBack 对象的 onResponse 方法 通过 Response 对象的 isSuccessful() 方法可以判断请求是否成功。通过 Response 的 headers() 方法可以得到响应头 Headers 对象，可以通过 for 循环索引遍历所有的响应头的名称和值。可以通过 Headers.name(index) 方法获取响应头的名称，通过 Headers.value(index) 方法获取响应头的值。 访问百度首页，可以看到有 7 个 Set-Cookie 的响应头 为了解决同时获取==多个 name 相同的响应头的值==，Headers 中提供了一个 public List&lt;String&gt; values(String name)方法，该方法会返回一个 List&lt;String&gt; 对象，所以此处通过 Headers 对象的 values(‘Set-Cookie’) 可以获取全部的 Cookie 信息，如果调用 Headers 对象的 get(‘Set-Cookie’) 方法，那么只会获取最后一条 Cookie 信息。 12345678910111213141516171819202122232425262728293031public final class Response implements Closeable &#123; final Request request;//请求 final Protocol protocol;//协议 final int code;//响应码 final String message;//相应信息 final @Nullable Handshake handshake;//握手 final Headers headers;//响应头 final @Nullable ResponseBody body;//响应体 final @Nullable Response networkResponse;//网络响应 final @Nullable Response cacheResponse;//缓存响应 final @Nullable Response priorResponse;//优先响应？ final long sentRequestAtMillis;//该请求发送的时间 final long receivedResponseAtMillis;//接收到响应的时间 private volatile CacheControl cacheControl; // 缓存控制，懒加载 Response(Builder builder) &#123; this.request = builder.request; this.protocol = builder.protocol; this.code = builder.code; this.message = builder.message; this.handshake = builder.handshake; this.headers = builder.headers.build(); this.body = builder.body; this.networkResponse = builder.networkResponse; this.cacheResponse = builder.cacheResponse; this.priorResponse = builder.priorResponse; this.sentRequestAtMillis = builder.sentRequestAtMillis; this.receivedResponseAtMillis = builder.receivedResponseAtMillis; &#125;&#125; ResponseBody通过 Response 的 body()方法可以得到响应体 ResponseBody，==响应体必须最终要被关闭，否则会导致资源泄露、App 运行变慢甚至崩溃==。 ResponseBody 和 Response 都实现了 Closeable 和 AutoCloseable 接口，它们都有 close()方法，Response 的 close()方法内部直接调用了 ResponseBody 的 close()方法，无论是同步调用 execute()还是异步回调 onResponse()，最终都==需要关闭响应体==。 可以通过如下方法关闭响应体： 1234567Response.close()Response.body().close()Response.body().source().close()Response.body().charStream().close()Response.body().byteString().close()Response.body().bytes()Response.body().string() 复用连接池连接池的使用与分析首先先说下源码中关键的对象： Call: 对 http 的请求封装，属于程序员能够接触的上层高级代码 Connection: 对 jdk 的 socket 物理连接的包装，它内部有List&lt;WeakReference&lt;StreamAllocation&gt;&gt;的引用 StreamAllocation: 表示 Connection 被上层高级代码的引用次数 ConnectionPool: Socket 连接池，对连接缓存进行回收与管理，与 CommonPool 有类似的设计 Deque: Deque 也就是双端队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，这个是 java 基础 在 okhttp 中，连接池对用户，甚至开发者都是透明的。它自动创建连接池，自动进行泄漏连接回收，自动帮你管理线程池，提供了 put/get/clear 的接口，甚至内部调用都帮你写好了。自动管理。 缓存策略以上内容是作为一个服务器开发或者客户端的常识，下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。 代码与其他网络请求框架、方式对比HttpURLConnectionHttpURLConnection 是一种多用途、轻量极的 HTTP 客户端，使用它来进行 HTTP 操作可以适用于大多数的应用程序。虽然 HttpURLConnection 的 API 提供的比较简单，但是同时这也使得我们可以更加容易地去使用和扩展它。从 Android 4.4 开始 HttpURLConnection 的底层实现采用的是 okHttp。 android-async-http与 volley 一样是异步网络库，但 volley 是封装的 httpUrlConnection，它是封装的 httpClient，而 android 平台不推荐用 HttpClient 了，所以这个库已经不适合 android 平台了。 VolleyVolley 是一个简单的异步 http 库，仅此而已。 缺点是不支持同步，这点会限制开发模式。自带缓存，支持自定义请求。不适合大文件上传和下载。 Volley 在 Android 2.3 及以上版本，使用的是 HttpURLConnection，而在 Android 2.2 及以下版本，使用的是 HttpClient。Volle y 自己的定位是轻量级网络交互，适合大量的，小数据传输。 不过再怎么封装 Volley 在功能拓展性上始终无法与 OkHttp 相比。Volley 停止了更新，而 OkHttp 得到了官方的认可，并在不断优化。 RetrofitRetrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。这里并没有说它是网络请求框架，主要原因在于==网络请求的工作并不是 Retrofit 来完成的==。它所做的只是一层封装而已。 Retrofit 2.0 开始内置 OkHttp，前者专注于接口的封装，后者专注于网络请求的高效。 参考资料与学习资源推荐 OkHttp3 源码分析[综述] OkHttp3 源码分析[复用连接池] OkHttp3 源码分析[缓存策略] OkHttp3 源码分析[DiskLruCache] OkHttp3 源码分析[任务队列]]]></content>
      <categories>
        <category>源码解析</category>
        <category>框架原理</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>框架原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆轮子系列——EventBus源码解析]]></title>
    <url>%2Fblog%2F2017%2F10%2F14%2F%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>源码分析</category>
        <category>拆轮子</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>拆轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆轮子系列——ButterKnife工作原理]]></title>
    <url>%2Fblog%2F2017%2F10%2F07%2F%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ButterKnife%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概要本篇博客主要包括以下三个部分 日常使用 ButterKnife 的方式以及 ButterKnife 的 bind 方法 Xxx_ViewBinding 类是如何生成的？ 注解处理器是怎么注册的？ 其中的代码基于 ButterKnife 8.6.0 本文假设你已经对注解有所了解。不了解注解的同学可以先看看这篇文章 ，我们主要关注编译期注解。 运行期 ButterKnife#bind我们通常都是通过以下方式使用 ButterKnife 的。将要绑定的控件加上 @BindView 注解，在 onCreate 方法 完成 setContentView(R.layout.activity_main); 之后。调用 ButterKnife.bind(this); 对相应的 View 进行初始化。 123456789101112131415public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; @BindView(R.id.btn) Button mBtn; @BindView(R.id.radar_view) RadarView mRadarView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this);//ButterKnife 的入口 &#125;&#125; public static Unbinder bind(@NonNull Activity target) ，在 Activity 中以该方法作为入口，首先获取 与 Activity 相关联的 window，然后再通过 window 获取 DecorView。最后通过 createBinding 方法创建相关绑定。 1234public static Unbinder bind(@NonNull Activity target) &#123; View sourceView = target.getWindow().getDecorView(); return createBinding(target, sourceView);&#125; 1234567891011121314private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123; Class&lt;?&gt; targetClass = target.getClass(); if (debug) Log.d(TAG, "Looking up binding for " + targetClass.getName()); Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);//查找目标类的构造器 if (constructor == null) &#123; return Unbinder.EMPTY; &#125; try &#123; return constructor.newInstance(target, source);//利用反射创建一个实例，这里实际上调用了 Xxx_ViewBinding 的构造方法，也是有使用到反射 &#125; //代码省略&#125; 12345678910111213141516171819202122232425static final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();//LinkedHashMap 作为缓存容器@Nullable @CheckResult @UiThreadprivate static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123; Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);//先从缓存中查找 if (bindingCtor != null) &#123; return bindingCtor;//缓存命中直接返回 &#125; String clsName = cls.getName();//获取类型 //如果是 FrameWork 层的类，则直接返回 null if (clsName.startsWith("android.") || clsName.startsWith("java.")) &#123; return null; &#125; try &#123; Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding");//加载类 //noinspection unchecked bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);//获取构造器 &#125; catch (ClassNotFoundException e) &#123; bindingCtor = findBindingConstructorForClass(cls.getSuperclass());//递归查找父类的构造器 &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException("Unable to find binding constructor for " + clsName, e); &#125; BINDINGS.put(cls, bindingCtor);//加入到缓存中 return bindingCtor;//返回构造器&#125; 以下为编译器生成的 MainActivity_ViewBinding 类，该类在构造方法中对 MainActivity 中相应的类进行了初始化。 12345678910111213141516171819202122232425262728293031public class MainActivity_ViewBinding implements Unbinder &#123; private MainActivity target;//目标类 private View view2131427444; private View view2131427442; private View view2131427443; @UiThread public MainActivity_ViewBinding(MainActivity target) &#123; this(target, target.getWindow().getDecorView()); &#125; @UiThread public MainActivity_ViewBinding(final MainActivity target, View source) &#123; this.target = target; View view; view = Utils.findRequiredView(source, R.id.btn, "field 'mBtn' and method 'onViewClicked'");//findViewbyId target.mBtn = Utils.castView(view, R.id.btn, "field 'mBtn'", Button.class); view2131427444 = view;//强制类型转换 view.setOnClickListener(new DebouncingOnClickListener() &#123;//注册监听器 @Override public void doClick(View p0) &#123; target.onViewClicked(p0); &#125; &#125;); target.mRadarView = Utils.findRequiredViewAsType(source, R.id.radar_view, "field 'mRadarView'", RadarView.class);//findViewbyId &#125; 这里插一个小话题：通常我们都会把不需要被外部使用到的成员变量声明为 private 的，但是回头看看我们使用 @BindView的 View 访问权限均为 defalut 。为什么呢？从 MainActivity_ViewBinding 的构造方法中可以看到对 View 进行初始化时直接使用了 target.mBtn、 target.mRadarView，如果声明为 private ，那就需要通过反射才能访问到对应的 View，这样会有性能上的损失。 小结在运行时以 ButterKnife#bind 方法作为入口，首先以目标 class 为 key 到缓存（一个 LinkedHashMap）中查找相应的 binding class，如果命中直接返回。如果没有缓存，则通过类加载器加载对应的 Xxx_ViewBinding 类，然后返回。最后调用 Xxx_ViewBinding 类的构造器创建一个实例。Xxx_ViewBinding 类的构造器中对 View 进行了绑定。比如 findViewById，setOnClickListener 编译期生成代码Q：前面提到的 MainActivity_ViewBinding 类是如何生成的呢？ Answer: 通过编译时对 Annotation 进行解析。 1) 编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，由编译器自动解析。需要做的a. 自定义类继承自 AbstractProcessorb. 重写其中的 process 函数c. 注册注解处理器。注册完成后，编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理 自定义 Annotation 用于存储元数据以 BindView 注解为例 12345@Retention(CLASS) @Target(FIELD)public @interface BindView &#123; /** View ID to which the field will be bound. */ @IdRes int value();&#125; @Retention(CLASS) ：表示保留到编译期 @Target(FIELD)：表示作用域为成员变量 ButterKnifeProcessorButterKnifeProcessor 继承自 AbstractProcessor ，AbstractProcessor 的主要源码如下，我们主要关注四个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class AbstractProcessor implements Processor &#123; protected ProcessingEnvironment processingEnv; private boolean initialized = false; protected AbstractProcessor() &#123;//默认构造器 &#125; //获取支持的注解类型 public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; SupportedAnnotationTypes var1 = (SupportedAnnotationTypes)this.getClass().getAnnotation(SupportedAnnotationTypes.class);//获取支持的注解类型 if(var1 == null) &#123; if(this.isInitialized()) &#123;//如果已经初始化了，打印提醒 this.processingEnv.getMessager().printMessage(Kind.WARNING, "No SupportedAnnotationTypes annotation found on " + this.getClass().getName() + ", returning an empty set."); &#125; return Collections.emptySet();//返回空集 &#125; else &#123; return arrayToSet(var1.value());//返回支持的注解集合 &#125; &#125; public SourceVersion getSupportedSourceVersion() &#123;//获取支持的源码版本 SupportedSourceVersion var1 = (SupportedSourceVersion)this.getClass().getAnnotation(SupportedSourceVersion.class);//支持的源码版本 SourceVersion var2 = null; if(var1 == null) &#123; var2 = SourceVersion.RELEASE_6; if(this.isInitialized()) &#123; this.processingEnv.getMessager().printMessage(Kind.WARNING, "No SupportedSourceVersion annotation found on " + this.getClass().getName() + ", returning " + var2 + "."); &#125; &#125; else &#123; var2 = var1.value(); &#125; return var2; &#125; public synchronized void init(ProcessingEnvironment var1) &#123; if(this.initialized) &#123; throw new IllegalStateException("Cannot call init more than once."); &#125; else &#123; Objects.requireNonNull(var1, "Tool provided null ProcessingEnvironment"); this.processingEnv = var1; this.initialized = true; &#125; &#125; public abstract boolean process(Set&lt;? extends TypeElement&gt; var1, RoundEnvironment var2);&#125; init(ProcessingEnvironment env)：每个注解处理器都必须有个空的构造方法。不过，有一个特殊的 init 方法，它会被注解处理器工具传入一个 ProcessingEnvironment 作为参数来调用。ProcessingEnvironment 提供了一些有用的工具类，如 Elements，Types 和 Filter。我们后面会用到它们。 process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)：这个方法可以看做每个处理器的 main 方法。你要在这里写下你的扫描，判断和处理注解的代码，并生成 java 文件。通过传入的 RoundEnvironment 参数，你可以查询被某个特定注解注解的元素，我们稍后会看到。 getSupportedAnnotationTypes( )：这里你需要说明这个处理器需要针对哪些注解来注册。注意返回类型是一个字符串的 Set，包含了你要用这个处理器处理的注解类型的全名 getSupportedSourceVersion( )：用于指定你使用的 java 版本。通常会选择返回SourceVersion.latestSupported( )。当然，你也可以指定具体 java 版本：比如return SourceVersion.RELEASE_7; ButterKnife 的解析工作就是通过 ButterKnife#process 方法实现的。 123456789101112131415161718192021private Filer filer;//成员变量@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);//扫描并解析目标类 //遍历获取到的注解 for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk);//使用 javaPoet 生成 java 文件 try &#123; javaFile.writeTo(filer);//调用 javaPoet 的方法，将内容写入文件 &#125; catch (IOException e) &#123; error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage()); &#125; &#125; return false; &#125;&#125; process 方法首先调用 findAndParseTargets 方法获取解析的目标类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); scanForRClasses(env); // 处理 @BindArray 元素. for (Element element : env.getElementsAnnotatedWith(BindArray.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceArray(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindArray.class, e); &#125; &#125;//代码省略 // 处理每一个 @BindView . for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123; // 解析 BindView 注解 try &#123; parseBindView(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindView.class, e); &#125; &#125; // 处理每一个关联有监听器的注解 for (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123; findAndParseListener(env, listener, builderMap, erasedTargetNames); &#125; // Associate superclass binders with their subclass binders. This is a queue-based tree walk // which starts at the roots (superclasses) and walks to the leafs (subclasses). Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries = new ArrayDeque&lt;&gt;(builderMap.entrySet()); Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;(); while (!entries.isEmpty()) &#123; Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst(); TypeElement type = entry.getKey(); BindingSet.Builder builder = entry.getValue(); TypeElement parentType = findParentType(type, erasedTargetNames); if (parentType == null) &#123; bindingMap.put(type, builder.build()); &#125; else &#123; BindingSet parentBinding = bindingMap.get(parentType); if (parentBinding != null) &#123; builder.setParent(parentBinding); bindingMap.put(type, builder.build()); &#125; else &#123; // Has a superclass binding but we haven't built it yet. Re-enqueue for later. entries.addLast(entry); &#125; &#125; &#125; return bindingMap; &#125; 针对 BindView 我们主要看 parseBindViews 方法 12345678910111213141516171819202122232425262728293031private void parseBindViews(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames) &#123; TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); // 检查常见的代码生成限制 boolean hasError = isInaccessibleViaGeneratedCode(BindViews.class, "fields", element) || isBindingInWrongPackage(BindViews.class, element); //代码省略。主要功能为检查类型是否是一个 List 或者是一个 数组 //代码省略。主要功能为检查注释使用是否存在错误 if (hasError) &#123; return; &#125; assert viewType != null; // Always false as hasError would have been true. TypeName type = TypeName.get(viewType); boolean required = isFieldRequired(element); List&lt;Id&gt; idVars = new ArrayList&lt;&gt;(); for (int id : ids) &#123; QualifiedId qualifiedId = elementToQualifiedId(element, id); idVars.add(getId(qualifiedId)); &#125; //创建绑定代码 BindingSet.Builder builder = getOrCreateBindingBuilder(builderMap, enclosingElement); builder.addFieldCollection(new FieldCollectionViewBinding(name, type, kind, idVars, required)); erasedTargetNames.add(enclosingElement);&#125; 通过 JavaPoet 生成 java 文件正如其名，poet 指诗人，也就是作诗的人。java poet 指的是能够自动写 java 源代码的库。 javapoet 里面常用的几个类： MethodSpec 代表一个构造函数或方法声明。 TypeSpec 代表一个类，接口，或者枚举声明。 FieldSpec 代表一个成员变量，一个字段声明。 JavaFile包含一个顶级类的 Java 文件。 关于 javapoet 的介绍详见这篇文章 回到前面的 process 方法，可以看到 JavaFile javaFile = binding.brewJava(sdk); javaFile.writeTo(filer); BindingSet#brewJava 。该方法通过 Javapoet 生成一个 java 文件 12345JavaFile brewJava(int sdk) &#123; return JavaFile.builder(bindingClassName.packageName(), createType(sdk)) .addFileComment("Generated code from Butter Knife. Do not modify!")//添加文件注释 .build();&#125; 注解处理器的注册方法 1：使用 google 提供的注册处理器库最简单的方式是使用 google 提供的一个注册处理器的库。 compile &#39;com.google.auto.service:auto-service:1.0-rc2&#39; 然后@AutoService(Processor.class):向 javac 注册我们这个自定义的注解处理器，这样，在 javac 编译时，才会调用到我们这个自定义的注解处理器方法。 AutoService 这里主要是用来生成META-INF/services/javax.annotation.processing.Processor文件的。 方法 2：手动注册如果不使用上述处理库，那么，你需要自己进行手动配置进行注册，具体手动注册方法如下：1.创建一个META-INF/services/javax.annotation.processing.Processor 文件，其内容是一系列的自定义注解处理器完整有效类名集合，以换行切割： 123com.example.MyProcessorcom.foo.OtherProcessornet.blabla.SpecialProcessor 2.将自定义注解处理器和META-INF/services/javax.annotation.processing.Processor 打包成一个.jar 文件。所以其目录结构大概如下所示： 12345678MyProcessor.jar - com - example - MyProcessor.class - META-INF - services - javax.annotation.processing.Processor ButterKnife 使用的是第一种方式。 1234@AutoService(Processor.class)public final class ButterKnifeProcessor extends AbstractProcessor &#123; //...&#125; 总结ButterKnife 在编译的时候帮我们自动生成了绑定的代码，然后在运行的时候调用就行了。 首先我们在需要绑定 View 的 地方使用 @BindView 等 ButterKnife 提供的注解。 在编译期 ButterKnifeProcessor 的 process 函数会被调用，在其中获取使用了相应注解的相关方法/成员变量信息，通过 javapoet，生成 Xx_ViewBinder 和 Xx_ViewBinding 类。 运行时，onCreate 方法中通常需要 ButterKnife.Bind()方法，从此处进入，通过 反射调用 Xx_ViewBinding 的构造方法对 View 进行初始化。 参考资料与学习资源推荐 公共技术点之 Java 注解 Annotation ButterKnife 源码分析 深入理解 ButterKnife，让你的程序学会写代码 javapoet——让你从重复无聊的代码中解放出来 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。]]></content>
      <categories>
        <category>源码分析</category>
        <category>拆轮子</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>拆轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String StringBuilder与StringBuffer的区别]]></title>
    <url>%2Fblog%2F2017%2F09%2F21%2FString-StringBuilder%E4%B8%8EStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[概述 CharSequence 就是字符序列，String, StringBuilder 和 StringBuffer 本质上都是通过字符数组实现的。 String 字符串常量（不可变） StringBuffer 字符串变量（线程安全） StringBuilder 字符串变量（非线程安全） String 类型和 StringBuilder 类型的主要性能区别 String 是不可变的对象,因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，会进一步消耗性能。 StringBuilder 是可变的， 可以对 StringBuilder 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuilder ，特别是字符串对象经常改变的情况下。 通常 String 对象的字符串拼接其实是被 JVM 解释成了 StringBuilder 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuilder 对象慢。 特别是以下的字符串对象生成中，String 效率是远要比 StringBuffer 高的： 12String S1 = “This is only a” + “ simple” + “ test”;//直接拼接现有字符串StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”); 这其实涉及到了编译器的优化。在编译期，编译器会把字符串常量相加的情况直接变为拼接为目标字符串。也就是说编译之后就获得了目标字符串。 123String S1 = “This is only a” + “ simple” + “test”; //其实就是：String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。要注意的是，如果你的字符串是来自另外的 String 对象的话（比如下面所列举的这个例子），直接将 String 相加，性能上不会有什么提升。 1234String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 + S3 + S4; 这时候 JVM 会规规矩矩的按照原来的方式去做——先创建一个 StringBuilder 对象，然后再进行调用它的 append 方法对 字符串进行拼接。 StringBufferStringBuffer 是线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 主要操作:append 和 insert 方法，可重载这些方法，以接受任意类型的数据。 append 方法始终将这些字符添加到缓冲区的末端。 insert 方法则在指定的点添加字符。 例如:z 引用一个当前内容是“start”的字符串缓冲区对象，用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。 StringBuilderStringBuilder 是 Java5 新增的一个非线程安全的可变的字符序列。可以把它理解为 StringBuffer 的非线程安全版本，因为实际应用中很少有需要对字符串进行同步的情况，所以采用 StringBuilder 的性能更加。在不需要同步，优先采用 StringBuilder。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机类加载机制]]></title>
    <url>%2Fblog%2F2017%2F09%2F19%2FJVM%20%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[概述虚拟机的类加载机制：虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 与那些在编译时需要进行连接工作的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的， 缺点：这种策略会令类加载时稍微增加一些性能开销 优点：为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类； 约定： 第一，在实际情况中，后文中直接对「类」的描述都包括了类和接口的可能性，而对于类和接口需要分开描述的场景会特别指明； 第二，「Class 文件」并非特指某个存在于具体磁盘中的文件，这里所说的「Class 文件」应当是一串二进制的字节流，无论以何种形式存在都可以。 类加载的时机七个阶段：如下所示 上图中，加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而==解析阶段则不一定==：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。注意，这里说的是按部就班地「开始」，这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。也就是说可能有些阶段未完成，下一个阶段就开始了。 什么情况下需要会开始加载一个类？Java 虚拟机规范中并没有进行强制约束。但是对于初始化阶段，虚拟机规范严格规定了有且只有 5 种情况必须立即对类进行「初始化」（而加载、验证、准备自然需要在此之前开始）： 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这 4 条指令的最常见的 Java 代码场景是： 使用 new 关键字实例化对象的时候、 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候， 以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 主动引用：以上 5 种场景中的行为称为对一个类进行主动引用。 被动引用：除了以上 5 种场景中的行为以外的对一个进行引用的行为。 对于静态字段，只有直接定义这个字段的类才会被初始化，所以通过一个类的子类来引用父类中定义的静态变量，只会触发父类的初始化，而不会触发子类的初始化。 通过数组定义来引用类，不会触发此类的初始化。 常量定义在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 在编译阶段通过常量传播优化实现 接口的加载过程与类加载过程稍有一些不同，接口也有初始化过程，这点与类是一致的，虽然接口中不能使用 static{}语句块，但编译器仍然会为接口生成 &lt;clinit&gt;()类构造器，用于初始化接口中所定义的成员变量。 接口与类真正有所区别的是前面讲述的 5 种「有且仅有」需要开始初始化场景中的第 3 种： 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 类加载的过程加载「加载」是「类加载」（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下 3 件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。 虚拟机规范的这 3 点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。 一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的 loadClass()方法）。 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是==由 Java 虚拟机直接创建==的。 一个数组类（下面简称为 C）创建过程就遵循以下规则： 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（一个类必须与类加载器一起确定唯一性）。 如果数组的组件类型不是引用类型（例如 int[] 数组），Java 虚拟机将会把数组 C 标记为与引导类加载器关联。数组类的可见性与它的组件类型的可见性一致， 如果组件类型不是引用类型，那数组类的可见性将默认为 public。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个 java.lang.Class 类的对象（并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。 加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证为什么需要验证？ 虽然在编译时，编译器也会对 java 源码会对代码进行检查。但是 .class 文件并一定不要求用 java 源码编译来的，它可以使用任何途径生成，甚至可以用十六进制编辑器直接编写 class 文件。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃。所以验证是虚拟机对自身保护的一项重要工作。 验证什么？ 文件格式验证 元数据验证 字节码验证 符号引用验证 文件格式验证 是否以魔数 0xCAFEBABE 开头。 主、次版本号是否在当前虚拟机处理范围之内。 常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 …… 该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的 3 个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。 元数据验证第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求 这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。 这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。即，非抽象类是否实现了所有应该实现的方法？ 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 继承关系，方法覆盖 字节码验证第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的； 但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。 离散数学中一个很著名的问题「Halting Problem」（停机问题） ：通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。 符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。 符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的*方法和字段。 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 准备准备阶段是正式为类变量分配内存并设置==类变量==初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。 其次，这里所说的初始值「通常情况」下是数据类型的零值 这时候尚未开始执行任何 Java 方法。 「==特殊情况==」：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值。 假设上面类变量 value 的定义变为：public static final int value=123； 那么在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在 Class 文件中 符号引用 以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果有了直接引用，那引用的目标必定已经在内存中存在。 虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。 invokedynamic 指令的目的本来就是用于动态语言支持（目前仅使用 Java 语言不会生成这条字节码指令），它所对应的引用称为「动态调用点限定符」（Dynamic Call Site Specifier），这里「动态」的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。 相对的，其余可触发解析的指令都是「静态」的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。 1. 类或接口的解析假设当前代码所处的类为 D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，那虚拟机完成整个解析的过程需要以下 3 个步骤： 如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。 如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的描述符会是类似「[Ljava/lang/Integer」的形式，那将会按照第 1 点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式，需要加载的元素类型就是「java.lang.Integer」，接着由虚拟机生成一个代表此数组维度和元素的数组对象。 如果上面的步骤没有出现任何异常，那么 C 在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，检查访问权限。如果发现不具备访问权限，将抛出 java.lang.IllegalAccessError 异常。 字段解析类方法解析接口方法解析接口的方法、常量都是 public 的，所以不需要进行权限验证 初始化类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。 在准备阶段，变量已经赋过一次系统要求的初始值 在初始化阶段，根据项目需要对类变量进行相应的初始化，或者可以从另外一个角度来表达：初始化阶段是执行类构造器 () 方法的过程。 ()方法是由编译器自动收集类中的所有类变量的==赋值动作==和静态语句块（static{}块）中的语句合并产生的， 编译器收集的顺序是由语句在源文件中出现的顺序所决定的， 静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。 如果没有静态语句块也没有变量初始化赋值，就不会产生 方法 ()方法不需要显式地调用父类构造器，虚拟机会保证在子类的 ()方法执行之前，父类的()方法已经执行完毕。因此在虚拟机中第一个被执行的 ()方法的类肯定是 java.lang.Object。 接口与类一样都会生成 ()方法。但接口与类不同的是， 执行接口的 ()方法不需要先执行父接口的 ()方法。只有当父接口中定义的变量使用时，父接口才会初始化。 另外，接口的实现类在初始化时也一样不会执行接口的 ()方法。 虚拟机会保证一个类的 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的 ()方法中有耗时很长的操作，就可能造成多个进程阻塞。在实际应用中这种阻塞往往是很隐蔽的 类加载器类与类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器都拥有一个独立的命名空间。 双亲委派模型从 Java 虚拟机的角度来讲，只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现 ，是虚拟机自身的一部分； 另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度来看，绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器。 启动类加载器（Bootstrap ClassLoader）：这个类将器负责将存放在＜JAVA_HOME＞\lib 目录中的，或者被-Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 无法直接被用户使用，只能通过子类返回 null 来间接调用。 扩展类加载器：Extension ClassLoader，负责加载＜JAVA_HOME＞\lib\ext (扩展库)目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器：因为可以通过 ClassLoader.getSystemClassLoader() 获取，因此一般也称为系统类加载器，负责加载用户路径上所指定类库，可以直接被开发者使用。 上图中展示的层次关系，称为类加载器的双亲委派模型。 该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。 此处的父子关系通常不会通过继承关系来实现，而是选择组合关系来复用父加载器的代码 工作过程：当一个类加载器收到了类加载的请求时，它不是自己加载，而是将这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成该请求时，子加载器才会尝试自己去加载。 好处： Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。 保证 java 核心库的安全性（例如：如果用户自己写了一个 java.lang.String 类就会因为双亲委派机制不能被加载，不会破坏原生的 String 类的加载） 栗子： Object 类，无论哪一个类要加载该类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。 实现：在 ClassLoader 的 loadClass 方法中。 对比：代理模式： 与双亲委派机制相反，代理模式是先自己尝试加载，如果无法加载则向上传递。tomcat 就是代理模式。 破坏双亲委派模型双亲委派模型并不是一个强制性的约束模型。 双亲委派模型的第一次「被破坏」其实发生在双亲委派模型出现之前——即 JDK 1.2 发布之前。 双亲委派模型的第二次「被破坏」是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载） 基础类之所以称为「基础」，是因为它们总是作为被用户代码调用的 API，但是基础类调用回用户的代码不容易（用回调不行？？） 一个典型的例子便是 JNDI 服务 双亲委派模型的第三次「被破坏」是由于用户对程序动态性的追求而导致的，这里所说的「动态性」指的是当前一些非常「热门」的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U 盘，不用重启机器就能立即使用。热插拔？ 在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索： 将以 java.*开头的类委派给父类加载器加载。 否则，将委派列表名单内的类委派给父类加载器加载。 否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载。 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。 否则，类查找失败。 小结加载加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 验证这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： 1public static int v = 8080; 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的putstatic指令是程序被编译后，存放于类构造器&lt;client&gt;方法之中，这里我们后面会解释。 但是注意如果声明为： 1public static final int v = 8080; 在编译阶段会为 v 生成ConstantValue属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。 解析解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的： CONSTANT_Class_info CONSTANT_Field_info CONSTANT_Method_info 等类型的常量。 下面我们解释一下符号引用和直接引用的概念： 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 初始化初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 初始化阶段是执行类构造器&lt;clint&gt;方法的过程。&lt;clint&gt;方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证&lt;clint&gt;方法执行之前，父类的&lt;clint&gt;方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成&lt;clint&gt;()方法。 注意以下几种情况不会执行类初始化： 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 参考资料与学习资源推荐 《深入理解 Java 虚拟机》 JVM 类加载机制详解 本文大部分内容参考自《深入理解 Java 虚拟机》，当然也有一些个人理解，若有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>JVM</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 内存模型与线程浅析]]></title>
    <url>%2Fblog%2F2017%2F09%2F14%2FJava-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[硬件的效率与一致性多级缓存的作用：由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以为了提高处理器的利用率，现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 缓存虽然解决了速度差，但是也引入了新问题——缓存与主内存的数据一致性(Cache Coherence) 本文中「内存模型」一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化（即 指令重排序），处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致。 Java 语言规范要求 JVM 在线程中维护一种类似串行的语义：只要程序的最终结果与在严格串行环境中执行的结果相同，那么上述操作（指令重排序、增加高速缓存）都是允许的。 Java 内存模型主内存与工作内存以下所谈的变量(Variables)与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。 ~注~：如果局部变量是一个 reference 类型，它引用的对象在 Java 堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中，它是线程私有的。 Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中(此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分)。 每条线程还有自己的工作内存(Working Memory，可与前面讲的处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝 [4] 线程对变量的所有操作(读取、赋值等)都必须在==工作==内存中进行，而不能直接读写主内存中的变量 [5] 。 干活要在操作线程中干。 这个对象的引用、对象中某个在线程访问到的字段是有可能存在拷贝的，但不会有虚拟机实现成把整个对象拷贝 A 一次。 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 内存间交互操作Java 内存模型中定义了以下 8 种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外。 lock unlock read load use assign store write 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作， 如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。 注意，Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是==连续==执行。 Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则： 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 read 和 load、store 和 write 。工作内存与主内存之间有求必应。 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 改了一定要让主内存知道。 不允许一个线程无原因地(没有发生过任何 assign 操作)把数据从线程的工作内存同步回主内存中。 没改就别瞎折腾。 一个新的变量只能在主内存中「诞生」，不允许在工作内存中直接使用一个未被初始化(load 或 assign)的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。 ​ 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。 锁了多少次，开多少次。 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。 没有锁不要乱开锁 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)。 做好手尾，再开锁。 这 8 种内存访问操作以及上述规则限定，再加上稍后介绍的对 volatile 的一些特殊规定，就已经完全确定了 Java 程序中哪些内存访问操作在并发下是安全的。 对于 volatile 型变量的特殊规则当一个变量定义为 volatile 之后，它将具备两种特性， 第一是保证此变量对所有线程的可见性，这里的「可见性」是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。 第二个语义是禁止指令重排序。 可见性 != 线程安全 volatile 变量在各个线程的工作内存中不存在一致性问题(在各个线程的工作内存中，volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)，但是 Java 里面的==运算并非原子操作==，导致 volatile 变量的运算在并发下一样是不安全的， 非原子操作会导致读取数据后，多个线程并行进行操作的都是旧值。那么加载到主内存的值也就不是最新的了。 由于 volatile 变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用 synchronized 或 java.util.concurrent 中的原子类)来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束 性能某些情况下，volatile 的同步机制的性能确实要优于锁(使用 synchronized 关键字或 java.util.concurrent 包里面的锁)，但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为 volatile 就会比 synchronized 快多少。 volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求。 内存屏障内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。Java 编译器也会根据内存屏障的规则禁止重排序。内存屏障可以被分为以下 4 种类型 LoadLoad 屏障：对于这样的语句 Load1; LoadLoad 屏障; Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。 StoreStore 屏障：对于这样的语句 Store1; StoreStore 屏障; Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。 LoadStore 屏障：对于这样的语句 Load1; LoadStore 屏障; Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。 StoreLoad 屏障：对于这样的语句 Store1; StoreLoad 屏障; Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。 有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java 编译器会在这种情况下不放置内存屏障。为了实现 JSR-133 的规定，Java 编译器会这样使用内存屏障： 对于 long 和 double 型变量的特殊规则允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定(Nonatomic Treatment ofdouble andlong Variables)。 Java 内存模型「强烈建议」虚拟机把这些操作实现为具有原子性的操作。目前各种商用虚拟机也都是将它们实现为原子操作，因此我们在编写代码时==一般不需要==把用到的 long 和 double 变量专门声明为 volatile。 原子性、可见性与有序性原子性原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。 由 Java 内存模型直接保证的原子性变量操作包括 read、load、assign、use、store 和 write，我们大致可以认为基本数据类型的访问读写是具备原子性的(例外就是 long 和 double 的非原子性协定)。 尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性。 可见性可见性(Visibility)：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 除了 volatile 以外，Java 还有两个关键字能实现可见性，即 synchronized 和 final。 同步块的可见性是由「对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)」这条规则获得的， final 关键字的可见性是指：保证一个对象的构建方法结束前，所有 final 成员变量都必须完成初始化（前提是没有 this 引用溢出）。在构造器中一旦初始化完成，并且构造器没有把「this」的引用传递出去，那在其他线程中就能看见 final 字段的值。 this 引用逃逸 是指在构造函数返回之前其他线程就持有该对象的引用。调用尚未构造完全的对象的方法可能引发令人疑惑的错误, 因此应该避免 this 逃逸的发生。this 逃逸经常发生在构造函数中启动线程或注册监听器时 有序性如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指「线程内表现为串行的语义」(Within-Thread As-If-Serial Semantics)，后半句是指「指令重排序」现象和「工作内存与主内存同步延迟」现象。 先行发生原则先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据。 先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。所谓偏序关系可以这样理解：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。 123456//以下操作在线程 A 中执行i=1；//以下操作在线程 B 中执行j=i；//以下操作在线程 C 中执行i=2； 假设 A B C 之间满足 Happens-Before 条件，且 A Happens-Before B Happens-Before C，那么执行结果就是 j = 1; i = 2; 这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。 程序次序规则(Program Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则(Monitor Lock Rule)：一个 unlock 操作先行发生于后面对同一个锁的 lock操作。这里必须强调的是同一个锁，而「后面」是指时间上的先后顺序。 volatile 变量规则(Volatile Variable Rule)：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的「后面」同样是指时间上的先后顺序。 线程启动规则(Thread Start Rule)：Thread 对象的 start()方法先行发生于此线程的每一个动作。 线程终止规则(Thread Termination Rule)：线程中的所有操作必须在其他线程检测到该线程已经结束之前完成，我们可以通过 Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则(Thread Interruption Rule)：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生。 对象终结规则(Finalizer Rule)：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始。 传递性(Transitivity)：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。 Java 无需任何同步手段就能成立的先行发生规则就以上 8 点。看上去有些抽象，想要进一步了解的同学可以参考下这篇文章 从Java多线程可见性谈Happens-Before原则 ==时间先后顺序与先行发生原则之间基本没有太大的关系==，所以我们衡量并发安全问题的时候==不要受到时间顺序的干扰，一切必须以先行发生原则为准==。 这句话应该如何理解呢？ 考虑这样一个场景： 123456789private int value = 0;//线程 A 先（时间上）调用了 getValue 方法public int getValue() &#123; return value;&#125;//之后（时间上）线程 B 调用了 setValue(2) 方法public void setValue(int value) &#123; this.value = value;&#125; 但是线程 A 的 getValue 获取的结果是什么呢？可能是 0 ，也可能是 2。也就是说，没有进行同步处理的情况下，不同线程对在时间上先后对调用对某个共享变量的操作，并不能保证但是它们的结果是根据它们在时间上调用顺序确定的。换句话说，在不同线程之间，「时间上的先调用」并不代表「先行发生」。要解决这个问题，可以给 getValue 和 setValue 方法都定义为 synchronized 的，因为这样就可以套用「管程锁定原则」了。或者将 value 定义了 volatile 变量，因为 setValue 方法对 value 的修改不依赖 value 的原值，满足 volatile 关键字使用场景，这样就可以套用 volatile 变量规则来实现先行发生规则了。 通过上面的讨论，我们可以得出结论：一个操作「时间上的先发生」不代表这个操作会会是「先行发生」。那么一个操作「先行发生」是否能推导出这个操作必定是「时间上先发生」呢？这个推论也是不成立的，一个典型的栗子就是「指令重排序」 12int i = 2;int j = 1; 按照程序次序规则，int i = 2; 的操作先行发生与 int j = 1;,但是 int j = 1; 完全可能先执行，这并不影响先行发生原则的正确性，因为在同一条线程中无法感知到这点。 先行发生原则的真正意义该段内容参考自从Java多线程可见性谈Happens-Before原则 从上面的分析中我们可以看出，Happens-Before原则致力于解决变量间可见性问题。但是它是如何解决的呢？ 导致多线程间变量间可见性问题的根源在于 CPU 缓存以及指令重排序。那么，要解决这个可见性问题，一个最简单粗暴的方法就是禁止所有的重排序和 CPU 缓存。即关闭所有的编译器、操作系统和处理器的优化，这样所有的指令顺序全部按照程序代码书写的顺序执行。去掉 CPU 高速缓存，让 CPU 每次读写操作都直接与主存交互。 但是，如此粗暴的解决方案是不可取的，因为这会极大影响处理器的计算性能，并且对于那些非多线程共享的 变量是极不公平的。我们可以采用一种折中的方案来解决 CPU 高速缓存与指令重排带来的数据一致性问题。使用分割线把整个程序划分为几个程序块，在每个程序内部的指令是可重排序的，但是分割线上的指令与程序块其他指令之间是不可以重排序的。在一个程序块内部，CPU 不用每次都与主内存进行交互，只需要在 CPU 缓存中执行读写操作即可，但是当程序执行到分割线出，CPU 必须将执行结果同步到主内存或者从主内存读取最新的变量值，那么 Happen-before 规则就是定义了这些程序块的分割线。 如图所示，这里的unlock M和lock M就是划分程序的分割线。在这里，红色区域和绿色区域的代码内部是可以进行重排序的，但是unlock和lock操作是不能与它们进行重排序的。即第一个图中的红色部分必须要在unlock M指令之前全部执行完，第二个图中的绿色部分必须全部在lock M指令之后执行。并且在第一个图中的unlock M指令处，红色部分的执行结果要全部刷新到主存中，在第二个图中的lock M指令处，绿色部分用到的变量都要从主存中重新读取。 在程序中加入分割线将其划分成多个程序块，虽然在程序块内部代码仍然可能被重排序，但是保证了程序代码在宏观上是有序的。并且可以确保在分割线处，CPU一定会和主内存进行交互。Happens-Before原则就是定义了程序中什么样的代码可以作为分割线。并且无论是哪条Happens-Before原则，它们所产生分割线的作用都是相同的。 Java 与线程线程的实现(广义)实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。 Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的。在 Java API 中，一个 Native 方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现(当然也可能是为了执行效率而使用 Native 方法，不过，通常最高效率的手段也就是平台相关的手段)。 1.内核线程实现内核线程(Kernel-Level Thread,KLT)就是直接由操作系统内核(Kernel，下称内核)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process,LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。 系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间)，因此一个系统支持轻量级进程的数量是有限的。 1:1 2.使用用户线程实现从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程(User Thread,UT)，因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知用户线程存在的实现。 现在使用用户线程的程序越来越少了，Java、Ruby 等语言都曾经使用过用户线程，最终又都放弃使用它。 3.使用用户线程加轻量级进程混合实现线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为 N：M 的关系 线程调度主要调度方式有两种，分别是协同式线程调度(Cooperative Threads-Scheduling)和抢占式线程调度(Preemptive Threads-Scheduling)。 如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。 优点：实现简单，不用考虑同步问题。 缺点：不稳定，前面一个线程执行出现问题，那么后面的线程都会受到影响。 如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。 优点：相对于协同式调度而言，较为稳定。 缺点：可控性不是很高，因为线程的优先级不是很靠谱；虽然 Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法。 目前 Java 使用的线程调度方式就是抢占式调度。JDK 后续版本中有可能会提供协程(Coroutines)方式来进行多任务处理 为什么说线程优先级并不是太靠谱？因为 Java 的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与 Java 线程的优先级一一对应。 线程的状态转换图片参考自这篇文章 创建 (New) 运行，两种子状态 Running 正在执行 Ready 等待着 CPU 给它分配执行时间。 等待 (Waiting) 无限期等待 没有设置 Timeout 参数的 Object.wait()方法。 没有设置 Timeout 参数的 Thread.join()方法。 LockSupport.park()方法。 有限期等待 (Timed Waiting) Thread.sleep()方法。 设置了 Timeout 参数的 Object.wait()方法。 设置了 Timeout 参数的 Thread.join()方法。 LockSupport.parkNanos()方法。 LockSupport.parkUntil()方法。 阻塞 (Blocked) 「阻塞状态」与「等待状态」的区别是：「阻塞状态」在等待着获取到一个互斥锁(排它锁)，这个事件将在另外一个线程放弃这个锁的时候发生；而「等待状态」则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 结束 (Terminated) 相关方法介绍调用 sleep、join 时，不会释放所占用的资源，会进入阻塞状态；调用 wait 时，会释放所占用的资源，会进入等待队列。 sleep 方法线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态 。sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep() 方法不能保证该线程睡眠到期后就开始执行。 sleep()是静态方法，只能控制当前正在运行的线程。 wait 方法因为 wait() 方法会释放锁，所以必须要在 synchronized 块中调用（也就是要先拿到锁，不然就没有锁可以是释放了）。 join 方法join() 导致线程栈发生了变化，当然这些变化都是瞬时的。 join() 方法有带超时限制的重载版本。 例如 t.join(5000);则让线程等待 5000 毫秒，如果超过这个时间，则停止等待，变为可运行状态。 yield 方法yield() 方法会停止当前线程（使之进入可运行状态），让同等优先权的线程运行。如果没有同等优先权的线程，那么 yield() 方法将不会起作用。 实际中无法保证 yield() 达到让步目的，因为让步的线程(回到可执行状态)还有可能被线程调度程序再次选中。 简记：硬件效率与一致性因为处理器需要读取和返回数据，所以需要存储器。而存储器的速度与处理器的运算速度相差几个数量级。所以引入了缓存，引入缓存的同时也引入了主存与缓存中的数据一致性问题。 为了充分利用处理器的运算能力，除了引入缓存以外，处理器可能还会对输入的代码进行来乱序执行(不影响结果)。JVM 的即时编译器中也有类似于指令重排的优化。 工作内存与主内存每条线程有自己的工作内存，工作内存是线程私有的，如果要交换必须通过主内存。若要把二者与 Java 中的内存区域对应起来，则工作内存像对应虚拟机栈中的部分区域，主内存对应于堆中的对象实例数据部分。 虚拟机可能会让工作内存优先存储在寄存器或者高速缓存中，因为程序运行时主要访问读写的是工作内存 。 内存间的交互操作(lock)read load use assign store write(unlock) 一个变量在同一时刻只能被某一个线程 lock。但是该线程可以对这个变量 lock 多次。 某些操作必须成对出现，比如 read 与 load 、store 与 write。 对某个变量执行了 assign 操作，必须把它同步回主内存。 volatile 关键字保证可见性、禁止指令重排。 无法保证一致性。以多线程修改变量自增为例，当线程 A 读取了该变量(此时变量的值是正确的)但是还未进行 +1 操作，此变量的值被线程 B 执行了 +1 操作(更新后会通知所有线程，但是由于 线程 A 已经读取过该值了但是由还没有进行赋值操作，所以不会得到最新的值)，但是之后线程 A 会对旧值进行自增操作，导致结果错误。 注：i++ 由 4 条字节码指令构成。从字节码层面解释：当 getStatic 指令把 race 的值(进行自增操作的变量)读取到操作栈顶时，volatile 保证 race 的值在此时是正确的，但是在执行 iconst_1、add 这些指令时，其他线程可能已经把 race 的值加大了，而在操作栈顶的值就变成了过期的数据，所以 putStatic 指令执行后就可能把较小的 race 值同步回主内存中。 在不符合以下两条规则的运算场景中，仍然要通过加锁来保证原子性。 运算结果不依赖变量当前的值 or 只要单一的线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束。 普通变量只保证「结果正确」，volitale 变量还保证「程序正确」 「程序正确」指的是按照顺序执行 参考资料与学习资源推荐 《深入理解 Java 虚拟机》 Java 内存访问重排序的研究 线程状态的转换 从Java多线程可见性谈Happens-Before原则 若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>Java</category>
        <category>原理解析</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>原理解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程安全与锁优化]]></title>
    <url>%2Fblog%2F2017%2F09%2F11%2FJava%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[线程安全线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。 Java 语言中的线程安全可将 Java 语言中的各种操作共享的数据分为以下 5 类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 1. 不可变只要一个不可变对象被正确地构建出来（没有 this 引用逃的情况），那么其外部的可见状态永远也不会改变。 final + 基本数据类型，则该变量为不可变变量final + 对象，无法保证对象是不可变的 如何保证对象的行为不会对其状态产生任何影响？最简单的就是将对象中带有状态的变量都声明为 final。 Java API 中属于不可变的类有以下几种： String 基础数据类型包装类 BigInteger BigDecimal 注意：同为 Number 的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。因为它们都有 set 方法，可以改变对象的状态。 2. 绝对线程安全绝对线程安全的定义是很严格的。Java API 中标注自己的是线程安全的类，大多数都不是绝对的线程安全。 栗子：Vector 123456789101112131415161718192021222324252627282930313233package jvm.ch13;import java.util.Vector;public class VectorTest &#123; private static Vector&lt;Integer&gt; sIntegerVector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; sIntegerVector.add(i); &#125; Thread removeThread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; sIntegerVector.size(); i++) &#123; sIntegerVector.remove(i); &#125; &#125;); Thread printThread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; sIntegerVector.size(); i++) &#123; System.out.println(sIntegerVector.get(i)); &#125; &#125;); removeThread.start(); printThread.start(); while (Thread.activeCount() &gt; 20) &#123; &#125; &#125; &#125;&#125; 以上代码可能会报 ArrayIndexOutOfBoundException 因为可能出现一个线程恰好在一个错误的时间删除了一个元素，导致 i 元素已经不再可用。因为可能出现这样的情况：get(i) 进入等待锁期间，remove(i) 刚好执行了。 解决：操作时加上锁，使得复合操作变为原子操作。 原子操作与复合操作简介： 原子操作：不可分割的操作，要么成功要么失败 复合操作：可分割的操作，可能出现数据失效的问题。 1234567891011121314Thread removeThread = new Thread(() -&gt; &#123; synchronized (sIntegerVector) &#123;//加上锁使之成为原子操作 for (int i = 0; i &lt; sIntegerVector.size(); i++) &#123; sIntegerVector.remove(i); &#125; &#125;&#125;);Thread printThread = new Thread(() -&gt; &#123; synchronized (sIntegerVector) &#123; for (int i = 0; i &lt; sIntegerVector.size(); i++) &#123; System.out.println(sIntegerVector.get(i)); &#125; &#125;&#125;); 为什么是使用 Vector 对象作为锁？因为 Vector 内部是使用自带的锁来实现的。 3. 相对线程安全即通常意义上所讲的线程安全。它需要保证对这个对象单独操作是线程安全的，调用时就不需要做额外的保障措施。 对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确=性。 Java API 中大部分线程安全的类都属于这种类型： Vector HashTable Collections.sychronizedCollection() 4. 线程兼容也就是平常所说的线程不安全类。对象本身并不安全，但是可以通过在调用端正确地使用同步手段来保证对象子啊并发环境中可以安全地使用。 比如：ArrayList HashKMap 5. 线程对立在调用端是否使用同步手段都无法再多线程环境下使用。 这种排斥多线程代码很少出现。 线程安全的实现方法线程安全的实现方法主要有以下几种：互斥同步、非阻塞同步、无同步方案。 1. 互斥同步「互斥同步」的意思是通过互斥来实现同步。同步是指在多个线程并发访问共享数据的时候，保证共享数据在同一时刻只能有一个（或者一些，使用信号量的时候）线程使用。临界区、互斥量、信号量都是主要的互斥实现方式。 最基本的互斥同步实现方法就是使用 synchronized 关键字。synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter、monitorexit 两条指令。根据虚拟机规范的要求， 在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1， 在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 上述描述中有两点是需要特别注意的。 首先，synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。 其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。 Java 的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。 除了 synchronized 之外，我们还可以使用 java.util.concurrent（简称 J.U.C）包中的重入锁（ReentrantLock）来实现同步，在基本用法上，ReentrantLock 与 synchronized 很相似，他们都具备一样的线程重入特性，不同点表现在代码写法上 一个表现为 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成）， 另一个表现为原生语法层面的互斥锁。 相比 synchronized,ReentrantLock 增加了一些高级功能，主要有以下 3 项： 等待可中断,如果持有锁的线程长时间不释放锁，正在等待的线程可以选择放弃等待，改为处理其他事情。 公平锁 多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁; 非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized 中的锁是非公平的， ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 锁可以绑定多个条件 一个 ReentrantLock 对象可以同时绑定多个 Condition 对象 而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁， ReentrantLock 还是 synchronized？关于性能：Java 1.6 发布之后，synchronized 与 ReentrantLock 的性能基本上是完全持平了。因此，Java 1.6 或以上，性能因素就不再是选择 ReentrantLock 的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized。 因此在不需要用到 ReentrantLock 三个特性的情况下，优先考虑使用 synchronized 来进行同步。 2. 非阻塞同步互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题。 基于冲突检测的乐观并发策略，通俗地说，就是先进行操作， 如果没有其他线程争用共享数据，那操作就成功了； 如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。 为什么说使用乐观并发策略需要 “硬件指令集的发展” 才能进行呢？ 因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。 这类指令常用的有： 测试并设置（Test-and-Set）。 获取并增加（Fetch-and-Increment）。 交换（Swap）。 ==比较并交换（Compare-and-Swap，下文称 CAS==）。 加载链接/条件存储（Load-Linked/Store-Conditional，下文称 LL/SC）。 Java 1.5 之后，Java 程序中才可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 compareAndSwapInt()和 compareAndSwapLong() 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令。 CAS 指令需要有 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。 Unsafe 类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的 Class 才能访问它），因此，如果不采用反射手段，我们只能通过其他的 Java API 来间接使用它。 如 J.U.C（java.util.concurrent） 包里面的整数原子类，其中的 compareAndSet()和 getAndIncrement()等方法都使用了 Unsafe 类的 CAS 操作。 12345678public final int incrementAndGet()&#123; for（;;）&#123; int current = get()； int next = current+1； if（compareAndSet（current,next）） return next； &#125;&#125; CAS 存在的问题： 无法涵盖互斥同步的所有使用场景 存在==ABA 问题==，值改了但是自己却不知道。 怎么解决？ 加入引用计数。 加入修改记录 可重入代码（Reentrant Code）：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码的一些共同的特征： 不依赖存储在堆上的数据和公用的系统资源、 用到的状态量都由参数中传入、 不调用非可重入的方法等。 判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，也就是说只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。 3. 无同步方案一个数据的可见范围局限在同一个线程之内， 不会存在多线程竞争问题，也就不需要进行同步了。 如果一个变量要被某个线程独享，Java 中可以通过 java.lang.ThreadLocal 类来实现线程本地存储的功能。每一个线程的 Thread 对象中都有一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值，使用这个值就可以在线程 K-V 值对中找回对应的本地线程变量。 Java 中锁的分类与优化可重入锁又称为「递归锁」，指的是当同一个线程的外层方法获取锁时，进入内层方法会自动获取锁。 可重入锁的一个好处就是可以在一定程度上避免死锁。 123456synchronized void setA() throws Exception &#123; Thread.sleep(1000); synchronized(this) &#123; Thread.sleep(1000); &#125;&#125; 独享(占)锁/共享锁根据能够同时被多少线程持有来区分。 独享锁就是指该锁一次仅能被一个线程所持有。 共享锁可以同时被多个线程持有。 互斥锁/读写锁上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。 互斥锁：在 Java 中的具体就是 ReentrantLock 读写锁：在 Java 中的具体实现就是 ReadWriteLock。其读锁是共享锁，其写锁是独享锁。 读锁的共享可保证高效并发。 读写、写读、写写的过程是互斥的 独享锁与共享锁也是使用 AQS 来实现的。通过实现不同的方法来实现独享或者共享。 乐观锁/悲观锁并不是指具体类型的锁，而是指看待并发同步的态度。 悲观锁采用一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁不能解决脏读的问题。 二者之间如何选择选择？首先要弄清楚，事实是悲观的还是乐观的？ 假如你的资源竞争很激烈，并且无法共享的话，乐观锁不过是让大量请求的希望落空罢了。——如果事实是悲观的，但是采用了乐观锁，那就只会导致大量请求落空罢了。 假如你的资源没什么竞争（这个和并发高低没必然的关联，业务的影响更大），那悲观锁意味着不必要地加锁。如果原本是可共享的资源（比如资源支持多个只读方），那么悲观锁意味着失去原本的可以使用的时间。——如果事实是乐观的，但是使用了悲观锁，那么就损失一些本来可以使用的时间。 再详细点可以从以下几个方面来判断： 响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。 冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。 重试代价：如果重试代价大，建议采用悲观锁。 以上内容参考自高并发下悲观锁与乐观锁的选择问题 分段锁分段锁其实是一种锁的设计，并不是具体的一种锁。 我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为 Segment，它即类似于 HashMap（Java7 与 Java8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表；同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock)。当需要 put 元素的时候，并不是对整个 hashmap 进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。 但是，在统计 size 的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 偏向锁/轻量级锁/重量级锁这三种锁是指锁的状态，并且是针对Synchronized。在 Java5 通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。 偏向锁：当一段同步代码总是被一个线程访问的时候， 那么该线程就会自动获取锁，降低获取锁的代价。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。偏向锁的“偏”，意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。 轻量级锁：当锁是偏向锁时（因为经常被一个线程访问），当另外一个线程需要访问相应的同步代码段时，偏向锁会升级为轻量级锁，其他线程会通过自旋的方式尝试去获取锁，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 重量级锁：自旋达到一定次数之后，就会膨胀为重量级锁。重量级锁会使其他申请线程进入阻塞状态。 错误观点：锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。具体可以参考下这篇文章 锁的升级： 偏向锁的实现假设当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中， 如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking、Unlocking 及对 Mark Word 的 Update 等）。 当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。 根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态， 后续的同步操作就如上面介绍的轻量级锁那样执行。 图片参考自聊聊并发（二）——Java SE1.6中的Synchronized 轻量级锁轻量级锁的加锁过程在代码进入同步块的时候， 如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），这时候线程堆栈与对象头的状态如图 13-3 所示。 然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后 2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示。 如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧， 如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行， 否则说明这个锁对象已经被其他线程抢占了。 如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 图片参考自聊聊并发（二）——Java SE1.6中的Synchronized 轻量级锁的解锁过程解锁过程也是通过 CAS 操作来进行的 如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来， 如果替换成功，整个同步过程就完成了。 如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。（如何唤醒？ notify() ） 轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。 如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销， 如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在==有竞争的情况下，轻量级锁会比传统的重量级锁更慢==。 锁的优缺点对比 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 适用于只有一个线程访问同步块场景 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度 如果始终得不到锁竞争的线程使用自旋会消耗 CPU 追求响应时间,锁占用时间很短 重量级锁 线程竞争不使用自旋，不会消耗 CPU 线程阻塞，响应时间缓慢 追求吞吐量,锁占用时间较长 自旋锁在 Java 中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。典型的自旋锁实现的例子，可以参考自旋锁的实现 如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。这样可以避免线程挂起和恢复(挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力)，从而降低性能开销。 自旋次数的默认值是 10 次，用户可以使用参数-XX：PreBlockSpin 来更改。 在 Java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 锁消除的主要判定依据来源于逃逸分析的数据支持（第 11 章已经讲解过逃逸分析技术），如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 举个栗子： 1234567public String concatString（String s1，String s2，String s3）&#123; StringBuffer sb=new StringBuffer()； sb.append（s1）； sb.append（s2）； sb.append（s3）； return sb.toString()；&#125; 每个 StringBuffer.append()方法中都有一个同步块，锁就是 sb 对象。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString()方法内部。sb 的所有引用永远不会“逃逸”到 concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。 锁粗化原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为使得需要同步的操作数量尽可能变小。 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。 1234567public String concatString（String s1，String s2，String s3）&#123; StringBuffer sb=new StringBuffer()； sb.append（s1）； sb.append（s2）； sb.append（s3）； return sb.toString()；&#125; 上面连续的 append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以上述代码为例，就是扩展到第一个 append()操作之前直至最后一个 append()操作之后，这样只需要加锁一次就可以了。 参考资料与学习资源推荐 乐观锁的一种实现方式——CAS Java 中的锁分类 Java多线程（七）之同步器基础：AQS框架深入分析 高并发下悲观锁与乐观锁的选择问题 聊聊并发（二）——Java SE1.6中的Synchronized 《深入理解 Java 虚拟机》 如果本文中存在不正确的说法，请提出，共同讨论，共同进步，谢谢！]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合框架之 HashMap 工作原理]]></title>
    <url>%2Fblog%2F2017%2F09%2F10%2FJava%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8B%20HashMap%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概要概括的说，HashMap 是一个关联数组、哈希表，它是线程不安全的，允许key 为 null,value 为 null。遍历时无序。其底层数据结构是数组称之为哈希桶，每个桶里面放的是链表，链表中的每个节点，就是哈希表中的每个元素。在 JDK8 中，当链表长度达到 8，会转化成红黑树，以提升它的查询、插入效率，它实现了Map&lt;K,V&gt;, Cloneable, Serializable接口。 因其底层哈希桶的数据结构是数组，所以也会涉及到扩容的问题。 当HashMap的容量达到threshold域值时，就会触发扩容。扩容前后，哈希桶的长度一定会是 2 的次方。这样在根据 key 的 hash 值寻找对应的哈希桶时，可以用位运算替代取余操作，更加高效。 而 key 的 hash 值，并不仅仅只是 key 对象的hashCode()方法的返回值，还会经过扰动函数的扰动，以使 hash 值更加均衡。因为hashCode()是int类型，取值范围是 40 多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。 但就算原本的hashCode()取得很好，每个 key 的hashCode()不同，但是由于HashMap的哈希桶的长度远比 hash 取值范围小，默认是 16，所以当对 hash 值以桶的长度取余，以找到存放该 key 的桶的下标时，由于取余是通过与操作完成的，会忽略 hash 值的高位。因此只有hashCode()的低位参加运算，发生不同的 hash 值，但是得到的 index 相同的情况的几率会大大增加，这种情况称之为hash 碰撞。 即，碰撞率会增大。 扰动函数就是为了解决 hash 碰撞的。它会综合 hash 值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少 hash 碰撞的概率。（在 JDK8 之前，扰动函数会扰动四次，JDK8 简化了这个操作） 执行扩容操作时，会 new 一个新的Node数组作为哈希桶，然后将原哈希表中的所有数据(Node节点)移动到新的哈希桶中，相当于对原哈希表中所有的数据重新做了一个 put 操作。所以性能消耗很大，可想而知，在哈希表的容量越大时，性能消耗越明显。 扩容时，如果发生过哈希碰撞，节点数小于 8 个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位= low 位+原哈希桶容量如果追加节点后，链表数量》=8，则转化为红黑树 由迭代器的实现可以看出，遍历 HashMap 时，顺序是按照哈希桶从低到高，链表从前往后，依次遍历的。属于无序集合。 实现两个重要的参数 An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets. capacity：容量。也就是哈希桶数组的长度。默认初始化容量为 16。 loadFactor：加载因子。 扩容的阈值 threshold = capacity * loadFactor 加载因子默认为 0.75，这是时间和空间上的折衷点。大于 0.75，能提高空间利用率，但是会导致查找效率降低。 当 hashMap 中元素的总数大于 capacity * loadFactor 时，就会发生扩容（将 buckets 的数目调整为当前的两倍）。 capacity 被控制为 2 的 n 次方（一定是合数），这有点不合常规。常规的做法是将桶数组的长度设置为素数，因为相对而言使用素数发生冲突的概率要比使用合数要小一些。HashTable 默认初始化容量就为 11（素数，Hashtable 扩容后不能保证还是素数）。之所以这样设计是取模和扩容时进行优化（使用位运算提高效率），同时也是为了减少冲突，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。 put 函数的实现1.8 对 HashMap 的底层实现进行了修改（当相同 hash 值的元素大于 8 个时，会将链表转换为 红黑树，以提高查找效率），所以 put 函数看起来相对复杂了点，通过以下流程图能帮助理解。 图片出自这篇文章。 注意：对于 resize 方法的是否需要执行有两次判断： 第一次判断桶数组是否为空，如果为空，则通过 resize 方法执行初始化操作。第二次判断是在插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。 put 方法具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 将指定的值与该映射中指定的键关联起来。 * 如果该 key 对应的 value 存在，则替换旧值 * */public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; java.util.HashMap.Node&lt;K,V&gt;[] tab; java.util.HashMap.Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)//桶数组为空或者长度为 0（说明还未初始化） n = (tab = resize()).length;//调用扩容方法进行初始化，并获取初始化后桶数组的长度 if ((p = tab[i = (n - 1) &amp; hash]) == null)//根据 hash 值与 n-1 进行「模运算」获取插入数组的索引的 i。 tab[i] = newNode(hash, key, value, null);//创建新结点 else &#123; //发生碰撞 java.util.HashMap.Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; //key 值相同，替换旧值 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof java.util.HashMap.TreeNode)//该链为树 e = ((java.util.HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//该链为链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash);//转换为红黑树 break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果本身存在相同的 key，则将旧值返回 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount;//结构化修改次数加 1 if (++size &gt; threshold)//如果当前数量超过阈值，则进行扩容 resize(); afterNodeInsertion(evict);//默认为空实现 return null;//原先 key 不存在，也就是说没有旧值，直接返回 null&#125; get 函数的实现12345678910111213141516171819202122232425262728/** * 获取给定 key 的 hash 值，获取相应位置 value * */public V get(Object key) &#123; java.util.HashMap.Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final java.util.HashMap.Node&lt;K,V&gt; getNode(int hash, Object key) &#123; java.util.HashMap.Node&lt;K,V&gt;[] tab; java.util.HashMap.Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))//先检查对应位置的「头结点」，如果匹配直接返回对应的值 return first; if ((e = first.next) != null) &#123; if (first instanceof java.util.HashMap.TreeNode)//该链是红黑树，根据 hash 和 key 到 树中查找相应的 value,直接返回 return ((java.util.HashMap.TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //该链是链表，到链表中遍历查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 可以看到 get 方法的大致逻辑是这样的： 先计算出当前 key 的 hash 值，然后通过 getNode 方法去获取当前对应的结点 如果对应的节点为 null，直接返回 null， 否则返回节点中的 value。 getNode 方法的实现思路是这样的： 通过 hash 跟 当前容量进行 与运算 得到数组下标 使用指定下标去获取对应的节点（从头结点开始） 如果首个元素就命中，直接返回结点。 存在冲突：如果该 hash 值对应的是一棵红黑树，则到红黑树中去获取相应的结点。如果该 hash 值对应的是一个链表，则遍历该链表，直到取得相应的结点或者到达链尾。 hash 函数的实现在 HashMap 中，哈希桶数组 table 的长度 length 大小必须为 2 的 n 次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable 初始化桶大小为 11，就是桶大小设计为素数的应用（Hashtable 扩容后不能保证还是素数）。HashMap 采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。 通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。当 length 总是 2 的 n 次方时，h&amp; (length-1) 运算等价于对 length 取模，也就是 h%length，但是&amp;比%具有更高的效率。 h &amp; (length - 1) 《==》 h % length 在 JDK1.8 的实现中，优化了高位运算的算法，通过 hashCode()的高 16 位（其实是完整的） 异或 低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。 hash 是 int 类型的（32 位），原 hashcode 异或 右移 16 位后的 hashcode，高低位兼顾 右移 16 位，那么高 16 位均为 0，所以高十六位的取值均取决于 key 的 hashCode 高十六位， 低 16 位的值由 hashcode 的低十六位与高十六位 在 get 和 put 的过程中，计算下标时，先对 hashCode 进行 hash 操作，然后再通过 hash 值进一步计算下标，如下图所示： 在对 hashCode()计算 hash 时具体实现是这样的： 123456static final int hash(Object key) &#123; int h; //因为 h &gt;&gt;&gt; 16 右移了 16 位(高 16 位都为 0)，因此结果的高 16 位仍然是 key.hashCode() 的高 16 位 //而低 16 位取决于 key.hashCode() 的高十六位和低十六位进行异或的结果 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 可以看到这个函数大概的作用就是：高 16bit 不变，低 16bit 和高 16bit 做了一个异或。这样做的目的就在于你求余的时候包含了高 16 位和第 16 位的特性 也就是说你所计算出来的 hash 值包含从而使得你的 hash 值更加「随机」以降低碰撞的概率 计算下标存储结点时，计算得到的 hash 值可能远大于哈希桶数组的长度，为了避免数组越界，我们需要进行取模运算。计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)： 1(n - 1) &amp; hash 上面的计算实际上等价于hash % n，但是前者的效率比较高。前面我们提到过，HashMap 的数组长度一定是 2 的 ？次方。也就是说 (n - 1) 可以化为 0…0011…1，这样跟 hash 进行与运算，就相当于取模运算。 Java 8 所做的优化hash 函数设计得再好，也无法避免冲突的。如何解决冲突也是一门学问。 在 Java 8 之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行 get 时，两步的时间复杂度是 O(1)+O(n)。因此，当碰撞很厉害的时候 n 很大，O(n)的速度显然是影响速度的。 因此在 Java 8 中，当链表长度大于 8 时，就利用红黑树替换链表，这样复杂度就变成了 O(1)+O(logn)了，这样在 n 很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap 的性能提升一文中有性能测试的结果。 resize （扩容）实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 初始化或者扩容一倍 * */final java.util.HashMap.Node&lt;K,V&gt;[] resize() &#123; java.util.HashMap.Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;//旧长度 int oldThr = threshold;//旧阈值 int newCap, newThr = 0; //这一段用于确定新容量,并根据新容量重新确定阈值 if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//旧容量大于最大允许容量，将阈值赋值为最大允许容量 threshold = Integer.MAX_VALUE; return oldTab;//直接返回旧表 &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//扩容后小于允许的最大容量，且大于默认初始容量（16），则修改 threshold newThr = oldThr &lt;&lt; 1; // threshold 增大一倍 &#125; else if (oldThr &gt; 0) // 原有阈值大于 0，但是原容量小于 0 newCap = oldThr;//将新容量赋值为就旧阈值 else &#123; // 原阈值、原容量均为 0 ，使用默认的初始化参数来创建 map newCap = DEFAULT_INITIAL_CAPACITY;//默认的初始化容量 （16） newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//新的阈值 &#125; if (newThr == 0) &#123;//如果新阈值为 0 float ft = (float)newCap * loadFactor;//重新计算 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); //如果阈值大于最大容量，修改阈值为 int 的最大值(2^31-1)，这样以后就不会扩容了 &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) java.util.HashMap.Node&lt;K,V&gt;[] newTab = (java.util.HashMap.Node&lt;K,V&gt;[])new java.util.HashMap.Node[newCap];//按照新容量 创建数组 table = newTab; if (oldTab != null) &#123;//原有的 map 上的元素不为空，将原有 map 上面的数据复制到新的 map 上面 //遍历旧元素 for (int j = 0; j &lt; oldCap; ++j) &#123; java.util.HashMap.Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null;//释放，防止内存泄漏 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e;//该桶中只有一个元素，获取的 hash 值并与（新容量 -1）进行 与运算 else if (e instanceof java.util.HashMap.TreeNode)//如果该元素是一个树节点（说明该桶对应有一棵红黑树），将树存储到新数组上 ((java.util.HashMap.TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 保持顺序 //因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位 = low 位+原哈希桶容量 //低位链表的头结点、尾节点 java.util.HashMap.Node&lt;K,V&gt; loHead = null, loTail = null; //高位链表的头结点、尾节点 java.util.HashMap.Node&lt;K,V&gt; hiHead = null, hiTail = null; //临时结点 java.util.HashMap.Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123;//根据 hash 值与 oldCap 的运算结果，将链表中集结的元素分开，可认为结果是随机的 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //在原索引处存放 「低位链表」 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //在原索引加上原容量处，存放「高位链表」 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。 元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化： 因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图： 这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。 常见问题此部分内容参考自HashMap 的工作原理 1. 什么时候会使用 HashMap？他有什么特点？是基于 Map 接口的实现，存储键值对时，它可以接收 null 的键值，是非同步的，HashMap 存储着 Entry(hash, key, value, next)对象。 2. 你知道 HashMap 的工作原理吗？通过 hash 的方法，通过 put 和 get 存储和获取对象。存储对象时，我们将 K/V 传给 put 方法时，它调用 hashCode 计算 hash 从而得到 bucket 位置，进一步存储，HashMap 会根据当前 bucket 的占用情况自动调整容量(超过 Load Facotr 则 resize 为原来的 2 倍)。获取对象时，我们将 K 传给 get，它调用 hashCode 计算 hash 从而得到 bucket 位置，并进一步调用 equals()方法确定键值对。如果发生碰撞的时候，Hashmap 通过链表将产生碰撞冲突的元素组织起来，在 Java 8 中，如果一个 bucket 中碰撞冲突的元素超过某个限制(默认是 8)，则使用红黑树来替换链表，从而提高速度。 3. 你知道 get 和 put 的原理吗？equals()和 hashCode()的都有什么作用？通过对 key 的 hashCode()进行 hashing，并计算下标( n-1 &amp; hash)，从而获得 buckets 的位置。如果产生碰撞，则利用 key.equals()方法去链表或树中去查找对应的节点 4. 你知道 hash 的实现吗？为什么要这样实现？在 Java 1.8 的实现中，是通过 hashCode()的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在 bucket 的 n 比较小的时候，也能保证考虑到高低 bit 都参与到 hash 的计算中，同时不会有太大的开销。 5. 如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认 0.75)，则会重新 resize 一个原来长度两倍的 HashMap，并且重新调用 hash 方法。 参考资料与学习资源推荐 面试必备：HashMap 源码解析（JDK8） HashMap 的 hash 函数原理 重新认识 HashMap HashMap 的工作原理]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 垃圾收集器与内存分配策略]]></title>
    <url>%2Fblog%2F2017%2F09%2F08%2FJVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[确定回收的对象「死去」的对象即不可能再被任何途径使用的对象。 几乎所有对象的实例都存在堆中。（部分 String 对象存在于字符串常量池中，JDK1.7 以前，字符串常量池存放在方法区中）。 进行回收的第一步就是确定哪些对象还活着，哪些已经死亡。 引用计数算法给对象中添加一个引用计数器， 每当有一个地方引用它时，计数器值就加 1； 当引用失效时，计数器值就减 1； 任何时刻计数器为 0 的对象就是不可能再被使用的。 缺点：很难解决对象之间相互循环引用的问题。因此 Java 虚拟机中没有采用引用计数算法来管理内存。 可达性分析算法主流的商用程序语言的主流实现中，都是通过可达性分析来判断对象是否存活的。 算法的基本思路： 通过一系列的称为 GC Root 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为『引用链』（Reference Chain） 当一个对象到 GC Root 没有任何引用链相连时，则证明此对象是不可用的。 GC Root 对象的定义是什么？ Help - Eclipse Platform 上给的定义是这样的： A garbage collection root is an object that is accessible from outside the heap 也就是说 GC Roots 是可以从堆外访问的对象。由 Java 运行时数据区可以知道，堆外的空间有虚拟机栈、本地方法栈以及方法区。而java 1.8 将整个方法区被移到一个叫元空间的地方（使用本地内存存储） 所以GC Roots 对象包含以下几种： 虚拟机栈(栈帧中的本地变量表)中引用的对象，也就是局部变量引用的对象。 本地方法栈中 JNI 引用的对象，包括 本地方法栈中的局部变量或者参数 JNI全局引用 方法区中类静态属性引用的对象。由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。它们可以通过静态属性的方式持有对象的引用。注意，一般情况下由自定义的类加载器加载的类不能成为GC Roots 方法区中常量引用的对象 引用分类JDK 1.2 之后对，Java 对引用的概念进行了扩充（不再是仅有被引用或者没有被引用两种）： 共有四种： 强引用 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用 SoftReference 内存不够时被回收 在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。 弱引用 WeakReference 只要一执行 GC 就会被回收 虚引用，也称为幽灵引用、幻影引用 PhantomReference 『形同虚设』。一个对象被持有虚引用对其生命周期毫无影响 虚引用的作用仅仅是在该对象被回收时，收到一个系统通知而已 生存还是死亡一个对象的 finalize 方法最多只会被系统调用一次。 即使在可达性分析算法中不可达的对象，也并非是「非死不可」的，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与 GCRoots 相连接的引用链，那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为「没有必要执行」。 如果这个对象被判定为有必要执行 finalize 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。 这里所谓的「执行」是指虚拟机 会触发这个方法，但并不承诺会等待它运行结束，为什么要这么做？ 因为如果承诺得到 finalize 方法执行结束，那么当一个对象在 finalize 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。 finalize 方法是对象逃脱死亡命运的==最后一次机会==，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记， 如果对象要在 finalize 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出「即将回收」的集合； 如果对象这时候还没有逃脱，那基本上它就真的被回收了。 任何一个对象的 finalize 方法只会被系统调用一次。 回收方法区永久代的垃圾回收主要回收两部分的内容： 废弃常量 无用的类 回收废弃常量回收废弃常量与回收 Java 堆中对象很相似。以常量池中字面量的回收为例，假如一个字符串「abc」已经进入了常量池中，它没有被引用，如果这时发生内存回收，而且必要的话，这个「abc」常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 回收无用类类需要同时满足下面 3 个条件才能算是「无用的类」： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。 而且因为由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。所以正常情况下回收无用类收效甚微。 垃圾收集算法标记-清除算法标记-清除 (Mark-Sweep) 算法是最基础的收集算法，分为标记和清除两个阶段： 首先标记出所有需要回收的对象， 在标记完成后统一回收所有被标记的对象 之所以说它基础，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。 主要不足有两个： 效率问题：标记和清除两个过程的效率都不高； 空间问题（确切而言是空间碎片问题）：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 仅有 CMS 收集器使用了标记-清除算法。 复制算法复制算法主要是为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 商业虚拟机都采用复制收集算法来回收新生代，但并不是按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和==两块==较小的 ==Survivor== 空间，每次使用 Eden 和其中一块 Survivor，当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到==另外一块==Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。 HotSpot 虚拟机默认 Eden 和两块 Survivor 的大小比例是 8:1:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10%的内存会被「浪费」。当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。 缺点： 使用空间换取时间，这种算法将内存缩小为了原来的一半。 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种复制算法。 标记-==整理==算法「标记-整理」算法的标记过程仍然与「标记-清除」算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。(先移动到『安全位置』再清除掉安全区域边界外的无用位置) 分代收集算法目前商业虚拟机的垃圾收集都采用「分代收集」（Generational Collection）算法， 只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，因为对象存活率比较低，只需要付出少量存活对象的复制成本就可以完成收集。选用复制算法。 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用「标记-清理」或者「标记-整理」算法来进行回收。 HotSpot 的算法实现如何发起内存回收？首先要知道回收的哪些对象。 枚举根节点可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。 分析期间引用不可变导致 GC 停顿可达性分析对执行时间的敏感还体现在 GC 停顿 上，因为这项分析工作必须在一个能确保一致性的快照中进行。 「一致性」的意思是指在整个分析期间，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程（Sun 将这件事情称为「Stop The World」）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。 由于目前的主流 Java 虚拟机使用的都是准确式 GC，也就是说，虚拟机可以准确的知道内存中某个位置的数据类型是什么。所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机只要直接扫描存放对象引用的区域。 在 HotSpot 的实现中，使用一组称为 OopMap 的数据结构来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC 在扫描时就可以直接得知这些信息了。 使用空间换时间。 安全点从线程角度看，safepoint 可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，（就好像高速公路上的服务区，可以安全地停下来休息） 如果有需要，可以在这个位置暂停，比如发生 GC 时，需要暂停暂停所以活动线程， 但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待 GC 结束。（还在马路上，就不能休息，要到下一个服务区才能休息） 安全的选取安全点是怎么选的？基本上是以程序「是否具有让程序长时间执行的特征」为标准进行选定的。 「长时间执行」的最明显特征就是指令序列复用，例如：方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint。 GC 时让线程停止的方式如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都「跑」到最近的安全点上再停顿下来？ 这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）， 抢先式中断在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它「跑」到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。 主动式中断主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域安全区域是一个安全点连续的代码段。 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region， 那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。 （那些没标记为安全区域的怎么处理？） 在线程要离开 Safe Region 时，它要检查系统是否已经完成了==根节点枚举==（或者是整个 GC 过程）[因为其他步骤可能不需要 stop the world ] 如果完成了，那线程就继续执行， 否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。 垃圾收集器内存回收如何进行是由虚拟机所采用的 GC 收集器决定的，而通常虚拟机中往往不止有一种 GC 收集器。 如果说收集算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现。 虚拟机规范中对于垃圾回收器应该如何实现并没有任何规定。 图 3-5 展示了 7 种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。 我们选择的只是对具体应用最合适的收集器。 以下分析的关注点： 收集器的特点： 工作线程数? 工作过程中需不需要 stop the word？ 需要的话具体是哪个过程需要？ 能与哪个收集器搭配使用? Serial 收集器一个单线程的收集器。单线程指的是它用单条线程去完成垃圾收集工作 重点：在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。 实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。 优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器专心做垃圾收集自然可以获得最高的单线程收集效率。 Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择因为在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。 ParNew 收集器ParNew 收集器其实就是 Serial 收集器的多线程版本 是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。 两个名词：并发和并行。 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。 二者关系：并行是并发的一个子集 ParallelScavenge 收集器Parallel Scavenge 收集器是一个新生代收集器， 与 ParNew 很相似。但它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个==可控制==的吞吐量（Throughput）。实际上二者概念存在重叠的地方。因为 GC 过程中用户线程停顿时间缩短，那么吞吐量也就上去了，只不过要考虑用户代码执行时间与停顿时间的比例。 吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即 吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间），假设虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。注意：GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，这也直接导致垃圾收集发生得更频繁一些。停顿时间的确在下降，但吞吐量也降下来了。 GCTimeRatio 参数的值是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1/（1+19）），默认值为 99，就是允许最大 1 %（即 1/（1+99））的垃圾收集时间。 由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为「吞吐量优先」收集器。 Parallel Scavenge 收集器还有一个开关参数 -XX：+UseAdaptiveSizePolicy当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 ==GC 自适应的调节策略==（GC Ergonomics）。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。 SerialOld 收集器Serial Old 是 Serial 收集器的老年代版本，使用「标记-整理」算法。 这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。 如果在 Server 模式下，那么它主要还有两大用途： 一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用 另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集，并非直接使用了 Serial Old 收集器，但是这个 PS MarkSweep 收集器与 Serial Old 的实现非常接近。 ParallelOld 收集器Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和「标记-整理」算法。 这个收集器是在 JDK 1.6 中才开始提供的，此前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。因为 JDK1.6 以前只能选择 serial old 作为老年代收集器。（唯一能选择的队友不行） 直到 Parallel Old 收集器出现后，「吞吐量优先」收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 CMS 收集器CMS 收集器（Concurrent Mark Sweep）在 JDK1.5 时期被推出，这款收集器是 HotSpot 虚拟机中第一款真正意义上的==并发==收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作。 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。适合于交互型的应用。希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。从名字（包含「Mark Sweep」）上就可以看出，CMS 收集器是基于「标记—==清除==」算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤，包括： 初始标记（CMS initial mark） ,需要「Stop The World」仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快 并发标记（CMS concurrent mark）进行 GC RootsTracing 重新标记（CMS remark）,需要「Stop The World」为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 并发清除（CMS concurrent sweep） 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。通过图 3-10 可以比较清楚地看到 CMS 收集器的运作步骤中并发和需要停顿的时间。 缺点 对 CPU 资源非常敏感其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。 CMS 默认启动的回收线程数是（CPU 数量 + 3）/ 4， 也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25%的 CPU 资源，并且随着 CPU 数量的增加而下降。 但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大. 用户程序在 GC 过程中执行 缓慢的问题，推出了增量式 CMS（i-CMS），在并发标记、清除时让 GC 线程与用户线程交替执行，尽量减少 GC 线程独占资源的时间，虽然这样会导致整个垃圾回收过程变长。但是效果不明显，目前版本中已经不再推荐使用。 无法处理浮动垃圾（Floating Garbage）可能出现「Concurrent Mode Failure」失败而导致另一次 Full GC 的产生。 由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为「浮动垃圾」。 收集结束时会产生大量空间碎片。（因为使用了「标记-清除」算法）空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC 。 为了解决这个问题，CMS 收集器提供了一个-XX：+UseCMSCompactAtFullCollection 开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。 另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。 G1 收集器G1（Garbage-First）是一款面向服务端应用的垃圾收集器。它有以下几个优点： 并行与并发：G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短Stop-The-World停顿的时间 分代收集：不需要其他收集器配合就能独立管理整个 GC 堆，能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合：无内存碎片。与 CMS 的「标记—清理」算法不同，G1 从整体来看是基于「标记—整理」算法实现的收集器 从局部（两个 Region 之间）上来看是基于「复制」算法实现的 这两种算法都意味着G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。 可预测的停顿：降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别（其他收集器都是对整一个老年代或者新生代进行操作），它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。 之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 Region 不可能是孤立的。一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。那在做可达性判定确定对象是否存活的时候，岂不是还得扫描整个 Java 堆才能保证准确性？在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 ==Remembered Set== 来避免全堆扫描的。 G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。 当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 哪一块回收的收益大就选哪一块。 G1 的前几个步骤的运作过程和 CMS 有很多相似之处。 初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。 筛选回收阶段对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。 组合策略在进行 JVM 调优的过程中，并非任何一种新生代 GC 策略都可以和另一种年老代 GC 策略进行配合工作，所以，我们应该知道，哪些种组合可以有效地进行 GC，而且应该在什么样的应用场景下选择哪一种组合，如下表所示： 新生代 GC 策略 年老代 GC 策略 说明 组合 1 Serial Serial Old Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。 组合 2 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。 组合 3 ParNew CMS 使用-XX:+UseParNewGC 选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用-XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC 选项，则新生代默认使用 ParNew GC 策略。 组合 4 ParNew Serial Old 使用-XX:+UseParNewGC 选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。 组合 5 Parallel Scavenge Serial Old Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 组合 6 Parallel Scavenge Parallel Old Parallel Old 是 Parallel Scavenge 收集器的老年代版本。适用于注重吞吐量以及 CPU 资源敏感的场合 7 G1 G1 是 Garbage First 垃圾收集器。 理解 GC 日志GC 日志开头的 「[GC」和「[Full GC」说明了这次垃圾收集的==停顿类型==，而不是用来区分新生代 GC 还是老年代 GC 的。 如果有「Full」，说明这次 GC 是发生了 Stop-The-World 的，这段新生代收集器 ParNew 的日志也会出现「[Full GC」（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW）。 如果是调用 System.gc（）方法所触发的收集，那么在这里将显示「[Full GC（System）」。 接下来的「[DefNew」、「[Tenured」、「[Perm」表示 GC 发生的区域，这里显示的区域名称与使用的 GC 收集器是密切相关的， Serial 收集器中的新生代名为 「Default New Generation」，所以显示的是「[DefNew」。 如果是 ParNew 收集器，新生代名称就会变为「[ParNew」，意为 「Parallel New Generation」。 如果采用 Parallel Scavenge 收集器，那它配套的新生代称为「PSYoungGen」 内存分配与回收策略对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配*。少数情况下也可能会直接分配在老年代中， 注: TLAB 全称为 Thread Local Allocation Buffered 分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。以下为几条最普遍的内存分配规则。 对象优先在 Eden 分配、 大对象直接进入老年代、 长期存活的对象将进入老年代 、 动态对象年龄判定 、 空间分配担保 对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 Minor GC 和 Full GC 有什么不一样吗？ 新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。 老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。 虚拟机提供了一个-XX：PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制（复习一下：新生代采用复制算法收集内存）。 长期存活的对象将进入老年代为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。 对象在 Survivor 区中每「熬过」一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。 对象晋升老年代的年龄阈值，可以通过参数 -XX：MaxTenuringThreshold 设置。 动态对象年龄判定虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold中要求的年龄。 也就是说，同龄的小伙伴的内存大于总内存的一半。那么 &gt;= 该年龄的就算老了。 空间分配担保在发生 Minor GC 之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立，那么 Minor GC 可以确保是安全的。 如果不成立，则虚拟机会查看 Handlailure 设置值是否允许担保失败。 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象容量的==平均大小==， 如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 如果不成立，改为进行一次 Full GC 「冒险」是冒了什么风险？ 一句话就是：老年代的最大可用连续空间可能小于新生代所有存活对象总空间，就会导致 Full GC，本来是应该直接执行 Full GC 的，但是没有直接执行，导致浪费了时间。 具体而言：新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。 取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了 HandlePromotionFailure 失败，那就只好在失败后重新发起一次 Full GC。 虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将 HandlePromotionFailure 开关打开，避免 Full GC 过于频繁。 常见问题你能不能谈谈，GC 是在什么时候，对什么东西，做了什么事情？此问题摘自《深入理解 Java 虚拟机》作者的一篇博文详见 一个面试官对面试问题的分析 java的gc为什么要分代？答案可参考 R 大的这个回答 总结没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。 学习虚拟机内存知识，如果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。 参考资料与学习资源推荐 《深入理解 Java 虚拟机》 本文大部分内容都出自《深入理解 Java 虚拟机》 第三章，若文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 运行时数据区域与对象创建布局]]></title>
    <url>%2Fblog%2F2017%2F09%2F07%2FJVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[java 运行时数据区域根据《Java 虚拟机规范》规定，Java 虚拟机锁管理的内存包含以下以下几个运行时数据区域，如下图所示： 程序计数器程序计数器是线程私有的，各线程独立存储，以便线程切换后能恢复到正确的执行位置。可以看作是当前线程所执行的字节码的行号指示器。 如果正在执行的是一个 Java 方法，该计数器记录的是正在执行的虚拟机字节码指令的地址。 如果正在执行的是一个 Native 方法，则该计数器值为空。 ==此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域== Java 虚拟机栈Java 虚拟机栈是==线程私有的==。生命周期与线程相同。 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）。每一个方法从调用到执行都对应着一个栈帧在虚拟机栈中入栈和出栈的过程。 注：栈帧（Stack Frame ）是方法运行时基础数据结构，其中存储了局部变量表、操作数栈、动态链接、方法出口等信息。 平时所讲的栈内存，就是现在讲的 Java 虚拟机栈，或者说是虚拟机栈中局部变量表部分。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 SOF（Stack Over Flow） 异常 如果扩展时，无法申请到足够的内存，就会抛 OOMError 异常 本地方法栈发挥的作用与虚拟机栈相似。只不过一个是针对 Java 方法，一个是针对本地方法。 Java 堆对于大多数应用而言，Java 堆是 Java 虚拟机所管理的内存中最大的一块。同时它也是==所有线程共享==的一块内存区域。Java 虚拟机规定，Java 堆可以是物理上不连续的内存空间，只要逻辑上连续即可。 按照虚拟机规范中的描述，所有对象实例以及数组都要在堆上分配。不过随着 JIT 编译器的发展和逃逸分析技术的逐渐成熟，未来或许会有所改变。 从内存分配角度来看，线程共享的 Java 堆中可能会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不管怎么划分，其中存储的都是对象，进行划分的目的只是为了更好地回收/分配内存。 方法区方法区有一个别名：non-heap，与 Java 堆区分开来。它是==所有线程共享==的，用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。 Hotspot 虚拟机设计团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区。因为这样就不用专门为方法区编写内存管理的代码的工作。对于其他虚拟机而言是不存在永久代这个概念的。 使用永久代来实现方法区的好处在于可以直接像管理 Java 堆那样管理这部分内存，而不需要再专门为方法区编写内存管理代码。坏处在于这样更容易导致 OOM，因为永久代有 -XX：MaxPermSize 的上限。在 JDK 1.8 HotSpot 虚拟机的实现中已经将整个永久代移除，取而代之的是一个叫元空间（Metaspace）的区域。 当方法区无法满足内存分配需求时，将抛出 java.lang.OutOfMemoryError: PermGen space 。 运行时常量池Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。JDK 1.8 前运行时常量池是方法区的一部分。 虚拟机规范中对 Class 文件中的每一个部分的格式都有严格规定。但是对于运行时常量池，并没有做任何细节的要求。一般而言，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于 Class 文件常量池的的另一特征在于具备动态性。java 运行期间也可以把新的常量放入池中。比如使用 String.intern() 将堆中的字符串加入常量池中。 JDK1.7 中把原本放在永久代的字符串常量池移到 Java 堆中。常量池位置的不同影响到了 String 的 intern()方法的表现。不同版本的 JDK 使用「==」去比较 String 字符串的结果会有不同。具体情况可参考这篇文章——Java 技术——你真的了解 String 类的 intern()方法吗 Metaspace（元空间）介绍元空间之前先说点题外话。其实，移除永久代的工作从 JDK1.7 就开始了。JDK1.7 中，存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。譬如符号引用(Symbols)转移到了 native heap、字面量(interned strings)转移到了 java heap、类的静态变量(class statics)转移到了 java heap。但 JDK1.7 并没有完全移除将永久代完全移除。直到 JDK1.8 才将永久代完整地移除。 元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小： -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时 GC 会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 MaxMetaspaceSize 时，适当提高该值。 -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 如果本地空间的内存用尽了会收到java.lang.OutOfMemoryError: Metadata space 的错误信息。JDK1.8 中持久代相关的 JVM 参数 -XX:PermSize 及 -XX:MaxPermSize 将会被忽略掉。 为什么移除持久代？ 它的大小只能在启动时指定，运行时无法修改——很难进行调优。-XX:MaxPermSize，设置成多少好呢？ HotSpot 的内部类型也是 Java 对象：它可能会在 Full GC 中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。 简化 Full GC：每一个回收器有专门的元数据迭代器。 可以在 GC 不进行暂停的情况下并发地释放类数据。 使得原来受限于持久代的一些改进未来有可能实现 元空间的内存分配模型 绝大多数的类元数据的空间都从本地内存中分配 用来描述类元数据的类（klasses)也被删除了 分元数据分配了多个虚拟内存空间 给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些 归还内存块，释放内存块列表 一旦元空间的数据被清空了，虚拟内存的空间会被回收掉 减少碎片的策略 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。 JDK 1.4 新添加的 NIO（New Input/Output） 可以使用 Native 函数库直接分配堆外存，然后通过一个存储在 Java 堆中的 DireByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场合能够显著提高性能。 本机直接内存不受 Java 堆大小的限制，但是受到本机总内存的大小以及处理器寻址空间的限制。 HotSpot 虚拟机中对象创建、初始化与布局对象的创建类加载检查、判断遇到一条 new 指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载。 分配内存类加载检查通过后，将为新生对象分配内存。也就是划分出一块内存区域。 如果 java 堆中的内存是绝对规整的，那么会使用指针碰撞的分配方式 如果 java 堆中的内存不规整的，虚拟机必须维护一个列表，记录哪些内存块可用，在分配时从列表中，找到一块足够大的空间划分给对象。即，使用空闲列表的分配方式。 选择哪种分配方式由 java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞 而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。 线程安全问题：另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案： 一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性； 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。 哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。 虚拟机是否使用 TLAB，可以通过-XX：+/-UseTLAB 参数来设定。 对象的初始化此处的初始化指的是将分配到的内存空间初始化为零值。（不包括对象头）。如果使用 TLAB，该过程也可以提前至 TLAB 分配时进行。初始化为零值的操作保证了对象的实例字段在 Java 代码中可不赋初值就使用。 对象头的设置： 对象是哪个类的实例 如何才能找到类的元数据信息 对象的哈希码 对象的 GC 分代年龄等信息。 … 从虚拟机的视角来看，一个新的对象已经创建完毕。 但从 Java 程序视角来看，对象的创建才刚刚开始—— 方法还没有执行、所有字段都还为零. 一般来说（由字节码中是否跟随 invokespecial 指令所决定），执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局HotSpot 中，对象在内存中存储的布局可以分为 3 块区域： 对象头 Header 实例数据 Instance Data 对齐填充 Padding (并不是必然存在) 1. 对象头对象头包括两部分信息：第一部分为存储对象自身得运行时数据，第二部分为类型指针。 存储对象自身的运行时数据。如： 哈希码（HashCode） GC 分代年龄、 锁状态标志、 线程持有的锁、 偏向线程 ID、 偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit，官方称它为「Mark Word」。 对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 类型指针，即对象指向它的类元数据的指针，虚拟机通过该指针来确定这个对象是哪个类的实例。 如果对象是一个数组，那么对象头中还需要有一块用于记录数据长度的数据 因为从数据的元数据无法确定数组的大小 注意：并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身 比如：通过句柄访问对象 2. 实例数据接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。 无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。 HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers）， 可以看出，相同宽度的字段总是被分配到一起。 在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。 如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 3. 对齐填充对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说，就是对象的大小必须是 8 字节的整数倍。 对象的访问定位由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。 主流的访问方式有两种：1. 使用句柄，2. 使用直接指针 使用句柄访问： Java 堆中将会划分出来一块内存作为句柄池，reference 中就是存储了对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。 直接指针访问： 采用这种方式，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，而对象中包含了对象类型数据的地址信息。 对比 使用句柄访问优点：是 reference 中存储的是稳定的句柄地址，在对象被移动时，只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。 使用直接指针的最大好处就是速度更快，节省了一次指针定位需要的时间开销，由于 Java 对象访问十分频繁，这类开销积小成多后也是一项非常可观的执行成本。 Sun HotSpot 虚拟机使用的就是这种访问方式。 OutOfMemoryError 异常简析Java 堆溢出不断创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象。在对象总内存达到 -XmX:heapSize指定的值之后就会 OOM。 一般出现这种情况都是通过 MAT 工具来分析。确定是出现了内存泄漏，还是的最大堆空间的设置不合理。 如果是内存泄漏，可进一步通过工具来查看对象到 GC Roots 的引用链，找出内存泄漏的原因 如果不存在内存泄漏，即对象确实必须存活着，那就要检查虚拟机的堆参数（-Xmx 与 -Xms）与机器物理内存比较看是否还可以调大；同时也可以通过检查代码中是否存在一些对象的生命周期过长、持有状态时间过长的情况，尝试·减少程序运行期的内存消耗。 虚拟机栈和本地方法栈溢出在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈。栈容量只由 -Xss 参数设定。 关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常： 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 导致 SOF 的常见原因有递归、定义大量的局部变量等。 方法区和运行时常量池溢出可以通过在运行时产生大量的类去填满方法区。 由于 JDK1.7 把字符串常量池从方法区移到堆中，在不同的版本的 JDK中String.intern()方法的表现不一。 JDK1.6 中调用 String.intern() 方法时，会把首次遇到的字符串复制到永久代中。 JDK1.7 中调用 String.intern()方法时，不会再复制实例，只是在常量池中记录首次出现的实例引用 本机直接内存溢出可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，默认与 Java 堆最大值（-Xmx指定）一样 参考资料与学习资源推荐 Java8 内存模型—永久代(PermGen)和元空间(Metaspace) Java 8 的元空间 Java 8 的元空间英文原文 JAVA 8 ：从永久区（PermGen）到元空间（Metaspace） Java虚拟机（一）结构原理与运行时数据区域 《深入理解 Java 虚拟机(第 2 版)》 若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合框架之 ArrayList]]></title>
    <url>%2Fblog%2F2017%2F09%2F06%2FJava-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BArrayList%2F</url>
    <content type="text"><![CDATA[概要ArrayList 是一个动态数组，它是线程不安全的，允许元素为 null。它的底层数据结构是数组，ArrayList 实现了 List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 接口，其中 RandomAccess 代表了其拥有随机快速访问的能力，ArrayList 可以以 O(1) 的时间复杂度去根据下标访问元素。 时间、空间效率因为数组内存的连续，可以根据下标以 O1 的时间改查元素，因此时间效率很高 同样也因为数组要占据一块连续的内存空间，所以它也有数组的缺点——空间效率不高。 性能当集合中的元素超出容量时，会进行扩容操作，扩容操作是一个性能消耗较大的地方，所以如果能预知数据的规模，最好在初始化时通过 public ArrayList(int initialCapacity) 构造方法指定 ArrayList 的大小，来构造 ArrayList 实例，以减少扩容次数，提高效率。 在添加大量元素前，应用程序也可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量，这可以减少递增式再分配的数量。 不过该方法是 ArrayList 中添加的，List 中没有该方法。所以如果声明的类型为 List 的话，需要进行强转。((ArrayList)list).ensureCapacity(number); 当每次修改结构时(添加或者删除元素)，都会修改 modCount。 成员变量123456789101112131415private static final int DEFAULT_CAPACITY = 10;//默认初始容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//空对象数据，用于空对象，如果指定初始容量为 0 就给元素附一个空对象/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//共享的空数组对象，使用该对象用以区分 EMPTY_ELEMENTDATA，从而知道第一次添加元素时，应该初始化的数组长度。transient Object[] elementData; // 之所以不声明为 private 是为了简化内部类访问，// 所有原本为默认容量的空数组，在第一次添加元素的时候都会被初始化为长度为默认容量的数组private int size;//包含元素的数量 构造方法ArrayList 提供了三种方式的构造器，可以构造一个默认初始容量为 10 的空列表、构造一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。 123456789101112131415161718192021222324252627public ArrayList(int initialCapacity) &#123;//按照指定的初始容量初始化 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity];//创建数组 &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA;//如果指定初始容量为 0 就给元素附一个空对象 &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity); &#125;&#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//初始化一个初始容量为 10 的 ArrayList&#125;//构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。public ArrayList(Collection&lt;? extends E&gt; c) &#123;//从给定的容器中构建一个 ArrayList elementData = c.toArray();//将容器对象中的元素转换为数组 if ((size = elementData.length) != 0) &#123;//长度不为 0，进行判断操作 // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);//如果返回的数组不是 Object[].class 类型的，则进行将数组元素复制到类型为 Object 数组上 &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA;//长度为 0，则将空数组对象赋值给元素数组 &#125;&#125; 这里要注意的是第三个构造方法中对数组元素类型的判断 12345if (elementData.getClass() != Object[].class)&#123; elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; else&#123; //...&#125; 虽然表面上看起来，c.toArray() 会返回一个 Object[] 对象数组，但是它指向的实际类型并不一定是 Object[]，这样当我们调用 objList[i] = new Object(); 就会报错 。 比如说如果我们有 1 个 List stringList 对象，当我们调用Object[] objectArray = stringList.toArray()的时候， objectArray 只能存放 String 类型的数据而不能存储其他类型的对象。 增 ArrayList 提供了 add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。 1234567891011121314151617181920212223/** * 添加元素到列表尾部。 * 先确认 ArrayList 的容量 * 每次 add 之前，都会判断 add 后的容量，是否需要扩容。 * */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! 确保容量足以容纳原有元素加上新增的元素 elementData[size++] = e; return true;&#125;/** * 添加元素到列表指定位置。需要将该位置右端的所有元素都往右移动一个单位 * 先确认 ArrayList 的容量 * */public void add(int index, E element) &#123; rangeCheckForAdd(index);//上下界判断 ensureCapacityInternal(size + 1); // Increments modCount!! 判断 add 之后的容量，根据情况进行扩容 System.arraycopy(elementData, index, elementData, index + 1,// 将 index ~ size-1 范围内的元素复制到 index+1 ~ size 范围中。也就是将 index 及其以后的元素后移一个位置 size - index); elementData[index] = element;//将给定元素添加到指定元素中 size++;//元素数量 + 1&#125; 12345678910111213141516171819202122232425262728293031/** * 添加给定集合中的所有元素到 ArrayList 中 * */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray();//先转换为数组 int numNew = a.length;//要添加的元素数量 ensureCapacityInternal(size + numNew); // Increments modCount，确保容量足够容纳新添加的所有元素 System.arraycopy(a, 0, elementData, size, numNew);//将元素添加到列表尾部 size += numNew; return numNew != 0;&#125;/** * 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。 * */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index);//检查上下界 Object[] a = c.toArray();//转换为数组 int numNew = a.length;//增加的数量 ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index;//要移动的元素数 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved);//移动数组中需要移动的元素 System.arraycopy(a, 0, elementData, index, numNew);//插入元素 size += numNew; return numNew != 0;&#125; 删ArrayList 提供了根据下标或者指定对象两种方式的删除功能。 1234567891011121314151617/** * 移除指定位置的元素 * */public E remove(int index) &#123; rangeCheck(index);//上界判断 modCount++;//结构修改次数 + 1 E oldValue = elementData(index); int numMoved = size - index - 1;//移动的元素总数 if (numMoved &gt; 0) System.arraycopy(elementData, index + 1, elementData, index,// numMoved);//将要删除的元素的后面的所有元素往前移一个单位 elementData[--size] = null; // clear to let GC do its work 将末元素置为 null，以免内存泄漏 return oldValue;//返回删除掉的值&#125; 123456789101112131415161718192021/** * 移除此列表中首次出现的指定元素（如果存在的话）。 * 先找到指定元素在数组中的位置，然后再调用 fastRemove 删除 * */public boolean remove(Object o) &#123; // 由于 ArrayList 中允许存放 null，因此下面通过两种情况来分别处理。 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 12345678910111213141516/** * 删除 [fromIndex，toIndex) 范围中的所有元素 * */protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex - fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125; 1234567/** * 移除 ArrayList 中给定指定集合中的所有元素。 * */public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125; 123456789101112131415161718192021222324252627282930313233343536/** * 批量删除 * complement 为 false 时，删除指定集合 c 中所有的元素。 * complement 为 true 时，删除指定集合 c 中以外的所有的元素。 * */private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;// complement 为 true 时为补集 final Object[] elementData = this.elementData;//将数组引用赋给 elementdata,节省空间 int r = 0, w = 0; boolean modified = false; try &#123; //遍历，把要保存的元素存在前面 for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement)//存储要保留的元素。集合 c 中是否包括该元素 == 删除补集？ elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123;// 此段代码作用为：当 c.contains 抛出异常时（此时 r &lt; size ），保持与 AbstractCollection 的行为兼容性 System.arraycopy(elementData, r, elementData, w, size - r);//将后面的元素移动到 w 后面 w += size - r;//加上移动的元素数，获取「最后的元素」的下标 &#125; if (w != size) &#123;//清除引用，防止内存泄漏 // clear to let GC do its work for (int i = w; i &lt; size; i++)//将 w 之后的元素都置为 null elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 性能注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。 查/获取 获取此列表中指定位置上的元素。 12345public E get(int index) &#123; rangeCheck(index); checkForComodification(); return java.util.ArrayList.this.elementData(offset + index);&#125; 小结、对比改1234567public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = java.util.ArrayList.this.elementData(offset + index); java.util.ArrayList.this.elementData[offset + index] = e; return oldValue;&#125; 对比调整数组容量扩容123456789101112131415161718192021222324252627282930313233343536public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;/** * 内部保证容量，如果 ArrayList 是通过无参构造函数创建的， * 那么第一次 add 元素的时候就会调用该方法扩容 * */private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;/** * 确保分配指定的容量 * */private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //如果指明的最小容量超过数组的长度，就增大容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 每次数组容量的增长大约是其原容量的 1.5 倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造 ArrayList 实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用 ensureCapacity 方法来手动增加 ArrayList 实例的容量。 「压缩」 ArrayList 还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过 trimToSize 方法来实现。代码如下： 12345678910//将 ArrayList 的容量压缩到当前元素数量，这样可以最大限度节省空间public void trimToSize() &#123; modCount++;//定义与父类 AbstractList 中，记录发生结构化修改的次数。如果不打算提供「快速失败的迭代器」，可忽略此域 if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; Fail-Fast 机制ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考我之前的文章深入 Java 集合学习系列：HashMap 的实现原理 中的 Fail-Fast 机制。 快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 java.util 包下的都是快速失败。 安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。 在 java.util.concurrent 包下的全是安全失败的。 即 抛异常是快速失败（util 包下都是快速失败），不抛异常是安全失败。 Java 版本越往后越「安全」，concurrent 包下面全部为安全失败 总结可以看到核心操作在于增加和删除元素。 增删改查中， 增导致扩容，则会修改 modCount，删一定会修改。 改和查一定不会修改 modCount。 扩容操作会导致数组复制，批量删除会导致找出两个集合的交集，以及数组复制操作，因此，增、删都相对低效。 而 改、查都是很高效的操作。 因此，结合特点，在使用中，以 Android 中最常用的展示列表为例，列表滑动时需要展示每一个 Item（element）的数组，所以 查 操作是最高频的。相对来说，增操作只有在列表加载更多时才会用到 ，而且是在列表尾部插入，所以也不需要移动数据的操作。而删操作则更低频。 故选用 ArrayList 作为保存数据的结构。 和Vector的区别，Vector内部也是数组实现的，区别在于Vector在 API 上都加了synchronized所以它是线程安全的，以及Vector扩容时，是翻倍 size，而ArrayList`是扩容 50%。 参考资料与学习资源推荐 面试必备：ArrayList 源码解析（JDK8） 深入 Java 集合学习系列：ArrayList 的实现原理 Java ArrayList 工作原理及实现 若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>Java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码中的装饰者模式]]></title>
    <url>%2Fblog%2F2017%2F09%2F05%2FAndroid-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰者模式的定义装饰模式（Decorator Pattern） 也称包装模式（Wrapper Pattern），是结构型设计模式之一，使用一种对客户端透明的方式来动态地拓展对象的功能，同时它也是继承关系的一种替代方案之一。 通过装饰者模式可以动态地给一个对象添加一些额外的职责。就增加功能而言，装饰模式相比生成子类更灵活。因为它装饰者持有一个被装饰者的引用，因此可以方便地调用具体被装饰者对象中的方法，因此可以在不破坏原类层次结构的情况下为类增加一些功能，我们只需要在被装饰者对象的相应方法前后增加相应的功能逻辑即可。 使用场景需要透明且动态地拓展类的功能时。 UML 类图 Component 抽象组件 可以是接口或者抽象类，充当一个被装饰的原始对象。（在该模式中位于继承结构的顶部，大家都直接/间接地继承它） ConcreteComponent 组件具体实现类 该类是 Component 类的具体实现，也是我们装饰的具体对象。 Decorator 抽象装饰者 继承自 Component 并且必须持有一个指向 Component 的引用 通常会在其方法中调用 ConcreteComponent 的方法。 如果装饰逻辑单一，可以直接省略该类，直接写一个具体的装饰者对象即可。 ConcreteDecoratorA,B,C 继承自 Decoration， 在父类对 Component 的方法调用基础上上，增加自己的一些功能。（通常都是在基础方法执行前或者后调用自己新增的方法） 使用时经常会把 ComponentImpl 或者说 ConcreteComponent 传入给具体的 Decorator。 123Compoent component = new ConponentImpl();DecoratorImpl decoratorImpl = new DecoratorImpl(component);decoratorImpl.xxOperation(); Android 源码中的模式实现 角色简介： Context ：抽象组件 ComtextImpl ：Context 的具体实现类 ContextWrapper ：装饰者的父类（其中的所有方法都只是调用了 ContextImpl 中对应的方法） ContextThemeWrapper ：继承自 ContextWrapper 的装饰者 Activity ：继承自 ContextThemeWrapper 的装饰者 我们以常用的方法为例，看看装饰者模式在其中的具体实现方式 123456789101112131415161718192021222324252627public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; //启动 Activity @Override public void startActivity(Intent intent, Bundle options) &#123; mBase.startActivity(intent, options); &#125; //发送广播 @SystemApi @Override public void sendBroadcast(Intent intent, String receiverPermission, Bundle options) &#123; mBase.sendBroadcast(intent, receiverPermission, options); &#125; //注册监听器 @Override public Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter); &#125;&#125; 从以上的代码中可以看出，ContextWrapper 作为装饰者的父类，持有 Context 的引用 mBase（mBase 的实际类型为 ContextImpl），其中的所有方法都只是调用了 ContextImpl 中对应的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class ContextImpl extends Context &#123; //启动 Activity 的逻辑实现 @Override public void startActivity(Intent intent) &#123; warnIfCallingFromSystemProcess(); startActivity(intent, null); &#125; @Override public void startActivity(Intent intent, Bundle options) &#123; warnIfCallingFromSystemProcess(); // 代码省略 //调用 Instrumentation.execStartActivity() 方法 mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options); &#125; @Override public void sendBroadcast(Intent intent, String receiverPermission) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); String[] receiverPermissions = receiverPermission == null ? null : new String[] &#123;receiverPermission&#125;; try &#123; intent.prepareToLeaveProcess(this); //调用 AMS 的 broadcastIntent 方法 ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; //注册广播的方法 public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; return registerReceiver(receiver, filter, null, null); &#125; //注册广播 @Override public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) &#123; return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext()); &#125; //注册广播的具体实现 private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; //调用 AMS 的 registerReceiver 方法 final Intent intent = ActivityManagerNative.getDefault().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125; 可以看到，ContextImpl 中提供了具体的方法实现。 ContextWrapper 的子类，例如 Activity 会根据需要对具体方法的实现进行装饰或者修改。 比如 startActivity() 方法，Activity 没有使用被装饰者的实现，而是自己实现了一套逻辑。 123456789101112131415161718192021222324252627282930313233public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, WindowControllerCallback &#123; @Override public void startActivity(Intent intent) &#123; this.startActivity(intent, null); &#125; @Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125; public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); //调用 Instrumentation.execStartActivity() 方法 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); //代码省略 &#125;&#125; ContextImpl 的创建从上面解析中我们知道 Context 的实现中使用了装饰者模式也知道了 ContextImpl 是 Context 具体实现类，但是 ContextImpl 是在上面地方被初始化的呢？ 我们猜想 Activity 启动之后我们便可以调用 Context 中的方法了，我们猜想 ContextImpl 是在 Activity 创建过程中初始化的。 对 Android FrameWork 层有所了解同学应该知道 Activity 是由 AMS 管理的，AMS 会通过调用 ApplicationThread 与间接地控制 Activity。 ApplicationThread 的 scheduleXxx 方法中会调用 sendMessage 方法将相应的 Message 发送给 H，H 根据不同的 Message 调用 ActivityThread 中相应的 handleXxx 方法。 ActivityThread#H 12345678910111213141516private class H extends Handler &#123; //代码省略 public void handleMessage(Message msg) &#123; //代码省略 switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); //调用 handleLaunchActivity handleLaunchActivity(r, null, "LAUNCH_ACTIVITY"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; //代码省略&#125; 当需要启动新的 Activity 时，ApplicationThread 的 scheduleLaunchActivity 方法会先被调用，该方法会通过 H 调用 handleLaunchActivity 方法，而 handleLaunchActivity 方法又会调用 performLaunchActivity 方法。 ActivityThread#performLaunchActivity 1234567891011121314151617181920212223242526private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //代码省略 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //创建 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; //获取 Context Context appContext = createBaseContextForActivity(r, activity); //将前面准备的值关联到 Activity 中 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); //代码省略 &#125; return activity;&#125; ActivityThread#createBaseContextForActivity 12345678private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; ContextImpl appContext = ContextImpl.createActivityContext(//调用 ContextImpl 的静态方法创建 Activity Context this, r.packageInfo, r.token, displayId, r.overrideConfig); appContext.setOuterContext(activity);//外部的 context（此处为 Activity）设置给 ContextImpl Context baseContext = appContext; //代码省略 return baseContext;&#125; ContextImpl#createActivityContext() 1234567static ContextImpl createActivityContext(ActivityThread mainThread, LoadedApk packageInfo, IBinder activityToken, int displayId, Configuration overrideConfiguration) &#123; if (packageInfo == null) throw new IllegalArgumentException("packageInfo"); return new ContextImpl(null, mainThread, packageInfo, activityToken, null, 0, null, overrideConfiguration, displayId);&#125; 经过上面的分析，我们可以得出结论，Activity 的 Context 是在 performLaunchActivity 方法中通过调用 createBaseContextForActivity 初始化的。在 createBaseContextForActivity 方法中，通过调用 ContextImpl 的静态方法 createActivityContext 创建 获取一个 ContextImpl 的实例对象，并通过 setOuterContext 方法将两者建立关联。 总结学过代理模式的同学可能觉得装饰模式与代理模式有点像（因为同样持有引用）。但是既然是它们是两个不同的设计模式，先看看它们的格子的定义。 装饰模式：以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；代理模式：给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用； 光看定义可能还是比较模糊。二者区别在哪里呢？ 装饰模式应该为所装饰的对象增强功能 代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。 可以简单地理解为：你在一个地方写装饰，大家就知道这是在增加功能，你写代理，大家就知道是在限制。 参考资料与学习资源推荐 《Android 源码设计模式解析与实战》]]></content>
      <categories>
        <category>并发</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码中的享元模式——Message 复用原理]]></title>
    <url>%2Fblog%2F2017%2F08%2F26%2FAndroid-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Message%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[介绍享元模式是对象池的一种实现，它的英文名为 Flyweight，代表轻量级的意思。 享元模式用来尽可能==减少内存使用量==，它适合用于可能存在大量对象的场景，来==缓存可共享的对象==（例如 Message、Java 中的字符串常量池）,从而实现对象共享、避免创建过多对象的效果，这样一来就可以提升性能，避免内存移除等。 享元模式中的部分状态是可以共享的， 可以共享的状态称为内部状态。内部状态不会随着环境变化 不可共享的状态则称之为外部状态，他们会随着环境的改变而改变。 享元模式会建立一个对象容器，在经典的享元模式中，该容器为一个 Map，它的键是享元对象的内部状态，它的值就是享元对象本身。 享元模式的定义享元模式是一种结构型设计模式，以共享的方式高效地支持大量的细粒度对象。 使用场景 系统中存在大量的相似对象 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。 需要缓冲池的场景。 UML 类图 Flyweight ：享元对象抽象基类或者接口。 ConcreteFlyweight：具体享元对象。 FlyweightFactory ：享元工厂，负责创建享元对象和管理享元对象池。 Android 源码中的享元模式在使用 Handler 发送消息之前，我们一般都会使用如下代码调用 mHandler.obtainMessage() 方法获取一个 Message 对象。这其中究竟是怎么实现的呢？ 1234567891011121314Handler mHandler = new Handler();public void do() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //do sth Message message = mHandler.obtainMessage(); message.what = 1; message.obj = result; mHandler.sendMessage(message); &#125; &#125;);&#125; 1234//Handler.otainMessage()方法public final Message obtainMessage()&#123; return Message.obtain(this);&#125; 可以看到 Handler.obtainMessage() 实际上调用的是 Message 的 obtain 方法，我们顺着源码看下去。 先看看 Message 类部分源码 1234567891011121314151617181920212223242526272829// sometimes we store linked lists of these thingsMessage next;private static final Object sPoolSync = new Object();//作为锁对象private static Message sPool;//虽然名称为 sPool 但是实际上是一个指向消息队列队首的指针private static int sPoolSize = 0;//private static final int MAX_POOL_SIZE = 50;//「对象池」中的最大数量public static Message obtain(Handler h) &#123; Message m = obtain();//调用 obtain 方法获取 message 对象 m.target = h;//指定 message 的目标对象 return m;&#125;//从消息对象池中取出一个 Message 对象，如果没有就创建一个public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // 清空 in-use flag sPoolSize--; return m; &#125; &#125; return new Message();//消息池中没有可复用的 Message 就创建一个新的 Message&#125; 至此，从对象池中获取对象的大致流程。无论是 Handler.obtainMessage(参数列表) 方法，还是 Message 的 obtain(参数列表) 方法，最终都会调用 Message.obtain() 方法。在 Message.obtain() 方法的实现中，会先从对象池中获取 Message 对象，如果获取不到，则创建一个新的 Message 对象，然后返回。该对象在后续的执行过程中会被回收到对象池，以便复用。 但是 Message 对象是如何被回收到「对象池」中的呢？ 从 Message 类的部分代码中我们看到 sPool 的实际类型是一个 Message 对象，而不是一个容器。另外从 obtain 方法中我们不难看到链表的踪影。难道消息池是使用链表实现的吗？ 在 AS 中打开 Message 类的结构图，可以看到其中有一个 recycle 方法，我们看看里面是怎么实现的。 123456789101112131415161718192021222324252627282930313233343536public void recycle() &#123; if (isInUse()) &#123;//判断消息是否还在使用 if (gCheckRecycle) &#123;//如果消息处在使用状态时被 gc 回收，就抛出异常 throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); &#125; return;//直接返回，取消回收操作 &#125; recycleUnchecked();//调用回收方法&#125;/** * 回收一个可能还在使用的对象 */void recycleUnchecked() &#123; // 只要该对象还在回收对象池中，就标记该对象为正在使用状态。 // 清空其他状态 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; //回收消息到消息池中 synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; recycle 方法首先会判断 Message 对象是否处在使用状态。如果处在使用状态会直接返回（如果此时 GC 回收该对象会抛出异常），否则调用 recycleUnchecked 方法，具体的回收逻辑是在 recycleUnchecked 方法中实现的。首先会标记 Message 处于使用状态，然后清空对象中的其他状态。将消息存入回收池，主要是链表的操作。大致如下图所示。 小结Message 通过在内部构建一个链表来维护一个被会受到 Message 对象的对象池，当用户调用 obtain 方法时，会优先从池中获取。如果池中没有可以复用的对象就创建一个新的对象，该对象使用完之后，会被缓存到对象池中，当下次调用 obtain 方法时，他们就会被复用。 此处 Message 扮演了三个角色。既是 FlyWeight 抽象，又是 ConcreteFlyWeight 对象，同时还担任 FlyWeightFactory 角色，承担着管理对象池的职责。 想进一步了解 Android 消息机制的同学可参考Android 消息机制解析。 总结享元模式的优点： 大幅度降低了内存中对象的数量。从而降低了内存的占用，提高了程序的性能。 缺点： 使得系统更加复杂。为了使应用能够共享，需要将一些状态外部化，这使得程序的逻辑复杂化。 享元模式将状态外部化，而读取外部状态使得运行时间稍微变长 参考资料与学习资源推荐 《JAVA 与模式》之享元模式 《Android 源码设计模式解析与实战》 Android 消息机制解析 若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>设计模式</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码中的模板方法模式——AsyncTask解析]]></title>
    <url>%2Fblog%2F2017%2F08%2F24%2FAndroid-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AsyncTask%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言假设我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的。就好像执行程序的流程： 检查代码的正确性 链接相关代码 编译相关代码 执行程序 对于不同的语言，上述 4 个步骤都是不一样的，但是它们的执行流程是固定的，这类问题的解决方案就是我们介绍的模板方法模式。 模板方法模式的定义定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式的使用场景 多个子类有公有的方法，并且逻辑基本相同时。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，把相同的代码抽取到父类中，然后通过钩子方法约束其行为。 注：何谓钩子方法？基本方法又可以分为三种：抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。 这是《java与模式》书里的一种说法，三种方法也是在书中的模板方法模式中提及到的。 先说这个三个方法的基本定义： 抽象方法：由抽象类声明，由具体子类实现。在java语言里一个抽象方法以abstract关键字标示出来。 具体方法：由抽象类声明并实现，而子类并不实现或覆盖。其实就是一般的方法，但是不需要子类来实现。 钩子方法：由抽象类声明并实现，而子类也会加以扩展。通常抽象类给出的是一个空的钩子方法，也就是方法体为空的方法（也可以根据需要实现部分逻辑）。其实它和具体方法在代码上没有区别，不过是意识上的一种区别。 详见抽象方法 具体方法 钩子方法 模板方法模式的 UML 类图 AbsTemplate：抽象类，定义一套算法框架 ConcreteImplA：具体实现类 A ConcreteImplB：具体实现类 B 模板方法模式的简单示例实际上是封装一个固定流程，就像是一套执行模板一样，第一步该做什么，第二步该做什么都已经在抽象类中定义好。而子类可以有不同的算法实现，在框架不被修改的情况下实现某些步骤的算法替换。 Android 源码中的模板方法模式AsyncTask使用过 AsyncTask 的同学都知道，我们调用 execute 之后，（如果没有调用 cancel 方法的话）以下三个方法会依次执行： onPreExecute doInBackground onPostExecute 为什么能让它们依次执行呢？其内部是怎么实现的？我们看看源码，一探究竟。 首先看看异步任务的入口方法 execute。123456789101112131415161718192021222324252627282930 @MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 以上两个构造方法中主要做了如下几件事： 状态判断 判断之后执行 onPreExecute(); 使用线程池执行 mFuture 什么样的线程池？ 默认为 SerialExecutor 单线程的线程池 123456789101112131415161718192021222324252627282930313233343536public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);//设置进程优先级 //noinspection unchecked result = doInBackground(mParams);//调用 doInBackground 方法 Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result);//调用 postResult 方法 &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get());//任务完成 &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occurred while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 12private final WorkerRunnable&lt;Params, Result&gt; mWorker;private final FutureTask&lt;Result&gt; mFuture; mWorker 类型为 WorkerRunnable&lt;Params, Result&gt; ， WorkerRunnable 实现了 Callable mFuture 类型为 FutureTask&lt;Result&gt; 简而言之，这个 mFuture 包装了这个 mWorker 对象，而 mFuture 是在线程池中执行的，会调用 mFuture 的 run 方法，该 run 方法中调用了 mWorker 的 call 方法，mWorker 的 call 方法又调用了 doInBackground 方法，所以 doInBackground 是在工作线程执行的。 123456private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125;&#125; doInBackground 执行完成后会通过 postResult(result) 方法将结果传递给主线程。 postResult(result) 可能通过 call 方法的 finally 块直接调用或者通过 FutureTask 中的 done 方法里面的 postResultIfNotInvoked(get()); 来间接调用。 接下来我们看看 postResult(result) 方法1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // 调用 AsyncTask 的 finish 方法 result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; postResult(result) 方法就是通过发送一条消息（msg.what == MESSAGE_POST_RESULT）给 sHandler，sHandler 为 InternalHanlder。当 InternalHanlder 接收到 MESSAGE_POST_RESULT 时，就会调用 result.mTask.finish(result.mData[0]) 方法，result 的类型为 AsyncTaskResult 123456789private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 从 AsyncTaskResult 的具体实现中吗，我们知道 mTask 就是 AsyncTask，finish 方法中又调用了 onPostExecute ，此时整个执行流程就完成了。 小结execute 方法内部封装了 onPreExecute、doInBackGround、onPostExecute 这个逻辑流程。通过这种方式，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时的操作及更新 UI。实际上就是通过线程池来执行耗时的任务，得到结果之后，通过 Handler 将结果传递给 UI 线程执行。 Activity 的生命周期函数除了 AsyncTask 以外，Android 源码中还有不少地方有模板方法的身影，比如说 Activity 的生命周期方法—— onCreate 、onStart、onResume 等，都是按照顺序调用的，我们会在对应的方法中执行合适的操作。 其内部实现涉及到进程间通信，限于篇幅，本文不作深入介绍。有兴趣的同学可以看看 ActivityThread 的 main 方法，以之作为入口，对生命周期方法的调用时机做进一步研究。 模板方法总结简单概括模板方法模式就是流程封装。把某一个固定的流程封装到一个固定的 final 方法中。并且让子类能够定制这个过程中的某些甚至所有步骤，这就要求父类提取共用的代码，提升代码的复用率，同时也带来了更高的可扩展性。 优点： 封装不变的部分，扩展可变的部分 提取公共部分代码，便于维护。 缺点： 提高了代码阅读的难度，会让用户觉得难以理解 参考资料与学习资源推荐 《Android 源码设计模式解析与实战》 抽象方法 具体方法 钩子方法 若有不正之处请多多谅解，欢迎批评指正。]]></content>
      <categories>
        <category>设计模式</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型设计模式之备忘录模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[备忘录模式的定义备忘录模式是一种行为型设计模式，该模式用于保存对象当前的状态，并且在之后可以再次恢复到此状态。 实现效果为：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便后续将对象恢复到原来的状态。 备忘录模式的使用场景 需要保存一个对象在某一个时刻的状态或部分状态 一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。（如果使用接口来让其他对象获取对象的状态，会破坏封装性） 备忘录模式的UML类图 三个角色： Originator：需要保存状态的对象。负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。 Memento（类似于 pojo 类）备忘录角色。用于存储 Originator 内部状态，并且可以防止 Originator 以外的对象访问 Memento Caretaker：负责存储备忘录，不能对备忘录的内容进行操作和访问，只能将备忘录传递给其他对象。 Android源码中的备忘录模式日常开发中如果需要保存什么数据以防止 Activity 意外销毁，第一时间会想到 Activity 中的这两个方法——onSaveInstanceState、onRestoreInstanceState。其内部具体是如何实现数据保存的呢？ 先透漏一下，这里面使用到了备忘录模式。 123456789101112protected void onSaveInstanceState(Bundle outState) &#123; //1. 存储窗口的视图树的状态 outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); //2. 存储 Fragment 中的状态 Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; //3. 若用户设置了 Activity 的 ActivityLifeCycleCallbacks， //则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。 getApplication().dispatchActivitySaveInstanceState(this, outState);&#125; Activity.onSaveInstanceState 方法中主要做了三件事 存储窗口的视图树的状态 存储 Fragment 中的状态 若用户设置了 Activity 的 ActivityLifeCycleCallbacks，则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。 首先看看步骤 1，该步骤将 Window 对象中的视图树中的各个 View 状态存储到 Bundle 中。 Window 的具体实现在 PhoneWindow 中.以下为 PhoneWindow.saveHierarchyState 的具体实现。 12345678910111213141516171819202122232425262728293031public Bundle saveHierarchyState() &#123; Bundle outState = new Bundle(); if (mContentParent == null) &#123; return outState; &#125; // SparseArray 相当于一个 key 为 整型的 map SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;(); //此处的 mContentParent 就是我们 setContentView 时设置的 View mContentParent.saveHierarchyState(states); outState.putSparseParcelableArray(VIEWS_TAG, states); // 持有焦点的 View 必须设置 id，否则重新进入该界面时不会恢复它的焦点状态 final View focusedView = mContentParent.findFocus(); if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) &#123; outState.putInt(FOCUSED_ID_TAG, focusedView.getId()); &#125; // 存储整个面板的状态 SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;(); savePanelState(panelStates); if (panelStates.size() &gt; 0) &#123; outState.putSparseParcelableArray(PANELS_TAG, panelStates); &#125; // 保存 actionbar 的状态 if (mDecorContentParent != null) &#123; SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;(); mDecorContentParent.saveToolbarHierarchyState(actionBarStates); outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates); &#125; return outState;&#125; 看看步骤 2 中的 mContentParent.saveHierarchyState 方法，mContentParent 是一个 ViewGroup 但是 saveHierarchyState 方法并不是定义在 ViewGroup 中，而是定义在它的父类——View 中，查看下该方法在 View 中的实现。123public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123; dispatchSaveInstanceState(container);&#125; 12345678910111213141516protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; //1. 只有含有 id 的 View，状态才会被存储 if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123; mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED; //2. 调用 onSaveInstanceState 方法获取自身状态 Parcelable state = onSaveInstanceState(); if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123; throw new IllegalStateException( "Derived class did not call super.onSaveInstanceState()"); &#125; //3. 将自身状态存放到 container 中 if (state != null) &#123; container.put(mID, state); &#125; &#125;&#125; View.onSaveInstanceState 方法默认存储的状态为空状态。但是它的子类通常都有定义自身的覆盖方法。12345678910@CallSuperprotected Parcelable onSaveInstanceState() &#123; mPrivateFlags |= PFLAG_SAVE_STATE_CALLED; if (mStartActivityRequestWho != null) &#123; BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE); state.mStartActivityRequestWhoSaved = mStartActivityRequestWho; return state; &#125; return BaseSavedState.EMPTY_STATE;&#125; 步骤 2 中的 View 的调用大致如下：saveHierarchyState ==》 dispatchSaveInstanceState ==》 onSaveInstanceState 其中要注意的是 只有含有 id 的 View，状态才会被存储，如果没有给 view 赋一个 id，那么系统是不会帮忙保存该 view 的状态的。 View 类中的 saveHierarchyState 方法调用了dispatchSaveInstanceState 方法用来存储自身状态。 ViewGroup 覆写了 dispatchSaveInstanceState 来存储自身以及子视图的状态。 ViewGroup.dispatchSaveInstanceState具体实现如下：123456789101112@Overrideprotected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; super.dispatchSaveInstanceState(container); final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) &#123;//遍历调用子 View 的 dispatchSaveInstanceState 方法 View c = children[i]; if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123; c.dispatchSaveInstanceState(container); &#125; &#125;&#125; 可以看到 ViewGroup 的 dispatchSaveInstanceState 方法会先调用 super.dispatchSaveInstanceState(container); 存储自身的状态。然后遍历调用所有子视图的 dispatchSaveInstanceState(container) 方法来保存它们的状态，如果子 View 也是一个 ViewGroup，则会再次执行这个过程。 我们以 TextView 的 saveInstanceState 方法为例，看看具体的控件是如何保存自身状态的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overridepublic Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); // Save state if we are forced to final boolean freezesText = getFreezesText(); boolean hasSelection = false; int start = -1; int end = -1; //存储 TextView 的 start、end if (mText != null) &#123; start = getSelectionStart(); end = getSelectionEnd(); if (start &gt;= 0 || end &gt;= 0) &#123; // 是否存存在选项 hasSelection = true; &#125; &#125; if (freezesText || hasSelection) &#123; SavedState ss = new SavedState(superState); //保存 TextView 的文本内容 if (freezesText) &#123; if (mText instanceof Spanned) &#123; final Spannable sp = new SpannableStringBuilder(mText); if (mEditor != null) &#123; removeMisspelledSpans(sp); sp.removeSpan(mEditor.mSuggestionRangeSpan); &#125; ss.text = sp; &#125; else &#123; ss.text = mText.toString(); &#125; &#125; //存储 TextView 的 start、end if (hasSelection) &#123; // XXX Should also save the current scroll position! ss.selStart = start; ss.selEnd = end; &#125; if (isFocused() &amp;&amp; start &gt;= 0 &amp;&amp; end &gt;= 0) &#123; ss.frozenWithFocus = true; &#125; ss.error = getError(); if (mEditor != null) &#123; ss.editorState = mEditor.saveInstanceState(); &#125; //返回状态对象 return ss; &#125; return superState;&#125; 调用 View 的 onSaveInstance 函数之后就得到了 View 要存储的数据，此时执行到 View 的 dispatchSaveInstanceState 方法中的注释 3。这里以 View 的 id 为 key，以状态为 value，存储到 container（ SparseArray 类型）中。1234//3. 将自身状态存放到 container 中if (state != null) &#123; container.put(mID, state);&#125; 存储完 Window 的视图状态信息之后，便会执行存储 Fragment 中的状态信息、回退栈等。Fragment 也是通过调用自身的 onSaveInstaceState 方法来存储自身的 View 视图树状态的。 最后就是调用用户设置的 ActivityLifecycleCallbacks 的 onSaveInstaceState 方法，让用户做一些额外的处理 前面我们所提及到的只是备忘录模式中的 Originator 角色，即需要保存备忘录的对象。不过也有涉及到 CareTaker 角色——Activity。下面我们再看看另外两个角色——Memoto 和 CareTaker。 存了状态信息的 Bundle 数据存储在哪？ onSaveInstance 方法是在 onStop 方法之前调用的。Activity.onStop 方法是通过 Activity 的 performStopActivity 间接调用。123456 final void performStopActivity(IBinder token, boolean saveState, String reason) &#123; //获取 ActivityClientRecord ActivityClientRecord r = mActivities.get(token); // saveState 表示是否保存状态 performStopActivityInner(r, null, false, saveState, reason);&#125; 1234567891011121314151617181920212223242526272829303132333435private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState, String reason) &#123; if (r != null) &#123; if (!keepShown &amp;&amp; r.stopped) &#123; if (r.activity.mFinished) &#123; // 如果正在执行销毁过程，是用户主动销毁。 activity 不打算恢复，我们也没必要调用 onStop 方法 return; &#125; //代码省略 &#125; // 在调用 onStop 之前必须先调用 onPause performPauseActivityIfNeeded(r, reason); //代码省略 // 接下来让 activity 保存它目前的状态和它所管理的 dialogs if (!r.activity.mFinished &amp;&amp; saveState) &#123; if (r.state == null) &#123; // 间接调用 Activity.onSaveInstance() callCallActivityOnSaveInstanceState(r); &#125; &#125; if (!keepShown) &#123; try &#123; // 执行 onStop 方法 r.activity.performStop(false /*preserveWindow*/); &#125; catch (Exception e) &#123; // ... &#125; //将 stop 字段置为 true 表示已经调用了 stop 方法。 r.stopped = true; &#125; &#125;&#125; 123456789101112private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123; r.state = new Bundle();//内容就存储在该 Bundle 中 r.state.setAllowFds(false); if (r.isPersistable()) &#123; r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); &#125; else &#123; //该方法实际调用了 Activity.onSaveInstanceState 方法 mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); &#125;&#125; 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) &#123; activity.performSaveInstanceState(outState, outPersistentState);&#125; 上面的 performStopActivity 与 performStopActivityInner 方法中，首先通过 token 从 mActivities 中获取一个 ActivityClientRecord 对象，状态信息就是存储在这里面的。获取该对象之后，调用了 performStopActivityInner 方法，对于保存状态而言，该方法大概有如下三步 判断 Activity 是否需要保存状态 如果需要，则调用 onSaveInstance 方法，该方法会将状态信息存储到 ActivityClientRecord 中 调用 Activity.onStop() 方法 执行 onStop 方法之前，系统会根据情况来选择是否存储 Activity 的状态，并且将这些状态（简介地）存储到 mActivities 中。 mActivities 是一个 ArrayMap&lt;IBinder, ActivityClientRecord&gt; ，它维护了一个 Activity 的信息表，当 Activity 重新启动时，会从 mActivities 中查询对应的 ActivityClientRecord，如果这个记录对象中含有状态信息就调用 Activity 的 onRestoreInstanceState 方法。开发人员可以从这个方法中做一些状态恢复操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //代码省略 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //1. 构建 Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); //代码省略 &#125; catch (Exception e) &#123; //代码省略 &#125; try &#123; //2. 创建一个 Application 对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); //代码省略 if (activity != null) &#123; //创建 appContext，类型为 ContextImpl Context appContext = createBaseContextForActivity(r, activity); //代码省略 //3. 关联 appContext、Application 等对象到 Activity 中 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); //代码省略 activity.mCalled = false; //4. 调用 Activity.onCreate 方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; //代码省略 r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; //调用 onStart 方法 activity.performStart(); r.stopped = false; &#125; //5. 如果有保存状态的话，调用 Activity.onRestoreInstanceState 方法恢复状态 if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; //代码省略 &#125; r.paused = true; //6. 将 Activity 的信息记录对象——ActivityClientRecord 存储到 mActivities 中。 mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; return activity;&#125; 在上面的注释 5 处，系统会判断 Activity 是否调用过了 Activity.finish() 方法、是否是「永久的」以及 ActivityClientRecord 对象中的 state 是否为空， 如果满足条件，就会获取存储的状态信息传递给 Activity.onRestoreInstanceState 方法，也会将这些数据传递给 onCreate 方法的 bundle 参数 。 不过 Google 官方推荐调用 onRestoreInstanceState 方法来恢复状态，因为只有在存储有状态信息的时候才会调用该方法，而在 onCreate 方法中还需要先进行判空处理。 小结上述过程中备忘录模式的三种关键角色分别由什么类扮演？ CareTaker：Activity 负责存储、恢复 UI 的态信息。 Originator：Activity、Fragment、View、ViewGroup ，是需要存储状态的对象 Memoto：由 Bundle 类扮演 Activity 会在停止之前根据 Activity 的退出情景来选择是否需要存储状态 在重新启动该 Activity 时会判断 ActivityClientRecord 对象中是否存储了 Activity 的状态 如果含有状态，调用 Activity.onRestoreInstanceState() 方法恢复状态。从而使得 Activity 的 UI 可以恢复至异常退出前的状态。 你可能会问的问题onSaveInstanceState 何时被调用onSaveInstanceState() 方法会在什么时候被执行？有这么几种情况： 当用户按下 HOME 键时。 这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 长按HOME键，选择运行其他的程序时。 按下电源按键（关闭屏幕显示）时。 从 Activity A 中启动一个新的 Activity 时。 屏幕方向切换时，例如从竖屏切换到横屏时。 onSaveInstanceState 的调用在 onStop 方法之前，但是与 onPause 方法之间没有既定关系。 总而言之，当系统存在「==未经用户许可==」时销毁了我们的 Activity，则 onSaveInstanceState() 会被系统调用，这是系统的责任，因此它必须提供一个机会让用户保存数据。 「经用户许可」的情况不多，通常只有用户按下回退键这一种。这种情况下是用户主动退出某个 Activity，系统不会调用 onSaveInstanceState() 方法。 各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？在前面的分析中我们知道即使没有覆写 onSaveInstanceState()方法, ViewGroup、View、Fragment、Activity 内部都有自己的默认实现，它们的默认实现也会保存某些状态数据。 比如 activity 中各种 UI 控件的状态。android 应用框架中定义的几乎所有 UI 控件都恰当的实现了 onSaveInstanceState() 方法,因此当 Activity 被销毁和重建时, 这些 UI 控件会自动保存和恢复状态数据. EditText 控件会自动保存和恢复输入的数据 CheckBox 控件会自动保存和恢复选中状态 … 开发者只需要为这些控件指定一个唯一的 id(通过设置 android:id 属性即可), 剩余的事情就可以自动完成了 注意：如果没有为控件指定ID, 则这个控件就不会进行自动的数据保存和恢复操作。 由上所述, 如果我们需要覆写 onSaveInstanceState() 方法, 一般会在第一行代码中调用该方法的默认实现:super.onSaveInstanceState(outState)。 有默认实现，还需要重写 onSaveInstanceState() 方法吗？既然该方法的默认实现可以自动的保存UI控件的状态数据, 那什么时候需要覆写该方法呢? 如果需要保存额外的数据时, 就需要覆写 onSaveInstanceState() 方法。大家需要注意的是：onSaveInstanceState()方法只适合保存瞬态数据, 比如 UI 控件的状态，成员变量的值等，而不应该用来保存持久化数据，持久化数据应该当用户离开当前的 activity时，在 onPause() 中保存（比如将数据保存到数据库或文件中）。说到这里，还要说一点的就是在onPause()中不适合用来保存比较费时的数据，所以这点要理解。 另外由于 onSaveInstanceState() 方法方法不一定会被调用, 因此不适合在该方法中保存持久化数据, 例如向数据库中插入记录等。 保存持久化数据的操作应该放在 onPause() 中。若是永久性值，则在 onPause() 中保存；若有大量要保存的数据，则另开线程，以免阻塞 UI 线程。 参考资料与学习资源推荐 《Android 源码设计模式解析与实战》 Android 开发之 instanceState详解]]></content>
      <categories>
        <category>设计模式</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 ThreadLocal]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2F%E7%90%86%E8%A7%A3%20ThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal 是什么？ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。 为什么要使用 ThreadLocal？从定义我们知道 ThreadLocal 是一个用于存储本线程内部数据的类。假设没有 ThreadLocal 的话，每个 Thread 中可以输入自己的一个本地变量，但是在整个 Thread 的生命周期中，如果要穿梭很多 class 的很多 method 来使用这个本地变量的话，就要一直一直向下传送这个变量，显然很麻烦。那么怎么才能在这个 Thread 的生命中，在任何地方都能够方便的访问到这个变量呢，这时候 ThreadLocal 就诞生了。 ThreadLocal 就是这么个作用，除此之外和通常使用的本地变量没有任何区别。也就是说，没有 ThreadLocal 也是可以解决问题的，但是会比较麻烦，ThreadLocal 的作用便是简化线程内部数据的使用流程。 ThreadLocal 的内部实现既然是线程的本地变量，那自然与线程有着密切的联系。 打开 Thread 的源码可以看到，源码中有一个类型为 ThreadLocal.ThreadLocalMap 的变量1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal#get 流程我们以 ThreadLocal#get 方法作为分析的源头。这些方法的逻辑都比较简单，因此直接在注释中说明。可参考小结部分的调用流程图。 12345678910public T get() &#123; Thread t = Thread.currentThread();//获取当前线程 ThreadLocalMap map = getMap(t);//获取当前线程的 ThreadLocalMap 对象 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this);//获取存储该 ThreadLocal 的 Entry if (e != null) return (T)e.value;//获取目标值并返回 &#125; return setInitialValue();//设置初始值&#125; ThreadLocal#getMap，该方法返回当前线程的 ThreadLocalMap 对象。 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; Entry 类继承自弱引用，防止内存泄漏。其中存储了 ThreadLocal 以及对应的值 12345678static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125;&#125; ThreadLocal#setInitialValue 12345678910private T setInitialValue() &#123; T value = initialValue();//获取默认的初始值 Thread t = Thread.currentThread();//获取当前线程 ThreadLocalMap map = getMap(t);//获取当前线程的 ThreadLocalMap 对象 if (map != null) map.set(this, value);//当前线程的 ThreadLocalMap 对象不为空，直接设置给目标对象。 else createMap(t, value);//为当前线程创建 ThreadLocalMap 对象。 return value;&#125; ThreadLocal#createMap 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);//调用构造方法初始化&#125; ThreadLocal#set 流程12345678public void set(T value) &#123; Thread t = Thread.currentThread();//获取当前线程 ThreadLocalMap map = getMap(t);//获取当前线程的 ThreadLocalMap 对象 if (map != null) map.set(this, value);//当前线程的 ThreadLocalMap 对象 已经存在直接设置值 else createMap(t, value);//为当前线程创建 ThreadLocalMap &#125; 可以看到 ThreadLocal#set 方法的逻辑与 ThreadLocal#setInitialValue 方法中的逻辑如出一辙，这里不再赘述。 ThreadLocalMapThreadLocalMap 是 ThreadLocal 的一个静态内部类。其中以键值对的形式存储数据。可以将它简单理解为一个 HashMap。ThreadLocal#createMap 方法通过调用 ThreadLocalMap 的构造方法为当前线程创建一个 ThreadLocalMap 对象。 ThreadLocalMap 的构造方法1234567ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY];//创建一个长度为 16 的 Entry 数组 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);//计算 key 的哈希值 table[i] = new Entry(firstKey, firstValue);//将 Entry 存到指定位置。 size = 1; setThreshold(INITIAL_CAPACITY);&#125; ThreadLocalMap 的构造方法主要做了下面几件事： 首先创建了一个 Entry 数组， Entry 是 ThreadLocalMap 中的一个静态内部类,它以 ThreadLocal 为 key，以要存储的值为 value。 然后根据 key 计算 Hash 值 接着创建一个 Entry 对象存储在数组中 最后设置大小和阈值。 ThreadLocalMap.Entry123456789static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125;&#125; Entry 作为 ThreadLocalMap 的元素，表示的是一个键值对：ThreadLocal 的弱引用为键，将要用 ThreadLocal 存储的对象为值。 内存泄漏？因为作为 key 的 ThreadLocal 是弱引用，所以一发生 GC ，ThreadLocal 就会被回收，这个时候 Map 中存在一个 Key 为 null 的键值对，但是 value 仍然被线程强引用着，那么如果用完ThreadLocal后不主动移除（调用 ThreadLocal#remove 方法），就会内存泄露了。但事实上，ThreadLocal 用完后主动调 remove 就能规避这个问题。 注：上面说 value 被线程强引用是因为存在这样一条引用链：栈帧中持有有一个当前线程的引用，ThreadLocalMap 被当前线程引用着，ThreadLocalMap 中有指向 Entry 的强引用，Entry 有持有 value 的强引用。具体可参考下图。 当前 Thread 结束以后, Current Thread 就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收。 以 ThreadLocal#get 为例 12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this);//调用 ThreadLcoalMap#getEntry 方法 if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; 12345678private Entry getEntry(ThreadLocal key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key)//命中 return e; else return getEntryAfterMiss(key, i, e);//不在数组的相应位置上（可能是冲突）&#125; ThreadLocal.ThreadLocalMap#getEntryAfterMiss 12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i);//移除「过期的」Entry，也就是移除 key 为 null 的 Entry else i = nextIndex(i, len);//加 1 「取模」，获得下一个地址 e = tab[i]; &#125; return null;&#125; ThreadLocal.ThreadLocalMap#expungeStaleEntry 123456789101112131415161718192021222324252627282930313233343536//移除「过期的」Entry，也就是移除 key 为 null 的 Entryprivate int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // 删除过期的 slot 上的 entry tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal k = e.get(); if (k == null) &#123; e.value = null;//将 value 置为 null，方便 GC tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 从 ThreadLocal#get 方法（set 方法也有类似的实现）的调用链中可以看到：在没有主动调用 ThreadLocal#remove 的情况下，ThreadLocalMap后续的get/set中也会探测到那些key为 null的entry，然后将其 value 设置为 null 以帮助GC，因此 value 在 key 被 GC 后可能还会存活一段时间（也就是说会造成短期的内存泄漏），但最终也会被回收。这个过程和 java.util.WeakHashMap 的实现几乎是一样的。不过为了避免潜在的内存泄漏还是要养成一个习惯，使用完 ThreadLocal 中的value 之后要调用 ThreadLocal#remove 。 小结get 方法调用大致流程 get 方法中会尝试获取当前线程的 ThreadLocalMap 如果 ThreadLocalMap 非空，并且以当前 ThreadLocal 对象为 key 去获取到的 Entry 不为空，就返回该 ThreadLocal 对应的值； 否则，先获取默认的初始值（默认实现为空，可以自己重写 initialValue 方法来设置需要的值） 然后判断 ThreadLocalMap 是否为空 如果为空创建一个 ThreadLocalMap 同时将初始值设置进去。 如果不为空，直接把初始值存储在其中。 set 方法调用流程 你可能存在的疑问每个 ThreadLocal 只能放一个对象吗？每个 ThreadLocal 只能放一个对象。要是需要放其他的对象，就再 new 一个新的 ThreadLocal 出来，这个新的 ThreadLocal 将作为 key,需要放的对象作为value，放在 ThreadLocalMap 中。也就是说一个线程可以含有多个 ThreadLocal 类。 当然也可以根据需要在 ThreadLocal 存放一些容器对象，比如 List、Set、Map，一个 ThreadLocal 存放一个容器对象，借助该容器对象也可以实现存储多个对象。 为什么 ThreadLocal 只存储一个对象却要用一个 ThreadLocalMap 来存储值？实际上每个线程中都有一个 ThreadLocal.ThreadLocalMap，真正存储数据的类是 ThreadLocalMap ，可以将它看作是一个 HashMap，而 ThreadLocal 是一个维护类。我们知道，存储的时候，都是以 ThreadLocal 实例作为 key，然后和 value 一起作为键值对存储到 ThreadLocalMap 中。当我们调用不同 ThreadLocal 的 set 方法时，如果 ThreadLocalMap 不为空，那么直接在里面存储键值对就可以了，不需要再创建新的值。也就是说，同一个线程上的不同 ThreadLocal 对象，存储的值是在同一个 ThreadLocalMap 上。 没有 ThreadLocal 能不能解决问题？能。 可以自己定义一个静态的 map，将当前 thread 作为 key，将目标值作为 value，put 到 map 中，这也是一般人的想法。 ThreadLocal 的实现刚好相反，它是在每个线程中有一个 map，而将 ThreadLocal 实例作为 key，这样每个 map 中的项数很少，而且当线程销毁时相应的东西也一起销毁了。因为各线程访问的 map 是各自不同的 map，所以不需要同步，速度会快些；而如果把所有线程要用的对象都放到一个静态 map中的话 多线程并发访问需要进行同步。 所以说 ThreadLocal 只是实现线程私有变量的一种方式。但是综合来看这种方式相比其他实现方式要更好。 典型应用我们通常会用下面的方式为普通线程创建一个 Looper。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare();//为当前线程创建一个 Looper mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop();//开启消息循环 &#125; &#125; Android 中每个线程中最多只能有一个 Looper，这种限制就是通过 ThreadLocal 来实现的。 12345public final class Looper &#123; //创建一个 ThreadLocal 对象，其泛型类型为 Looper，在调用 prepare 之前 sThreadLocal.get() 都返回空。 static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //...&#125; 创建 Looper 时会同时创建一个泛型类型为 Looper 的 ThreadLocal 对象。 Looper#prepare()，通过 prepare 方法可以为当前线程创建一个 Looper。 12345678910public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123;//如果线程已经存在 Looper 了 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));//为当前线程创建一个 Looper 对象，并将它存储在当前线程的 ThreadLocalMap 中&#125; Looper#myLooper() ，通过该方法可以获取当前线程的 Looper 对象 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 注意如果一个对象的引用被多个线程持有，那么即使该对象存在 ThreadLocalMap 中也不是线程的本地变量。 首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过 ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。 也就是说，其他线程能否访问，还要看你的 set 进去的对象引用是否被其他线程持有。 如果两个线程都存入同一个对象引用，那就会有线程共享问题。 小结我们总结 ThreadLocal 具体是怎么一步一步去为每一个线程创建一个~线程私有变量~的： 首先，在每个线程 Thread 内部有一个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals，这个 threadLocals 就是用来存储~线程私有变量的~，键值（key）为当前 ThreadLocal 变量，值 value 为~线程的私有变量~（即 T 类型的变量）。 初始时，在 Thread 里面，threadLocals 为空，当通过 ThreadLocal 变量调用 get() 方法或者 set() 方法，就会对 Thread 类中的 threadLocals 进行初始化，并且以当前 ThreadLocal 变量为 key，以 ThreadLocal 要保存的~线程私有变量~为 value，存到 threadLocals 中。 注意，如果是 先调用 get() 方法而不是 set() 方法的话，会返回 null 然后在当前线程里面，如果要使用~该线程私有变量~，就可以通过 get 方法在 threadLocals 里面查找。 参考与学习资源推荐 正确理解 ThreadLocal ThreadLocal and synchronized 补充 ThreadLocal Java并发编程：深入剖析ThreadLocal Android关于ThreadLocal的思考和总结 深入理解ThreadLocal 如果本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>并发</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明白原理,轻松解决内存泄漏]]></title>
    <url>%2Fblog%2F2017%2F08%2F19%2F%E6%98%8E%E7%99%BD%E5%8E%9F%E7%90%86-%E8%BD%BB%E6%9D%BE%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[相信「内存泄漏」 问题，是一个挺让开发者头疼的事情，笔者在回顾以为代码时，惊讶发现：初学 Android 时，许多不修边幅的代码习惯，导致了许多内存泄漏问题，借此分析其原因，把自己挖过的坑补一下，也希望奔跑在 Android 开发道路上的你能够优雅避免。 什么是内存泄漏 对于 C++ 来说，内存泄漏就是 new 出来的对象没有 delete，俗称野指针； 而对于 java 而言，就是存放在堆上的 Object 无法被 GC 正常回收； 分析之前我们先来看看三个基础知识点。 基础知识java 的内存分配简述运行时数据区域内存模型图 方法区（non-heap）：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量； 栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存； 堆区（heap）：通常用来存放 new 出来的对象。由 GC 负责回收。 四种不同类型的引用GC 过程与对象的引用类型有着很大的联系，下面我们就看看 Java 中（Android 中存在差异）的四种引用： 强引用（Strong Reference）:JVM 宁愿抛出 OOM，也不会让 GC 回收存在强引用的对象。 软引用（Soft Reference） ：只有内存不足时，才会被 GC 回收。 弱引用（weak Reference）：在 GC 时，如果一个对象只存在弱引用，将会被回收 虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为 GC 回收 Object 的标志。 与 Android 中的差异：在 2.3 以后版本中，即使内存够用，Android 系统会优先将 SoftReference 的对象提前回收掉, 其他和 Java 中是一样的。因此谷歌官方建议用 LruCache(least recentlly use 最少最近使用算法)。会将内存控制在一定的大小内, 超出最大值时会自动回收, 这个最大值开发者自己定。 可达性分析算法内存泄漏是因为内存无法被正常回收引起。为什么无法被回收？我们前面是这么说的——「因为它的强/软引用被长生命周期的对象持有」。可为什么引用被长生命周期的对象持有就不能进行释放呢？这就涉及到了垃圾回收机制。 进行垃圾回收的第一个问题是如何确定哪些对象是可以被回收的垃圾。通常有两种判断方法，一种是引用计数方法，另一种是可达性分析算法。主流的商用程序语言的主流实现中，都是通过可达性分析来判断对象是否存活的。 可达性分析算法的基本思路是这样的： 通过一系列的称为 GC Root 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为『引用链』（Reference Chain） 当一个对象到 GC Root 没有任何引用链相连时，则证明此对象是不可用的。 问题来了，到底什么是 GC Root 呢？ R 大在知乎中这样答道：所谓“GC roots”，或者说tracing GC的“根集合”，一组必须活跃的==引用== 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。 VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。 JNI handles，包括global handles和local handles （看情况）所有当前被加载的Java类 （看情况）Java类的运行时常量池里的引用类型常量（String或Class类型） （看情况）String常量池（StringTable）里的引用 关于 GC 回收机制，可以参考下这篇文章 内存泄漏的危害 运行性能的问题: Android在运行的时候，如果内存泄漏将导致其他组件可用的内存变少，一方面会使得GC的频率加剧，在发生GC的时候，所有进程都必须进行等待，GC的频率越多，从而用户越容易感知到卡顿。另一方面，内存变少，将可能使得系统会额外分配给你一些内存，而影响整个系统的运行状况。 运行崩溃问题: 内存泄露是内存溢出(OOM)的重要原因之一，会导致 Crash。如果应用程序在消耗光了所有的可用堆空间，那么再试图在堆上分配新对象时就会引起 OOM(Out Of Memory Error) 异常，此时应用程序就会崩溃退出。 内存泄漏的典型案例要想避免内存泄漏，首先要知道导致内存泄漏的原因。内存泄漏本质原因:==长生命周期的对象持有短生命周期对象的强/软引用。导致本应该被回收的短生命周期的对象无法被正常回收==。 这么讲可能比较抽象。举个常见的栗子：单例模式中，我们常常在获取单例对象时需要传一个 Context 。单例对象是一个长生命周期的对象（应用程序结束时才终结），而如果我们传递的是某一个 Activity 作为 context,那么这个 Activity 就会因为引用被持有而无法销毁，从而导致内存泄漏。 下面我们来看看导致内存泄漏的常见例子。 永远的 Singleton单例的使用在我们的程序中随处可见，因为使用它可以解决我们在程序中重复创建对象的问题。但是由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏。 解决 应该把传入的 Context 改为同应用生命周期一样长的 Application 中的 Context。 也可以通过重写 Application，提供 getContext 方法,那样就不需要在获取单例时传入 context。 123456789101112public class BaseApplication extends Application&#123; private static ApplicationContext sContext; @Override public void onCreate()&#123; super.onCreate(); sContext = getApplicationContext(); &#125; public static Context getApplicationContext()&#123; return sContext; &#125;&#125; Handler 引发的内存泄漏由于 Handler 属于 TLS（Thread Local Storage）变量，导致它的生命周期和 Activity 不一致。因此通过 Handler 来更新 UI 一般很难保证跟 View 或者 Activity 的生命周期一致，故很容易导致无法正确释放。12345678910111213141516171819202122public class HandlerBadActivity extends AppCompatActivity &#123; private final Handler handler = new Handler()&#123;//非静态内部类，持有外部类的强引用 @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler_bad); // 延迟 5min 发送一个消息 handler.postDelayed(new Runnable() &#123;//内部会将该 Runable 封装为一个 Message 对象，同时将 Message.target 赋值为 handler @Override public void run() &#123; //do something &#125; &#125;, 1000 * 60 * 5); this.finish(); &#125;&#125; 上面的代码中发送了了一个延时 5 分钟执行的 Message，当该 Activity 退出的时候，延时任务（Message）还在主线程的 MessageQueue 中等待，此时的 Message 持有 Handler 的强引用（创建时通过 Message.target 进行指定），并且由于 Handler 是 HandlerBadActivity 的非静态内部类，所以 Handler 会持有一个指向 HandlerBadActivity 的强引用，所以虽然此时 HandlerBadActivity 调用了 finish 也无法进行内存回收，造成内存泄漏。 解决将 Handler 声明为静态内部类，但是要注意如果用到 Context 等外部类的 非static 对象，还是应该使用 ApplicationContext 或者通过弱引用来持有这些外部对象。123456789101112131415161718192021public class HandlerGoodActivity extends AppCompatActivity &#123; private static final class MyHandler extends Handler&#123;//声明为静态内部类（避免持有外部类的强引用） private final WeakReference&lt;HandlerGoodActivity&gt; mActivity; public MyHandler(HandlerGoodActivity activity)&#123; this.mActivity = new WeakReference&lt;HandlerGoodActivity&gt;(activity);//使用弱引用 &#125; @Override public void handleMessage(Message msg) &#123; HandlerGoodActivity activity = mActivity.get(); if (activity == null || activity.isFinishing() || activity.isDestroyed()) &#123;//判断 activity 是否为空，以及是否正在被销毁、或者已经被销毁 removeCallbacksAndMessages(null); return; &#125; // do something &#125; &#125; private final MyHandler myHandler = new MyHandler(this);&#125; 慎用 static 成员变量从前面的介绍我们知道，static 修饰的变量位于内存的方法区，其生命周期与 App 的生命周期一致。这必然会导致一系列问题，如果你的 app 进程设计上是长驻内存的，那即使 app 切到后台，这部分内存也不会被释放。 解决不要在类初始时初始化静态成员，也就是可以考虑懒加载。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。 当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下： 说明： NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要==创建一个新的 task 任务队列==。 对于 Dialog 而言，只有在 Activity 中才能创建 下面举一个隐蔽的栗子 使用系统服务引发的内存泄漏为了方便我们使用一些常见的系统服务，Activity 做了一些封装。比如说，可以通过 getPackageManager 在 Activtiy 中获取 PackageManagerService，但是，里面实际上调用了 Activity 对应的 ContextImpl 中的 getPackageManager 方法 ContextWrapper#getPackageManager 1234@Overridepublic PackageManager getPackageManager() &#123; return mBase.getPackageManager();&#125; ContextImpl#getPackageManager 1234567891011121314@Overridepublic PackageManager getPackageManager() &#123; if (mPackageManager != null) &#123; return mPackageManager; &#125; IPackageManager pm = ActivityThread.getPackageManager(); if (pm != null) &#123; // Doesn't matter if we make more than one instance. return (mPackageManager = new ApplicationPackageManager(this, pm));//创建 ApplicationPackageManager &#125; return null;&#125; ApplicationPackageManager#ApplicationPackageManager 12345ApplicationPackageManager(ContextImpl context, IPackageManager pm) &#123; mContext = context;//保存 ContextImpl 的强引用 mPM = pm;&#125; 123456private UserManagerService(Context context, PackageManagerService pm, Object packagesLock, File dataDir) &#123; mContext = context;//持有外部 Context 引用 mPm = pm; //代码省略&#125; PackageManagerService#PackageManagerService 1234567public class PackageManagerService extends IPackageManager.Stub &#123; static UserManagerService sUserManager;//持有 UMS 静态引用 public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; sUserManager = new UserManagerService(context, this, mPackages);//初始化 UMS &#125;&#125; 笔者遇到的内存泄漏问题是因为在 Activity 中调用了 getPackageManger 方法获取 PMS ，该方法调用的是 ContextImpl，此时如果ContextImpl 中 PackageManager 为 null，就会创建一个 PackageManger（ContextImpl 会将自己传递进去，而 ContextImpl 的 mOuterContext 为 Activity），创建 PackageManager 实际上会创建 PackageManagerService（简称 PMS），而 PMS 的构造方法中会创建一个 UserManger（UserManger 初始化之后会持有 ContextImpl 的强引用）。 只要 PMS 的 class 未被销毁，那么就会一直引用着 UserManger ，进而导致其关联到的资源无法正常释放。 小结本例的引用链大致如下： 方法区中（1.8 后移到了 元空间）含有已经加载的 PMS class，PMS 静态引用 –&gt; UserManger（mContext） –&gt; ContextImpl（mOuterContext） –&gt; Activity (资源无法被正常回收) 通常这种内存泄漏总是比较隐蔽，不使用检测工具，根本就想不到，原来那一行代码竟然会引发内存泄漏。 解决将getPackageManager() 改为 getApplication()#getPackageManager() 。这样引用的就是 Application Context，而非 Activity 了。 远离非静态内部类和匿名类，有需要时请使用静态内部类为什么要怎么做呢?因为使用非静态内部类和匿名类都会默认持有外部类的引用，如果生命周期不一致，就会导致内存泄漏。 看一个例子。 1234567891011121314151617public class NestedClassLeakActivity extends AppCompatActivity &#123; class InnerClass &#123;//非静态内部类 &#125; private static InnerClass sInner;//指向非静态内部类的静态引用 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_nested_class); if (sInner == null) &#123; sInner = new InnerClass();//创建非静态内部类的实例 &#125; &#125;&#125; 本例中，因为非静态内部类默认会持有外部类的引用，而外部类中又有一个该非静态内部类的静态实例，该静态实例的生命周期和应用的一样长，而静态实例又持有 Activity 的引用，因此导致 Activity 的内存资源不能正常回收。 解决 将该内部类设为静态内部类 也可以将该内部类抽取出来封装成一个单例 集合引发的内存泄漏我们通常会把一些对象的引用加入到集合容器（比如ArrayList）中，当我们不再需要该对象时（通常会调用 remove 方法），并没有把它的引用从集合中清理掉（其中的一种情况就是 remove 方法没有将不再需要的引用赋值为 null），下面以 ArrayList 的 remove 方法为例 12345678910111213141516public E remove( int index) &#123; // 数组越界检查 RangeCheck(index); modCount++; // 取出要删除位置的元素，供返回使用 E oldValue = (E) elementData[index]; // 计算数组要复制的数量 int numMoved = size - index - 1; // 数组复制，就是将index之后的元素往前移动一个位置 if (numMoved &gt; 0) System. arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收 elementData[--size ] = null; // Let gc do its work return oldValue;&#125; elementData[--size ] = null; // Let gc do its work 如果替换为 --size，就会导致已经「移除」的对象因为强引用被集合持有，而无法正常被 gc 回收。 WebView 引发的内存泄漏WebView 解析网页时会申请Native堆内存用于保存页面元素，当页面较复杂时会有很大的内存占用。如果页面包含图片，内存占用会更严重。并且打开新页面时，为了能快速回退，之前页面占用的内存也不会释放。有时浏览十几个网页，都会占用几百兆的内存。这样加载网页较多时，会导致系统不堪重负，最终强制关闭应用，也就是出现应用闪退或重启。 由于占用的都是 Native 堆内存，所以实际占用的内存大小不会显示在常用的 DDMS Heap 工具中（ DMS Heap 工具看到的只是Java虚拟机分配的内存，即使Native堆内存已经占用了几百兆，这里显示的还只是几兆或十几兆）。只有使用 adb shell 中的一些命令比如 dumpsys meminfo 包名，或者在程序中使用 Debug.getNativeHeapSize() 才能看到 Native 堆内存信息。 据说由于 WebView 的一个 BUG，即使它所在的 Activity(或者Service) 结束也就是 onDestroy() 之后，或者直接调用 WebView.destroy()之后，它所占用这些内存也不会被释放。 解决把使用了 WebView 的 Activity (或者 Service) 放在单独的进程里。 系统在检测到应用占用内存过大有可能被系统干掉 也可以在它所在的 Activity(或者 Service) 结束后，调用 System.exit(0)，主动Kill掉进程。由于系统的内存分配是以进程为准的，进程关闭后，系统会自动回收所有内存。 使用 WebView 的页面（Activity），在生命周期结束页面退出（onDestory）的时候，主动调用WebView.onPause()==以及==WebView.destory()以便让系统释放 WebView 相关资源。 其他常见的引起内存泄漏原因 Android 3.0 以下，Bitmap 在不使用的时候没有使用 recycle() 释放内存。 非静态内部类的静态实例容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。 警惕线程未终止造成的内存泄露；譬如在 Activity 中关联了一个生命周期超过 Activity 的 Thread，在退出 Activity 时切记结束线程。 一个典型的例子就是 HandlerThread 的 run 方法。该方法在这里是一个死循环，它不会自己结束，线程的生命周期超过了 Activity 生命周期，我们必须手动在 Activity 的销毁方法中中调用 thread.getLooper().quit() 才不会泄露。 对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。 创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。 避免代码设计模式的错误造成内存泄露；譬如循环引用，A 持有 B，B 持有 C，C 持有 A，这样的设计谁都得不到释放。 内存泄漏的检测工具 LeakCanary 是 Apache 开源的一个自动检测内存泄漏的框架。具体用法可以参考 LeakCanary——如何检测 Activity 是否泄漏 使用 AS Monitor + MAT 自己分析内存泄漏原因。虽然MAT不会准确告诉你你的代码哪泄漏了，但是它会给你发现哪泄露的数据和线索。 AS 3.0 中提供了 Profiler 工具，这里简述一下使用流程：手动点击 GC 按钮（图标是一个垃圾桶）—&gt; 选择 Dump 内存（等待20秒左右）—&gt; 下方会弹出分析结果窗口—&gt; 下拉选择 app heap ，下拉选择 Arrange by package—&gt;到包下寻找自己认为可能发生内存泄漏的类，单击选中类 —&gt; 右边弹出 Instance View 窗口，显示该类的所有实例 —&gt; 选中某一个实例 –&gt; 下方会弹出 Reference 窗口（显示该实例的所有引用），然后分析一下到底是谁强引用了该实例，导致内存无法释放。 参考资料与学习资源推荐 Android 性能优化 详解内存优化的来龙去脉 内存泄漏全解析，从此拒绝ANR，让OOM远离你的身边，跟内存泄漏say byebye 明白原理，轻松应对Android内存泄漏 如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码中的代理模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F18%2FAndroid%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式的定义代理模式也称为委托模式，为其他对象提供一种代理以控制对这个对象的访问。 代理模式的使用场景当无法或不想访问某个对象或者访问某个对象存在困难时可以通过一个代理对象来间接访问。 为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口（或继承相同的抽象类） 代理模式的UML类图 角色介绍： Subject 抽象主题类 主要职责是声明真实主题类与代理的共同接口方法，该类可以是一个抽象类也可以是一个接口 RealSubject 真实主题类 也称为被委托类或被代理理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。 ProxySubject 代理类 也称为委托类，持有一个对真实主题类的引用，在其实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。 Client 使用代理类的类 代理模式的简单实现代理模式大致可分为两大部分，静态代理和动态代理。 动态代理通过反射机制动态地生成代理者的对象，code 阶段不需要知道代理谁，代理的真正对象会在执行阶段确定。 Java 提供一个便捷的动态代理接口 InvocationHandler，实现该接口需要重写其调用方法 invoke。 动态代理通过一个代理类来代理 N 多个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的的耦合关系。 静态代理 vs 动态代理相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂。 但是静态代理更符合面向对象的原则。 实际开发中具体使用哪种方式来实现代理，看自己的偏好。 分类静态代理和动态代理是从 code 方面来区分代理模式的。 也可以从其使用范围来区分不同类型的代理实现： 远程代理（Remote Proxy）为某个对象在不同的内存地址空间提供局部代理。使系统可以将 Server 部分的实现隐藏，以便 Client 可以不考虑 Server 的存在。 虚拟代理（Virtual Proxy）使用一个代理对象表示一个十分耗资源的对象并在真正需要时才创建。 保护代理(Protection Proxy)：使用代理控制对原始对象的访问。该类型的代理常被用于原始对象具有不同访问权限的情况。 智能引用(Smart Reference)：在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数。 静动态代理都可以应用于上述 4 种情形。 Android源码中的代理模式实现以 ActivityManager 为例。 抽象接口: IActivityManager 代理类 ActivityManagerProxy 被代理类 ActivityManagerNative(抽象类，并不处理太多的逻辑，大部分逻辑由其子类——ActivityManagerService 承担) ActivityManagerService(真实部分) ActivityManagerService 是系统级的 Service 并且运行于独立的进程空间中，可以通过 ServiceManger 获取到它。 ActivityManagerProxy 运行于自己所处的进程空间中（也就是说，与 ActivityManagerService 运行在不同的进程中） 所以此处源码所实现的代理实质为==远程代理==。 ActivityManagerProxy 在实际的逻辑处理并没有过多地被外部类使用，Android 中管理与维护 Activity 相关信息的类是另一个叫做 ActivityManager 的类。不过实质上 ActivityManager 大多数逻辑还是由 ActivityManagerProxy 承担。（注意：ActivityManager 并没有实现 IActivityManager 接口，它直接继承自 Object） 以 ActivityManager 的 getAppTasks() 方法为例1234567891011121314public List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123; ArrayList&lt;AppTask&gt; tasks = new ArrayList&lt;AppTask&gt;(); List&lt;IAppTask&gt; appTasks; try &#123; appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; int numAppTasks = appTasks.size(); for (int i = 0; i &lt; numAppTasks; i++) &#123; tasks.add(new AppTask(appTasks.get(i))); &#125; return tasks;&#125; ActivityManagerNative.getDefault();方法 返回一个 IActivityManager 类型的对象，通过该对象调用其 getAppTasks 方法123static public IActivityManager getDefault() &#123; return gDefault.get();&#125; gDefault 到底是什么？123456789private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService("activity");//获取 AMS //代码省略 IActivityManager am = asInterface(b);//完成创建一个 AMS 的客户端端代理对象—— ActivityManagerProxy //代码省略 return am; &#125;&#125;; 上述代码中构造了一个 Singleton&lt;IActivityManager&gt; 类型的 gDefault 对象，其中通过 ServiceManager.getService(&quot;activity&quot;); 获取一个系统级的 Service，而该 Service 实质上就是 AMS，接着调用 asInterface 方法，创建一个 ActivityManagerProxy 对象。 ActivityManagerNative.asInterface 方法的具体实现1234567891011static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; ActivityManagerProxy 的 getTasks 方法，将数据打包跨进程传递给 Server 端的 AMS 处理12345678910111213141516171819202122232425public List&lt;ActivityManager.RunningTaskInfo&gt; getTasks(int maxNum, int flags) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeInt(maxNum); data.writeInt(flags); mRemote.transact(GET_TASKS_TRANSACTION, data, reply, 0); reply.readException(); ArrayList&lt;ActivityManager.RunningTaskInfo&gt; list = null; int N = reply.readInt(); if (N &gt;= 0) &#123; list = new ArrayList&lt;&gt;(); while (N &gt; 0) &#123; ActivityManager.RunningTaskInfo info = ActivityManager.RunningTaskInfo.CREATOR .createFromParcel(reply); list.add(info); N--; &#125; &#125; data.recycle(); reply.recycle(); return list; &#125; 看看 AMS 中的 getTasks 方法的具体实现。1234567891011121314151617181920212223242526272829303132333435@Overridepublic List&lt;IAppTask&gt; getAppTasks(String callingPackage) &#123; int callingUid = Binder.getCallingUid(); long ident = Binder.clearCallingIdentity(); synchronized(this) &#123; ArrayList&lt;IAppTask&gt; list = new ArrayList&lt;IAppTask&gt;(); try &#123; if (DEBUG_ALL) Slog.v(TAG, "getAppTasks"); final int N = mRecentTasks.size(); for (int i = 0; i &lt; N; i++) &#123; TaskRecord tr = mRecentTasks.get(i); // Skip tasks that do not match the caller. We don't need to verify // callingPackage, because we are also limiting to callingUid and know // that will limit to the correct security sandbox. if (tr.effectiveUid != callingUid) &#123; continue; &#125; Intent intent = tr.getBaseIntent(); if (intent == null || !callingPackage.equals(intent.getComponent().getPackageName())) &#123; continue; &#125; ActivityManager.RecentTaskInfo taskInfo = createRecentTaskInfoFromTaskRecord(tr); AppTaskImpl taskImpl = new AppTaskImpl(taskInfo.persistentId, callingUid); list.add(taskImpl); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; return list; &#125;&#125; Android 中的 Binder 跨进程通信机制与 AIDL四个重要类： Binder Client 类比 PC、终端设备 Binder Server 类比 服务器 Binder Driver（实现在内核中） 类比 路由器 Binder Manager 类比 DNS 服务器 因为依赖于抽象，加上本地代理类的存在，所以调用远程方法时，还是与调用本地的普通的方法一样。但是代理类内部需要对参数什么的进行打包处理，然后再通过 Binder 机制，跨进程将数据传递给远程方法，远程方法执行完毕再返回数据。 Binder Driver 实现在内核中，主要负责 Binder 通信的建立，以及 Binder数据在进程间的传递和 Binder 引用计数管理/数据包的传输等。 Binder Client 和 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发， 对于 Binder Client 而言，它只需要知道自己要使用的 Binder 的名字以及该 Binder 实体在 ServerManager 中的 0 号引用即可。 访问原理： 通过 0 号引用去访问 ServerManager 获取该 Binder 的引用， 得到引用后就可以像普通方法调用那样调用 Binder 实体的方法 ServerManager 用来管理 Binder Server（Android 中通常是一个 Service） Binder Client 通过它来查询 Binder Server 的引用 ServerManager 是一个标准的 Binder Server，并且在 Android 中约定其在 Binder 通信过程中的唯一标识（类似于 IP 地址）永远为 0。 在 IServiceManager 接口中定义有对外开放的接口方法，供客户端访问。 匿名 Binder。很多时候 Binder Server 会将一个 Binder 实体封装进数据包传递给 Binder Client，而此时 Binder Server 会在该数据包中标注 Binder 实体的位置，Binder Driver 会为该匿名的 Binder 生成实体结点和实体引用，并将该引用传递给 Binder Client。 IServiceManager 接口(声明 ServerManger 对外提供的方法、数据 )1234567891011121314151617181920212223public interface IServiceManager extends IInterface &#123; public IBinder getService(String name) throws RemoteException; public IBinder checkService(String name) throws RemoteException; */ public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException; public String[] listServices() throws RemoteException; public void setPermissionController(IPermissionController controller) throws RemoteException; static final String descriptor = "android.os.IServiceManager"; int GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION; int CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+1; int ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+2; int LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+3; int CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+4; int SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+5;&#125; 参考《Andorid 源码设计模式解析与实战》 如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 LayoutInflater]]></title>
    <url>%2Fblog%2F2017%2F08%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20LayoutInflater%2F</url>
    <content type="text"><![CDATA[基础系统服务的注册什么时候初始化 ContextImpl？ ContextImpl 中有这样一个成员变量，缓存系统服务。final Object[] mServiceCache = SystemServiceRegistry.createServiceCache(); 在 SystemServiceRegistry 中的静态代码块中注册。注册方法如下所示。在 static 代码块中，会注册所有的系统服务。 123456789/** * Statically registers a system service with the context. * This method must be called during static initialization only. */private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) &#123; SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);&#125; 以 LAYOUT_INFLATER_SERVICE 为例子，123456registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); CachedServiceFetcher 是一个实现了 ServiceFetcher&lt;T&gt; 接口的抽象类 createService 为 CachedServiceFetcher 中的抽象方法，当初始化时会调用该方法。1234567/** * Base interface for classes that fetch services. * These objects must only be created during static initialization. */static abstract interface ServiceFetcher&lt;T&gt; &#123; T getService(ContextImpl ctx);&#125; 123456789101112131415161718192021222324static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123; private final int mCacheIndex; public CachedServiceFetcher() &#123; mCacheIndex = sServiceCacheSize++; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public final T getService(ContextImpl ctx) &#123; final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; // Fetch or create the service. Object service = cache[mCacheIndex]; if (service == null) &#123;//使用了延时加载,第一次调用时才初始化，并将相应服务缓存起来。 service = createService(ctx); cache[mCacheIndex] = service; &#125; return (T)service; &#125; &#125; public abstract T createService(ContextImpl ctx);&#125; 系统服务的获取平时我们都是通过 Context.getSystemService(&quot;服务名字&quot;) 来获取服务。 具体为 ContextImpl 中的。1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; 而 getSystemService 的实际实现是在 SystemServiceRegistry 中的。 SystemServiceRegistry 中有一个 HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; ，该 HashMap 以服务名称为 key，以服务相对应的 ServiceFetcher 作为 value。 12private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); 具体的获取方法为1234567/** * Gets a system service from a given context. */public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; 根据服务名称去获取相应的 ServiceFetcher， 如果 ServiceFetcher 不为空，则调用 ServiceFetcher.getService 方法获取相应服务的引用。 如果是第一次调用会先创建，然后直接返回 否则直接返回缓存的值 如果 ServiceFetcher 为空，则返回 null。 深入理解 LayoutInflaterLayoutInflater的创建123456registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); 可见实际实现为 PhoneLayoutInflater（继承了 LayoutInflater） onCreateView 是其中最重要的方法。为什么说它重要，后面会提到。123456789101112131415161718192021/** Override onCreateView to instantiate names that correspond to the widgets known to the Widget factory. If we don't find a match, call through to our super class.*///为系统内置的控件添加前缀。比如为 TextView 添加前缀，结果为 android.widget.TextView@Override protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123; for (String prefix : sClassPrefixList) &#123; try &#123; View view = createView(name, prefix, attrs); if (view != null) &#123; return view; &#125; &#125; catch (ClassNotFoundException e) &#123; // In this case we want to let the base class take a crack // at it. &#125; &#125; return super.onCreateView(name, attrs);&#125; 渲染过程解析一般我们在渲染 ListView 或者 RecyclerView 中的列表时，都会调用 inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) 方法（有时也会使用两个参数的方法）。可以看到该方法内部会调用 inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)。123public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null);&#125; 1234567891011public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); //代码省略 //获取 xml 解析器 final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; //存储父视图 View result = root; try &#123; // 查找根标签 int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; final String name = parser.getName(); if (TAG_MERGE.equals(name)) &#123; //1. 解析 merge 标签 rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // 2. 不是 merge 元素就直接解析布局中的视图 // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; // 生成布局参数 params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; //如果 attachToRoot 为 false，就给 temp 设置布局参数 temp.setLayoutParams(params); &#125; &#125; // 解析 temp 视图下的所有子 View rInflateChildren(parser, temp, attrs, true); // 如果 root 不为空并且 attachToRoot 为 true，那么将 temp 添加到 父视图中 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; //如果 root 为空 或者 attachToRoot 为 false，返回 xml 中的 root，而不是父视图 if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; return result; &#125;&#125; 以上的 inflate 方法主要有以下几步 解析 xml 的根标签 如果根标签是 merge，调用 rInflate 进行解析，rInflate 会将 merge 标签下的所有子 View 直接添加到根标签中 如果标签是普通元素，调用 createFromTag 调用 rInflate 解析 temp 根元素下的所有子 View，并且将这些子 View 都添加到 temp 下 返回解析到的根视图。 我们先从解析单个元素的 createViewFromTag 方法看起。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals(&quot;view&quot;)) &#123; name = attrs.getAttributeValue(null, &quot;class&quot;); &#125; // Apply a theme wrapper, if allowed and one is specified. if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; try &#123; View view; //用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段 if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf(&apos;.&apos;)) &#123; // 解析内置 View 控件 view = onCreateView(parent, name, attrs); &#125; else &#123; // 解析自定义控件 view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; //代码省略 onCreateView 方法和 createView 方法有何不同？前面的介绍中，我们有提到 LayoutInlflater 创建的实际类型为 PhoneLayoutInlflater ，PhoneLayoutInlflater 覆写了 onCreateView 方法，该方法就是在 View 的标签名前添加一个 &quot;android.widget.&quot; 或 &quot;android.webkit.&quot; 或 &quot;android.app.&quot;前缀。然后再传递给 createView 解析。 也就是说内置 View 和自定义 View 最终都调用了 createView 进行解析。 为什么要这么设计呢？这是为了方便开发者在 xml 文件中更方便使用系统内置的 View（只需要写 View 名称而不需要写完整的路径），如果是自定义控件或者第三方库，写完整路径。 createView 的具体实现如下12345678910111213141516171819202122232425262728293031323334353637383940414243//根据完整路径的类名通过反射机制构造 View 对象public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; //从缓存中获取构造函数 Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); // 缓存中找不到构造函数 if (constructor == null) &#123; //如果前缀（prefix）不为空，构造完整路径，并且加载该类 clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); //代码省略 //从 class 对象中获取构造函数 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); &#125; else &#123; //代码省略 &#125; &#125; Object[] args = mConstructorArgs; args[1] = attrs; //通过反射构造 View final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123; // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; return view; &#125; //省略各种 catch、finally 代码&#125; createView 方法中，如果控件名有前缀就先构造 View 的完整路径，并且将该类加载到虚拟机中 然后获取该类的构造函数并缓存起来，再通过构造函数来创建该 View 的对象， 最后将 View 对象返回，这就是解析单个 View 的过程 123456789101112131415161718192021222324252627282930313233343536373839404142void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; //获取树的深度 final int depth = parser.getDepth(); int type; //逐个元素解析 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123;//解析 include 标签 if (parser.getDepth() == 0) &#123; throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123;解析 merge 标签 throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); &#125; else &#123; //根据元素名进行解析 final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); //递归调用进行解析，即深度优先遍历 rInflateChildren(parser, view, attrs, true); //将解析到的 View 添加到它的父视图中 viewGroup.addView(view, params); &#125; &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125; rInflate() 通过深度优先遍历来构造视图树。每解析到一个 View 元素就会递归调用 rInflate，直到这条路径下的最后一个元素，然后在回溯过来将每个 View 元素添加到它们的 parent 中。 通过 rInflate 的解析之后，整棵视图树就构建完毕。当调用了 Activity 的 onResume 之后，之前通过 setContentView 设置的内容就会出现在我们的视野中。 总结渲染流程大致如下： inflate 查找根标签 如果是 merge，调用 rInflate 否则，调用 createViewFromTag 如果是系统内置控件（通过名称中是否含有「.」来判断），调用 PhoneLayoutInflater.onCreateView() 方法添加前缀， 处理后将完整路径传给 LayoutInflater.createView() 方法 否则，直接调用 LayoutInflater.createView() 进行解析。 参考《Android 源码设计模式解析与实战》]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中子线程真的不能更新UI吗？]]></title>
    <url>%2Fblog%2F2017%2F08%2F16%2FAndroid%20%E4%B8%AD%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97%2F</url>
    <content type="text"><![CDATA[Android中子线程真的不能更新UI吗？先说结论：Android 中子线程在满足一定的条件下可以更新 UI。 一个栗子：1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.btn1) Button mBtn1; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; mBtn1.setText("worker thread"); &#125; &#125;).start(); &#125;&#125; 如上在 onCreate 方法中新建一个线程对 mBtn1 进行了操作，成功从子线程更新了 ui。 但是如果让线程 sleep 一段时间（比如 300ms），1234567891011new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mBtn1.setText("worker thread"); &#125;&#125;).start(); 那么就很可能会报如下错误：1234567891011android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:4788) at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:865) at android.view.ViewGroup.invalidateChild(ViewGroup.java:4106) at android.view.View.invalidate(View.java:10386) at android.view.View.invalidate(View.java:10341) at android.widget.TextView.checkForRelayout(TextView.java:6657) at android.widget.TextView.setText(TextView.java:3696) at android.widget.TextView.setText(TextView.java:3554) at android.widget.TextView.setText(TextView.java:3529) at com.android.rdc.androidsamples.MainActivity$1.run(MainActivity.java:63) 分析为什么会报这个错误呢？从出错的堆栈信息中可以异常看到是 ViewRootImpl.checkThread() 方法中抛出的。123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125;&#125; 在访问UI的时候，ViewRootImpl会去检查当前是哪个线程访问的UI，如果不是主线程，那就会抛出异常： 分析到了这里，其实异常信息对我们帮助也不大了，它只告诉了我们子线程中访问UI在哪里抛出异常。 而我们会思考：当访问UI时，ViewRootImpl 会调用 checkThread 方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，这是没问题的。但是为什么一开始在 MainActivity 的 onCreate 方法中创建一个子线程访问UI，程序还是正常能跑起来呢？答案就是执行 onCreate 方法的那个时候 ViewRootImpl 还没创建，无法去检查当前线程。那么，ViewRootImpl 创建之前的，程序对 UI 的更新操作是如何进行的呢？这个问题我暂时还没有找出答案，希望有了解的同学能指导一下。 回过头看，抛异常的方法既然是 ViewRootImpl 中的方法，那首先应该去看看 ViewRootImpl 是在哪里、在什么时候被创建的。在 AS 中对 ViewRootImpl 进行查找，发现唯一一个初始化了它的地方是 WindowManagerGlobal.addView() 方法。1234567891011public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //代码省略 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams);&#125; 可以看到，该方法创建了一个 ViewRootImpl 并将它添加到一个列表中。 该方法又是什么被调用的呢？对 Window 和 WindowManager 有所了解的同学应该知道，Window 的添加过程。 先来看看 ActivityThread 中的 handleResumeActivity 方法123456789101112final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; //代码省略 r = performResumeActivity(token, clearHide, reason); //代码省略 r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125;&#125; 该方法内部调用了 performResumeActivity 方法，看这个方法名可以揣测该方法最终会调用 Activity 的 onResume 方法，大致流程如下。 ActivityThread.performResumeActivity ==》 ActivityClientRecord.Activity.performResume(); ==》 Instrumentation.callActivityOnResume(this); ==》 Activity.onResume(); 回归正题。执行完 performResumeActivity 方法后，会执行 r.activity.makeVisible()，即调用 Activity 的 makeVisible() 。该方法实现如下：12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; 此处调用了 WindowManager.addView() 方法。而 WindowManger 是一个接口，它的具体实现为 WindowManagerImpl12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; 这里的 mGlobal 为 WindowManagerGlobal，也就是说调用了 WindowManagerGlobal.addView() 创建 ViewRootImpl 总结：ViewRootImpl 的创建在 onResume 方法回调之后，而我们一开篇是在 onCreate 方法中创建了子线程并访问 UI，在那个时刻，ViewRootImpl 还没有创建，无法检测当前线程是否是 UI 线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了 300 毫秒后，程序就崩了。很明显 300 毫秒后 ViewRootImpl 已经创建了，可以执行 checkThread 方法检查当前线程。 开篇的例子中我们在 onCreate 方法中创建的子线程访问 UI 是一种极端的情况。实际开发中不会这么做。 下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答： 子线程可以更新UI，但是需要创建子线程的根视图（RootView），并添加到 WindowManager，还要创建子线程的 Looper。以上条件都满足时，它可以修改它自己创建的根视图中的 UI。 参考 Android中子线程真的不能更新UI吗？ 多线程学习之–真的不能在子线程里更新UI吗？ 互联网笔记 Android中子线程真的不能更新UI吗？]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码中的观察者模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F09%2FAndroid%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[解决、解耦的钥匙——观察者模式定义观察者模式定义了对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 使用场景 关联行为场景 需要注意的是，关联行为是可拆分的，而不是“组合”关系 事件多级触发场景 跨系统的消息交换场景，如消息队列、事件总线的处理机制。 UML 类图UML 类图如下所示： 四个角色： Subject 抽象主题（抽象的被观察者）。把所有观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，提供接口供添加和删除观察者对象。 ConcreteSubject 具体主题（具体的被观察者）。将有关状态存入具体观察者对象，在具体主题的内部实现发生改变时，给所有注册过的观察者发出通知 Observer 抽象观察者。定义一个更新接口，用来接收主题更改时做出相应的操作（比如更新自身的状态） ConcreteObserver 具体观察者（实现抽象观察者所定义的更新接口，以便在主题状态更改时更新自身的状态） Android ListView 的观察者模式ListView 和 RecyclerView 在 Android 中都占据着很重要的地位。 使用这两个组件时，总免不了数据更新的情况：当要更新数据时我们通常都会调用 Adapter.notifyDataSetChanged()，这其中的原理又是怎么样的呢？ 下面以 ListView 作为一个栗子，看看其中的具体实现是怎么样的。 123public void notifyDataSetChanged() &#123; mDataSetObservable.notifyChanged();&#125; 1234567891011public void notifyChanged() &#123; synchronized(mObservers) &#123; // since onChanged() is implemented by the app, it could do anything, including // removing itself from &#123;@link mObservers&#125; - and that could cause problems if // an iterator is used on the ArrayList &#123;@link mObservers&#125;. // to avoid such problems, just march thru the list in the reverse order. for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125;&#125; notifyDataSetChanged 方法会调用 DataSetObservable.notifyChanged() 方法,notifyChanged() 内部会遍历调用观察者的 onChanged() 方法。通知数据更新。 但是观察者又是什么时候注册的呢？ 以下为 setAdapter 的方法的具体实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Overridepublic void setAdapter(ListAdapter adapter) &#123; //如果 已经有 Adapter 存在，先解除注册 if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mAdapter.unregisterDataSetObserver(mDataSetObserver); &#125; resetList(); mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; mAdapter = adapter; &#125; mOldSelectedPosition = INVALID_POSITION; mOldSelectedRowId = INVALID_ROW_ID; // AbsListView#setAdapter will update choice mode states. super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; mItemCount = mAdapter.getCount(); checkFocus(); // 构建一个 AdapterDataSetObserver mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者 mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; if (mStackFromBottom) &#123; position = lookForSelectablePosition(mItemCount - 1, false); &#125; else &#123; position = lookForSelectablePosition(0, true); &#125; setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) &#123; // Nothing selected checkSelectionChanged(); &#125; &#125; else &#123; mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); &#125; requestLayout();&#125; 通过源码可以看到，setAdapter 方法内部会构建一个 AdapterDataSetObserver ，然后注册为观察者。我们还可以看到注册的时候是通过 Adapter 来注册的。 Adapter 接口中声明了注册和解注册的方法签名。1234567891011121314151617public interface Adapter &#123; /** * Register an observer that is called when changes happen to the data used by this adapter. * * @param observer the object that gets notified when the data set changes. */ void registerDataSetObserver(DataSetObserver observer); /** * Unregister an observer that has previously been registered with this * adapter via &#123;@link #registerDataSetObserver&#125;. * * @param observer the object to unregister. */ void unregisterDataSetObserver(DataSetObserver observer); //代码省略&#125; 而 BaseAdapter 实现了 ListAdapter 接口，ListAdapter 接口又继承自 Adapter 接口。BaseAdapter 中注册方法和解除注册方法的具体实现： 1234567public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer);&#125;public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer);&#125; BaseAdapter 中注册方法和解除注册方法的具体实现都是通过 mDataSetObservable 来完成的。查看一下 DataSetObservable 的具体实现。1234567891011121314151617public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123; public void notifyChanged() &#123; synchronized(mObservers) &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125; &#125; public void notifyInvalidated() &#123; synchronized (mObservers) &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onInvalidated(); &#125; &#125; &#125;&#125; 该类继承了 android.database 包下的 Observable 类，而 Observable 类中存有所有观察者的引用，以及注册和解注册方法。 ListView 中的 onChange 方法具体实现又是什么样的? 还记得前面我们说 Observer 是如何注册的吗？注册时，我们构建的是 AdapterDataSetObserver。 该类是 AbsListView 的内部类。 AbsListView.AdapterDataSetObserver 继承自 AdapterView.AdapterDataSetObserver onChange 方法的主要逻辑都在 AdapterDataSetObserver 中 12345678910111213141516171819202122class AdapterDataSetObserver extends DataSetObserver &#123; //代码省略 ... @Override public void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); requestLayout(); &#125; //代码省略 ...&#125; onChange 方法中，会获取当前 Adapter 中的数据集的新数量，方法的最后调用 ListView 的 requestLayout() 方法重新进行布局。 从上面的分析中，我们可以看到 AbsListView 是抽象的观察者 ListView 是具体的观察者 Adapter 接口是抽象的被观察者 BaseAdapter 是具体的被观察者，其内部实际上是通过 android.database 包下的 Observerable 来实现注册和监听的。 小结 AdapterView 中有一个 AdapterDataSetObserver 内部类， 在 ListView 中设置 Adapter（即调用 ListView 的 setAdapter 方法）时，其内部会构建一个 AdapterDataSetObserver，并注册到 Adapter 中。可见该场景中 ListView 扮演一个观察者角色。 而 Adapter 中有一个数据集可观察者 DataSetObserable。即一个被观察者。 数据集发生变化时，开发者手动调用 Adapter.notifyDataSetChanged 方法，notifyDataSetChanged 会调用 DataSetObserverable.notifyChanged() notifyChanged() 方法会遍历所有观察者，并调用观察者的 onChanged 方法， onChanged 会获取 Adapter 中数据集的新数量，同时会调用 View.requestLayout 方法通知 ListView 更新布局，刷新用户界面。 虽然 RecyclerView 直接继承自 ViewGroup，而不是 AdapterView ，但是更新列表数据集方法的内部也是通过观察者模式来实现的。只是在其中多提供了单个数据或者指定范围数据更新等回调接口，供开发者使用。感兴趣的同学可以去看看 RecyclerView 中观察者模式的实现。 作者水平有限，疏漏之处，恳请指出。 参考 《Android 源码设计模式解析与实战》 第十二章]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toast 原理]]></title>
    <url>%2Fblog%2F2017%2F07%2F28%2FToast%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Toast.makeText(context,”msg”,Toast.Length_SHORT).show();`我们都知道调用了这行代码，便会触发显示 Toast 信息，但是从调用开始到显示出来的具体过程是怎么样的，里面具体实现又是怎么样的呢？ 在 Toast 内部有两类 IPC 过程。 第一类： Toast 访问 NotificationManagerService 第二类：NotificationManagerService 回调 Toast 里的 TN 接口。 Toast 属于系统 Window，它内部的视图由两种方式指定，一种是系统默认的样式，另一种是自定义一个 view 然后通过 setView 方法将 view 设置进去。不管哪一种方式，它们都对应 Toast 的一个 View 类型的内部成员 mNextView。 Toast 提供 show 和 cancel 方法分别用于显示和隐藏 view，它们的内部都是一个 IPC 过程。 Toast 有定时取消功能，所以系统采用了 Handler（利用其中的 sendMessageDelayed() 方法） Toast.show() 调用流程大致如下： 先来看看 Toast.makeText 方法1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context);//创建一个新的 Toast 对象 LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取 LayoutInflater View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); //渲染出系统默认的布局 TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text);//将我们的信息设置到 TextView 中去 result.mNextView = v;//把 view 赋给 Toast 内部的View result.mDuration = duration;//设置 toast 时长 return result;&#125; 再瞧一瞧 Toast.show(); 方法12345678910111213141516public void show() &#123; if (mNextView == null) &#123;//判断，如果没有设置 Toast 的 view，就抛出异常 throw new RuntimeException(&quot;setView must have been called&quot;); &#125; INotificationManager service = getService();//获取 INotificationManager String pkg = mContext.getOpPackageName();// 获取调用者的包名 TN tn = mTN;//给 TN 赋值 tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; 这里面有几个地方看起来比较陌生 INotificationManager 是什么，TN 又是什么？ INotificationManager 的值是从 getService() 方法中得来的。我们先查看下 getService() 的内部实现：1234567static private INotificationManager getService() &#123; if (sService != null) &#123; return sService; &#125; sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService;&#125; 了解 Binder 的同学应该一看便知道，这里用到了 Binder。 INotificationManager 的具体实现在 NotificationManagerService 中，简便起见，后续内容将 NotificationManagerService 称为 NMS。 TN 又是什么？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140private static class TN extends ITransientNotification.Stub &#123; final Runnable mHide = new Runnable() &#123; @Override public void run() &#123; handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; &#125; &#125;; private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams(); final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; IBinder token = (IBinder) msg.obj; handleShow(token); &#125; &#125;; int mGravity; int mX, mY; float mHorizontalMargin; float mVerticalMargin; View mView; View mNextView; int mDuration; WindowManager mWM; static final long SHORT_DURATION_TIMEOUT = 5000; static final long LONG_DURATION_TIMEOUT = 1000; TN() &#123; // XXX This should be changed to use a Dialog, with a Theme.Toast // defined that sets up the layout params appropriately. final WindowManager.LayoutParams params = mParams; params.height = WindowManager.LayoutParams.WRAP_CONTENT; params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.format = PixelFormat.TRANSLUCENT; params.windowAnimations = com.android.internal.R.style.Animation_Toast; params.type = WindowManager.LayoutParams.TYPE_TOAST; params.setTitle("Toast"); params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; &#125; /** * schedule handleShow into the right thread */ @Override public void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "SHOW: " + this); mHandler.obtainMessage(0, windowToken).sendToTarget(); &#125; /** * schedule handleHide into the right thread */ @Override public void hide() &#123; if (localLOGV) Log.v(TAG, "HIDE: " + this); mHandler.post(mHide); &#125; public void handleShow(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "HANDLE SHOW: " + this + " mView=" + mView + " mNextView=" + mNextView); if (mView != mNextView) &#123; // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) &#123; context = mView.getContext(); &#125; mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123; mParams.horizontalWeight = 1.0f; &#125; if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123; mParams.verticalWeight = 1.0f; &#125; mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; mParams.hideTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT; mParams.token = windowToken; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; if (localLOGV) Log.v(TAG, "ADD! " + mView + " in " + this); mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125; &#125; private void trySendAccessibilityEvent() &#123; AccessibilityManager accessibilityManager = AccessibilityManager.getInstance(mView.getContext()); if (!accessibilityManager.isEnabled()) &#123; return; &#125; // treat toasts as notifications since they are used to // announce a transient piece of information to the user AccessibilityEvent event = AccessibilityEvent.obtain( AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED); event.setClassName(getClass().getName()); event.setPackageName(mView.getContext().getPackageName()); mView.dispatchPopulateAccessibilityEvent(event); accessibilityManager.sendAccessibilityEvent(event); &#125; public void handleHide() &#123; if (localLOGV) Log.v(TAG, "HANDLE HIDE: " + this + " mView=" + mView); if (mView != null) &#123; // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeViewImmediate(mView); &#125; mView = null; &#125; &#125;&#125; TN 是 Toast 的一个私有的静态内部类，继承自 ITransientNotification.Stub 也是用到了 Binder 机制。 在回到 show 方法。该方法最后调用了 service.enqueueToast(pkg, tn, mDuration); 方法。我们到 NMS 看看该方法的主要实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 @Overridepublic void enqueueToast(String pkg, ITransientNotification callback, int duration)&#123; //.... final boolean isSystemToast = isCallerSystem() || ("android".equals(pkg));//是否是 android 系统的 toast final boolean isPackageSuspended = isPackageSuspendedForUser(pkg, Binder.getCallingUid()); //... synchronized (mToastQueue) &#123; int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try &#123; ToastRecord record; int index = indexOfToastLocked(pkg, callback);//根据包名和回调来获取的对应包名的 Toast 的在 mToastQueue 中的位置（如果有的话） //如果对应包名的 Toast 已经存在了，则直接在原位更新，不会把它排到队尾 if (index &gt;= 0) &#123; record = mToastQueue.get(index); record.update(duration); &#125; else &#123; //限制非系统应用的数量（不能超过 50），防止 DOS 攻击同时也是为了解决内存泄漏问题 if (!isSystemToast) &#123; int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) &#123; final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) &#123; count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123; Slog.e(TAG, "Package has already posted " + count + " toasts. Not showing more. Package=" + pkg); return; &#125; &#125; &#125; &#125; Binder token = new Binder(); mWindowManagerInternal.addWindowToken(token, WindowManager.LayoutParams.TYPE_TOAST); record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord mToastQueue.add(record);//加入 mToastQueue index = mToastQueue.size() - 1; keepProcessAliveIfNeededLocked(callingPid); &#125; if (index == 0) &#123; showNextToastLocked();//显示下一条 Toast &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125; &#125;&#125; 该方法会将 Toast 请求封装为 ToastRecord 并将其添加进 mToastQueue 队列中。 mToastQueue 是一个 ArrayList 注意：每个非系统应用最多只能有 50 个ToastRecord。如果超出了最大值，就会出错。 这样做主要是为了 防止 DOS（Denial Of Service） 拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 将 ToastRecord 加入队列之后， enqueueToast 还调用了 showNextToastLocked(); 方法, 该方法的具体实现如下：12345678910111213void showNextToastLocked() &#123; ToastRecord record = mToastQueue.get(0); while (record != null) &#123; if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try &#123; record.callback.show(record.token);//调用 record 对象中 callback 的 show 方法 scheduleTimeoutLocked(record); //超时提醒，控制显示时间 return; &#125; catch (RemoteException e) &#123; //...代码省略 &#125; &#125;&#125; 这里的 callBack 是什么？ 它是在 ToastRecord 中的，瞅瞅 ToastRecord 的构造方法。12345678ToastRecord(int pid, String pkg, ITransientNotification callback, int duration, Binder token) &#123; this.pid = pid; this.pkg = pkg; this.callback = callback; this.duration = duration; this.token = token;&#125; 在 enqueueToast 方法中，将 Toast 包装为 ToastRecord ，创建了 ToastRecord 对象。 record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord callBack 是 enqueueToast 中的一个参数，我们的调用如下： service.enqueueToast(pkg, tn, mDuration); 没错，callBack 实际上就是前面讲到的 Toast 的内部类 TN。 回到前面看看，TN 确实继承了 ITransientNotification.Stub。 showNextToastLocked() 方法调用 callBack 的 show() 方法来显示 Toast。 12345@Overridepublic void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.obtainMessage(0, windowToken).sendToTarget();&#125; 1234567final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; IBinder token = (IBinder) msg.obj; handleShow(token); &#125;&#125;; 其具体实现又是在 handleShow(token);1234567891011121314151617public void handleShow(IBinder windowToken) &#123; if (mView != mNextView) &#123; // 如果有必要的话，将还在显示的 toast 隐藏掉 handleHide(); mView = mNextView; //代码省略 mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);//获取 windowManager //省略代码，给布局参数赋值 if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125;&#125; 以上代码核心在于12`mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);``mWM.addView(mView, mParams);` 将 Toast 的视图添加到 Window 中。 这样 View 就能顺利显示出来了。 你可能会问，为什么 TN 调用 show 方法要用到的 Handler ？ 因为该方法是被是被 NMS 以跨进程方式调用的，因此它们运行在 Binder 线程池中。为了将执行环境切换到 Toast 请求所在的线程，在它们内部使用了 Handler。 那么时间到了 Toast 又是怎么样取消的呢？ 在令 Toast 显示方法调用过程中 我们也调用了 scheduleTimeoutLocked(record); 方法。 123456private void scheduleTimeoutLocked(ToastRecord r)&#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;//设置 延迟时间 mHandler.sendMessageDelayed(m, delay);&#125; SHORT_DELAY 为 2s LONG_DELAY 为 3.5s scheduleTimeoutLocked 会发出消息给 hanlder,收到相应的信息后 handleMessage 方法会调用handleTimeout((ToastRecord)msg.obj);, 该方法又会调用 cancelToastLocked(index); 123456789void cancelToastLocked(int index) &#123; ToastRecord record = mToastQueue.get(index); try &#123; record.callback.hide();// &#125; catch (RemoteException e) &#123; //代码省略 &#125; //代码省略&#125; 可以看到隐藏 Toast 的实现也是在 TN 中的。与 handleShow 对应，有一个 handleHide 方法。该方法会将 Toast 的视图从 Window 中移除。如下所示：12345678public void handleHide() &#123; if (mView != null) &#123; if (mView.getParent() != null) &#123; mWM.removeViewImmediate(mView); &#125; mView = null; &#125;&#125;]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之单例模式]]></title>
    <url>%2Fblog%2F2017%2F07%2F20%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、什么是单例模式？wiki 给出的定义如下：单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。 比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 二、为什么要使用单例模式？ 有一些对象的内存消耗比较大，创建多次会造成很大的资源开支。 方便配置。 例如 网络请求经常要用到 cookie，如果使用 OkHttp 可以将其封装为一个单例工具类，内部使用 CookJar 对 cookie 进行管理，这样后续的请求就会方便很多。 三、单例模式的实现方式1. 饿汉模式1234567891011public class Singleton &#123; private static Singleton sInstance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance() &#123; return sInstance; &#125;&#125; 在声明静态对象时就把它初始化。（因为饿，所以迫不及待先把它 new 出来） 2. 懒汉模式1234567891011121314public class Singleton &#123; private static Singleton sInstance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (sInstance == null) &#123; sInstance = new Singleton(); &#125; return sInstance; &#125;&#125; 在 getInstance 方法中添加了 synchronized 关键字，也就是 一个问题：即使 instance 已经被初始化，之后的每次调用还是会 进行同步，这样会消耗不必要的资源 为什么叫做懒汉呢？其实可以理解为懒加载，有需要的时候，再把它加载出来。 懒汉单例模式的 优点：单例只有在使用时才会被实例化，在一定程度上节约了资源。 缺点：第一次加载时需要及时地实例化，反应稍慢，最大的问题是：每次调用都会进行同步，造成不必要的同步开销。 3. 双重校验锁 ( DCL )DCL 既能够在需要时才初始化实例，又能够保证线程安全，而且单例对象初始化后才调用 getInstance 不进行同步锁。12345678910public static Singleton getInstance()&#123; if (sInstance == null)&#123; synchronized (Singleton.class)&#123; if (sInstance == null)&#123; sInstance = new Singleton(); &#125; &#125; &#125; return sInstance;&#125; 为什么在同步块内还要再进行判空？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 为什么要加 volitale 关键字？sInstance = new Singleton();这句代码会被编译成多条汇编指令，它大致做了 3 件事情 给 Singleton 实例分配内存 调用 Singleton 的构造函数，初始化成员字段 将 sInstance 对象指向分配的内存空间 但是由于 Java 编译器允许处理器乱序执行，以及 JDK 1.5 之前 JMM（Java Memory Model， Java 内存模型） 中 cache、寄存器到主内存回写顺序的规定，上面的 2 和 3 的顺序是无法保证的。 如果是 1-3-2，那么当 3 执行完，并且 2 还没有执行的话，被切换到到线程 B，这时 sInstance 已经非空（因为 3 已经被执行了嘛），若 此时线程 B 直接取走 sInstance 使用时就会报错。 解决：JDK 1.5 之后，SUN 官方调整了 JVM，具体化了 volatile 关键字（禁止指令重排序）。 如果是在 JDK 1.5 之后，那么只需要把 sInstance 的声明 改为 private volatile static Singleton sInstance; 即可 4. 静态内部类单例模式DCL 在某些情况下会出现失效的问题。这个问题被称为双重检查锁定（DCL）失效。 123456789101112public class Singleton&#123; private static volatile Singleton; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static final Singleton sInstance = new Singleton(); &#125;&#125; 第一次调用 Singleton 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 SingletonHolder 类，这种方式不仅能够确保线程安全，也能保证单例对象的唯一性。 所以这是推荐使用的单例模式实现方式 5. 枚举单例对枚举不了解可以先看看枚举这篇文章 写法简单是枚举单例 最大的优点。12345678910public enum Singleton&#123; INSTANCE; //枚举内部可以定义成员； private String mString; //枚举内部可以定义方法； public void doSth() &#123; //do sth &#125;&#125; 获取对象：只需要 Singleton singleton = Singleton.INSTANCE; 枚举在 Java 中与普通的类是一样的，不仅能够有字段，还能定义自己的方法。最重要的是默认枚举实例的创建是线程安全的，并且任何情况下它都是一个单例。 上述几种方式中，在一个情况下都会重新创建对象的情况，那就是反序列化。 即使构造函数是私有的，反序列化是依然可以通过特殊的途径去创建类的一个新的实例，相当于 调用该类的构造函数。 反序列化操作提供了一个很特别的钩子函数，类中具有一个私有的、被实例化的方法 readResolve(),这个方法可以让开发人员控制对象的反序列化。 上述几种单例方法中如果要杜绝单例对象在被反序列化时重新生成对象，那必须加入如下方法：123private Object readResolve() throws ObjectStreamException &#123; return sInstance;&#125; 也就是在 readResolve 方法中将 sInstance 对象返回，而不是默认的重新生成一个新的对象。 而对于枚举，并不存在这个问题，因为即使反序列化也不会重新生成新的实例。 6. 使用容器实现单例模式1234567891011121314151617public class SingletonManager &#123; private static Map&lt;String, Object&gt; sObjectMap = new HashMap&lt;&gt;(); private SingletonManager() &#123; &#125; public static void registerService(String key, Object instance) &#123; if (!sObjectMap.containsKey(key)) &#123; sObjectMap.put(key, instance); &#125; &#125; public static Object getService(String key) &#123; return sObjectMap.get(key); &#125;&#125; 在程序的初始，将多种单例类型注入到一个统一的管理类中，使用时格根据 key 获取对象对应类型的对象。 这种实现方式主要是方便对单例对象进行统一管理。 小结 不管使用哪一种形式实现单例模式，核心原理都是==将构造函数私有化==，并且==通过静态方法获取唯一的的实例==。 在获取的过程中必须保证线程安全、防止反序列化导致重新生成实例对象等问题。 使用时的注意点避免内存泄漏 Android 开发中使用单例模式，如果获取单例对象需要使用 Context，那么尽量使用 ApplicationContext(只要用 contxt.getApplicationContext() 即可获取)。因为如果使用其他 Context（如 Activity) 可能会造成 Activiity 生命周期 执行完成之后，因为其引用被单例所持有，而无法被回收。 多进程环境下，单例模式会失效。 Android 源码中的单例模式简述我们经常会通过 Context 去获取系统服务，如 LayoutInflater、NetworkStatsManager，这些服务在创建时会以键值对的形式缓存到 HashMap 中，便于管理。 需要时就通过调用 context.getSystemService(String name) 方法获取 。首先会以 name 作为 key，到 hashMap 中查找中相应的服务，如果对应的服务为 null 就创建一个实例，并将该实例缓存到 HashMap 中；如果对应的服务已经存在，则直接返回。 参考资料与学习资源推荐 wiki 单例模式 Android 源码设计模式 单例模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 消息机制解析]]></title>
    <url>%2Fblog%2F2017%2F04%2F28%2FAndroid-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述提起 Handler，相信大家都不会陌生，日常开发中不可避免地要使用到它。今天要讲的是消息机制。消息机制？咋听起来有点抽象。其实我们在使用 Handler 的时候，就使用了 Android 的消息机制。 从开发的角度来看，Handler 是 Android 消息机制的上层接口，这使得开发过程中只需要设计这方面的内容即可。但是作为一名合格的开发者，弄清它的实现原理是很有必要的。 俗话说得好，一图胜千言，我们先来看下 Android 消息机制简单示意图（参考自网络）吧。 我们把 Thread 比作是一个 发动机，MessageQueue 看作是一条流水线，Message 就像是流水线上的工人，Looper 是流水线下的滚筒，Handler 像是一个工人，它负责把 Message 这个产品送到流水线上，最后又负责把它取走。 这幅图中的各个组件的说明如下： Looper ==》 滚轮 MessageQueue ==》 流水线 Message ==&gt; 流水线上的产品 Handler ==》 扮演把『产品』送进流水线，完了以后又把『产品』取走的角色 Thread ==》 动力 另外还有一个重要概念 ——ThreadLocal 图中没有标明出来。下面对各个部分进行详细介绍。 Android 的消息机制分析从 Handler 出发相信很多做 Android 开发的同学都写过与下面相似的代码。在子线程中做一些耗时操作，比如网络请求，操作完成之后，将返回的数据包装为 Message 对象然后调用 sendMessageXxx 方法，最后在 handleMessage 方法中对结果进行处理。 12345678910111213141516171819202122232425Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 1: //handle break; default: super.handleMessage(msg); &#125; &#125;&#125;;public void do() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //do sth Message message = mHandler.obtainMessage(); message.what = 1; message.obj = result; mHandler.sendMessage(message); &#125; &#125;);&#125; 从 Handler.sendMessage(message) 到 Handler.handlerMessage方法经历了什么样的过程？ 我们先看看 sendMessage 方法内部是怎么实现的。 12345678910111213141516171819202122232425262728293031public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 整个调用流程是这样的 sendMessage ==》 sendMessageDelayed ==》 sendMessageAtTime ==》 enqueueMessage ==》 MessageQueue.enqueueMessage 我们可能还会调用 Handler.post(Runnable)方法到目标线程中执行 run 方法。post 方法会先调用 getPostMessage方法将 Runable 包装为 一个 Message 对象，（Runnable 就存储在 callback 中）。其他的 postXxx(Runnable)方法内部实现也是这样的流程，首先将 Runnable 包装为一个 Message 对象然后调用相应的 sendXxx 方法。 123456789public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123;//将 Runnable 包装为一个 Message 对象 Message m = Message.obtain(); m.callback = r; return m;&#125; 从上述的调用流程可以看出 sendXxx 或者 postXxx 方法最终都会调用 MessageQueue 的 enqueueMessage方法，将 Message 追加到 MessageQueue 中。 小结 Handler 的消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。 post 系列方法最终是通过 send 的一系列方法来实现的。 Handler 的发送消息的过程仅仅是向消息队列插入了一条消息。 MessageQueue 对象是从哪里来的？mQueue 是 Handler 的一个成员变量，它是在哪里初始化的呢？先看看 Handler 的构造方法 123456789101112131415public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; //代码省略 mLooper = Looper.myLooper();//获取当前线程的 Looper if (mLooper == null) &#123; throw new RuntimeException(//抛出异常，不能在没有 Looper 的线程创建 Handler "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//从本线程的 Looper 中获取 MessageQueue mCallback = callback;//回调 mAsynchronous = async;//是否异步&#125; 我们看到 mQueue 是从 Looper 中取出的。在解说 Looper 之前，我们先看看前面提到的 MessageQueue 。 MessageQueue 的工作原理MessageQueue 主要包含两个操作：插入和读取（分别对应 enqueueMessage 和 next 方法）。 顾名思义，enqueueMessage 的作用是往队列中插入一条信息。 next() 的作用是从队列中取出一条信息并将其从消息队列中移除。 虽然 MessageQueue 名为消息队列，但是它的内部实现并不是用队列，而是通过一个单链表的数据结构来维护消息列表。 为什么选择使用单链表结构？ 因为 Message 是可以定时发送的，若使用普通的队列，当插入一个发送时间晚于队首 Message 发送时间的新 Message，那么就需要插队，实现起来不方便，而使用优先队列又显得比较复杂。因此就采用了单链表实现。 接下来我们重点看看 enqueueMessage 方法和 next 方法。 enqueueMessage 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; // 要进入队列的消息对象的目标 handler 不能为空 throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; // 要进入队的消息不能处在使用状态 throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123;//入队需要先获取内置锁 if (mQuitting) &#123; // 已经调用过 Looper.quit / Looper.quitSafely 方法。 MessageQueue 中不能再追加 Message 对象 IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle();//回收消息 return false;//返回 false 表示入队失败 &#125; // 标记消息为使用状态；设置消息发送的时间；是否需要唤醒 msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //将消息插入到队首 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; //通过该循环找到合适的插入位置（以发送的时间作为排序的标准） for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; //插入队列的指定位置中 msg.next = p; prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr);//当前处于阻塞状态，通过「写描述符」唤醒线程，从而使得 MessageQueue#next 方法中的 nativePollOnce 能够返回。（实际上运用了 Linux 的 epoll 机制） &#125; &#125; return true;&#125; 从代码中不难看出，enqueueMessaege 虽然有点长，但是逻辑还是比较清晰的。它先做了一些状态判断以及一些边界检测，完了以后再进行单链表的插入操作。 next 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; //代码省略 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //处理 native 层事件（内部使用 Linux 的 epoll 机制），可能会阻塞 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123;//如果消息的目标 Handler 为空 do &#123; // 找出队列中下一个异步 Message 对象 prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 计算下一条消息的执行时间，设置一个唤醒的延迟 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 队首 Message 执行的时机到了，获取一条消息 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse();//标记 Message 为正在使用状态 return msg;//返回消息 &#125; &#125; else &#123; // 队列中没有消息了 nextPollTimeoutMillis = -1; &#125; // 外部调用了 quit 方法。退出 if (mQuitting) &#123; dispose(); //处理底层消息队列。实际上移除了 native 层的消息队列 return null; &#125; if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // 没有可运行的闲置 handler。跳出本次循环再等待。 mBlocked = true; continue; &#125; //代码省略 &#125; &#125; next 方法中有一个死循环，其主要逻辑如下: 如果消息队列中没有消息，那么 next 会一直阻塞在那里。 当队首的消息设置了延迟执行时，会造成短时间的阻塞。 当有新消息到来时，next 方法会返回这条信息并将其从单链表中移除。 当调用了 quit 方法之后，mQuitting 为 true ，next 方法会移除 native 层的消息队列并返回 null。 整个 next 方法的逻辑如下： 从消息队列中依次取出消息。如果这个消息到了执行时间，那么就将该消息返回给 Looper，并且将消息队列链表的指针后移。实际上消息队列维护着一个分发屏障(dispatch barrier)，当一个 Message 的时间戳低于这个值的时候，消息就会被分发给 Handler 进行处理。形象一点？看看下面这张图（图片来自 Android Handler Internals，侵删） 位于 dispatch barrier 左边的 Message 都被阻塞着，位于其右边的是即将分发的 Message。 我们是不是该说下 Looper 了，下下个就到它了，在此之前需要先看看 ThreadLocal 相关知识。 ThreadLocal 简介ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。 使用场景： 当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑采用 ThrradLocal。 在 Android 中，Looper 类就是利用了 ThreadLocal 的特性，保证每个线程只存在一个 Looper 对象。 复杂逻辑下的对象传递。 比如监听器的传递。 从 ThreadLocal 的 set 和 get 方法 可以看出，它们所操作的对象都是当前线程的 localValues 对象的 table 数组，因此在不同的线程中访问同一个 ThreadLocal 的 get 和 set 方法，他们对 ThreadLocal 所做的读/写操作仅限于各自线程的内部。 关于 ThreadLocal 的具体介绍请见 这篇文章 理解 ThreadLocal 对后面理解 Looper 有很大的帮助，建议先细看 ThreadLocal 的内容再看后面的内容。 Looper 的工作原理Android 的官方文档中是这么介绍 Looper 的： Looper 是一个用来为单个线程运行消息循环的类。默认情况下线程是没有一个 Looper 跟他们相关联的。如果一个线程需要 looper 的话，可以通过先调用 prepare() 方法初始化一个本线程的 Looper 实例。然后调用 loop 方法让它开始处理信息，一直到循环结束。 我们通常通过 Handler 类与 Looper 的打交道。 一个 线程最多只能有一个 Looper，一个 Looper 中有一个消息队列（前面 Hanlder 中的 MessageQueue 对象就是从 Looper 中取出的），并且持有它所在线程的引用。Looper 就像一个「死循环」（通过 quit 或者 quitSafely 方法可以退出），它会不断地从 MessageQueue 中查看是否有新消息。如果有，就调用 handler.dispatchMessage 方法进行处理；如果没有，就一直阻塞在那里。 创建 Looper我们先看看 Looper 的构造方法： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//创建一个消息队列 mThread = Thread.currentThread(); //把当前线程的对象保存起来&#125; Looper 构造方法中创建了一个消息队列，并且会保存当前线程对象。 创建普通线程上的 LooperLooper 的构造方法是私有的，那么要创建一个 Looper。？调用 Looper.prepare()即可为当前线程创建一个 Looper 对象，接着通过 Looper.loop() 方法开启消息循环。要注意的是：在子线程中，如果手动为其创建了 Looper，那么在所有的任务完成之后，需要调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待状态。 我们看下 prepare 方法实现 1234567891011121314public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread");//一个线程最多只能有一个 Looper &#125; sThreadLocal.set(new Looper(quitAllowed));//为当前线程创建一个 Looper &#125;public static @Nullable Looper myLooper() &#123;//获取当前线程的 Looper 对象 return sThreadLocal.get();&#125; 创建主线程上的 Looper有一个要注意的地方就是 Looper 的另一个创建方法 —— prepareMainLooper。 prepareMainLooper 在应用的入口方法（ActivityThread.main() ）中被调用，用来启动主线程的消息循环。 123456789101112131415public static void main(String[] args) &#123; //代码省略 Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper();//创建主线程的 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler();//创建主线程的 Handler &#125; //代码省略 Looper.loop();//开启主线程消息循环&#125; 123456789101112131415public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125;public static Looper getMainLooper() &#123;//该方法使得在任何地方都可以获得主线程的消息循环 synchronized (Looper.class) &#123; return sMainLooper; &#125;&#125; 小结在应用启动时会开启一个主线程（UI 线程），并且开启消息循环，应用不断地从该消息队列中取出、处理消息达到程序运行的结果。 loop 方法前面所讲都是 Looper 自身的一些特性，没有提到它是怎么跟其他部分交互的。Looper 与其他 MessageQueue 、Hanlder 的交互主要在 loop 方法中。下面我们来看看 loop 方法的源码。 12345678910111213141516171819202122232425262728293031323334public static void loop() &#123; final Looper me = myLooper();//获取本线程的 Looper if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");//调用 loop 方法之前必须先调用 Looper.prepare() 方法创建 Looper &#125; final MessageQueue queue = me.mQueue;//获取所在线程的消息队列 // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // 阻塞方法，如果没有获取到消息，就一直阻塞在这里 if (msg == null) &#123; //只有当 msg == null 时才会退出循环 return; &#125; // 代码省略 try &#123; msg.target.dispatchMessage(msg);// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。 &#125; finally &#123; // 代码省略 &#125; // 代码省略 // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); // 代码省略 msg.recycleUnchecked();//调用 Message 的回收方法 &#125;&#125; 由源码可见 loop 方法是一个死循环，唯一跳出循环的方式是 MessageQueue 的 next 方法返回了 null。 当我们调用 Looper 的 quit 方法时，Looper 会调用 MessageQueue 的 quit 或 quitSafely 方法来通知消息队列退出，否则 loop 方法会一直循环下去。 另外，代码中可以看到，loop 调用了 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 方法会一直阻塞在那里，这也导致了 loop 方法一直阻塞在那里。 msg.target.dispatchMessage(msg);// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。 绕了这么一个大圈意义何在？通常我们都会在子线程中调用 Handler.sendMessageXxx 或者 Handler.postXxx 方法， 而Handler 的 dispatchMessage 方法是在创建 Handler 的那个线程中执行的，这样就顺利地将代码切换到目标线程中去执行了。 退出 LooperLooper 也是可以退出的（这里的退出 Looper 主要是指跳出 loop 方法中的死循环）。通过调用 Looper 的 quit 方法或者 quitSafely 方法即可。那么这二者有什么区别？ 调用 Looper 的 quit 方法可以直接退出Looper。 调用 Looper 的 quitSafely 方法只是设定了一个退出标记，然后把消息队列中已有的消息处理完才退出 Looper。 我们来看看这两个方法的实现 12345678//Looper.quitpublic void quit() &#123; mQueue.quit(false);&#125;//Looper.quitSafelypublic void quitSafely() &#123; mQueue.quit(true);&#125; mQueue 的实际类型为 MessageQueue，Looper 的两个 quit 方法都是通过调用 MessageQueue 的 quit 方法来实现的。 1234567891011121314151617181920void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit.");//主线程的 Looper 无法退出。主线程的 Looper 是通过 prepareMainLooper 方法创建的，创建时调用了 prepare（false），也就是令 mQuitAllowed = false &#125; synchronized (this) &#123; if (mQuitting) &#123;//是否正在退出 return; &#125; mQuitting = true; if (safe) &#123; //安全退出,不会取消执行时机早于或等于当前时间的 Message removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked();//移除 MessageQueue 中所有的消息 &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; MessageQueue.next() 方法片段。当调用了 quit 方法之后会使得 mQuitting 为 true，从而导致 next 方法返回 null，一旦 next 方法返回 null， Looper.loop 就跳出了死循环。 1234if (mQuitting) &#123; dispose();//消息 native 层的消息队列。 return null;&#125; MessageQueue.enqueueMessage 方法片段 1234567if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false;&#125; 从这里实现可以看到，调用了 Looper.quit / quitSafely 方法之后，再通过 Handler 发送的消息无法添加到 MessageQueue 中，此时 Handler 的 send 方法会返回 false。 回到 Handler Looper 的 loop 方法中有这样一行代码 msg.target.dispatchMessage(msg);该方法调用的就是 Handler.dispatchMessage 方法。dispatchMessage 方法会根据情况对 Message 进行分发。 12345678910111213141516171819202122/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg);//回调执行 Runnable 的 run 方法 &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123;//执行创建 Handler 时指定的 Callback.handleMessage 方法 return; &#125; &#125; handleMessage(msg);//执行 handleMessage(msg) 方法 &#125;&#125;public interface Callback &#123;// Callback 接口 public boolean handleMessage(Message msg);&#125;public void handleMessage(Message msg) &#123;//空实现，需要由子类覆写&#125; 123private static void handleCallback(Message message) &#123; message.callback.run(); // callback 的实际类型为 Runnable，这行代码的作用就是回调 Runnable 的 run 方法&#125; Handler 的工作主要包含消息的发送和接收过程（还有一个「分发过程」）。 消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。 post 系列方法最终是通过 send 的一系列方法来实现的。 查看源码不难发现，Handler 的发送消息的过程仅仅是向 MessageQueue 插入了一条 Message，MessageQueue 的 next 方法就会返回此 Message 给 Looper， Looper 在 loop 方法中对 Message 进行处理，最终由 Looper 交回给 Handler 处理（调用 Handler 的 dispatchMessage 方法）。 数量关系一个线程最多只能有一个 Looper ，一个 MessageQueue，可以有多个 Handler。 MessageQueue 封装在 Looper 中。 问题为什么主线程不会因为 Looper.loop()里的死循环卡死？阻塞是有的，但是不会卡住主要原因有 2 个： 1.Linux 的 epoll 机制当没有消息的时候会 epoll.wait，等待句柄写的时候再唤醒，这个时候其实是阻塞的。 2.所有的 ui 操作都通过 handler 来发消息操作。比如屏幕刷新 16ms 一个消息，你的各种点击事件，就会有句柄写操作，唤醒上文的 wait 操作，所以不会被卡死了。 一个比较形象的比喻： 就像一辆车在圆形赛车道上跑，一边跑(一边执行任务)，比如开到市中心买瓶水，任务完成又回到刚刚离开的地方，继续各种执行买水的任务，直到没有任务了（msg 为空），行了，跑一圈回到起点。睡觉（epoll_wait），有任务叫醒你（唤醒 wait），你又开始跑一圈。边跑边接单。 想进一步了解的同学可以看下知乎上对该问题的讨论 总结Looper 对象封装了消息队列，Looper 对象被封装在 ThreadLocal 中，是线程私有的，不同线程之间的 Looper 无法共享。Handler 通过与 Looper 之间的绑定来实现与执行线程之间的绑定，handler 发送消息时会将 Message 对象追加到与线程相关的消息队列中，然后由 Looper 回调它的分发消息方法，根据情况处理消息。 最后我们看一张完整的流程图（图片参考自Handler 异步通信机制全面解析），笔者修改了原图中的 Handler dispatchMessage 方法描述。 参考资料与学习资源推荐 理解 Java 中的 ThreadLocal 谈谈 ThreadLocal Android 中 Handler 的使用 Handler 异步通信机制全面解析 深入源码解析 Android 中的 Handler,Message,MessageQueue,Looper 探索 Android 大杀器—— Handler 《Android 开发艺术探索》 《Android 源码设计模式解析与实战》 如果本文中有不正确的结论、说法或者表述不清晰的地方，恳请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
