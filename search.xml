<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 源码中的享元模式——Message 复用原理]]></title>
    <url>%2Fblog%2F2017%2F08%2F26%2FAndroid-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Message%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[介绍享元模式是对象池的一种实现，它的英文名为 Flyweight，代表轻量级的意思。 享元模式用来尽可能==减少内存使用量==，它适合用于可能存在大量对象的场景，来==缓存可共享的对象==（例如 Message、Java 中的字符串常量池）,从而实现对象共享、避免创建过多对象的效果，这样一来就可以提升性能，避免内存移除等。 享元模式中的部分状态是可以共享的， 可以共享的状态称为内部状态。内部状态不会随着环境变化 不可共享的状态则称之为外部状态，他们会随着环境的改变而改变。 享元模式会建立一个对象容器，在经典的享元模式中，该容器为一个 Map，它的键是享元对象的内部状态，它的值就是享元对象本身。 享元模式的定义享元模式是一种结构型设计模式，以共享的方式高效地支持大量的细粒度对象。 使用场景 系统中存在大量的相似对象 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。 需要缓冲池的场景。 UML 类图 Flyweight ：享元对象抽象基类或者接口。 ConcreteFlyweight：具体享元对象。 FlyweightFactory ：享元工厂，负责创建享元对象和管理享元对象池。 Android 源码中的享元模式在使用 Handler 发送消息之前，我们一般都会使用如下代码调用 mHandler.obtainMessage() 方法获取一个 Message 对象。这其中究竟是怎么实现的呢？ 1234567891011121314Handler mHandler = new Handler();public void do() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //do sth Message message = mHandler.obtainMessage(); message.what = 1; message.obj = result; mHandler.sendMessage(message); &#125; &#125;);&#125; 1234//Handler.otainMessage()方法public final Message obtainMessage()&#123; return Message.obtain(this);&#125; 可以看到 Handler.obtainMessage() 实际上调用的是 Message 的 obtain 方法，我们顺着源码看下去。 先看看 Message 类部分源码 1234567891011121314151617181920212223242526272829// sometimes we store linked lists of these thingsMessage next;private static final Object sPoolSync = new Object();//作为锁对象private static Message sPool;//虽然名称为 sPool 但是实际上是一个指向消息队列队首的指针private static int sPoolSize = 0;//private static final int MAX_POOL_SIZE = 50;//「对象池」中的最大数量public static Message obtain(Handler h) &#123; Message m = obtain();//调用 obtain 方法获取 message 对象 m.target = h;//指定 message 的目标对象 return m;&#125;//从消息对象池中取出一个 Message 对象，如果没有就创建一个public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // 清空 in-use flag sPoolSize--; return m; &#125; &#125; return new Message();//消息池中没有可复用的 Message 就创建一个新的 Message&#125; 至此，从对象池中获取对象的大致流程。无论是 Handler.obtainMessage(参数列表) 方法，还是 Message 的 obtain(参数列表) 方法，最终都会调用 Message.obtain() 方法。在 Message.obtain() 方法的实现中，会先从对象池中获取 Message 对象，如果获取不到，则创建一个新的 Message 对象，然后返回。该对象在后续的执行过程中会被回收到对象池，以便复用。 但是 Message 对象是如何被回收到「对象池」中的呢？ 从 Message 类的部分代码中我们看到 sPool 的实际类型是一个 Message 对象，而不是一个容器。另外从 obtain 方法中我们不难看到链表的踪影。难道消息池是使用链表实现的吗？ 在 AS 中打开 Message 类的结构图，可以看到其中有一个 recycle 方法，我们看看里面是怎么实现的。 123456789101112131415161718192021222324252627282930313233343536public void recycle() &#123; if (isInUse()) &#123;//判断消息是否还在使用 if (gCheckRecycle) &#123;//如果消息处在使用状态时被 gc 回收，就抛出异常 throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); &#125; return;//直接返回，取消回收操作 &#125; recycleUnchecked();//调用回收方法&#125;/** * 回收一个可能还在使用的对象 */void recycleUnchecked() &#123; // 只要该对象还在回收对象池中，就标记该对象为正在使用状态。 // 清空其他状态 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; //回收消息到消息池中 synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; recycle 方法首先会判断 Message 对象是否处在使用状态。如果处在使用状态会直接返回（如果此时 GC 回收该对象会抛出异常），否则调用 recycleUnchecked 方法，具体的回收逻辑是在 recycleUnchecked 方法中实现的。首先会标记 Message 处于使用状态，然后清空对象中的其他状态。将消息存入回收池，主要是链表的操作。大致如下图所示。 小结Message 通过在内部构建一个链表来维护一个被会受到 Message 对象的对象池，当用户调用 obtain 方法时，会优先从池中获取。如果池中没有可以复用的对象就创建一个新的对象，该对象使用完之后，会被缓存到对象池中，当下次调用 obtain 方法时，他们就会被复用。 此处 Message 扮演了三个角色。既是 FlyWeight 抽象，又是 ConcreteFlyWeight 对象，同时还担任 FlyWeightFactory 角色，承担着管理对象池的职责。 想进一步了解 Android 消息机制的同学可参考Android 消息机制解析。 总结享元模式的优点： 大幅度降低了内存中对象的数量。从而降低了内存的占用，提高了程序的性能。 缺点： 使得系统更加复杂。为了使应用能够共享，需要将一些状态外部化，这使得程序的逻辑复杂化。 享元模式将状态外部化，而读取外部状态使得运行时间稍微变长 参考资料与学习资源推荐 《JAVA 与模式》之享元模式 《Android 源码设计模式解析与实战》 Android 消息机制解析 若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>设计模式</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码中的模板方法模式——AsyncTask解析]]></title>
    <url>%2Fblog%2F2017%2F08%2F24%2FAndroid-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AsyncTask%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言假设我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的。就好像执行程序的流程： 检查代码的正确性 链接相关代码 编译相关代码 执行程序 对于不同的语言，上述 4 个步骤都是不一样的，但是它们的执行流程是固定的，这类问题的解决方案就是我们介绍的模板方法模式。 模板方法模式的定义定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式的使用场景 多个子类有公有的方法，并且逻辑基本相同时。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，把相同的代码抽取到父类中，然后通过钩子方法约束其行为。 注：何谓钩子方法？基本方法又可以分为三种：抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。 这是《java与模式》书里的一种说法，三种方法也是在书中的模板方法模式中提及到的。 先说这个三个方法的基本定义： 抽象方法：由抽象类声明，由具体子类实现。在java语言里一个抽象方法以abstract关键字标示出来。 具体方法：由抽象类声明并实现，而子类并不实现或覆盖。其实就是一般的方法，但是不需要子类来实现。 钩子方法：由抽象类声明并实现，而子类也会加以扩展。通常抽象类给出的是一个空的钩子方法，也就是方法体为空的方法（也可以根据需要实现部分逻辑）。其实它和具体方法在代码上没有区别，不过是意识上的一种区别。 详见抽象方法 具体方法 钩子方法 模板方法模式的 UML 类图 AbsTemplate：抽象类，定义一套算法框架 ConcreteImplA：具体实现类 A ConcreteImplB：具体实现类 B 模板方法模式的简单示例实际上是封装一个固定流程，就像是一套执行模板一样，第一步该做什么，第二步该做什么都已经在抽象类中定义好。而子类可以有不同的算法实现，在框架不被修改的情况下实现某些步骤的算法替换。 Android 源码中的模板方法模式AsyncTask使用过 AsyncTask 的同学都知道，我们调用 execute 之后，（如果没有调用 cancel 方法的话）以下三个方法会依次执行： onPreExecute doInBackground onPostExecute 为什么能让它们依次执行呢？其内部是怎么实现的？我们看看源码，一探究竟。 首先看看异步任务的入口方法 execute。123456789101112131415161718192021222324252627282930 @MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 以上两个构造方法中主要做了如下几件事： 状态判断 判断之后执行 onPreExecute(); 使用线程池执行 mFuture 什么样的线程池？ 默认为 SerialExecutor 单线程的线程池 123456789101112131415161718192021222324252627282930313233343536public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);//设置进程优先级 //noinspection unchecked result = doInBackground(mParams);//调用 doInBackground 方法 Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result);//调用 postResult 方法 &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get());//任务完成 &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occurred while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 12private final WorkerRunnable&lt;Params, Result&gt; mWorker;private final FutureTask&lt;Result&gt; mFuture; mWorker 类型为 WorkerRunnable&lt;Params, Result&gt; ， WorkerRunnable 实现了 Callable mFuture 类型为 FutureTask&lt;Result&gt; 简而言之，这个 mFuture 包装了这个 mWorker 对象，而 mFuture 是在线程池中执行的，会调用 mFuture 的 run 方法，该 run 方法中调用了 mWorker 的 call 方法，mWorker 的 call 方法又调用了 doInBackground 方法，所以 doInBackground 是在工作线程执行的。 123456private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125;&#125; doInBackground 执行完成后会通过 postResult(result) 方法将结果传递给主线程。 postResult(result) 可能通过 call 方法的 finally 块直接调用或者通过 FutureTask 中的 done 方法里面的 postResultIfNotInvoked(get()); 来间接调用。 接下来我们看看 postResult(result) 方法1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // 调用 AsyncTask 的 finish 方法 result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; postResult(result) 方法就是通过发送一条消息（msg.what == MESSAGE_POST_RESULT）给 sHandler，sHandler 为 InternalHanlder。当 InternalHanlder 接收到 MESSAGE_POST_RESULT 时，就会调用 result.mTask.finish(result.mData[0]) 方法，result 的类型为 AsyncTaskResult 123456789private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 从 AsyncTaskResult 的具体实现中吗，我们知道 mTask 就是 AsyncTask，finish 方法中又调用了 onPostExecute ，此时整个执行流程就完成了。 小结execute 方法内部封装了 onPreExecute、doInBackGround、onPostExecute 这个逻辑流程。通过这种方式，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时的操作及更新 UI。实际上就是通过线程池来执行耗时的任务，得到结果之后，通过 Handler 将结果传递给 UI 线程执行。 Activity 的生命周期函数除了 AsyncTask 以外，Android 源码中还有不少地方有模板方法的身影，比如说 Activity 的生命周期方法—— onCreate 、onStart、onResume 等，都是按照顺序调用的，我们会在对应的方法中执行合适的操作。 其内部实现涉及到进程间通信，限于篇幅，本文不作深入介绍。有兴趣的同学可以看看 ActivityThread 的 main 方法，以之作为入口，对生命周期方法的调用时机做进一步研究。 模板方法总结简单概括模板方法模式就是流程封装。把某一个固定的流程封装到一个固定的 final 方法中。并且让子类能够定制这个过程中的某些甚至所有步骤，这就要求父类提取共用的代码，提升代码的复用率，同时也带来了更高的可扩展性。 优点： 封装不变的部分，扩展可变的部分 提取公共部分代码，便于维护。 缺点： 提高了代码阅读的难度，会让用户觉得难以理解 参考资料与学习资源推荐 《Android 源码设计模式解析与实战》 抽象方法 具体方法 钩子方法 若有不正之处请多多谅解，欢迎批评指正。]]></content>
      <categories>
        <category>设计模式</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型设计模式之备忘录模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[备忘录模式的定义备忘录模式是一种行为型设计模式，该模式用于保存对象当前的状态，并且在之后可以再次恢复到此状态。 实现效果为：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便后续将对象恢复到原来的状态。 备忘录模式的使用场景 需要保存一个对象在某一个时刻的状态或部分状态 一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。（如果使用接口来让其他对象获取对象的状态，会破坏封装性） 备忘录模式的UML类图 三个角色： Originator：需要保存状态的对象。负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。 Memento（类似于 pojo 类）备忘录角色。用于存储 Originator 内部状态，并且可以防止 Originator 以外的对象访问 Memento Caretaker：负责存储备忘录，不能对备忘录的内容进行操作和访问，只能将备忘录传递给其他对象。 Android源码中的备忘录模式日常开发中如果需要保存什么数据以防止 Activity 意外销毁，第一时间会想到 Activity 中的这两个方法——onSaveInstanceState、onRestoreInstanceState。其内部具体是如何实现数据保存的呢？ 先透漏一下，这里面使用到了备忘录模式。 123456789101112protected void onSaveInstanceState(Bundle outState) &#123; //1. 存储窗口的视图树的状态 outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); //2. 存储 Fragment 中的状态 Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; //3. 若用户设置了 Activity 的 ActivityLifeCycleCallbacks， //则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。 getApplication().dispatchActivitySaveInstanceState(this, outState);&#125; Activity.onSaveInstanceState 方法中主要做了三件事 存储窗口的视图树的状态 存储 Fragment 中的状态 若用户设置了 Activity 的 ActivityLifeCycleCallbacks，则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。 首先看看步骤 1，该步骤将 Window 对象中的视图树中的各个 View 状态存储到 Bundle 中。 Window 的具体实现在 PhoneWindow 中.以下为 PhoneWindow.saveHierarchyState 的具体实现。 12345678910111213141516171819202122232425262728293031public Bundle saveHierarchyState() &#123; Bundle outState = new Bundle(); if (mContentParent == null) &#123; return outState; &#125; // SparseArray 相当于一个 key 为 整型的 map SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;(); //此处的 mContentParent 就是我们 setContentView 时设置的 View mContentParent.saveHierarchyState(states); outState.putSparseParcelableArray(VIEWS_TAG, states); // 持有焦点的 View 必须设置 id，否则重新进入该界面时不会恢复它的焦点状态 final View focusedView = mContentParent.findFocus(); if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) &#123; outState.putInt(FOCUSED_ID_TAG, focusedView.getId()); &#125; // 存储整个面板的状态 SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;(); savePanelState(panelStates); if (panelStates.size() &gt; 0) &#123; outState.putSparseParcelableArray(PANELS_TAG, panelStates); &#125; // 保存 actionbar 的状态 if (mDecorContentParent != null) &#123; SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;(); mDecorContentParent.saveToolbarHierarchyState(actionBarStates); outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates); &#125; return outState;&#125; 看看步骤 2 中的 mContentParent.saveHierarchyState 方法，mContentParent 是一个 ViewGroup 但是 saveHierarchyState 方法并不是定义在 ViewGroup 中，而是定义在它的父类——View 中，查看下该方法在 View 中的实现。123public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123; dispatchSaveInstanceState(container);&#125; 12345678910111213141516protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; //1. 只有含有 id 的 View，状态才会被存储 if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123; mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED; //2. 调用 onSaveInstanceState 方法获取自身状态 Parcelable state = onSaveInstanceState(); if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123; throw new IllegalStateException( "Derived class did not call super.onSaveInstanceState()"); &#125; //3. 将自身状态存放到 container 中 if (state != null) &#123; container.put(mID, state); &#125; &#125;&#125; View.onSaveInstanceState 方法默认存储的状态为空状态。但是它的子类通常都有定义自身的覆盖方法。12345678910@CallSuperprotected Parcelable onSaveInstanceState() &#123; mPrivateFlags |= PFLAG_SAVE_STATE_CALLED; if (mStartActivityRequestWho != null) &#123; BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE); state.mStartActivityRequestWhoSaved = mStartActivityRequestWho; return state; &#125; return BaseSavedState.EMPTY_STATE;&#125; 步骤 2 中的 View 的调用大致如下：saveHierarchyState ==》 dispatchSaveInstanceState ==》 onSaveInstanceState 其中要注意的是 只有含有 id 的 View，状态才会被存储，如果没有给 view 赋一个 id，那么系统是不会帮忙保存该 view 的状态的。 View 类中的 saveHierarchyState 方法调用了dispatchSaveInstanceState 方法用来存储自身状态。 ViewGroup 覆写了 dispatchSaveInstanceState 来存储自身以及子视图的状态。 ViewGroup.dispatchSaveInstanceState具体实现如下：123456789101112@Overrideprotected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; super.dispatchSaveInstanceState(container); final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) &#123;//遍历调用子 View 的 dispatchSaveInstanceState 方法 View c = children[i]; if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123; c.dispatchSaveInstanceState(container); &#125; &#125;&#125; 可以看到 ViewGroup 的 dispatchSaveInstanceState 方法会先调用 super.dispatchSaveInstanceState(container); 存储自身的状态。然后遍历调用所有子视图的 dispatchSaveInstanceState(container) 方法来保存它们的状态，如果子 View 也是一个 ViewGroup，则会再次执行这个过程。 我们以 TextView 的 saveInstanceState 方法为例，看看具体的控件是如何保存自身状态的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overridepublic Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); // Save state if we are forced to final boolean freezesText = getFreezesText(); boolean hasSelection = false; int start = -1; int end = -1; //存储 TextView 的 start、end if (mText != null) &#123; start = getSelectionStart(); end = getSelectionEnd(); if (start &gt;= 0 || end &gt;= 0) &#123; // 是否存存在选项 hasSelection = true; &#125; &#125; if (freezesText || hasSelection) &#123; SavedState ss = new SavedState(superState); //保存 TextView 的文本内容 if (freezesText) &#123; if (mText instanceof Spanned) &#123; final Spannable sp = new SpannableStringBuilder(mText); if (mEditor != null) &#123; removeMisspelledSpans(sp); sp.removeSpan(mEditor.mSuggestionRangeSpan); &#125; ss.text = sp; &#125; else &#123; ss.text = mText.toString(); &#125; &#125; //存储 TextView 的 start、end if (hasSelection) &#123; // XXX Should also save the current scroll position! ss.selStart = start; ss.selEnd = end; &#125; if (isFocused() &amp;&amp; start &gt;= 0 &amp;&amp; end &gt;= 0) &#123; ss.frozenWithFocus = true; &#125; ss.error = getError(); if (mEditor != null) &#123; ss.editorState = mEditor.saveInstanceState(); &#125; //返回状态对象 return ss; &#125; return superState;&#125; 调用 View 的 onSaveInstance 函数之后就得到了 View 要存储的数据，此时执行到 View 的 dispatchSaveInstanceState 方法中的注释 3。这里以 View 的 id 为 key，以状态为 value，存储到 container（ SparseArray 类型）中。1234//3. 将自身状态存放到 container 中if (state != null) &#123; container.put(mID, state);&#125; 存储完 Window 的视图状态信息之后，便会执行存储 Fragment 中的状态信息、回退栈等。Fragment 也是通过调用自身的 onSaveInstaceState 方法来存储自身的 View 视图树状态的。 最后就是调用用户设置的 ActivityLifecycleCallbacks 的 onSaveInstaceState 方法，让用户做一些额外的处理 前面我们所提及到的只是备忘录模式中的 Originator 角色，即需要保存备忘录的对象。不过也有涉及到 CareTaker 角色——Activity。下面我们再看看另外两个角色——Memoto 和 CareTaker。 存了状态信息的 Bundle 数据存储在哪？ onSaveInstance 方法是在 onStop 方法之前调用的。Activity.onStop 方法是通过 Activity 的 performStopActivity 间接调用。123456 final void performStopActivity(IBinder token, boolean saveState, String reason) &#123; //获取 ActivityClientRecord ActivityClientRecord r = mActivities.get(token); // saveState 表示是否保存状态 performStopActivityInner(r, null, false, saveState, reason);&#125; 1234567891011121314151617181920212223242526272829303132333435private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState, String reason) &#123; if (r != null) &#123; if (!keepShown &amp;&amp; r.stopped) &#123; if (r.activity.mFinished) &#123; // 如果正在执行销毁过程，是用户主动销毁。 activity 不打算恢复，我们也没必要调用 onStop 方法 return; &#125; //代码省略 &#125; // 在调用 onStop 之前必须先调用 onPause performPauseActivityIfNeeded(r, reason); //代码省略 // 接下来让 activity 保存它目前的状态和它所管理的 dialogs if (!r.activity.mFinished &amp;&amp; saveState) &#123; if (r.state == null) &#123; // 间接调用 Activity.onSaveInstance() callCallActivityOnSaveInstanceState(r); &#125; &#125; if (!keepShown) &#123; try &#123; // 执行 onStop 方法 r.activity.performStop(false /*preserveWindow*/); &#125; catch (Exception e) &#123; // ... &#125; //将 stop 字段置为 true 表示已经调用了 stop 方法。 r.stopped = true; &#125; &#125;&#125; 123456789101112private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123; r.state = new Bundle();//内容就存储在该 Bundle 中 r.state.setAllowFds(false); if (r.isPersistable()) &#123; r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); &#125; else &#123; //该方法实际调用了 Activity.onSaveInstanceState 方法 mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); &#125;&#125; 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) &#123; activity.performSaveInstanceState(outState, outPersistentState);&#125; 上面的 performStopActivity 与 performStopActivityInner 方法中，首先通过 token 从 mActivities 中获取一个 ActivityClientRecord 对象，状态信息就是存储在这里面的。获取该对象之后，调用了 performStopActivityInner 方法，对于保存状态而言，该方法大概有如下三步 判断 Activity 是否需要保存状态 如果需要，则调用 onSaveInstance 方法，该方法会将状态信息存储到 ActivityClientRecord 中 调用 Activity.onStop() 方法 执行 onStop 方法之前，系统会根据情况来选择是否存储 Activity 的状态，并且将这些状态（简介地）存储到 mActivities 中。 mActivities 是一个 ArrayMap&lt;IBinder, ActivityClientRecord&gt; ，它维护了一个 Activity 的信息表，当 Activity 重新启动时，会从 mActivities 中查询对应的 ActivityClientRecord，如果这个记录对象中含有状态信息就调用 Activity 的 onRestoreInstanceState 方法。开发人员可以从这个方法中做一些状态恢复操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //代码省略 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //1. 构建 Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); //代码省略 &#125; catch (Exception e) &#123; //代码省略 &#125; try &#123; //2. 创建一个 Application 对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); //代码省略 if (activity != null) &#123; //创建 appContext，类型为 ContextImpl Context appContext = createBaseContextForActivity(r, activity); //代码省略 //3. 关联 appContext、Application 等对象到 Activity 中 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); //代码省略 activity.mCalled = false; //4. 调用 Activity.onCreate 方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; //代码省略 r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; //调用 onStart 方法 activity.performStart(); r.stopped = false; &#125; //5. 如果有保存状态的话，调用 Activity.onRestoreInstanceState 方法恢复状态 if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; //代码省略 &#125; r.paused = true; //6. 将 Activity 的信息记录对象——ActivityClientRecord 存储到 mActivities 中。 mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; return activity;&#125; 在上面的注释 5 处，系统会判断 Activity 是否调用过了 Activity.finish() 方法、是否是「永久的」以及 ActivityClientRecord 对象中的 state 是否为空， 如果满足条件，就会获取存储的状态信息传递给 Activity.onRestoreInstanceState 方法，也会将这些数据传递给 onCreate 方法的 bundle 参数 。 不过 Google 官方推荐调用 onRestoreInstanceState 方法来恢复状态，因为只有在存储有状态信息的时候才会调用该方法，而在 onCreate 方法中还需要先进行判空处理。 小结上述过程中备忘录模式的三种关键角色分别由什么类扮演？ CareTaker：Activity 负责存储、恢复 UI 的态信息。 Originator：Activity、Fragment、View、ViewGroup ，是需要存储状态的对象 Memoto：由 Bundle 类扮演 Activity 会在停止之前根据 Activity 的退出情景来选择是否需要存储状态 在重新启动该 Activity 时会判断 ActivityClientRecord 对象中是否存储了 Activity 的状态 如果含有状态，调用 Activity.onRestoreInstanceState() 方法恢复状态。从而使得 Activity 的 UI 可以恢复至异常退出前的状态。 你可能会问的问题onSaveInstanceState 何时被调用onSaveInstanceState() 方法会在什么时候被执行？有这么几种情况： 当用户按下 HOME 键时。 这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 长按HOME键，选择运行其他的程序时。 按下电源按键（关闭屏幕显示）时。 从 Activity A 中启动一个新的 Activity 时。 屏幕方向切换时，例如从竖屏切换到横屏时。 onSaveInstanceState 的调用在 onStop 方法之前，但是与 onPause 方法之间没有既定关系。 总而言之，当系统存在「==未经用户许可==」时销毁了我们的 Activity，则 onSaveInstanceState() 会被系统调用，这是系统的责任，因此它必须提供一个机会让用户保存数据。 「经用户许可」的情况不多，通常只有用户按下回退键这一种。这种情况下是用户主动退出某个 Activity，系统不会调用 onSaveInstanceState() 方法。 各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？在前面的分析中我们知道即使没有覆写 onSaveInstanceState()方法, ViewGroup、View、Fragment、Activity 内部都有自己的默认实现，它们的默认实现也会保存某些状态数据。 比如 activity 中各种 UI 控件的状态。android 应用框架中定义的几乎所有 UI 控件都恰当的实现了 onSaveInstanceState() 方法,因此当 Activity 被销毁和重建时, 这些 UI 控件会自动保存和恢复状态数据. EditText 控件会自动保存和恢复输入的数据 CheckBox 控件会自动保存和恢复选中状态 … 开发者只需要为这些控件指定一个唯一的 id(通过设置 android:id 属性即可), 剩余的事情就可以自动完成了 注意：如果没有为控件指定ID, 则这个控件就不会进行自动的数据保存和恢复操作。 由上所述, 如果我们需要覆写 onSaveInstanceState() 方法, 一般会在第一行代码中调用该方法的默认实现:super.onSaveInstanceState(outState)。 有默认实现，还需要重写 onSaveInstanceState() 方法吗？既然该方法的默认实现可以自动的保存UI控件的状态数据, 那什么时候需要覆写该方法呢? 如果需要保存额外的数据时, 就需要覆写 onSaveInstanceState() 方法。大家需要注意的是：onSaveInstanceState()方法只适合保存瞬态数据, 比如 UI 控件的状态，成员变量的值等，而不应该用来保存持久化数据，持久化数据应该当用户离开当前的 activity时，在 onPause() 中保存（比如将数据保存到数据库或文件中）。说到这里，还要说一点的就是在onPause()中不适合用来保存比较费时的数据，所以这点要理解。 另外由于 onSaveInstanceState() 方法方法不一定会被调用, 因此不适合在该方法中保存持久化数据, 例如向数据库中插入记录等。 保存持久化数据的操作应该放在 onPause() 中。若是永久性值，则在 onPause() 中保存；若有大量要保存的数据，则另开线程，以免阻塞 UI 线程。 参考资料与学习资源推荐 《Android 源码设计模式解析与实战》 Android 开发之 instanceState详解]]></content>
      <categories>
        <category>设计模式</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 ThreadLocal]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2F%E8%B0%88%E8%B0%88-ThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal 是什么？ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。 为什么要使用 ThreadLocal从定义我们知道 ThreadLocal 是一个用于存储本线程内部数据的类。假设没有 ThreadLocal 的话，每个 Thread 中可以输入自己的一个本地变量，但是在整个 Thread 的生命周期中，如果要穿梭很多 class 的很多 method 来使用这个本地变量的话，就要一直一直向下传送这个变量，显然很麻烦。那么怎么才能在这个 Thread 的生命中，在任何地方都能够方便的访问到这个变量呢，这时候 ThreadLocal 就诞生了。 ThreadLocal 就是这么个作用，除此之外和通常使用的本地变量没有任何区别。也就是说，没有 ThreadLocal 也是可以解决问题的，但是会比较麻烦，ThreadLocal 的作用便是简化线程内部数据的使用流程。 ThreadLocal 的内部实现既然是线程的本地变量，那自然与线程有着密切的联系。 打开 Thread 的源码可以看到，源码中有一个实例变量 threadLocals。该变量的实际类型为 ThreadLocal.ThreadLocalMap1ThreadLocal.ThreadLocalMap threadLocals = null; 这里我们主要关注三个问题 threadLocals 是如何创建的？ 怎么设置值？ 怎么获取值？ ThreadLocals 是如何创建的？ThreadLocal.createMap 方法中，会以当前的 ThreadLocal 对象作为 key，将初始值设置进去。 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; ThreadLocalMap 是 ThreadLocal 的一个静态内部类。其中以键值对的形式存储数据。可以简单但是不严谨的将它理解为一个 HashMap。 先看看 ThreadLocalMap 的构造函数1234567ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);//计算哈希值 table[i] = new Entry(firstKey, firstValue);//将 Entry 存到指定位置。 size = 1; setThreshold(INITIAL_CAPACITY);&#125; 123456789static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125;&#125; ThreadLocalMap 的构造函数主要做了下面几件事 首先创建了一个 Entry 数组， Entry 是 ThreadLocalMap 中的一个静态内部类,它以 ThreadLocal 为 key，以要存储的值为 value。 然后根据 key 计算 Hash 值 接着创建一个 Entry 对象存储在数组中 最后设置大小和阈值。 怎么设置值？ 首先通过 getMap 方法，获取当前线程的 ThreadLocalMap， 如果 map 不为空，则调用 ThreadLocalMap.set 方法，以当前的 ThreadLocal 对象 作为 key，将目标值设置进去。 如果 map 为空，就创建一个（创建的时候会设初始值） 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 怎么获取值？ 与 set 方法一样，首先通过 getMap 方法，获取当前线程的 ThreadLocalMap 如果 map 不为空，就以当前的 ThreadLocal 对象为键去获取值，(值存在 ThreadLocalMap.Entry) 如果 map 为空，会返回调用 setInitialValue 方法之后的返回值。（一般都为 null） 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;h 你可能存在的疑问每个 ThreadLocal 只能放一个对象吗？每个 ThreadLocal 只能放一个对象。要是需要放其他的对象，就再 new 一个新的 ThreadLocal 出来，这个新的 ThreadLocal 将作为 key,需要放的对象作为value，放在 ThreadLocalMap 中。也就是说一个线程可以含有多个 ThreadLocal 类。 当然也可以根据需要在 ThreadLocal 存放一些容器对象，比如 List、Set、Map，一个 ThreadLocal 存放一个容器对象，借助该容器对象也可以实现存储多个对象。 为什么 ThreadLocal 只存储一个对象却要用一个 ThreadLocalMap 来存储值？实际上每个线程中都有一个 ThreadLocal.ThreadLocalMap，真正存储数据的类是 ThreadLocalMap ，可以将它看作是一个 HashMap，而 ThreadLocal 是一个维护类。我们知道，存储的时候，都是以 ThreadLocal 实例作为 key，然后存储到 ThreadLocalMap 中。当我们调用不同 ThreadLocal 的 set 方法时，如果 ThreadLocalMap 不为空，那么直接在里面存储值就可以了，不需要再创建新的值。也就是说，同一个线程上的不同 ThreadLocal 对象，存储的值是在同一个 ThreadLocalMap 上。 没有 ThreadLocal 能不能解决问题？能。 可以自己定义一个静态的 map，将当前 thread 作为 key，将目标值作为 value，put 到 map 中，这也是一般人的想法。 ThreadLocal 的实现刚好相反，它是在每个线程中有一个 map，而将 ThreadLocal 实例作为 key，这样每个 map 中的项数很少，而且当线程销毁时相应的东西也一起销毁了。因为各线程访问的 map 是各自不同的 map，所以不需要同步，速度会快些；而如果把所有线程要用的对象都放到一个静态 map中的话 多线程并发访问需要进行同步。 所以说 ThreadLocal 只是实现线程局部变量的一种方式。但是综合来看这种方式相比其他实现方式要更好。 注意如果一个对象的引用被多个线程持有，那么即使该对象存在 ThreadLocalMap 中也不是线程的本地变量。 首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过 ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。 也就是说，其他线程能否访问，还要看你的 set 进去的对象引用是否被其他线程持有。 如果两个线程都存入同一个对象引用，那就会有线程共享问题。 小结我们总结 ThreadLocal 具体是怎么一步一步去为每一个线程创建一个~线程私有变量~的： 首先，在每个线程 Thread 内部有一个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals，这个 threadLocals 就是用来存储~线程私有变量的~，键值（key）为当前 ThreadLocal 变量，值 value 为~线程的私有变量~（即 T 类型的变量）。 初始时，在 Thread 里面，threadLocals 为空，当通过 ThreadLocal 变量调用 get() 方法或者 set() 方法，就会对 Thread 类中的 threadLocals 进行初始化，并且以当前 ThreadLocal 变量为 key，以 ThreadLocal 要保存的~线程私有变量~为 value，存到 threadLocals 中。 注意，如果是 先调用 get() 方法而不是 set() 方法的话，会返回 null 然后在当前线程里面，如果要使用~该线程私有变量~，就可以通过 get 方法在 threadLocals 里面查找。 参考与学习资源推荐 正确理解 ThreadLocal ThreadLocal and synchronized 补充 ThreadLocal Java并发编程：深入剖析ThreadLocal Android关于ThreadLocal的思考和总结 如果本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>并发</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明白原理,轻松解决内存泄漏]]></title>
    <url>%2Fblog%2F2017%2F08%2F19%2F%E6%98%8E%E7%99%BD%E5%8E%9F%E7%90%86-%E8%BD%BB%E6%9D%BE%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[相信「内存泄漏」 问题，是一个挺让开发者头疼的事情，笔者在回顾以为代码时，惊讶发现：初学 Android 时，许多不修边幅的代码习惯，导致了许多内存泄漏问题，借此分析其原因，把自己挖过的坑补一下，也希望奔跑在 Android 开发道路上的你能够优雅避免。 什么是内存泄漏 对于 C++ 来说，内存泄漏就是 new 出来的对象没有 delete，俗称野指针； 而对于 java 而言，就是存放在堆上的 Object 无法被 GC 正常回收； 分析之前我们先来看看两个基础知识点。 基础知识java 的内存分配简述运行时数据区域内存模型图 方法区（non-heap）：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量； 栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存； 堆区（heap）：通常用来存放 new 出来的对象。由 GC 负责回收。 四种不同类型的引用GC 过程与对象的引用类型有着很大的联系，下面我们就看看 Java 中（Android 中存在差异）的四种引用： 强引用（Strong Reference）:JVM 宁愿抛出 OOM，也不会让 GC 回收存在强引用的对象。 软引用（Soft Reference） ：只有内存不足时，才会被 GC 回收。 弱引用（weak Reference）：在 GC 时，如果一个对象只存在弱引用，将会被回收 虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为 GC 回收 Object 的标志。 与 Android 中的差异：在 2.3 以后版本中，即使内存够用，Android 系统会优先将 SoftReference 的对象提前回收掉, 其他和 Java 中是一样的。因此谷歌官方建议用 LruCache(least recentlly use 最少最近使用算法)。会将内存控制在一定的大小内, 超出最大值时会自动回收, 这个最大值开发者自己定。 内存泄漏的危害内存泄露是内存溢出(OOM)的重要原因之一，会导致 Crash。如果应用程序在消耗光了所有的可用堆空间，那么再试图在堆上分配新对象时就会引起 OOM(Out Of Memory Error)异常，此时应用程序就会崩溃退出。 内存泄漏的典型案例要想避免内存泄漏，首先要知道导致内存泄漏的原因。内存泄漏本质原因:==长生命周期的对象持有短生命周期对象的强/软引用。导致本应该被回收的短生命周期的对象无法被正常回收==。 这么讲可能比较抽象。举个常见的栗子：单例模式中，我们常常在获取单例对象时需要传一个 Context 。单例对象是一个长生命周期的对象（应用程序结束时才终结），而如果我们传递的是某一个 Activity 作为 context,那么这个 Activity 就会因为引用被持有而无法销毁，从而导致内存泄漏。 下面我们来看看导致内存泄漏的常见例子。 永远的 Singleton单例的使用在我们的程序中随处可见，因为使用它可以解决我们在程序中重复创建对象的问题。但是由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏。 解决 应该把传入的 Context 改为同应用生命周期一样长的 Application 中的 Context。 也可以通过重写 Application，提供 getContext 方法,那样就不需要在获取单例时传入 context。 123456789101112public class BaseApplication extends Application&#123; private static ApplicationContext sContext; @Override public void onCreate()&#123; super.onCreate(); sContext = getApplicationContext(); &#125; public static Context getApplicationContext()&#123; return sContext; &#125;&#125; Handler 引发的内存泄漏由于 Handler 属于 TLS（Thread Local Storage）变量，导致它的生命周期和 Activity 不一致。因此通过 Handler 来更新 UI 一般很难保证跟 View 或者 Activity 的生命周期一致，故很容易导致无法正确释放。12345678910111213141516171819202122public class HandlerBadActivity extends AppCompatActivity &#123; private final Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler_bad); // 延迟 5min 发送一个消息 handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; //do something &#125; &#125;, 1000 * 60 * 5); this.finish(); &#125;&#125; 上面的代码中发送了了一个延时 5 分钟执行的 Message，当该 Activity 退出的时候，延时任务（Message）还在主线程的 MessageQueue 中等待，此时的 Message 持有 Handler 的强引用，并且由于 Handler 是 HandlerBadActivity 的非静态内部类，所以 Handler 会持有一个指向 HandlerBadActivity 的强引用，所以虽然此时 HandlerBadActivity 调用了 finish 也无法进行内存回收，造成内存泄漏。 解决将 Handler 声明为静态内部类，但是要注意如果用到 Context 等外部类的 非static 对象，还是应该使用 ApplicationContext 或者通过弱引用来持有这些外部对象。1234567891011121314151617181920212223242526public class HandlerGoodActivity extends AppCompatActivity &#123; private static final class MyHandler extends Handler&#123; private final WeakReference&lt;HandlerGoodActivity&gt; mActivity; public MyHandler(HandlerGoodActivity activity)&#123; this.mActivity = new WeakReference&lt;HandlerGoodActivity&gt;(activity);//使用弱引用 &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); HandlerGoodActivity activity = mActivity.get(); if (activity != null)&#123; // do something &#125; &#125; &#125; private final MyHandler myHandler = new MyHandler(this); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler_good); &#125;&#125; 慎用 static 成员变量从前面的介绍我们知道，static 修饰的变量位于内存的方法区，其生命周期与 App 的生命周期一致。这必然会导致一系列问题，如果你的 app 进程设计上是长驻内存的，那即使 app 切到后台，这部分内存也不会被释放。 解决不要在类初始时初始化静态成员，也就是可以考虑懒加载。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。 当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下： 说明： NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要==创建一个新的 task 任务队列==。 对于 Dialog 而言，只有在 Activity 中才能创建 远离非静态内部类和匿名类，有需要时请使用静态内部类为什么要怎么做呢?因为使用非静态内部类和匿名类都会默认持有外部类的引用，如果生命周期不一致，就会导致内存泄漏。 看一个例子。 1234567891011121314151617public class NestedClassLeakActivity extends AppCompatActivity &#123; class InnerClass &#123;//非静态内部类 &#125; private static InnerClass sInner;//指向非静态内部类的静态引用 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_nested_class); if (sInner == null) &#123; sInner = new InnerClass();//创建非静态内部类的实例 &#125; &#125;&#125; 本例中，因为非静态内部类默认会持有外部类的引用，而外部类中又有一个该非静态内部类的静态实例，该静态实例的生命周期和应用的一样长，而静态实例又持有 Activity 的引用，因此导致 Activity 的内存资源不能正常回收。 解决 将该内部类设为静态内部类 也可以将该内部类抽取出来封装成一个单例 集合引发的内存泄漏我们通常会把一些对象的引用加入到集合容器（比如ArrayList）中，当我们不再需要该对象时（通常会调用 remove 方法），并没有把它的引用从集合中清理掉（其中的一种情况就是 remove 方法没有将不再需要的引用赋值为 null），下面以 ArrayList 的 remove 方法为例 12345678910111213141516public E remove( int index) &#123; // 数组越界检查 RangeCheck(index); modCount++; // 取出要删除位置的元素，供返回使用 E oldValue = (E) elementData[index]; // 计算数组要复制的数量 int numMoved = size - index - 1; // 数组复制，就是将index之后的元素往前移动一个位置 if (numMoved &gt; 0) System. arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收 elementData[--size ] = null; // Let gc do its work return oldValue;&#125; elementData[--size ] = null; // Let gc do its work 如果替换为 --size，就会导致已经「移除」的对象因为强引用被集合持有，而无法正常被 gc 回收。 WebView 引发的内存泄漏WebView 解析网页时会申请Native堆内存用于保存页面元素，当页面较复杂时会有很大的内存占用。如果页面包含图片，内存占用会更严重。并且打开新页面时，为了能快速回退，之前页面占用的内存也不会释放。有时浏览十几个网页，都会占用几百兆的内存。这样加载网页较多时，会导致系统不堪重负，最终强制关闭应用，也就是出现应用闪退或重启。 由于占用的都是 Native 堆内存，所以实际占用的内存大小不会显示在常用的 DDMS Heap 工具中（ DMS Heap 工具看到的只是Java虚拟机分配的内存，即使Native堆内存已经占用了几百兆，这里显示的还只是几兆或十几兆）。只有使用 adb shell 中的一些命令比如 dumpsys meminfo 包名，或者在程序中使用 Debug.getNativeHeapSize() 才能看到 Native 堆内存信息。 据说由于 WebView 的一个 BUG，即使它所在的 Activity(或者Service) 结束也就是 onDestroy() 之后，或者直接调用 WebView.destroy()之后，它所占用这些内存也不会被释放。 解决把使用了 WebView 的 Activity (或者 Service) 放在单独的进程里。 系统在检测到应用占用内存过大有可能被系统干掉 也可以在它所在的 Activity(或者 Service) 结束后，调用 System.exit(0)，主动Kill掉进程。由于系统的内存分配是以进程为准的，进程关闭后，系统会自动回收所有内存。 使用 WebView 的页面（Activity），在生命周期结束页面退出（onDestory）的时候，主动调用WebView.onPause()==以及==WebView.destory()以便让系统释放 WebView 相关资源。 其他常见的引起内存泄漏原因 Android 3.0 以下，Bitmap 在不使用的时候没有使用 recycle() 释放内存。 非静态内部类的静态实例容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。 警惕线程未终止造成的内存泄露；譬如在 Activity 中关联了一个生命周期超过 Activity 的 Thread，在退出 Activity 时切记结束线程。 一个典型的例子就是 HandlerThread 的 run 方法。该方法在这里是一个死循环，它不会自己结束，线程的生命周期超过了 Activity 生命周期，我们必须手动在 Activity 的销毁方法中中调用 thread.getLooper().quit() 才不会泄露。 对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。 创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。 避免代码设计模式的错误造成内存泄露；譬如循环引用，A 持有 B，B 持有 C，C 持有 A，这样的设计谁都得不到释放。 内存泄漏的检测工具 LeakCanary 是一个检查内存泄漏的优秀框架。具体用法可以参考 LeakCanary——如何检测 Activity 是否泄漏 使用 AS Monitor + MAT 自己分析内存泄漏原因。具体请移步 Google 或 Baidu 参考资料与学习资源推荐 Android 性能优化 详解内存优化的来龙去脉 内存泄漏全解析，从此拒绝ANR，让OOM远离你的身边，跟内存泄漏say byebye 明白原理，轻松应对Android内存泄漏 如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码中的代理模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F18%2FAndroid%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式的定义代理模式也称为委托模式，为其他对象提供一种代理以控制对这个对象的访问。 代理模式的使用场景当无法或不想访问某个对象或者访问某个对象存在困难时可以通过一个代理对象来间接访问。 为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口（或继承相同的抽象类） 代理模式的UML类图 角色介绍： Subject 抽象主题类 主要职责是声明真实主题类与代理的共同接口方法，该类可以是一个抽象类也可以是一个接口 RealSubject 真实主题类 也称为被委托类或被代理理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。 ProxySubject 代理类 也称为委托类，持有一个对真实主题类的引用，在其实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。 Client 使用代理类的类 代理模式的简单实现代理模式大致可分为两大部分，静态代理和动态代理。 动态代理通过反射机制动态地生成代理者的对象，code 阶段不需要知道代理谁，代理的真正对象会在执行阶段确定。 Java 提供一个便捷的动态代理接口 InvocationHandler，实现该接口需要重写其调用方法 invoke。 动态代理通过一个代理类来代理 N 多个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的的耦合关系。 静态代理 vs 动态代理相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂。 但是静态代理更符合面向对象的原则。 实际开发中具体使用哪种方式来实现代理，看自己的偏好。 分类静态代理和动态代理是从 code 方面来区分代理模式的。 也可以从其使用范围来区分不同类型的代理实现： 远程代理（Remote Proxy）为某个对象在不同的内存地址空间提供局部代理。 虚拟代理（Virtual Proxy）使用一个代理对象表示一个十分耗资源的对象并在真正需要时才创建。 保护代理(Protection Proxy)：使用代理控制对原始对象的访问。该类型的代理常被用于原始对象具有不同访问权限的情况。 智能引用(Smart Reference)：在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数。 静动态代理都可以应用于上述 4 种情形。 Android源码中的代理模式实现以 ActivityManager 为例。 抽象接口: IActivityManager 代理类 ActivityManagerProxy 被代理类 ActivityManagerNative(抽象类，并不处理太多的逻辑，大部分逻辑由其子类——ActivityManagerService 承担) ActivityManagerService(真实部分) ActivityManagerService 是系统级的 Service 并且运行于独立的进程空间中，可以通过 ServiceManger 获取到它。 ActivityManagerProxy 运行于自己所处的进程空间中（也就是说，与 ActivityManagerService 运行在不同的进程中） 所以此处源码所实现的代理实质为==远程代理==。 ActivityManagerProxy 在实际的逻辑处理并没有过多地被外部类使用，Android 中管理与维护 Activity 相关信息的类是另一个叫做 ActivityManager 的类。不过实质上 ActivityManager 大多数逻辑还是由 ActivityManagerProxy 承担。 以 ActivityManager 的 getAppTasks() 方法为例1234567891011121314public List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123; ArrayList&lt;AppTask&gt; tasks = new ArrayList&lt;AppTask&gt;(); List&lt;IAppTask&gt; appTasks; try &#123; appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; int numAppTasks = appTasks.size(); for (int i = 0; i &lt; numAppTasks; i++) &#123; tasks.add(new AppTask(appTasks.get(i))); &#125; return tasks;&#125; ActivityManagerNative.getDefault();方法 返回一个 IActivityManager 类型的对象，通过该对象调用其 getAppTasks 方法123static public IActivityManager getDefault() &#123; return gDefault.get();&#125; gDefault 到底是什么？123456789private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService("activity");//获取 AMS //代码省略 IActivityManager am = asInterface(b);//完成创建一个 AMS 的客户端端代理对象—— ActivityManagerProxy //代码省略 return am; &#125;&#125;; 上述代码中构造了一个 Singleton&lt;IActivityManager&gt; 类型的 gDefault 对象，其中通过 ServiceManager.getService(&quot;activity&quot;); 获取一个系统级的 Service，而该 Service 实质上就是 AMS，接着调用 asInterface 方法，创建一个 ActivityManagerProxy 对象。 ActivityManagerNative.asInterface 方法的具体实现1234567891011static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; ActivityManagerProxy 的 getTasks 方法，将数据打包跨进程传递给 Server 端的 AMS 处理12345678910111213141516171819202122232425public List&lt;ActivityManager.RunningTaskInfo&gt; getTasks(int maxNum, int flags) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeInt(maxNum); data.writeInt(flags); mRemote.transact(GET_TASKS_TRANSACTION, data, reply, 0); reply.readException(); ArrayList&lt;ActivityManager.RunningTaskInfo&gt; list = null; int N = reply.readInt(); if (N &gt;= 0) &#123; list = new ArrayList&lt;&gt;(); while (N &gt; 0) &#123; ActivityManager.RunningTaskInfo info = ActivityManager.RunningTaskInfo.CREATOR .createFromParcel(reply); list.add(info); N--; &#125; &#125; data.recycle(); reply.recycle(); return list; &#125; 看看 AMS 中的 getTasks 方法的具体实现。1234567891011121314151617181920212223242526272829303132333435@Overridepublic List&lt;IAppTask&gt; getAppTasks(String callingPackage) &#123; int callingUid = Binder.getCallingUid(); long ident = Binder.clearCallingIdentity(); synchronized(this) &#123; ArrayList&lt;IAppTask&gt; list = new ArrayList&lt;IAppTask&gt;(); try &#123; if (DEBUG_ALL) Slog.v(TAG, "getAppTasks"); final int N = mRecentTasks.size(); for (int i = 0; i &lt; N; i++) &#123; TaskRecord tr = mRecentTasks.get(i); // Skip tasks that do not match the caller. We don't need to verify // callingPackage, because we are also limiting to callingUid and know // that will limit to the correct security sandbox. if (tr.effectiveUid != callingUid) &#123; continue; &#125; Intent intent = tr.getBaseIntent(); if (intent == null || !callingPackage.equals(intent.getComponent().getPackageName())) &#123; continue; &#125; ActivityManager.RecentTaskInfo taskInfo = createRecentTaskInfoFromTaskRecord(tr); AppTaskImpl taskImpl = new AppTaskImpl(taskInfo.persistentId, callingUid); list.add(taskImpl); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; return list; &#125;&#125; Android 中的 Binder 跨进程通信机制与 AIDL四个重要类： Binder Client 类比 PC、终端设备 Binder Server 类比 服务器 Binder Driver（实现在内核中） 类比 路由器 Binder Manager 类比 DNS 服务器 因为依赖于抽象，加上本地代理类的存在，所以调用远程方法时，还是与调用本地的普通的方法一样。但是代理类内部需要对参数什么的进行打包处理，然后再通过 Binder 机制，跨进程将数据传递给远程方法，远程方法执行完毕再返回数据。 Binder Driver 实现在内核中，主要负责 Binder 通信的建立，以及 Binder数据在进程间的传递和 Binder 引用计数管理/数据包的传输等。 Binder Client 和 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发， 对于 Binder Client 而言，它只需要知道自己要使用的 Binder 的名字以及该 Binder 实体在 ServerManager 中的 0 号引用即可。 访问原理： 通过 0 号引用去访问 ServerManager 获取该 Binder 的引用， 得到引用后就可以像普通方法调用那样调用 Binder 实体的方法 ServerManager 用来管理 Binder Server（Android 中通常是一个 Service） Binder Client 通过它来查询 Binder Server 的引用 ServerManager 是一个标准的 Binder Server，并且在 Android 中约定其在 Binder 通信过程中的唯一标识（类似于 IP 地址）永远为 0。 在 IServiceManager 接口中定义有对外开放的接口方法，供客户端访问。 匿名 Binder。很多时候 Binder Server 会将一个 Binder 实体封装进数据包传递给 Binder Client，而此时 Binder Server 会在该数据包中标注 Binder 实体的位置，Binder Driver 会为该匿名的 Binder 生成实体结点和实体引用，并将该引用传递给 Binder Client。 IServiceManager 接口(声明 ServerManger 对外提供的方法、数据 )1234567891011121314151617181920212223public interface IServiceManager extends IInterface &#123; public IBinder getService(String name) throws RemoteException; public IBinder checkService(String name) throws RemoteException; */ public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException; public String[] listServices() throws RemoteException; public void setPermissionController(IPermissionController controller) throws RemoteException; static final String descriptor = "android.os.IServiceManager"; int GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION; int CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+1; int ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+2; int LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+3; int CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+4; int SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+5;&#125; 参考《Andorid 源码设计模式解析与实战》 如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 LayoutInflater]]></title>
    <url>%2Fblog%2F2017%2F08%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20LayoutInflater%2F</url>
    <content type="text"><![CDATA[基础系统服务的注册什么时候初始化 ContextImpl？ ContextImpl 中有这样一个成员变量，缓存系统服务。final Object[] mServiceCache = SystemServiceRegistry.createServiceCache(); 在 SystemServiceRegistry 中的静态代码块中注册。注册方法如下所示。在 static 代码块中，会注册所有的系统服务。 123456789/** * Statically registers a system service with the context. * This method must be called during static initialization only. */private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) &#123; SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);&#125; 以 LAYOUT_INFLATER_SERVICE 为例子，123456registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); CachedServiceFetcher 是一个实现了 ServiceFetcher&lt;T&gt; 接口的抽象类 createService 为 CachedServiceFetcher 中的抽象方法，当初始化时会调用该方法。1234567/** * Base interface for classes that fetch services. * These objects must only be created during static initialization. */static abstract interface ServiceFetcher&lt;T&gt; &#123; T getService(ContextImpl ctx);&#125; 123456789101112131415161718192021222324static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123; private final int mCacheIndex; public CachedServiceFetcher() &#123; mCacheIndex = sServiceCacheSize++; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public final T getService(ContextImpl ctx) &#123; final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; // Fetch or create the service. Object service = cache[mCacheIndex]; if (service == null) &#123;//使用了延时加载,第一次调用时才初始化，并将相应服务缓存起来。 service = createService(ctx); cache[mCacheIndex] = service; &#125; return (T)service; &#125; &#125; public abstract T createService(ContextImpl ctx);&#125; 系统服务的获取平时我们都是通过 Context.getSystemService(&quot;服务名字&quot;) 来获取服务。 具体为 ContextImpl 中的。1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; 而 getSystemService 的实际实现是在 SystemServiceRegistry 中的。 SystemServiceRegistry 中有一个 HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; ，该 HashMap 以服务名称为 key，以服务相对应的 ServiceFetcher 作为 value。 12private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); 具体的获取方法为1234567/** * Gets a system service from a given context. */public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; 根据服务名称去获取相应的 ServiceFetcher， 如果 ServiceFetcher 不为空，则调用 ServiceFetcher.getService 方法获取相应服务的引用。 如果是第一次调用会先创建，然后直接返回 否则直接返回缓存的值 如果 ServiceFetcher 为空，则返回 null。 深入理解 LayoutInflaterLayoutInflater的创建123456registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); 可见实际实现为 PhoneLayoutInflater（继承了 LayoutInflater） onCreateView 是其中最重要的方法。为什么说它重要，后面会提到。123456789101112131415161718192021/** Override onCreateView to instantiate names that correspond to the widgets known to the Widget factory. If we don't find a match, call through to our super class.*///为系统内置的控件添加前缀。比如为 TextView 添加前缀，结果为 android.widget.TextView@Override protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123; for (String prefix : sClassPrefixList) &#123; try &#123; View view = createView(name, prefix, attrs); if (view != null) &#123; return view; &#125; &#125; catch (ClassNotFoundException e) &#123; // In this case we want to let the base class take a crack // at it. &#125; &#125; return super.onCreateView(name, attrs);&#125; 渲染过程解析一般我们在渲染 ListView 或者 RecyclerView 中的列表时，都会调用 inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) 方法（有时也会使用两个参数的方法）。可以看到该方法内部会调用 inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)。123public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null);&#125; 1234567891011public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); //代码省略 //获取 xml 解析器 final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; //存储父视图 View result = root; try &#123; // 查找根标签 int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; final String name = parser.getName(); if (TAG_MERGE.equals(name)) &#123; //1. 解析 merge 标签 rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // 2. 不是 merge 元素就直接解析布局中的视图 // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; // 生成布局参数 params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; //如果 attachToRoot 为 false，就给 temp 设置布局参数 temp.setLayoutParams(params); &#125; &#125; // 解析 temp 视图下的所有子 View rInflateChildren(parser, temp, attrs, true); // 如果 root 不为空并且 attachToRoot 为 true，那么将 temp 添加到 父视图中 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; //如果 root 为空 或者 attachToRoot 为 false，返回 xml 中的 root，而不是父视图 if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; return result; &#125;&#125; 以上的 inflate 方法主要有以下几步 解析 xml 的根标签 如果根标签是 merge，调用 rInflate 进行解析，rInflate 会将 merge 标签下的所有子 View 直接添加到根标签中 如果标签是普通元素，调用 createFromTag 调用 rInflate 解析 temp 根元素下的所有子 View，并且将这些子 View 都添加到 temp 下 返回解析到的根视图。 我们先从解析单个元素的 createViewFromTag 方法看起。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals(&quot;view&quot;)) &#123; name = attrs.getAttributeValue(null, &quot;class&quot;); &#125; // Apply a theme wrapper, if allowed and one is specified. if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; try &#123; View view; //用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段 if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf(&apos;.&apos;)) &#123; // 解析内置 View 控件 view = onCreateView(parent, name, attrs); &#125; else &#123; // 解析自定义控件 view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; //代码省略 onCreateView 方法和 createView 方法有何不同？前面的介绍中，我们有提到 LayoutInlflater 创建的实际类型为 PhoneLayoutInlflater ，PhoneLayoutInlflater 覆写了 onCreateView 方法，该方法就是在 View 的标签名前添加一个 &quot;android.widget.&quot; 或 &quot;android.webkit.&quot; 或 &quot;android.app.&quot;前缀。然后再传递给 createView 解析。 也就是说内置 View 和自定义 View 最终都调用了 createView 进行解析。 为什么要这么设计呢？这是为了方便开发者在 xml 文件中更方便使用系统内置的 View（只需要写 View 名称而不需要写完整的路径），如果是自定义控件或者第三方库，写完整路径。 createView 的具体实现如下12345678910111213141516171819202122232425262728293031323334353637383940414243//根据完整路径的类名通过反射机制构造 View 对象public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; //从缓存中获取构造函数 Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); // 缓存中找不到构造函数 if (constructor == null) &#123; //如果前缀（prefix）不为空，构造完整路径，并且加载该类 clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); //代码省略 //从 class 对象中获取构造函数 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); &#125; else &#123; //代码省略 &#125; &#125; Object[] args = mConstructorArgs; args[1] = attrs; //通过反射构造 View final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123; // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; return view; &#125; //省略各种 catch、finally 代码&#125; createView 方法中，如果控件名有前缀就先构造 View 的完整路径，并且将该类加载到虚拟机中 然后获取该类的构造函数并缓存起来，再通过构造函数来创建该 View 的对象， 最后将 View 对象返回，这就是解析单个 View 的过程 123456789101112131415161718192021222324252627282930313233343536373839404142void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; //获取树的深度 final int depth = parser.getDepth(); int type; //逐个元素解析 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123;//解析 include 标签 if (parser.getDepth() == 0) &#123; throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123;解析 merge 标签 throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); &#125; else &#123; //根据元素名进行解析 final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); //递归调用进行解析，即深度优先遍历 rInflateChildren(parser, view, attrs, true); //将解析到的 View 添加到它的父视图中 viewGroup.addView(view, params); &#125; &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125; rInflate() 通过深度优先遍历来构造视图树。每解析到一个 View 元素就会递归调用 rInflate，直到这条路径下的最后一个元素，然后在回溯过来将每个 View 元素添加到它们的 parent 中。 通过 rInflate 的解析之后，整棵视图树就构建完毕。当调用了 Activity 的 onResume 之后，之前通过 setContentView 设置的内容就会出现在我们的视野中。 总结渲染流程大致如下： inflate 查找根标签 如果是 merge，调用 rInflate 否则，调用 createViewFromTag 如果是系统内置控件（通过名称中是否含有「.」来判断），调用 PhoneLayoutInflater.onCreateView() 方法添加前缀， 处理后将完整路径传给 LayoutInflater.createView() 方法 否则，直接调用 LayoutInflater.createView() 进行解析。 参考《Android 源码设计模式解析与实战》]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中子线程真的不能更新UI吗？]]></title>
    <url>%2Fblog%2F2017%2F08%2F16%2FAndroid%20%E4%B8%AD%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97%2F</url>
    <content type="text"><![CDATA[Android中子线程真的不能更新UI吗？先说结论：Android 中子线程在满足一定的条件下可以更新 UI。 一个栗子：1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.btn1) Button mBtn1; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; mBtn1.setText("worker thread"); &#125; &#125;).start(); &#125;&#125; 如上在 onCreate 方法中新建一个线程对 mBtn1 进行了操作，成功从子线程更新了 ui。 但是如果让线程 sleep 一段时间（比如 300ms），1234567891011new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mBtn1.setText("worker thread"); &#125;&#125;).start(); 那么就很可能会报如下错误：1234567891011android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:4788) at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:865) at android.view.ViewGroup.invalidateChild(ViewGroup.java:4106) at android.view.View.invalidate(View.java:10386) at android.view.View.invalidate(View.java:10341) at android.widget.TextView.checkForRelayout(TextView.java:6657) at android.widget.TextView.setText(TextView.java:3696) at android.widget.TextView.setText(TextView.java:3554) at android.widget.TextView.setText(TextView.java:3529) at com.android.rdc.androidsamples.MainActivity$1.run(MainActivity.java:63) 分析为什么会报这个错误呢？从出错的堆栈信息中可以异常看到是 ViewRootImpl.checkThread() 方法中抛出的。123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); &#125;&#125; 在访问UI的时候，ViewRootImpl会去检查当前是哪个线程访问的UI，如果不是主线程，那就会抛出异常： 分析到了这里，其实异常信息对我们帮助也不大了，它只告诉了我们子线程中访问UI在哪里抛出异常。 而我们会思考：当访问UI时，ViewRootImpl 会调用 checkThread 方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，这是没问题的。但是为什么一开始在 MainActivity 的 onCreate 方法中创建一个子线程访问UI，程序还是正常能跑起来呢？答案就是执行 onCreate 方法的那个时候 ViewRootImpl 还没创建，无法去检查当前线程。那么，ViewRootImpl 创建之前的，程序对 UI 的更新操作是如何进行的呢？这个问题我暂时还没有找出答案，希望有了解的同学能指导一下。 回过头看，抛异常的方法既然是 ViewRootImpl 中的方法，那首先应该去看看 ViewRootImpl 是在哪里、在什么时候被创建的。在 AS 中对 ViewRootImpl 进行查找，发现唯一一个初始化了它的地方是 WindowManagerGlobal.addView() 方法。1234567891011public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //代码省略 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams);&#125; 可以看到，该方法创建了一个 ViewRootImpl 并将它添加到一个列表中。 该方法又是什么被调用的呢？对 Window 和 WindowManager 有所了解的同学应该知道，Window 的添加过程。 先来看看 ActivityThread 中的 handleResumeActivity 方法123456789101112final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; //代码省略 r = performResumeActivity(token, clearHide, reason); //代码省略 r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125;&#125; 该方法内部调用了 performResumeActivity 方法，看这个方法名可以揣测该方法最终会调用 Activity 的 onResume 方法，大致流程如下。 ActivityThread.performResumeActivity ==》 ActivityClientRecord.Activity.performResume(); ==》 Instrumentation.callActivityOnResume(this); ==》 Activity.onResume(); 回归正题。执行完 performResumeActivity 方法后，会执行 r.activity.makeVisible()，即调用 Activity 的 makeVisible() 。该方法实现如下：12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; 此处调用了 WindowManager.addView() 方法。而 WindowManger 是一个接口，它的具体实现为 WindowManagerImpl12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; 这里的 mGlobal 为 WindowManagerGlobal，也就是说调用了 WindowManagerGlobal.addView() 创建 ViewRootImpl 总结：ViewRootImpl 的创建在 onResume 方法回调之后，而我们一开篇是在 onCreate 方法中创建了子线程并访问 UI，在那个时刻，ViewRootImpl 还没有创建，无法检测当前线程是否是 UI 线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了 300 毫秒后，程序就崩了。很明显 300 毫秒后 ViewRootImpl 已经创建了，可以执行 checkThread 方法检查当前线程。 开篇的例子中我们在 onCreate 方法中创建的子线程访问 UI 是一种极端的情况。实际开发中不会这么做。 下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答： 子线程可以更新UI，但是需要创建子线程的根视图（RootView），并添加到 WindowManager，还要创建子线程的 Looper。以上条件都满足时，它可以修改它自己创建的根视图中的 UI。 参考 Android中子线程真的不能更新UI吗？ 多线程学习之–真的不能在子线程里更新UI吗？ 互联网笔记 Android中子线程真的不能更新UI吗？]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码中的观察者模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F09%2FAndroid%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[解决、解耦的钥匙——观察者模式定义观察者模式定义了对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 使用场景 关联行为场景 需要注意的是，关联行为是可拆分的，而不是“组合”关系 事件多级触发场景 跨系统的消息交换场景，如消息队列、事件总线的处理机制。 UML 类图UML 类图如下所示： 四个角色： Subject 抽象主题（抽象的被观察者）。把所有观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，提供接口供添加和删除观察者对象。 ConcreteSubject 具体主题（具体的被观察者）。将有关状态存入具体观察者对象，在具体主题的内部实现发生改变时，给所有注册过的观察者发出通知 Observer 抽象观察者。定义一个更新接口，用来接收主题更改时做出相应的操作（比如更新自身的状态） ConcreteObserver 具体观察者（实现抽象观察者所定义的更新接口，以便在主题状态更改时更新自身的状态） Android ListView 的观察者模式ListView 和 RecyclerView 在 Android 中都占据着很重要的地位。 使用这两个组件时，总免不了数据更新的情况：当要更新数据时我们通常都会调用 Adapter.notifyDataSetChanged()，这其中的原理又是怎么样的呢？ 下面以 ListView 作为一个栗子，看看其中的具体实现是怎么样的。 123public void notifyDataSetChanged() &#123; mDataSetObservable.notifyChanged();&#125; 1234567891011public void notifyChanged() &#123; synchronized(mObservers) &#123; // since onChanged() is implemented by the app, it could do anything, including // removing itself from &#123;@link mObservers&#125; - and that could cause problems if // an iterator is used on the ArrayList &#123;@link mObservers&#125;. // to avoid such problems, just march thru the list in the reverse order. for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125;&#125; notifyDataSetChanged 方法会调用 DataSetObservable.notifyChanged() 方法,notifyChanged() 内部会遍历调用观察者的 onChanged() 方法。通知数据更新。 但是观察者又是什么时候注册的呢？ 以下为 setAdapter 的方法的具体实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Overridepublic void setAdapter(ListAdapter adapter) &#123; //如果 已经有 Adapter 存在，先解除注册 if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mAdapter.unregisterDataSetObserver(mDataSetObserver); &#125; resetList(); mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; mAdapter = adapter; &#125; mOldSelectedPosition = INVALID_POSITION; mOldSelectedRowId = INVALID_ROW_ID; // AbsListView#setAdapter will update choice mode states. super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; mItemCount = mAdapter.getCount(); checkFocus(); // 构建一个 AdapterDataSetObserver mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者 mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; if (mStackFromBottom) &#123; position = lookForSelectablePosition(mItemCount - 1, false); &#125; else &#123; position = lookForSelectablePosition(0, true); &#125; setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) &#123; // Nothing selected checkSelectionChanged(); &#125; &#125; else &#123; mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); &#125; requestLayout();&#125; 通过源码可以看到，setAdapter 方法内部会构建一个 AdapterDataSetObserver ，然后注册为观察者。我们还可以看到注册的时候是通过 Adapter 来注册的。 Adapter 接口中声明了注册和解注册的方法签名。1234567891011121314151617public interface Adapter &#123; /** * Register an observer that is called when changes happen to the data used by this adapter. * * @param observer the object that gets notified when the data set changes. */ void registerDataSetObserver(DataSetObserver observer); /** * Unregister an observer that has previously been registered with this * adapter via &#123;@link #registerDataSetObserver&#125;. * * @param observer the object to unregister. */ void unregisterDataSetObserver(DataSetObserver observer); //代码省略&#125; 而 BaseAdapter 实现了 ListAdapter 接口，ListAdapter 接口又继承自 Adapter 接口。BaseAdapter 中注册方法和解除注册方法的具体实现： 1234567public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer);&#125;public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer);&#125; BaseAdapter 中注册方法和解除注册方法的具体实现都是通过 mDataSetObservable 来完成的。查看一下 DataSetObservable 的具体实现。1234567891011121314151617public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123; public void notifyChanged() &#123; synchronized(mObservers) &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125; &#125; public void notifyInvalidated() &#123; synchronized (mObservers) &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onInvalidated(); &#125; &#125; &#125;&#125; 该类继承了 android.database 包下的 Observable 类，而 Observable 类中存有所有观察者的引用，以及注册和解注册方法。 ListView 中的 onChange 方法具体实现又是什么样的? 还记得前面我们说 Observer 是如何注册的吗？注册时，我们构建的是 AdapterDataSetObserver。 该类是 AbsListView 的内部类。 AbsListView.AdapterDataSetObserver 继承自 AdapterView.AdapterDataSetObserver onChange 方法的主要逻辑都在 AdapterDataSetObserver 中 12345678910111213141516171819202122class AdapterDataSetObserver extends DataSetObserver &#123; //代码省略 ... @Override public void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); requestLayout(); &#125; //代码省略 ...&#125; onChange 方法中，会获取当前 Adapter 中的数据集的新数量，方法的最后调用 ListView 的 requestLayout() 方法重新进行布局。 从上面的分析中，我们可以看到 AbsListView 是抽象的观察者 ListView 是具体的观察者 Adapter 接口是抽象的被观察者 BaseAdapter 是具体的被观察者，其内部实际上是通过 android.database 包下的 Observerable 来实现注册和监听的。 小结 AdapterView 中有一个 AdapterDataSetObserver 内部类， 在 ListView 中设置 Adapter（即调用 ListView 的 setAdapter 方法）时，其内部会构建一个 AdapterDataSetObserver，并注册到 Adapter 中。可见该场景中 ListView 扮演一个观察者角色。 而 Adapter 中有一个数据集可观察者 DataSetObserable。即一个被观察者。 数据集发生变化时，开发者手动调用 Adapter.notifyDataSetChanged 方法，notifyDataSetChanged 会调用 DataSetObserverable.notifyChanged() notifyChanged() 方法会遍历所有观察者，并调用观察者的 onChanged 方法， onChanged 会获取 Adapter 中数据集的新数量，同时会调用 View.requestLayout 方法通知 ListView 更新布局，刷新用户界面。 虽然 RecyclerView 直接继承自 ViewGroup，而不是 AdapterView ，但是更新列表数据集方法的内部也是通过观察者模式来实现的。只是在其中多提供了单个数据或者指定范围数据更新等回调接口，供开发者使用。感兴趣的同学可以去看看 RecyclerView 中观察者模式的实现。 作者水平有限，疏漏之处，恳请指出。 参考 《Android 源码设计模式解析与实战》 第十二章]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toast 原理]]></title>
    <url>%2Fblog%2F2017%2F07%2F28%2FToast%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Toast.makeText(context,”msg”,Toast.Length_SHORT).show();`我们都知道调用了这行代码，便会触发显示 Toast 信息，但是从调用开始到显示出来的具体过程是怎么样的，里面具体实现又是怎么样的呢？ 在 Toast 内部有两类 IPC 过程。 第一类： Toast 访问 NotificationManagerService 第二类：NotificationManagerService 回调 Toast 里的 TN 接口。 Toast 属于系统 Window，它内部的视图由两种方式指定，一种是系统默认的样式，另一种是自定义一个 view 然后通过 setView 方法将 view 设置进去。不管哪一种方式，它们都对应 Toast 的一个 View 类型的内部成员 mNextView。 Toast 提供 show 和 cancel 方法分别用于显示和隐藏 view，它们的内部都是一个 IPC 过程。 Toast 有定时取消功能，所以系统采用了 Handler（利用其中的 sendMessageDelayed() 方法） Toast.show() 调用流程大致如下： 先来看看 Toast.makeText 方法1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context);//创建一个新的 Toast 对象 LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取 LayoutInflater View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); //渲染出系统默认的布局 TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text);//将我们的信息设置到 TextView 中去 result.mNextView = v;//把 view 赋给 Toast 内部的View result.mDuration = duration;//设置 toast 时长 return result;&#125; 再瞧一瞧 Toast.show(); 方法12345678910111213141516public void show() &#123; if (mNextView == null) &#123;//判断，如果没有设置 Toast 的 view，就抛出异常 throw new RuntimeException(&quot;setView must have been called&quot;); &#125; INotificationManager service = getService();//获取 INotificationManager String pkg = mContext.getOpPackageName();// 获取调用者的包名 TN tn = mTN;//给 TN 赋值 tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; 这里面有几个地方看起来比较陌生 INotificationManager 是什么，TN 又是什么？ INotificationManager 的值是从 getService() 方法中得来的。我们先查看下 getService() 的内部实现：1234567static private INotificationManager getService() &#123; if (sService != null) &#123; return sService; &#125; sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService;&#125; 了解 Binder 的同学应该一看便知道，这里用到了 Binder。 INotificationManager 的具体实现在 NotificationManagerService 中，简便起见，后续内容将 NotificationManagerService 称为 NMS。 TN 又是什么？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140private static class TN extends ITransientNotification.Stub &#123; final Runnable mHide = new Runnable() &#123; @Override public void run() &#123; handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; &#125; &#125;; private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams(); final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; IBinder token = (IBinder) msg.obj; handleShow(token); &#125; &#125;; int mGravity; int mX, mY; float mHorizontalMargin; float mVerticalMargin; View mView; View mNextView; int mDuration; WindowManager mWM; static final long SHORT_DURATION_TIMEOUT = 5000; static final long LONG_DURATION_TIMEOUT = 1000; TN() &#123; // XXX This should be changed to use a Dialog, with a Theme.Toast // defined that sets up the layout params appropriately. final WindowManager.LayoutParams params = mParams; params.height = WindowManager.LayoutParams.WRAP_CONTENT; params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.format = PixelFormat.TRANSLUCENT; params.windowAnimations = com.android.internal.R.style.Animation_Toast; params.type = WindowManager.LayoutParams.TYPE_TOAST; params.setTitle("Toast"); params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; &#125; /** * schedule handleShow into the right thread */ @Override public void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "SHOW: " + this); mHandler.obtainMessage(0, windowToken).sendToTarget(); &#125; /** * schedule handleHide into the right thread */ @Override public void hide() &#123; if (localLOGV) Log.v(TAG, "HIDE: " + this); mHandler.post(mHide); &#125; public void handleShow(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "HANDLE SHOW: " + this + " mView=" + mView + " mNextView=" + mNextView); if (mView != mNextView) &#123; // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) &#123; context = mView.getContext(); &#125; mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123; mParams.horizontalWeight = 1.0f; &#125; if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123; mParams.verticalWeight = 1.0f; &#125; mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; mParams.hideTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT; mParams.token = windowToken; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; if (localLOGV) Log.v(TAG, "ADD! " + mView + " in " + this); mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125; &#125; private void trySendAccessibilityEvent() &#123; AccessibilityManager accessibilityManager = AccessibilityManager.getInstance(mView.getContext()); if (!accessibilityManager.isEnabled()) &#123; return; &#125; // treat toasts as notifications since they are used to // announce a transient piece of information to the user AccessibilityEvent event = AccessibilityEvent.obtain( AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED); event.setClassName(getClass().getName()); event.setPackageName(mView.getContext().getPackageName()); mView.dispatchPopulateAccessibilityEvent(event); accessibilityManager.sendAccessibilityEvent(event); &#125; public void handleHide() &#123; if (localLOGV) Log.v(TAG, "HANDLE HIDE: " + this + " mView=" + mView); if (mView != null) &#123; // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeViewImmediate(mView); &#125; mView = null; &#125; &#125;&#125; TN 是 Toast 的一个私有的静态内部类，继承自 ITransientNotification.Stub 也是用到了 Binder 机制。 在回到 show 方法。该方法最后调用了 service.enqueueToast(pkg, tn, mDuration); 方法。我们到 NMS 看看该方法的主要实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 @Overridepublic void enqueueToast(String pkg, ITransientNotification callback, int duration)&#123; //.... final boolean isSystemToast = isCallerSystem() || ("android".equals(pkg));//是否是 android 系统的 toast final boolean isPackageSuspended = isPackageSuspendedForUser(pkg, Binder.getCallingUid()); //... synchronized (mToastQueue) &#123; int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try &#123; ToastRecord record; int index = indexOfToastLocked(pkg, callback);//根据包名和回调来获取的对应包名的 Toast 的在 mToastQueue 中的位置（如果有的话） //如果对应包名的 Toast 已经存在了，则直接在原位更新，不会把它排到队尾 if (index &gt;= 0) &#123; record = mToastQueue.get(index); record.update(duration); &#125; else &#123; //限制非系统应用的数量（不能超过 50），防止 DOS 攻击同时也是为了解决内存泄漏问题 if (!isSystemToast) &#123; int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) &#123; final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) &#123; count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123; Slog.e(TAG, "Package has already posted " + count + " toasts. Not showing more. Package=" + pkg); return; &#125; &#125; &#125; &#125; Binder token = new Binder(); mWindowManagerInternal.addWindowToken(token, WindowManager.LayoutParams.TYPE_TOAST); record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord mToastQueue.add(record);//加入 mToastQueue index = mToastQueue.size() - 1; keepProcessAliveIfNeededLocked(callingPid); &#125; if (index == 0) &#123; showNextToastLocked();//显示下一条 Toast &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125; &#125;&#125; 该方法会将 Toast 请求封装为 ToastRecord 并将其添加进 mToastQueue 队列中。 mToastQueue 是一个 ArrayList 注意：每个非系统应用最多只能有 50 个ToastRecord。如果超出了最大值，就会出错。 这样做主要是为了 防止 DOS（Denial Of Service） 拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 将 ToastRecord 加入队列之后， enqueueToast 还调用了 showNextToastLocked(); 方法, 该方法的具体实现如下：12345678910111213void showNextToastLocked() &#123; ToastRecord record = mToastQueue.get(0); while (record != null) &#123; if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try &#123; record.callback.show(record.token);//调用 record 对象中 callback 的 show 方法 scheduleTimeoutLocked(record); //超时提醒，控制显示时间 return; &#125; catch (RemoteException e) &#123; //...代码省略 &#125; &#125;&#125; 这里的 callBack 是什么？ 它是在 ToastRecord 中的，瞅瞅 ToastRecord 的构造方法。12345678ToastRecord(int pid, String pkg, ITransientNotification callback, int duration, Binder token) &#123; this.pid = pid; this.pkg = pkg; this.callback = callback; this.duration = duration; this.token = token;&#125; 在 enqueueToast 方法中，将 Toast 包装为 ToastRecord ，创建了 ToastRecord 对象。 record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord callBack 是 enqueueToast 中的一个参数，我们的调用如下： service.enqueueToast(pkg, tn, mDuration); 没错，callBack 实际上就是前面讲到的 Toast 的内部类 TN。 回到前面看看，TN 确实继承了 ITransientNotification.Stub。 showNextToastLocked() 方法调用 callBack 的 show() 方法来显示 Toast。 12345@Overridepublic void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.obtainMessage(0, windowToken).sendToTarget();&#125; 1234567final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; IBinder token = (IBinder) msg.obj; handleShow(token); &#125;&#125;; 其具体实现又是在 handleShow(token);1234567891011121314151617public void handleShow(IBinder windowToken) &#123; if (mView != mNextView) &#123; // 如果有必要的话，将还在显示的 toast 隐藏掉 handleHide(); mView = mNextView; //代码省略 mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);//获取 windowManager //省略代码，给布局参数赋值 if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125;&#125; 以上代码核心在于12`mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);``mWM.addView(mView, mParams);` 将 Toast 的视图添加到 Window 中。 这样 View 就能顺利显示出来了。 你可能会问，为什么 TN 调用 show 方法要用到的 Handler ？ 因为该方法是被是被 NMS 以跨进程方式调用的，因此它们运行在 Binder 线程池中。为了将执行环境切换到 Toast 请求所在的线程，在它们内部使用了 Handler。 那么时间到了 Toast 又是怎么样取消的呢？ 在令 Toast 显示方法调用过程中 我们也调用了 scheduleTimeoutLocked(record); 方法。 123456private void scheduleTimeoutLocked(ToastRecord r)&#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;//设置 延迟时间 mHandler.sendMessageDelayed(m, delay);&#125; SHORT_DELAY 为 2s LONG_DELAY 为 3.5s scheduleTimeoutLocked 会发出消息给 hanlder,收到相应的信息后 handleMessage 方法会调用handleTimeout((ToastRecord)msg.obj);, 该方法又会调用 cancelToastLocked(index); 123456789void cancelToastLocked(int index) &#123; ToastRecord record = mToastQueue.get(index); try &#123; record.callback.hide();// &#125; catch (RemoteException e) &#123; //代码省略 &#125; //代码省略&#125; 可以看到隐藏 Toast 的实现也是在 TN 中的。与 handleShow 对应，有一个 handleHide 方法。该方法会将 Toast 的视图从 Window 中移除。如下所示：12345678public void handleHide() &#123; if (mView != null) &#123; if (mView.getParent() != null) &#123; mWM.removeViewImmediate(mView); &#125; mView = null; &#125;&#125;]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之单例模式]]></title>
    <url>%2Fblog%2F2017%2F07%2F20%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、什么是单例模式？wiki 给出的定义如下：单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。 比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 二、为什么要使用单例模式？ 有一些对象的内存消耗比较大，创建多次会造成很大的资源开支。 方便配置。 例如 网络请求经常要用到 cookie，如果使用 OkHttp 可以将其封装为一个单例工具类，内部使用 CookJar 对 cookie 进行管理，这样后续的请求就会方便很多。 三、单例模式的实现方式1. 饿汉模式1234567891011public class Singleton &#123; private static Singleton sInstance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance() &#123; return sInstance; &#125;&#125; 在声明静态对象时就把它初始化。（因为饿，所以迫不及待先把它 new 出来） 2. 懒汉模式 261234567891011121314public class Singleton &#123; private static Singleton sInstance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (sInstance == null) &#123; sInstance = new Singleton(); &#125; return sInstance; &#125;&#125; 在 getInstance 方法中添加了 synchronized 关键字，也就是 一个问题：即使 instance 已经被初始化，之后的每次调用还是会 进行同步，这样会消耗不必要的资源 懒汉单例模式的 优点：单例只有在使用时才会被实例化，在一定程度上节约了资源。 缺点：第一次加载时需要及时地实例化，反应稍慢，最大的问题是：每次调用都会进行同步，造成不必要的同步开销。 3. 双重校验锁 ( DCL )DCL 既能够在需要时才初始化实例，又能够保证线程安全，而且单例对象初始化后才调用 getInstance 不进行同步锁。12345678910public static Singleton getInstance()&#123; if (sInstance == null)&#123; synchronized (Singleton.class)&#123; if (sInstance == null)&#123; sInstance = new Singleton(); &#125; &#125; &#125; return sInstance;&#125; 为什么在同步块内还要再进行判空？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 为什么要加 volitale 关键字？sInstance = new Singleton();这句代码会被编译成多条汇编指令，它大致做了 3 件事情 给 Singleton 实例分配内存 调用 Singleton 的构造函数，初始化成员字段 将 sInstance 对象指向分配的内存空间 但是由于 Java 编译器允许处理器乱序执行，以及 JDK 1.5 之前 JMM（Java Memory Model， Java 内存模型） 中 cache、寄存器到主内存回写顺序的规定，上面的 2 和 3 的顺序是无法保证的。 如果是 1-3-2，那么当 3 执行完，并且 2 还没有执行的话，被切换到到线程 B，这时 sInstance 已经非空（因为 3 已经被执行了嘛），若 此时线程 B 直接取走 sInstance 使用时就会报错。 解决：JDK 1.5 之后，SUN 官方调整了 JVM，具体化了 volatile 关键字（禁止指令重排序）。 如果是在 JDK 1.5 之后，那么只需要把 sInstance 的声明 改为 private volatile static Singleton sInstance; 即可 4. 静态内部类单例模式DCL 在某些情况下会出现失效的问题。这个问题被称为双重检查锁定（DCL）失效。 123456789101112public class Singleton&#123; private static volatile Singleton; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static final Singleton sInstance = new Singleton(); &#125;&#125; 第一次调用 Singleton 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 SingletonHolder 类，这种方式不仅能够确保线程安全，也能保证单例对象的唯一性。 所以这是推荐使用的单例模式实现方式 5. 枚举单例对枚举不了解可以先看看枚举这篇文章 写法简单是枚举单例 最大的优点。12345678910public enum Singleton&#123; INSTANCE; //枚举内部可以定义成员； private String mString; //枚举内部可以定义方法； public void doSth() &#123; //do sth &#125;&#125; 获取对象：只需要 Singleton singleton = Singleton.INSTANCE; 枚举在 Java 中与普通的类是一样的，不仅能够有字段，还能定义自己的方法。最重要的是默认枚举实例的创建是线程安全的，并且任何情况下它都是一个单例。 上述几种方式中，在一个情况下都会重新创建对象的情况，那就是反序列化。 即使构造函数是私有的，反序列化是依然可以通过特殊的途径去创建类的一个新的实例，相当于 调用该类的构造函数。 反序列化操作提供了一耳光很特别的钩子函数，类中具有一个私有的、被实例化的方法 readResolve(),这个方法可以让开发人员控制对象的反序列化。 上述几种单例方法中如果要杜绝单例对象在被反序列化时重新生成对象，那必须加入如下方法：123private Object readResolve() throws ObjectStreamException &#123; return sInstance;&#125; 也就是在 readResolve 方法中将 sInstance 对象返回，而不是默认的重新生成一个新的对象。 而对于枚举，并不存在这个问题，因为即使反序列化也不会重新生成新的实例。 6. 使用容器实现单例模式1234567891011121314151617public class SingletonManager &#123; private static Map&lt;String, Object&gt; sObjectMap = new HashMap&lt;&gt;(); private SingletonManager() &#123; &#125; public static void registerService(String key, Object instance) &#123; if (!sObjectMap.containsKey(key)) &#123; sObjectMap.put(key, instance); &#125; &#125; public static Object getService(String key) &#123; return sObjectMap.get(key); &#125;&#125; 在程序的初始，将多种单例类型注入到一个统一的管理类中，使用时格根据 key 获取对象对应类型的对象。 这种实现方式主要是方便对单例对象进行统一管理。 小结 不管使用哪一种形式实现单例模式，核心原理都是==将构造函数私有化==，并且==通过静态方法获取唯一的的实例==。 在获取的过程中必须保证线程安全、防止反序列化导致重新生成实例对象等问题。 使用时的注意点避免内存泄漏 Android 开发中使用单例模式，如果获取单例对象需要使用 Context，那么尽量使用 ApplicationContext(只要用 contxt.getApplicationContext() 即可获取)。因为如果使用其他 Context（如 Activity) 可能会造成 Activiity 生命周期 执行完成之后，因为其引用被单例所持有，而无法被回收。 多进程环境下，单例模式会失效。 Android 源码中的单例模式简述我们经常会通过 Context 去获取系统服务，如 LayoutInflater、NetworkStatsManager，这些服务在创建时会以键值对的形式缓存到 HashMap 中，便于管理。 需要时就通过调用 context.getSystemService(String name) 方法获取 。首先会以 name 作为 key，到 hashMap 中查找中相应的服务，如果对应的服务为 null 就创建一个实例，并将该实例缓存到 HashMap 中；如果对应的服务已经存在，则直接返回。 参考资料与学习资源推荐 wiki 单例模式 Android 源码设计模式 单例模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 消息机制解析]]></title>
    <url>%2Fblog%2F2017%2F04%2F28%2FAndroid-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述提起 Handler，相信大家都不会陌生，日常开发中不可避免地要使用到它。今天要讲的是消息机制。消息机制？咋听起来有点抽象。其实我们在使用 Handler 的时候，就使用了 Android 的消息机制。 从开发的角度来看，Handler 是 Android 消息机制的上层接口，这使得开发过程中只需要设计这方面的内容即可。但是作为一名合格的开发者，弄清它的实现原理是很有必要的。 俗话说得好，一图胜千言，我们先来看下 Android 消息机制简单示意图（参考自网络）吧。 我们把 Thread 比作是一个 发动机，MessageQueue 看作是一条流水线，Message 就像是流水线上的工人，Looper 是流水线下的滚筒，Handler 像是一个工人，它负责把 Message 这个产品送到流水线上，最后又负责把它取走。 这幅图中的各个组件的说明如下： Looper ==》 滚轮 MessageQueue ==》 流水线 Message ==&gt; 流水线上的产品 Handler ==》 扮演把『产品』送进流水线，完了以后又把『产品』取走的角色 Thread ==》 动力 另外还有一个重要概念 ——ThreadLocal 图中没有标明出来。下面对各个部分进行详细介绍。 Android 的消息机制分析从 Handler 出发相信很多做 Android 开发的同学都写过与下面相似的代码。在子线程中做一些耗时操作，比如网络请求，操作完成之后，将返回的数据包装为 Message 对象然后调用 sendMessageXxx 方法，最后在 handleMessage 方法中对结果进行处理。 12345678910111213141516171819202122232425Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 1: //handle break; default: super.handleMessage(msg); &#125; &#125;&#125;;public void do() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //do sth Message message = mHandler.obtainMessage(); message.what = 1; message.obj = result; mHandler.sendMessage(message); &#125; &#125;);&#125; 从 Handler.sendMessage(message) 到 Handler.handlerMessage方法经历了什么样的过程？ 我们先看看 sendMessage 方法内部是怎么实现的。 12345678910111213141516171819202122232425262728293031public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 整个调用流程是这样的 sendMessage ==》 sendMessageDelayed ==》 sendMessageAtTime ==》 enqueueMessage ==》 MessageQueue.enqueueMessage 我们可能还会调用 Handler.post(Runnable)方法到目标线程中执行 run 方法。post 方法会先调用 getPostMessage方法将 Runable 包装为 一个 Message 对象，（Runnable 就存储在 callback 中）。其他的 postXxx(Runnable)方法内部实现也是这样的流程，首先将 Runnable 包装为一个 Message 对象然后调用相应的 sendXxx 方法。 123456789public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123;//将 Runnable 包装为一个 Message 对象 Message m = Message.obtain(); m.callback = r; return m;&#125; 从上述的调用流程可以看出 sendXxx 或者 postXxx 方法最终都会调用 MessageQueue 的 enqueueMessage方法，将 Message 追加到 MessageQueue 中。 小结 Handler 的消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。 post 系列方法最终是通过 send 的一系列方法来实现的。 Handler 的发送消息的过程仅仅是向消息队列插入了一条消息。 MessageQueue 对象是从哪里来的？mQueue 是 Handler 的一个成员变量，它是在哪里初始化的呢？先看看 Handler 的构造方法 123456789101112131415public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; //代码省略 mLooper = Looper.myLooper();//获取当前线程的 Looper if (mLooper == null) &#123; throw new RuntimeException(//抛出异常，不能在没有 Looper 的线程创建 Handler "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//从本线程的 Looper 中获取 MessageQueue mCallback = callback;//回调 mAsynchronous = async;//是否异步&#125; 我们看到 mQueue 是从 Looper 中取出的。在解说 Looper 之前，我们先看看前面提到的 MessageQueue 。 MessageQueue 的工作原理MessageQueue 主要包含两个操作：插入和读取（分别对应 enqueueMessage 和 next 方法）。 顾名思义，enqueueMessage 的作用是往队列中插入一条信息。 next() 的作用是从队列中取出一条信息并将其从消息队列中移除。 虽然 MessageQueue 名为消息队列，但是它的内部实现并不是用队列，而是通过一个单链表的数据结构来维护消息列表。 为什么选择使用单链表结构？ 因为 Message 是可以定时发送的，若使用普通的队列，当插入一个发送时间晚于队首 Message 发送时间的新 Message，那么就需要插队，实现起来不方便，而使用优先队列又显得比较复杂。因此就采用了单链表实现。 接下来我们重点看看 enqueueMessage 方法和 next 方法。 enqueueMessage 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; // 要进入队列的消息对象的目标 handler 不能为空 throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; // 要进入队的消息不能处在使用状态 throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; // 已经调用过 Looper.quit / Looper.quitSafely 方法。 MessageQueue 中不能再追加 Message 对象 IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle();//回收消息 return false;//返回 false 表示入队失败 &#125; // 标记消息为使用状态；设置消息发送的时间；是否需要唤醒 msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //将消息插入到队首 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; //通过该循环找到合适的插入位置（以发送的时间作为排序的标准） for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; //插入队列的指定位置中 msg.next = p; prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 从代码中不难看出，enqueueMessaege 虽然有点长，但是逻辑还是比较清晰的。它先做了一些状态判断以及一些边界检测，完了以后再进行单链表的插入操作。 next 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; //代码省略 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //处理 native 层事件 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123;//如果消息的目标 Handler 为空 do &#123; // 找出队列中下一个异步 Message 对象 prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 计算下一条消息的执行时间，设置一个唤醒的延迟 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 队首 Message 执行的时机到了，获取一条消息 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse();//标记 Message 为正在使用状态 return msg;//返回消息 &#125; &#125; else &#123; // 队列中没有消息了 nextPollTimeoutMillis = -1; &#125; // 既然所有待消息都已经处理好了，那就处理退出消息。 if (mQuitting) &#123; dispose(); //处理底层消息队列。实际上移除了 native 层的消息队列 return null; &#125; if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // 没有可运行的闲置 handler。跳出本次循环再等待。 mBlocked = true; continue; &#125; //代码省略 &#125; &#125; next 方法的主要逻辑如下： 从消息队列中依次取出消息，如果这个消息到了执行时间，那么就将该消息返回给 Looper，并且将消息队列链表的指针后移。 next 方法中有一个死循环，其主要逻辑如下: 如果消息队列中没有消息，那么 next 会一直阻塞在那里。 当队首的消息设置了延迟执行时，会造成短时间的阻塞。 当有新消息到来时，next 方法会返回这条信息并将其从单链表中移除。 当调用了 quit 方法之后，mQuitting 为 true ，next 方法会移除 native 层的消息队列并返回 null。 我们是不是该说下 Looper 了，下下个就到它了，在此之前需要先看看 ThreadLocal 相关知识。 ThreadLocal 简介ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。 使用场景： 当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑采用 ThrradLocal。 在 Android 中，Looper 类就是利用了 ThreadLocal 的特性，保证每个线程只存在一个 Looper 对象。 复杂逻辑下的对象传递。 比如监听器的传递。 从 ThreadLocal 的 set 和 get 方法 可以看出，它们所操作的对象都是当前线程的 localValues 对象的 table 数组，因此在不同的线程中访问同一个 ThreadLocal 的 get 和 set 方法，他们对 ThreadLocal 所做的读/写操作仅限于各自线程的内部。 关于 ThreadLocal 的具体介绍请见 理解 ThreadLocal 理解 ThreadLocal 对后面理解 Looper 有很大的帮助，建议先细看 ThreadLocal 的内容再看后面的内容。 Looper 的工作原理Android 的官方文档中是这么介绍 Looper 的： Looper 是一个用来为单个线程运行消息循环的类。默认情况下线程是没有一个 Looper 跟他们相关联的。如果一个线程需要 looper 的话，可以通过先调用 prepare() 方法初始化一个本线程的 Looper 实例。然后调用 loop 方法让它开始处理信息，一直到循环结束。 我们通常通过 Handler 类与 Looper 的打交道。 一个 线程最多只能有一个 Looper，一个 Looper 中有一个消息队列（前面 Hanlder 中的 MessageQueue 对象就是从 Looper 中取出的），并且持有它所在线程的引用。Looper 就像一个「死循环」（通过 quit 或者 quitSafely 方法可以退出），它会不断地从 MessageQueue 中查看是否有新消息。如果有，就调用 handler.dispatchMessage 方法进行处理；如果没有，就一直阻塞在那里。 创建 Looper我们先看看 Looper 的构造方法： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//创建一个消息队列 mThread = Thread.currentThread(); //把当前线程的对象保存起来&#125; Looper 构造方法中创建了一个消息队列，并且会保存当前线程对象。 创建普通线程上的 LooperLooper 的构造方法是私有的，那么要创建一个 Looper。？调用 Looper.prepare()即可为当前线程创建一个 Looper 对象，接着通过 Looper.loop() 方法开启消息循环。要注意的是：在子线程中，如果手动为其创建了 Looper，那么在所有的任务完成之后，需要调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待状态。 我们看下 prepare 方法实现 1234567891011121314public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread");//一个线程最多只能有一个 Looper &#125; sThreadLocal.set(new Looper(quitAllowed));//为当前线程创建一个 Looper &#125;public static @Nullable Looper myLooper() &#123;//获取当前线程的 Looper 对象 return sThreadLocal.get();&#125; 创建主线程上的 Looper有一个要注意的地方就是 Looper 的另一个创建方法 —— prepareMainLooper。 prepareMainLooper 在应用的入口方法（ActivityThread.main() ）中被调用，用来启动主线程的消息循环。 123456789101112131415public static void main(String[] args) &#123; //代码省略 Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper();//创建主线程的 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler();//创建主线程的 Handler &#125; //代码省略 Looper.loop();//开启主线程消息循环&#125; 123456789101112131415public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125;public static Looper getMainLooper() &#123;//该方法使得在任何地方都可以获得主线程的消息循环 synchronized (Looper.class) &#123; return sMainLooper; &#125;&#125; 小结在应用启动时会开启一个主线程（UI 线程），并且开启消息循环，应用不断地从该消息队列中取出、处理消息达到程序运行的结果。 loop 方法前面所讲都是 Looper 自身的一些特性，没有提到它是怎么跟其他部分交互的。Looper 与其他 MessageQueue 、Hanlder 的交互主要在 loop 方法中。下面我们来看看 loop 方法的源码。 12345678910111213141516171819202122232425262728293031323334public static void loop() &#123; final Looper me = myLooper();//获取本线程的 Looper if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");//调用 loop 方法之前必须先调用 Looper.prepare() 方法创建 Looper &#125; final MessageQueue queue = me.mQueue;//获取所在线程的消息队列 // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // 阻塞方法，如果没有获取到消息，就一直阻塞在这里 if (msg == null) &#123; //只有当 msg == null 时才会退出循环 return; &#125; // 代码省略 try &#123; msg.target.dispatchMessage(msg);// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。 &#125; finally &#123; // 代码省略 &#125; // 代码省略 // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); // 代码省略 msg.recycleUnchecked();//调用 Message 的回收方法 &#125;&#125; 由源码可见 loop 方法是一个死循环，唯一跳出循环的方式是 MessageQueue 的 next 方法返回了 null。 当我们调用 Looper 的 quit 方法时，Looper 会调用 MessageQueue 的 quit 或 quitSafely 方法来通知消息队列退出，否则 loop 方法会一直循环下去。 另外，代码中可以看到，loop 调用了 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 方法会一直阻塞在那里，这也导致了 loop 方法一直阻塞在那里。 msg.target.dispatchMessage(msg);// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。 绕了这么一个大圈意义何在？通常我们都会在子线程中调用 Handler.sendMessageXxx 或者 Handler.postXxx 方法， 而Handler 的 dispatchMessage 方法是在创建 Handler 的那个线程中执行的，这样就顺利地将代码切换到目标线程中去执行了。 退出 LooperLooper 也是可以退出的（这里的退出 Looper 主要是指跳出 loop 方法中的死循环）。通过调用 Looper 的 quit 方法或者 quitSafely 方法即可。那么这二者有什么区别？ 调用 Looper 的 quit 方法可以直接退出Looper。 调用 Looper 的 quitSafely 方法只是设定了一个退出标记，然后把消息队列中已有的消息处理完才退出 Looper。 我们来看看这两个方法的实现 12345678//Looper.quitpublic void quit() &#123; mQueue.quit(false);&#125;//Looper.quitSafelypublic void quitSafely() &#123; mQueue.quit(true);&#125; mQueue 的实际类型为 MessageQueue，Looper 的两个 quit 方法都是通过调用 MessageQueue 的 quit 方法来实现的。 1234567891011121314151617181920void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit.");//主线程的 Looper 无法退出。主线程的 Looper 是通过 prepareMainLooper 方法创建的，创建时调用了 prepare（false），也就是令 mQuitAllowed = false &#125; synchronized (this) &#123; if (mQuitting) &#123;//是否正在退出 return; &#125; mQuitting = true; if (safe) &#123; //安全退出,不会取消执行时机早于或等于当前时间的 Message removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked();//移除 MessageQueue 中所有的消息 &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; MessageQueue.next() 方法片段。当调用了 quit 方法之后会使得 mQuitting 为 true，从而导致 next 方法返回 null，一旦 next 方法返回 null， Looper.loop 就跳出了死循环。 1234if (mQuitting) &#123; dispose();//消息 native 层的消息队列。 return null;&#125; MessageQueue.enqueueMessage 方法片段 1234567if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false;&#125; 从这里实现可以看到，调用了 Looper.quit / quitSafely 方法之后，再通过 Handler 发送的消息无法添加到 MessageQueue 中，此时 Handler 的 send 方法会返回 false。 回到 Handler Looper 的 loop 方法中有这样一行代码 msg.target.dispatchMessage(msg);该方法调用的就是 Handler.dispatchMessage 方法。dispatchMessage 方法会根据情况对 Message 进行分发。 12345678910111213141516171819202122/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg);//回调执行 Runnable 的 run 方法 &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123;//执行创建 Handler 时指定的 Callback.handleMessage 方法 return; &#125; &#125; handleMessage(msg);//执行 handleMessage(msg) 方法 &#125;&#125;public interface Callback &#123;// Callback 接口 public boolean handleMessage(Message msg);&#125;public void handleMessage(Message msg) &#123;//空实现，需要由子类覆写&#125; 123private static void handleCallback(Message message) &#123; message.callback.run(); // callback 的实际类型为 Runnable，这行代码的作用就是回调 Runnable 的 run 方法&#125; Handler 的工作主要包含消息的发送和接收过程（还有一个「分发过程」）。 消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。 post 系列方法最终是通过 send 的一系列方法来实现的。 查看源码不难发现，Handler 的发送消息的过程仅仅是向 MessageQueue 插入了一条 Message，MessageQueue 的 next 方法就会返回此 Message 给 Looper， Looper 在 loop 方法中对 Message 进行处理，最终由 Looper 交回给 Handler 处理（调用 Handler 的 dispatchMessage 方法）。 总结Looper 对象封装了消息队列，Looper 对象被封装在 ThreadLocal 中，是线程私有的，不同线程之间的 Looper 无法共享。Handler 通过与 Looper 之间的绑定来实现与执行线程之间的绑定，handler 发送消息时会将 Message 对象追加到与线程相关的消息队列中，然后由 Looper 回调它的分发消息方法，根据情况处理消息。 最后我们看一张完整的流程图（图片参考自Handler 异步通信机制全面解析），笔者修改了原图中的 Handler dispatchMessage 方法描述。 参考资料与学习资源推荐 理解 Java 中的 ThreadLocal 谈谈 ThreadLocal Android 中 Handler 的使用 Handler 异步通信机制全面解析 深入源码解析 Android 中的 Handler,Message,MessageQueue,Looper 《Android 开发艺术探索》 《Android 源码设计模式解析与实战》 如果本文中有不正确的结论、说法或者表述不清晰的地方，恳请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
