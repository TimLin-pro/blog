<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JVM 运行时数据区域与对象创建布局]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/07/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h2 id="java-运行时数据区域"><a href="#java-运行时数据区域" class="headerlink" title="java 运行时数据区域"></a>java 运行时数据区域</h2><p>根据《Java 虚拟机规范》规定，Java 虚拟机锁管理的内存包含以下以下几个运行时数据区域，如下图所示：<br><img src="https://user-images.githubusercontent.com/16668676/30062052-64dd918e-927c-11e7-9ec8-a82e507dc3ce.png" alt="java runtime memory"></p>
<a id="more"></a>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是<strong>线程私有的</strong>，各线程独立存储，以便线程切换后能恢复到正确的执行位置。可以看作是<strong>当前线程</strong>所执行的<strong>字节码的行号指示器</strong>。</p>
<ul>
<li>如果正在执行的是一个 Java 方法，该计数器记录的是正在执行的虚拟机字节码指令的地址。</li>
<li>如果正在执行的是一个 Native 方法，则该计数器值为空。</li>
</ul>
<p>==此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域==</p>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈是==线程私有的==。生命周期与线程相同。</p>
<p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）。每一个方法从调用到执行都对应着一个栈帧在虚拟机栈中入栈和出栈的过程。</p>
<p>注：栈帧（Stack Frame ）是方法运行时基础数据结构，其中存储了局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>平时所讲的栈内存，就是现在讲的 Java 虚拟机栈，或者说是<strong>虚拟机栈中局部变量表部分</strong>。</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 SOF（Stack Over Flow） 异常</li>
<li>如果扩展时，无法申请到足够的内存，就会抛 OOMError 异常</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>发挥的作用与虚拟机栈相似。只不过一个是针对 Java 方法，一个是针对本地方法。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>对于大多数应用而言，Java 堆是 Java 虚拟机所管理的内存中最大的一块。同时它也是==所有线程共享==的一块内存区域。Java 虚拟机规定，Java 堆<strong>可以是物理上不连续的</strong>内存空间，只要逻辑上连续即可。</p>
<p>按照虚拟机规范中的描述，<strong>所有对象实例以及数组都要在堆上分配</strong>。不过随着 JIT 编译器的发展和逃逸分析技术的逐渐成熟，未来或许会有所改变。</p>
<p>从内存分配角度来看，线程共享的 Java 堆中可能会划分出多个<strong>线程私有的分配缓冲区</strong>（Thread Local Allocation Buffer，TLAB）。<strong>不管怎么划分，其中存储的都是对象</strong>，进行划分的目的只是为了更好地回收/分配内存。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区有一个别名：non-heap，与 Java 堆区分开来。它是==所有线程共享==的，用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。</p>
<p>Hotspot 虚拟机设计团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区。因为这样就不用专门为方法区编写内存管理的代码的工作。对于其他虚拟机而言是不存在永久代这个概念的。</p>
<p>使用永久代来实现方法区的<strong>好处</strong>在于可以直接像管理 Java 堆那样管理这部分内存，而不需要再专门为方法区编写内存管理代码。<strong>坏处</strong>在于这样<strong>更容易导致 OOM</strong>，因为永久代有 <code>-XX：MaxPermSize</code> 的上限。在 JDK 1.8  HotSpot 虚拟机的实现中已经将整个永久代移除，取而代之的是一个叫元空间（Metaspace）的区域。</p>
<p>当方法区无法满足内存分配需求时，将抛出 <code>java.lang.OutOfMemoryError: PermGen space</code> 。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是<strong>常量池</strong>，用于存放<strong>编译期生成的</strong>各种<strong>字面量和符号引用</strong>。JDK 1.8 前运行时常量池是方法区的一部分。</p>
<p>虚拟机规范中对 Class 文件中的每一个部分的<strong>格式</strong>都有严格规定。但是<strong>对于运行时常量池，并没有做任何细节的要求</strong>。一般而言，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的的另一特征在于<strong>具备动态性</strong>。java <strong>运行期间也可以把新的常量放入池中</strong>。比如使用 String.intern() 将堆中的字符串加入常量池中。</p>
<p>JDK1.7 中把原本放在永久代的字符串常量池移到 Java 堆中。<strong>常量池位置的不同影响到了 String 的 intern()方法的表现</strong>。不同版本的 JDK  使用「==」去比较 String 字符串的结果会有不同。具体情况可参考这篇文章——<a href="http://blog.csdn.net/seu_calvin/article/details/52291082" target="_blank" rel="external">Java 技术——你真的了解 String 类的 intern()方法吗</a></p>
<h3 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a>Metaspace（元空间）</h3><p>介绍元空间之前先说点题外话。其实，移除永久代的工作从 JDK1.7 就开始了。JDK1.7 中，存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。譬如符号引用(Symbols)转移到了 native heap、字面量(interned strings)转移到了 java heap、类的静态变量(class statics)转移到了 java heap。但 JDK1.7 并没有完全移除将永久代完全移除。直到 JDK1.8 才将永久代完整地移除。</p>
<p>元空间的本质和永久代类似，<strong>都是对 JVM 规范中方法区的实现</strong>。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是<strong>使用本地内存</strong>。因此，<strong>默认情况下，元空间的大小仅受本地内存限制</strong>，但可以通过以下参数来指定元空间的大小：</p>
<ul>
<li><code>-XX:MetaspaceSize</code>，<strong>初始空间大小</strong>，<strong>达到该值就会触发垃圾收集进行类型卸载</strong>，同时 <strong>GC 会对该值进行调整</strong>：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 MaxMetaspaceSize 时，适当提高该值。</li>
<li><code>-XX:MaxMetaspaceSize</code>，<strong>最大空间</strong>，默认是没有限制的。</li>
</ul>
<p>如果本地空间的内存用尽了会收到<code>java.lang.OutOfMemoryError: Metadata space</code> 的错误信息。<br>JDK1.8 中持久代相关的 JVM 参数 <code>-XX:PermSize</code> 及 <code>-XX:MaxPermSize</code> 将会被忽略掉。</p>
<h4 id="为什么移除持久代？"><a href="#为什么移除持久代？" class="headerlink" title="为什么移除持久代？"></a>为什么移除持久代？</h4><ul>
<li>它的大小只能在启动时指定，运行时无法修改——很难进行调优。-XX:MaxPermSize，设置成多少好呢？</li>
<li>HotSpot 的内部类型也是 Java 对象：它可能会在 Full GC 中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。</li>
<li>简化 Full GC：每一个回收器有专门的元数据迭代器。</li>
<li>可以在 GC 不进行暂停的情况下并发地释放类数据。</li>
<li>使得原来受限于持久代的一些改进未来有可能实现</li>
</ul>
<h4 id="元空间的内存分配模型"><a href="#元空间的内存分配模型" class="headerlink" title="元空间的内存分配模型"></a>元空间的内存分配模型</h4><ul>
<li>绝大多数的类元数据的空间都从本地内存中分配</li>
<li>用来描述类元数据的类（klasses)也被删除了</li>
<li>分元数据分配了多个虚拟内存空间</li>
<li>给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些</li>
<li>归还内存块，释放内存块列表</li>
<li>一旦元空间的数据被清空了，虚拟内存的空间会被回收掉</li>
<li>减少碎片的策略</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并<strong>不是虚拟机运行时数据区的一部分</strong>，也不是虚拟机规范中定义的内存区域。</p>
<p>JDK 1.4 新添加的 NIO（New Input/Output） 可以使用 Native 函数库直接分配堆外存，然后通过一个存储在 Java 堆中的 DireByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场合能够显著提高性能。</p>
<p>本机直接内存<strong>不受 Java 堆大小的限制</strong>，但是受到本机总内存的大小以及处理器寻址空间的限制。</p>
<h2 id="HotSpot-虚拟机中对象创建、初始化与布局"><a href="#HotSpot-虚拟机中对象创建、初始化与布局" class="headerlink" title="HotSpot 虚拟机中对象创建、初始化与布局"></a>HotSpot 虚拟机中对象创建、初始化与布局</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="类加载检查、判断"><a href="#类加载检查、判断" class="headerlink" title="类加载检查、判断"></a>类加载检查、判断</h4><p>遇到一条 new 指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载。</p>
<h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>类加载检查通过后，将<strong>为新生对象分配内存</strong>。也就是划分出一块内存区域。</p>
<ul>
<li>如果 java 堆中的内存是绝对规整的，那么会使用<strong>指针碰撞</strong>的分配方式</li>
<li>如果 java 堆中的内存不规整的，虚拟机必须维护一个列表，记录哪些内存块可用，在分配时从列表中，找到一块足够大的空间划分给对象。即，使用<strong>空闲列表</strong>的分配方式。</li>
</ul>
<p>选择哪种分配方式由 java 堆是否规整决定，而 <strong>Java 堆是否规整</strong>又由所采用的<strong>垃圾收集器</strong>是否带有<strong>压缩整理功能</strong>决定。</p>
<ul>
<li>在使用 Serial、ParNew 等<strong>带 Compact 过程</strong>的收集器时，系统采用的分配算法是<strong>指针碰撞</strong></li>
<li>而使用 CMS 这种<strong>基于 Mark-Sweep 算法</strong>的收集器时，通常采用<strong>空闲列表</strong>。</li>
</ul>
<p><strong>线程安全问题</strong>：<br>另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有<strong>两种方案</strong>：</p>
<ul>
<li>一种是<strong>对分配内存空间的动作进行同步处理</strong>——实际上虚拟机采用 <strong>CAS 配上失败重试的方式</strong>保证更新操作的原子性；</li>
<li>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即<strong>每个线程在 Java 堆中预先分配一小块内存</strong>，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer,TLAB）。<ul>
<li>哪个线程要分配内存，就在哪个线程的 TLAB 上分配，<strong>只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定</strong>。<ul>
<li>虚拟机是否使用 TLAB，可以通过<code>-XX：+/-UseTLAB</code> 参数来设定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>此处的初始化指的是将分配到的内存空间初始化为<strong>零值</strong>。（不包括对象头）。如果使用 TLAB，该过程也可以提前至 TLAB 分配时进行。初始化为零值的操作保证了对象的<strong>实例字段</strong>在 Java 代码中可不赋初值就使用。</p>
<p>对象头的设置：</p>
<ul>
<li>对象是哪个类的实例</li>
<li>如何才能找到类的元数据信息</li>
<li>对象的哈希码</li>
<li>对象的 GC 分代年龄等信息。</li>
<li>…</li>
</ul>
<p>从虚拟机的视角来看，一个新的对象已经创建完毕。  </p>
<ul>
<li>但从 Java 程序视角来看，对象的创建才刚刚开始——<init> 方法还没有执行、所有字段都还为零.<ul>
<li>一般来说（由字节码中是否跟随 invokespecial 指令所决定），执行 <strong>new 指令</strong>之后会接着执行 <strong><init> 方法</init></strong>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ul>
</init></li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot 中，对象在内存中存储的布局可以<strong>分为 3 块区域</strong>：</p>
<ul>
<li>对象头 Header</li>
<li>实例数据 Instance Data</li>
<li>对齐填充 Padding (并不是必然存在)</li>
</ul>
<h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1. 对象头"></a>1. 对象头</h4><p><strong>对象头包括两部分信息</strong>：第一部分为存储对象自身得运行时数据，第二部分为类型指针。</p>
<ol>
<li><strong>存储对象自身的运行时数据</strong>。如：<ul>
<li>哈希码（HashCode）</li>
<li>GC 分代年龄、</li>
<li>锁状态标志、</li>
<li>线程持有的锁、</li>
<li>偏向线程 ID、</li>
<li>偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit，官方称它为「<strong>Mark Word</strong>」。</li>
<li>对象头信息是<strong>与对象自身定义的数据无关的额外存储成本</strong>，考虑到虚拟机的空间效率，Mark Word 被设计成一个<strong>非固定的数据结构以便在极小的空间内存储尽量多的信息</strong>，它会根据对象的状态复用自己的存储空间。</li>
</ul>
</li>
<li><strong>类型指针</strong>，即对象指向它的<strong>类元数据的指针</strong>，虚拟机通过该指针来确定这个对象是哪个类的实例。<ul>
<li>如果对象是一个数组，那么对象头中还需要有一块用于记录数据长度的数据<ul>
<li>因为从数据的元数据无法确定数组的大小</li>
</ul>
</li>
<li>注意：并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，<strong>查找对象的元数据信息并不一定要经过对象本身</strong><ul>
<li>比如：通过句柄访问对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-实例数据"><a href="#2-实例数据" class="headerlink" title="2. 实例数据"></a>2. 实例数据</h4><p>接下来的<strong>实例数据部分</strong>是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
<ul>
<li>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>这部分的<strong>存储顺序</strong>会<strong>受到虚拟机分配策略参数</strong>（FieldsAllocationStyle）和<strong>字段在 Java 源码中定义顺序的影响</strong>。<ul>
<li>HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），<ul>
<li>可以看出，<strong>相同宽度的字段总是被分配到一起</strong>。</li>
<li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</li>
<li>如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-对齐填充"><a href="#3-对齐填充" class="headerlink" title="3. 对齐填充"></a>3. 对齐填充</h4><p><strong>对齐填充</strong>并不是必然存在的，也没有特别的含义，它仅仅<strong>起着占位符的作用</strong>。</p>
<p>由于 HotSpot VM 的自动内存管理系统<strong>要求对象起始地址必须是 8 字节的整数倍</strong>，换句话说，就是<strong>对象的大小必须是 8 字节的整数倍</strong>。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>由于 reference 类型在 Java 虚拟机规范中<strong>只规定了一个指向对象的引用</strong>，并<strong>没有定义这个引用应该通过何种方式去定位</strong>、访问堆中的对象的具体位置，所以<strong>对象访问方式也是取决于虚拟机实现而定的</strong>。</p>
<p>主流的访问方式有两种：1. 使用句柄，2. 使用直接指针</p>
<h4 id="使用句柄访问："><a href="#使用句柄访问：" class="headerlink" title="使用句柄访问："></a>使用句柄访问：</h4><ul>
<li>Java 堆中将会划分出来一块内存作为句柄池，reference 中就是存储了<strong>对象的句柄地址</strong>，而句柄中包含了对象<strong>实例数据</strong>和<strong>类型数据</strong>各自的<strong>具体地址</strong>信息。<br><img src="https://user-images.githubusercontent.com/16668676/30117448-d342779e-9352-11e7-8d1e-5d4c44308d8f.png" alt="visit obj with handle"></li>
</ul>
<h4 id="直接指针访问："><a href="#直接指针访问：" class="headerlink" title="直接指针访问："></a>直接指针访问：</h4><ul>
<li>采用这种方式，那么 Java 堆<strong>对象的布局中就必须考虑如何放置访问类型数据的相关信息</strong>，reference 中存储的直接就是对象地址，而<strong>对象中包含</strong>了对象<strong>类型数据的地址信息</strong>。<br><img src="https://user-images.githubusercontent.com/16668676/30117447-d31537ac-9352-11e7-980c-d56f667070e4.png" alt="visit obj with pointer"></li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>使用<strong>句柄</strong>访问优点：是 <strong>reference 中存储的是稳定的句柄地址</strong>，在<strong>对象被移动时</strong>，只会改变句柄中的实例数据指针，而 <strong>reference 本身不需要被修改</strong>。</li>
<li>使用<strong>直接指针</strong>的最大好处就是<strong>速度更快</strong>，节省了一次指针定位需要的时间开销，由于 Java 对象访问十分频繁，这类开销积小成多后也是一项非常可观的执行成本。<ul>
<li>Sun HotSpot 虚拟机使用的就是这种访问方式。</li>
</ul>
</li>
</ul>
<h2 id="OutOfMemoryError-异常简析"><a href="#OutOfMemoryError-异常简析" class="headerlink" title="OutOfMemoryError 异常简析"></a>OutOfMemoryError 异常简析</h2><h3 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h3><p>不断创建对象，并且保证 GC Roots 到对象之间有可达路径来<strong>避免垃圾回收机制清除这些对象</strong>。在对象总内存达到 <code>-XmX:heapSize</code>指定的值之后就会 OOM。</p>
<p>一般出现这种情况都是通过 MAT 工具来分析。确定是出现了内存泄漏，还是的最大堆空间的设置不合理。</p>
<ul>
<li>如果是内存泄漏，可进一步通过工具来查看对象到   GC Roots 的引用链，找出内存泄漏的原因</li>
<li>如果不存在内存泄漏，即对象确实必须存活着，那就要检查虚拟机的堆参数（-Xmx 与 -Xms）与机器物理内存比较看是否还可以调大；同时也可以通过检查代码中是否存在一些对象的生命周期过长、持有状态时间过长的情况，尝试·减少程序运行期的内存消耗。</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈。栈容量只由 <code>-Xss</code> 参数设定。</p>
<p>关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
</ul>
<p>导致 SOF 的常见原因有递归、定义大量的局部变量等。</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>可以通过在运行时产生大量的<strong>类</strong>去填满方法区。</p>
<p>由于 JDK1.7 把字符串常量池从方法区移到堆中，在不同的版本的 JDK中<code>String.intern()</code>方法的表现不一。</p>
<ul>
<li>JDK1.6 中调用 <code>String.intern()</code> 方法时，会把<strong>首次遇到的字符串复制到永久代中</strong>。</li>
<li>JDK1.7 中调用 <code>String.intern()</code>方法时，不会再复制实例，只是在常量池中<strong>记录首次出现的实例引用</strong></li>
</ul>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>可以通过 <code>-XX:MaxDirectMemorySize</code> 指定，如果不指定，默认与 Java 堆最大值（<code>-Xmx</code>指定）一样</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">Java8 内存模型—永久代(PermGen)和元空间(Metaspace)</a></li>
<li><a href="http://it.deepinmind.com/gc/2014/05/14/metaspace-in-java-8.html" target="_blank" rel="external">Java 8 的元空间</a></li>
<li>Java 8 的元空间<a href="http://java-latte.blogspot.sg/2014/03/metaspace-in-java-8.html" target="_blank" rel="external">英文原文</a></li>
<li><a href="http://caoyaojun1988-163-com.iteye.com/blog/1969853" target="_blank" rel="external">JAVA 8 ：从永久区（PermGen）到元空间（Metaspace）</a></li>
<li><a href="http://liuwangshu.cn/java/jvm/1-runtime-data-area.html" target="_blank" rel="external">Java虚拟机（一）结构原理与运行时数据区域</a></li>
<li>《深入理解 Java 虚拟机(第 2 版)》</li>
</ul>
<p>若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 集合框架之 ArrayList]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/06/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BArrayList/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>ArrayList 是一个动态数组，它是线程不安全的，允许元素为 null。它的底层数据结构是数组，ArrayList 实现了 <code>List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code> 接口，其中 RandomAccess 代表了其拥有随机快速访问的能力，<code>ArrayList</code> 可以以 O(1) 的时间复杂度去根据下标访问元素。</p>
<h3 id="时间、空间效率"><a href="#时间、空间效率" class="headerlink" title="时间、空间效率"></a>时间、空间效率</h3><p>因为数组内存的连续，可以根据下标以 O1 的时间改查元素，因此<strong>时间效率很高</strong></p>
<p>同样也因为数组要占据一块连续的内存空间，所以它也有数组的缺点——<strong>空间效率不高</strong>。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当集合中的元素超出容量时，会进行<strong>扩容操作</strong>，扩容操作是一个性能消耗较大的地方，所以如果能预知数据的规模，最好在初始化时通过 <code>public ArrayList(int initialCapacity)</code> 构造方法指定 ArrayList 的大小，来构造 ArrayList 实例，以<strong>减少扩容次数，提高效率</strong>。</p>
<p>在添加大量元素前，应用程序也可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量，这可以减少递增式再分配的数量。 不过该方法是 ArrayList 中添加的，List 中没有该方法。所以如果声明的类型为 List 的话，需要进行强转。<code>((ArrayList)list).ensureCapacity(number);</code></p>
<p>当每次修改结构时(添加或者删除元素)，都会修改 modCount。</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//空对象数据，用于空对象，如果指定初始容量为 0 就给元素附一个空对象</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Shared empty array instance used for default sized empty instances. We</div><div class="line"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line"> * first element is added.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//共享的空数组对象，使用该对象用以区分 EMPTY_ELEMENTDATA，从而知道第一次添加元素时，应该初始化的数组长度。</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 之所以不声明为 private 是为了简化内部类访问，</span></div><div class="line"><span class="comment">// 所有原本为默认容量的空数组，在第一次添加元素的时候都会被初始化为长度为默认容量的数组</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//包含元素的数量</span></div></pre></td></tr></table></figure>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ArrayList 提供了三种方式的构造器，可以构造一个默认初始容量为 10 的空列表、构造一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//按照指定的初始容量初始化</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//创建数组</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//如果指定初始容量为 0 就给元素附一个空对象</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> +</div><div class="line">                initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化一个初始容量为 10 的 ArrayList</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//从给定的容器中构建一个 ArrayList</span></div><div class="line">    elementData = c.toArray();<span class="comment">//将容器对象中的元素转换为数组</span></div><div class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;<span class="comment">//长度不为 0，进行判断操作</span></div><div class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);<span class="comment">//如果返回的数组不是 Object[].class 类型的，则进行将数组元素复制到类型为 Object 数组上</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// replace with empty array.</span></div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//长度为 0，则将空数组对象赋值给元素数组</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要注意的是第三个构造方法中对数组元素类型的判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (elementData.getClass() != Object[].class)&#123;</div><div class="line">    elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125; <span class="keyword">else</span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 虽然表面上看起来，c.toArray() 会返回一个  Object[]  对象数组，但是它指向的实际类型并不一定是 Object[]，这样当我们调用 objList[i] =  new Object(); 就会报错   。 比如说如果我们有 1 个 List<string> stringList 对象，当我们调用<code>Object[] objectArray = stringList.toArray()</code>的时候，  objectArray 只能存放 String 类型的数据而不能存储其他类型的对象。</string></p>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p> ArrayList 提供了 add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加元素到列表尾部。</div><div class="line"> * 先确认 ArrayList 的容量</div><div class="line"> * 每次 add 之前，都会判断 add 后的容量，是否需要扩容。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!! 确保容量足以容纳原有元素加上新增的元素</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加元素到列表指定位置。需要将该位置右端的所有元素都往右移动一个单位</div><div class="line"> * 先确认 ArrayList 的容量</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);<span class="comment">//上下界判断</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!! 判断 add 之后的容量，根据情况进行扩容</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,<span class="comment">// 将 index ~ size-1 范围内的元素复制到 index+1 ~ size 范围中。也就是将 index 及其以后的元素后移一个位置</span></div><div class="line">            size - index);</div><div class="line">    elementData[index] = element;<span class="comment">//将给定元素添加到指定元素中</span></div><div class="line">    size++;<span class="comment">//元素数量 + 1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加给定集合中的所有元素到 ArrayList 中</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = c.toArray();<span class="comment">//先转换为数组</span></div><div class="line">    <span class="keyword">int</span> numNew = a.length;<span class="comment">//要添加的元素数量</span></div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount，确保容量足够容纳新添加的所有元素</span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);<span class="comment">//将元素添加到列表尾部</span></div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。  </div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);<span class="comment">//检查上下界</span></div><div class="line"></div><div class="line">    Object[] a = c.toArray();<span class="comment">//转换为数组</span></div><div class="line">    <span class="keyword">int</span> numNew = a.length;<span class="comment">//增加的数量</span></div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index;<span class="comment">//要移动的元素数</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                numMoved);<span class="comment">//移动数组中需要移动的元素</span></div><div class="line"></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);<span class="comment">//插入元素</span></div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>ArrayList 提供了<strong>根据下标</strong>或者<strong>指定对象</strong>两种方式的删除功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除指定位置的元素</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);<span class="comment">//上界判断</span></div><div class="line"></div><div class="line">    modCount++;<span class="comment">//结构修改次数 + 1</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//移动的元素总数</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,<span class="comment">//</span></div><div class="line">                numMoved);<span class="comment">//将要删除的元素的后面的所有元素往前移一个单位</span></div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work 将末元素置为 null，以免内存泄漏</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;<span class="comment">//返回删除掉的值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除此列表中首次出现的指定元素（如果存在的话）。</div><div class="line"> * 先找到指定元素在数组中的位置，然后再调用 fastRemove 删除</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 由于 ArrayList 中允许存放 null，因此下面通过两种情况来分别处理。  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  删除 [fromIndex，toIndex) 范围中的所有元素 </div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</div><div class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</div><div class="line">            numMoved);</div><div class="line"></div><div class="line">    <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="keyword">int</span> newSize = size - (toIndex - fromIndex);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</div><div class="line">        elementData[i] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    size = newSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除 ArrayList 中给定指定集合中的所有元素。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(c);</div><div class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 批量删除</div><div class="line"> * complement 为 false 时，删除指定集合 c 中所有的元素。</div><div class="line"> * complement 为 true 时，删除指定集合 c 中以外的所有的元素。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;<span class="comment">// complement 为 true 时为补集</span></div><div class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;<span class="comment">//将数组引用赋给 elementdata,节省空间</span></div><div class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//遍历，把要保存的元素存在前面</span></div><div class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</div><div class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)<span class="comment">//存储要保留的元素。集合 c 中是否包括该元素 == 删除补集？</span></div><div class="line">                elementData[w++] = elementData[r];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></div><div class="line">        <span class="comment">// even if c.contains() throws.</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (r != size) &#123;<span class="comment">// 此段代码作用为：当 c.contains 抛出异常时（此时 r &lt; size ），保持与 AbstractCollection 的行为兼容性</span></div><div class="line">            System.arraycopy(elementData, r,</div><div class="line">                    elementData, w,</div><div class="line">                    size - r);<span class="comment">//将后面的元素移动到 w 后面</span></div><div class="line">            w += size - r;<span class="comment">//加上移动的元素数，获取「最后的元素」的下标</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (w != size) &#123;<span class="comment">//清除引用，防止内存泄漏</span></div><div class="line">            <span class="comment">// clear to let GC do its work</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)<span class="comment">//将 w 之后的元素都置为 null</span></div><div class="line">                elementData[i] = <span class="keyword">null</span>;</div><div class="line">            modCount += size - w;</div><div class="line">            size = w;</div><div class="line">            modified = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> modified;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h3><p>注意：从数组中移除元素的操作，也会<strong>导致被移除的元素以后的所有元素的向左移动一个位置</strong>。</p>
<h2 id="查-获取"><a href="#查-获取" class="headerlink" title="查/获取"></a>查/获取</h2><p> 获取此列表中指定位置上的元素。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    checkForComodification();</div><div class="line">    <span class="keyword">return</span> java.util.ArrayList.<span class="keyword">this</span>.elementData(offset + index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结、对比"><a href="#小结、对比" class="headerlink" title="小结、对比"></a>小结、对比</h3><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    checkForComodification();</div><div class="line">    E oldValue = java.util.ArrayList.<span class="keyword">this</span>.elementData(offset + index);</div><div class="line">    java.util.ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h2 id="调整数组容量"><a href="#调整数组容量" class="headerlink" title="调整数组容量"></a>调整数组容量</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">            <span class="comment">// any size if not default element table</span></div><div class="line">            ? <span class="number">0</span></div><div class="line">            <span class="comment">// larger than default for default empty table. It's already</span></div><div class="line">            <span class="comment">// supposed to be at default size.</span></div><div class="line">            : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 内部保证容量，如果 ArrayList 是通过无参构造函数创建的，</div><div class="line"> * 那么第一次 add 元素的时候就会调用该方法扩容</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 确保分配指定的容量</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">//如果指明的最小容量超过数组的长度，就增大容量</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次数组容量的增长大约是其原容量的 1.5 倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造 ArrayList 实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用 ensureCapacity 方法来手动增加 ArrayList 实例的容量。</p>
<h3 id="「压缩」"><a href="#「压缩」" class="headerlink" title="「压缩」"></a>「压缩」</h3><p>   ArrayList 还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过 trimToSize 方法来实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将 ArrayList 的容量压缩到当前元素数量，这样可以最大限度节省空间</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;<span class="comment">//定义与父类 AbstractList 中，记录发生结构化修改的次数。如果不打算提供「快速失败的迭代器」，可忽略此域</span></div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">        elementData = (size == <span class="number">0</span>)</div><div class="line">                ? EMPTY_ELEMENTDATA</div><div class="line">                : Arrays.copyOf(elementData, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h2><p>ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考我之前的文章<a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="external">深入 Java 集合学习系列：HashMap 的实现原理</a> 中的 Fail-Fast 机制。</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。   <ul>
<li>在 java.util 包下的都是快速失败。</li>
</ul>
</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。<ul>
<li>在 java.util.concurrent 包下的全是安全失败的。</li>
</ul>
</li>
</ul>
<p>即 抛异常是快速失败（util 包下都是快速失败），不抛异常是安全失败。 Java 版本越往后越「安全」，concurrent 包下面全部为<strong>安全失败</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到核心操作在于增加和删除元素。</p>
<ol>
<li>增删改查中， 增导致<strong>扩容</strong>，则<strong>会修改 modCount</strong>，<strong>删一定会修改</strong>。 <strong>改和查一定不会修改 modCount</strong>。</li>
<li>扩容操作会导致数组复制，<strong>批量删除会导致找出两个集合的交集，以及数组复制操作</strong>，因此，增、删都相对低效。 而 改、查都是很高效的操作。</li>
<li>因此，结合特点，在使用中，以 Android 中最常用的展示列表为例，列表滑动时需要展示每一个 Item（element）的数组，<strong>所以 查 操作是最高频的</strong>。相对来说，<strong>增操作只有在列表加载更多时才会用到</strong> ，而且是在列表尾部插入，所以也不需要移动数据的操作。而删操作则更低频。 故选用 ArrayList 作为保存数据的结构。</li>
<li>和<code>Vector</code>的区别，Vector<code>内部也是数组实现的，区别在于</code>Vector<code>在 API 上都加了</code>synchronized<code>所以它是线程安全的，以及</code>Vector<code>扩容时，是翻倍 size，而</code>ArrayList`是扩容 50%。</li>
</ol>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://blog.csdn.net/zxt0601/article/details/77281231" target="_blank" rel="external">面试必备：ArrayList 源码解析（JDK8）</a></li>
<li><a href="http://zhangshixi.iteye.com/blog/674856" target="_blank" rel="external">深入 Java 集合学习系列：ArrayList 的实现原理</a></li>
<li><a href="http://yikun.github.io/2015/04/04/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">Java ArrayList 工作原理及实现</a></li>
</ul>
<p>若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 集合框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的装饰者模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/05/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="装饰者模式的定义"><a href="#装饰者模式的定义" class="headerlink" title="装饰者模式的定义"></a>装饰者模式的定义</h2><p>装饰模式（Decorator Pattern） 也称<strong>包装模式</strong>（Wrapper Pattern），是结构型设计模式之一，使用一种对客户端透明的方式来<strong>动态地拓展对象的功能</strong>，同时它也是继承关系的一种替代方案之一。</p>
<p>通过装饰者模式可以动态地给一个对象添加一些额外的职责。就增加功能而言，装饰模式相比生成子类更灵活。因为它装饰者持有一个被装饰者的引用，因此可以方便地调用具体被装饰者对象中的方法，因此可以在不破坏原类层次结构的情况下为类增加一些功能，我们只需要在被装饰者对象的相应方法前后增加相应的功能逻辑即可。</p>
<a id="more"></a>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要透明且动态地拓展类的功能时。</p>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/30046081-a4423c2c-923a-11e7-9dad-170e000c5ece.png" alt="decorator uml"></p>
<ul>
<li>Component  抽象组件<ul>
<li>可以是接口或者抽象类，充当一个被装饰的原始对象。（在该模式中位于继承结构的顶部，大家都直接/间接地继承它）</li>
</ul>
</li>
<li>ConcreteComponent 组件具体实现类<ul>
<li>该类是 Component 类的具体实现，也是我们装饰的具体对象。</li>
</ul>
</li>
<li>Decorator  抽象装饰者<ul>
<li>继承自 Component 并且<strong>必须持有一个指向 Component 的引用</strong></li>
<li>通常会在其方法中调用 ConcreteComponent 的方法。</li>
<li>如果装饰逻辑单一，可以直接省略该类，直接写一个具体的装饰者对象即可。</li>
</ul>
</li>
<li>ConcreteDecoratorA,B,C<ul>
<li>继承自 Decoration， 在父类对 Component 的方法调用基础上上，增加自己的一些功能。（通常都是在基础方法执行前或者后调用自己新增的方法）</li>
</ul>
</li>
</ul>
<p>使用时经常会把 ComponentImpl 或者说 ConcreteComponent 传入给具体的 Decorator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Compoent component = <span class="keyword">new</span> ConponentImpl();</div><div class="line">DecoratorImpl decoratorImpl = <span class="keyword">new</span> DecoratorImpl(component);</div><div class="line">decoratorImpl.xxOperation();</div></pre></td></tr></table></figure>
<h2 id="Android-源码中的模式实现"><a href="#Android-源码中的模式实现" class="headerlink" title="Android 源码中的模式实现"></a>Android 源码中的模式实现</h2><p><img src="https://user-images.githubusercontent.com/16668676/30047048-b4aeb6e2-9241-11e7-9a04-b11bb1acdc44.png" alt="context"></p>
<p>角色简介：</p>
<ul>
<li>Context ：抽象组件</li>
<li>ComtextImpl ：Context 的具体实现类</li>
<li>ContextWrapper ：装饰者的父类（其中的所有方法都只是调用了 ContextImpl 中对应的方法）</li>
<li>ContextThemeWrapper ：继承自 ContextWrapper  的装饰者</li>
<li>Activity ：继承自 ContextThemeWrapper 的装饰者</li>
</ul>
<p>我们以常用的方法为例，看看装饰者模式在其中的具体实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    Context mBase;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="comment">//启动 Activity</span></div><div class="line">   <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</div><div class="line">        mBase.startActivity(intent, options);</div><div class="line">    &#125;</div><div class="line">  	</div><div class="line">    <span class="comment">//发送广播</span></div><div class="line">    <span class="meta">@SystemApi</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent, String receiverPermission, Bundle options)</span> </span>&#123;</div><div class="line">        mBase.sendBroadcast(intent, receiverPermission, options);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">//注册监听器</span></div><div class="line">      <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></div><div class="line">        BroadcastReceiver receiver, IntentFilter filter) &#123;</div><div class="line">        <span class="keyword">return</span> mBase.registerReceiver(receiver, filter);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上的代码中可以看出，ContextWrapper 作为装饰者的父类，持有 Context 的引用 mBase（mBase 的实际类型为 ContextImpl），其中的所有方法都只是调用了 ContextImpl 中对应的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">     <span class="comment">//启动 Activity 的逻辑实现</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        startActivity(intent, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line"></div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line">        <span class="comment">//调用 Instrumentation.execStartActivity() 方法</span></div><div class="line">        mMainThread.getInstrumentation().execStartActivity(</div><div class="line">                getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</div><div class="line">                (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent, String receiverPermission)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</div><div class="line">        String[] receiverPermissions = receiverPermission == <span class="keyword">null</span> ? <span class="keyword">null</span></div><div class="line">                : <span class="keyword">new</span> String[] &#123;receiverPermission&#125;;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            intent.prepareToLeaveProcess(<span class="keyword">this</span>);</div><div class="line">          	<span class="comment">//调用 AMS 的 broadcastIntent 方法</span></div><div class="line">            ActivityManagerNative.getDefault().broadcastIntent(</div><div class="line">                    mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</div><div class="line">                    Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, receiverPermissions, AppOpsManager.OP_NONE,</div><div class="line">                    <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, getUserId());</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//注册广播的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;  </div><div class="line">   <span class="comment">//注册广播</span></div><div class="line">  	<span class="meta">@Override</span></div><div class="line">  	<span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter,</span></span></div><div class="line">            String broadcastPermission, Handler scheduler) &#123;</div><div class="line">        <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</div><div class="line">                filter, broadcastPermission, scheduler, getOuterContext());</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//注册广播的具体实现</span></div><div class="line">    <span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span></span></div><div class="line">            IntentFilter filter, String broadcastPermission,</div><div class="line">            Handler scheduler, Context context) &#123;</div><div class="line">        IIntentReceiver rd = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = mPackageInfo.getReceiverDispatcher(</div><div class="line">                    receiver, context, scheduler,</div><div class="line">                    mMainThread.getInstrumentation(), <span class="keyword">true</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</div><div class="line">                        receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          	<span class="comment">//调用 AMS 的 registerReceiver 方法</span></div><div class="line">            <span class="keyword">final</span> Intent intent = ActivityManagerNative.getDefault().registerReceiver(</div><div class="line">                    mMainThread.getApplicationThread(), mBasePackageName,</div><div class="line">                    rd, filter, broadcastPermission, userId);</div><div class="line">            <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</div><div class="line">                intent.setExtrasClassLoader(getClassLoader());</div><div class="line">                intent.prepareToEnterProcess();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> intent;</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，ContextImpl 中提供了具体的方法实现。</p>
<p>ContextWrapper 的子类，例如 Activity 会根据需要对具体方法的实现进行装饰或者修改。</p>
<p>比如 startActivity() 方法，Activity 没有使用被装饰者的实现，而是自己实现了一套逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory2</span>,</div><div class="line">        <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</div><div class="line">        <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks2</span>,</div><div class="line">        <span class="title">Window</span>.<span class="title">OnWindowDismissedCallback</span>, <span class="title">WindowControllerCallback</span> &#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">         <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</div><div class="line">                startActivityForResult(intent, -<span class="number">1</span>, options);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Note we want to go through this call for compatibility with</span></div><div class="line">                <span class="comment">// applications that may have overridden the method.</span></div><div class="line">                startActivityForResult(intent, -<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;   </div><div class="line">             </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,@Nullable Bundle options)</span> </span>&#123;</div><div class="line">              <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</div><div class="line">                  options = transferSpringboardActivityOptions(options);</div><div class="line">                  <span class="comment">//调用 Instrumentation.execStartActivity() 方法</span></div><div class="line">                  Instrumentation.ActivityResult ar =</div><div class="line">                      mInstrumentation.execStartActivity(</div><div class="line">                          <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</div><div class="line">                          intent, requestCode, options);</div><div class="line">                <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ContextImpl-的创建"><a href="#ContextImpl-的创建" class="headerlink" title="ContextImpl 的创建"></a>ContextImpl 的创建</h2><p>从上面解析中我们知道 Context 的实现中使用了装饰者模式也知道了 ContextImpl 是 Context 具体实现类，但是 ContextImpl 是在上面地方被初始化的呢？</p>
<p>我们猜想 Activity 启动之后我们便可以调用 Context 中的方法了，我们猜想 ContextImpl 是在 Activity 创建过程中初始化的。</p>
<p>对 Android FrameWork 层有所了解同学应该知道 Activity 是由 AMS 管理的，AMS 会通过调用 ApplicationThread 与间接地控制 Activity。 ApplicationThread 的 scheduleXxx 方法中会调用 sendMessage 方法将相应的 Message 发送给 H，H 根据不同的 Message 调用 ActivityThread 中相应的 handleXxx 方法。</p>
<p>ActivityThread#H</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</div><div class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</div><div class="line">                <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</div><div class="line">                r.packageInfo = getPackageInfoNoCheck(</div><div class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</div><div class="line">              	<span class="comment">//调用 handleLaunchActivity</span></div><div class="line">                handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</div><div class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">            &#125; <span class="keyword">break</span>;       </div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当需要启动新的 Activity 时，ApplicationThread 的  scheduleLaunchActivity 方法会先被调用，该方法会通过 H 调用 handleLaunchActivity 方法，而 handleLaunchActivity 方法又会调用  performLaunchActivity 方法。</p>
<p>ActivityThread#performLaunchActivity </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">//代码省略</span></div><div class="line">    Activity activity = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">      	<span class="comment">//创建 Activity</span></div><div class="line">        activity = mInstrumentation.newActivity(</div><div class="line">                cl, component.getClassName(), r.intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">          	<span class="comment">//获取 Context</span></div><div class="line">            Context appContext = createBaseContextForActivity(r, activity);</div><div class="line">			<span class="comment">//将前面准备的值关联到 Activity 中</span></div><div class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window);</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ActivityThread#createBaseContextForActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">final</span> Activity activity)</span> </span>&#123;</div><div class="line">    ContextImpl appContext = ContextImpl.createActivityContext(<span class="comment">//调用 ContextImpl 的静态方法创建 Activity Context</span></div><div class="line">            <span class="keyword">this</span>, r.packageInfo, r.token, displayId, r.overrideConfig);</div><div class="line">    appContext.setOuterContext(activity);<span class="comment">//外部的 context（此处为 Activity）设置给 ContextImpl</span></div><div class="line">    Context baseContext = appContext;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    <span class="keyword">return</span> baseContext;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContextImpl#createActivityContext()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createActivityContext</span><span class="params">(ActivityThread mainThread,</span></span></div><div class="line">        LoadedApk packageInfo, IBinder activityToken, <span class="keyword">int</span> displayId,</div><div class="line">        Configuration overrideConfiguration) &#123;</div><div class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"packageInfo"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread, packageInfo, activityToken, <span class="keyword">null</span>, <span class="number">0</span>,</div><div class="line">            <span class="keyword">null</span>, overrideConfiguration, displayId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过上面的分析，我们可以得出结论，Activity 的 Context 是在 performLaunchActivity 方法中通过调用 createBaseContextForActivity  初始化的。在 createBaseContextForActivity 方法中，通过调用 ContextImpl 的静态方法 createActivityContext 创建 获取一个 ContextImpl 的实例对象，并通过 setOuterContext 方法将两者建立关联。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学过代理模式的同学可能觉得装饰模式与代理模式有点像（因为同样持有引用）。但是既然是它们是两个不同的设计模式，先看看它们的格子的定义。</p>
<p>装饰模式：以对客户端透明的方式<strong>扩展对象的功能</strong>，是<strong>继承关系的一个替代方案</strong>；<br>代理模式：给一个对象提供一个代理对象，并<strong>由代理对象来控制对原有对象的引用</strong>；</p>
<p>光看定义可能还是比较模糊。二者<strong>区别</strong>在哪里呢？</p>
<ul>
<li>装饰模式应该为所装饰的对象<strong>增强功能</strong></li>
<li>代理模式对代理的对象施加控制，但<strong>不对对象本身的功能进行增强</strong>。</li>
</ul>
<p>可以简单地理解为：你在一个地方写装饰，大家就知道这是在增加功能，你写代理，大家就知道是在限制。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 并发 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的享元模式——Message 复用原理]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/26/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Message%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>享元模式是对象池的一种实现，它的英文名为 Flyweight，代表轻量级的意思。</p>
<p>享元模式用来尽可能==减少内存使用量==，它适合用于可能存在大量对象的场景，来==缓存可共享的对象==（例如 Message、Java 中的字符串常量池）,从而实现对象共享、避免创建过多对象的效果，这样一来就可以提升性能，避免内存移除等。</p>
<p>享元模式中的部分状态是可以共享的，</p>
<ul>
<li>可以共享的状态称为<strong>内部状态</strong>。内部状态不会随着环境变化</li>
<li>不可共享的状态则称之为<strong>外部状态</strong>，他们会随着环境的改变而改变。</li>
</ul>
<p>享元模式会建立一个<strong>对象容器</strong>，在经典的享元模式中，该容器为一个 Map，它的键是享元对象的内部状态，它的值就是享元对象本身。</p>
<a id="more"></a>
<h2 id="享元模式的定义"><a href="#享元模式的定义" class="headerlink" title="享元模式的定义"></a>享元模式的定义</h2><p>享元模式是一种结构型设计模式，以共享的方式高效地支持大量的细粒度对象。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>系统中存在<strong>大量的相似对象</strong></li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要<strong>缓冲池</strong>的场景。</li>
</ol>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29702859-ac3f4f5c-89a5-11e7-92cd-2c26051b399f.png" alt="flyweight uml"></p>
<ul>
<li><strong>Flyweight</strong> ：享元对象抽象基类或者接口。</li>
<li><strong>ConcreteFlyweight</strong>：具体享元对象。</li>
<li><strong>FlyweightFactory</strong> ：享元工厂，负责创建享元对象和管理享元对象池。</li>
</ul>
<h2 id="Android-源码中的享元模式"><a href="#Android-源码中的享元模式" class="headerlink" title="Android 源码中的享元模式"></a>Android 源码中的享元模式</h2><p>在使用 Handler 发送消息之前，我们一般都会使用如下代码调用 <code>mHandler.obtainMessage()</code> 方法获取一个 Message 对象。这其中究竟是怎么实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Handler mHandler = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//do sth</span></div><div class="line">            Message message = mHandler.obtainMessage();</div><div class="line">            message.what = <span class="number">1</span>;</div><div class="line">            message.obj = result;</div><div class="line">            mHandler.sendMessage(message);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Handler.otainMessage()方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Handler.obtainMessage() 实际上调用的是 Message 的 obtain 方法，我们顺着源码看下去。</p>
<p>先看看 Message 类部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sometimes we store linked lists of these things</span></div><div class="line">Message next;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//作为锁对象</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//虽然名称为 sPool 但是实际上是一个指向消息队列队首的指针</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//「对象池」中的最大数量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</div><div class="line">    Message m = obtain();<span class="comment">//调用 obtain 方法获取 message 对象</span></div><div class="line">    m.target = h;<span class="comment">//指定 message 的目标对象</span></div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从消息对象池中取出一个 Message 对象，如果没有就创建一个</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</div><div class="line">            Message m = sPool;</div><div class="line">            sPool = m.next;</div><div class="line">            m.next = <span class="keyword">null</span>;</div><div class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清空 in-use flag</span></div><div class="line">            sPoolSize--;</div><div class="line">            <span class="keyword">return</span> m;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">//消息池中没有可复用的 Message 就创建一个新的 Message</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，从对象池中获取对象的大致流程。无论是 Handler.obtainMessage(参数列表) 方法，还是 Message 的 obtain(参数列表) 方法，最终都会调用 Message.obtain() 方法。在 Message.obtain() 方法的实现中，会先从对象池中获取 Message 对象，如果获取不到，则创建一个新的 Message 对象，然后返回。该对象在后续的执行过程中会被回收到对象池，以便复用。</p>
<p>但是 Message 对象是如何被回收到「对象池」中的呢？    从 Message 类的部分代码中我们看到 sPool 的实际类型是一个 Message 对象，而不是一个容器。另外从 obtain 方法中我们不难看到链表的踪影。难道消息池是使用链表实现的吗？</p>
<p>在 AS 中打开 Message 类的结构图，可以看到其中有一个 recycle 方法，我们看看里面是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isInUse()) &#123;<span class="comment">//判断消息是否还在使用</span></div><div class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;<span class="comment">//如果消息处在使用状态时被 gc 回收，就抛出异常</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span> + <span class="string">"is still in use."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;<span class="comment">//直接返回，取消回收操作</span></div><div class="line">    &#125;</div><div class="line">    recycleUnchecked();<span class="comment">//调用回收方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 回收一个可能还在使用的对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 只要该对象还在回收对象池中，就标记该对象为正在使用状态。</span></div><div class="line">    <span class="comment">// 清空其他状态</span></div><div class="line">    flags = FLAG_IN_USE;</div><div class="line">    what = <span class="number">0</span>;</div><div class="line">    arg1 = <span class="number">0</span>;</div><div class="line">    arg2 = <span class="number">0</span>;</div><div class="line">    obj = <span class="keyword">null</span>;</div><div class="line">    replyTo = <span class="keyword">null</span>;</div><div class="line">    sendingUid = -<span class="number">1</span>;</div><div class="line">    when = <span class="number">0</span>;</div><div class="line">    target = <span class="keyword">null</span>;</div><div class="line">    callback = <span class="keyword">null</span>;</div><div class="line">    data = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//回收消息到消息池中</span></div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">            next = sPool;</div><div class="line">            sPool = <span class="keyword">this</span>;</div><div class="line">            sPoolSize++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>recycle 方法首先会判断 Message 对象是否处在使用状态。如果处在使用状态会直接返回（如果此时 GC 回收该对象会抛出异常），否则调用 recycleUnchecked 方法，具体的回收逻辑是在 recycleUnchecked  方法中实现的。首先会标记 Message 处于使用状态，然后清空对象中的其他状态。将消息存入回收池，主要是链表的操作。大致如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29739978-6c03d780-8a7e-11e7-8aad-3da3590c2ea1.png" alt="msg"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Message 通过在内部构建一个链表来维护一个被会受到  Message 对象的对象池，当用户调用 obtain 方法时，会优先从池中获取。如果池中没有可以复用的对象就创建一个新的对象，该对象使用完之后，会被缓存到对象池中，当下次调用 obtain 方法时，他们就会被复用。</p>
<p>此处 Message 扮演了三个角色。既是 FlyWeight 抽象，又是 ConcreteFlyWeight 对象，同时还担任 FlyWeightFactory 角色，承担着管理对象池的职责。</p>
<p>想进一步了解 Android 消息机制的同学可参考<a href="https://ivanljt.github.io/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/">Android 消息机制解析</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>享元模式的优点：</p>
<ul>
<li>大幅度降低了内存中对象的数量。从而降低了内存的占用，提高了程序的性能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使得系统更加复杂。为了使应用能够共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li>
<li>享元模式将状态外部化，而读取外部状态使得<strong>运行时间稍微变长</strong></li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" target="_blank" rel="external">《JAVA 与模式》之享元模式</a></li>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="https://ivanljt.github.io/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/">Android 消息机制解析</a></li>
</ul>
<p>若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的模板方法模式——AsyncTask解析]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/24/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AsyncTask%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，<strong>某些步骤的具体实现是未知的</strong>，或者说某些步骤的实现是会<strong>随着环境的变化而改变的</strong>。<br>就好像执行程序的流程：</p>
<ol>
<li>检查代码的正确性</li>
<li>链接相关代码</li>
<li>编译相关代码</li>
<li>执行程序</li>
</ol>
<p>对于不同的语言，上述 4 个步骤都是不一样的，但是它们的执行流程是固定的，这类问题的解决方案就是我们介绍的模板方法模式。</p>
<a id="more"></a>
<h2 id="模板方法模式的定义"><a href="#模板方法模式的定义" class="headerlink" title="模板方法模式的定义"></a>模板方法模式的定义</h2><p>定义一个操作中的<strong>算法的框架</strong>，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<h2 id="模板方法模式的使用场景"><a href="#模板方法模式的使用场景" class="headerlink" title="模板方法模式的使用场景"></a>模板方法模式的使用场景</h2><ol>
<li>多个子类有公有的方法，并且逻辑基本相同时。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，把相同的代码抽取到父类中，然后通过<strong>钩子方法</strong>约束其行为。</li>
</ol>
<h3 id="注：何谓钩子方法？"><a href="#注：何谓钩子方法？" class="headerlink" title="注：何谓钩子方法？"></a>注：何谓钩子方法？</h3><p>基本方法又可以分为三种：抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。</p>
<p>这是《java与模式》书里的一种说法，三种方法也是在书中的模板方法模式中提及到的。</p>
<p>先说这个三个方法的基本定义：</p>
<ul>
<li>抽象方法：由抽象类声明，由具体子类实现。在java语言里一个抽象方法以abstract关键字标示出来。</li>
<li>具体方法：由抽象类声明并实现，而子类并不实现或覆盖。其实就是<strong>一般的方法</strong>，但是不需要子类来实现。</li>
<li>钩子方法：由抽象类<strong>声明并实现</strong>，而子类也会加以扩展。通常抽象类给出的是一个空的钩子方法，也就是方法体为空的方法（也可以根据需要实现部分逻辑）。其实它和具体方法在代码上没有区别，不过是意识上的一种区别。</li>
</ul>
<p>详见<a href="https://www.the5fire.com/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95-%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95.html" target="_blank" rel="external">抽象方法 具体方法 钩子方法</a></p>
<h2 id="模板方法模式的-UML-类图"><a href="#模板方法模式的-UML-类图" class="headerlink" title="模板方法模式的 UML 类图"></a>模板方法模式的 UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29603702-be32185a-8817-11e7-95f3-9cf7ee08c644.png" alt="template method pattern"></p>
<ul>
<li>AbsTemplate：抽象类，定义一套算法框架</li>
<li>ConcreteImplA：具体实现类 A</li>
<li>ConcreteImplB：具体实现类 B</li>
</ul>
<h2 id="模板方法模式的简单示例"><a href="#模板方法模式的简单示例" class="headerlink" title="模板方法模式的简单示例"></a>模板方法模式的简单示例</h2><p>实际上是封装一个固定流程，就像是一套执行模板一样，第一步该做什么，第二步该做什么都已经在抽象类中定义好。而子类可以有不同的算法实现，在框架不被修改的情况下实现某些步骤的算法替换。</p>
<h2 id="Android-源码中的模板方法模式"><a href="#Android-源码中的模板方法模式" class="headerlink" title="Android 源码中的模板方法模式"></a>Android 源码中的模板方法模式</h2><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>使用过 AsyncTask 的同学都知道，我们调用 execute 之后，（如果没有调用 cancel 方法的话）以下三个方法会依次执行：</p>
<ul>
<li>onPreExecute</li>
<li>doInBackground </li>
<li>onPostExecute</li>
</ul>
<p>为什么能让它们依次执行呢？其内部是怎么实现的？我们看看源码，一探究竟。</p>
<p>首先看看异步任务的入口方法 execute。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上两个构造方法中主要做了如下几件事：</p>
<ul>
<li>状态判断</li>
<li>判断之后执行 <code>onPreExecute();</code></li>
<li>使用线程池执行 mFuture<ul>
<li>什么样的线程池？<ul>
<li>默认为 SerialExecutor 单线程的线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Result result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);<span class="comment">//设置进程优先级</span></div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                result = doInBackground(mParams);<span class="comment">//调用 doInBackground 方法</span></div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">                mCancelled.set(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">throw</span> tr;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postResult(result);<span class="comment">//调用 postResult 方法</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());<span class="comment">//任务完成</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div></pre></td></tr></table></figure>
<ul>
<li>mWorker 类型为 <code>WorkerRunnable&lt;Params, Result&gt;</code> ， WorkerRunnable 实现了 Callable</li>
<li>mFuture 类型为 <code>FutureTask&lt;Result&gt;</code></li>
</ul>
<p>简而言之，这个 mFuture 包装了这个 mWorker 对象，而 mFuture 是在线程池中执行的，会调用 mFuture 的 run 方法，该 run 方法中调用了 mWorker 的 call 方法，mWorker 的 call 方法又调用了 doInBackground 方法，所以 doInBackground 是在工作线程执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</div><div class="line">    <span class="keyword">if</span> (!wasTaskInvoked) &#123;</div><div class="line">        postResult(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doInBackground</code> 执行完成后会通过 <code>postResult(result)</code> 方法将结果传递给主线程。</p>
<ul>
<li><code>postResult(result)</code> 可能通过 call 方法的 finally 块直接调用或者通过 FutureTask 中的 done 方法里面的 <code>postResultIfNotInvoked(get());</code> 来间接调用。</li>
</ul>
<p>接下来我们看看 <code>postResult(result)</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// 调用 AsyncTask 的 finish 方法</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>postResult(result)</code>  方法就是通过发送一条消息（msg.what == MESSAGE_POST_RESULT）给 sHandler，sHandler 为 InternalHanlder。当 InternalHanlder 接收到 MESSAGE_POST_RESULT 时，就会调用 <code>result.mTask.finish(result.mData[0])</code> 方法，result 的类型为 AsyncTaskResult</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">    <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">        mTask = task;</div><div class="line">        mData = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 AsyncTaskResult 的具体实现中吗，我们知道 mTask 就是 AsyncTask，finish 方法中又调用了 <code>onPostExecute</code> ，此时整个执行流程就完成了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>execute 方法内部封装了 onPreExecute、doInBackGround、onPostExecute 这个逻辑流程。<br>通过这种方式，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时的操作及更新 UI。实际上就是通过线程池来执行耗时的任务，得到结果之后，通过 Handler 将结果传递给 UI 线程执行。</p>
<h3 id="Activity-的生命周期函数"><a href="#Activity-的生命周期函数" class="headerlink" title="Activity 的生命周期函数"></a>Activity 的生命周期函数</h3><p>除了 AsyncTask 以外，Android 源码中还有不少地方有模板方法的身影，比如说 Activity 的生命周期方法—— onCreate 、onStart、onResume 等，都是按照顺序调用的，我们会在对应的方法中执行合适的操作。</p>
<p>其内部实现涉及到进程间通信，限于篇幅，本文不作深入介绍。有兴趣的同学可以看看 ActivityThread 的 main 方法，以之作为入口，对生命周期方法的调用时机做进一步研究。</p>
<h2 id="模板方法总结"><a href="#模板方法总结" class="headerlink" title="模板方法总结"></a>模板方法总结</h2><p>简单概括模板方法模式就是流程封装。把某一个固定的流程封装到一个固定的 final 方法中。并且让子类能够定制这个过程中的某些甚至所有步骤，这就要求父类提取共用的代码，提升代码的复用率，同时也带来了更高的可扩展性。</p>
<ul>
<li>优点：<ul>
<li>封装不变的部分，扩展可变的部分</li>
<li>提取公共部分代码，便于维护。</li>
</ul>
</li>
<li>缺点：<ul>
<li>提高了代码阅读的难度，会让用户觉得难以理解</li>
</ul>
</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="https://www.the5fire.com/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95-%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95.html" target="_blank" rel="external">抽象方法 具体方法 钩子方法</a></li>
</ul>
<p>若有不正之处请多多谅解，欢迎批评指正。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[行为型设计模式之备忘录模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/21/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="备忘录模式的定义"><a href="#备忘录模式的定义" class="headerlink" title="备忘录模式的定义"></a>备忘录模式的定义</h2><p>备忘录模式是一种<strong>行为型设计模式</strong>，该模式用于保存对象当前的状态，并且在之后可以再次恢复到此状态。</p>
<p>实现效果为：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便后续将对象恢复到原来的状态。</p>
<h2 id="备忘录模式的使用场景"><a href="#备忘录模式的使用场景" class="headerlink" title="备忘录模式的使用场景"></a>备忘录模式的使用场景</h2><ol>
<li>需要保存一个对象在某一个时刻的状态或部分状态</li>
<li>一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。（如果使用接口来让其他对象获取对象的状态，会破坏封装性）</li>
</ol>
<a id="more"></a>
<h2 id="备忘录模式的UML类图"><a href="#备忘录模式的UML类图" class="headerlink" title="备忘录模式的UML类图"></a>备忘录模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29518826-890e58e8-86ad-11e7-9ce8-90ff79fcc071.png" alt="memoto pattern"></p>
<p>三个角色：</p>
<ul>
<li>Originator：需要保存状态的对象。负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。</li>
<li>Memento（类似于 pojo 类）备忘录角色。用于存储 Originator 内部状态，并且可以防止 Originator 以外的对象访问 Memento</li>
<li>Caretaker：负责存储备忘录，不能对<strong>备忘录的内容</strong>进行操作和访问，只能将备忘录传递给其他对象。</li>
</ul>
<h2 id="Android源码中的备忘录模式"><a href="#Android源码中的备忘录模式" class="headerlink" title="Android源码中的备忘录模式"></a>Android源码中的备忘录模式</h2><p>日常开发中如果需要保存什么数据以防止 Activity 意外销毁，第一时间会想到 Activity 中的这两个方法——<code>onSaveInstanceState</code>、<code>onRestoreInstanceState</code>。其内部具体是如何实现数据保存的呢？</p>
<p>先透漏一下，这里面使用到了备忘录模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 存储窗口的视图树的状态</span></div><div class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</div><div class="line">    <span class="comment">//2. 存储 Fragment 中的状态    </span></div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//3. 若用户设置了 Activity 的 ActivityLifeCycleCallbacks，</span></div><div class="line">    <span class="comment">//则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。</span></div><div class="line">    getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Activity.onSaveInstanceState 方法中主要做了三件事</p>
<ol>
<li>存储窗口的视图树的状态</li>
<li>存储 Fragment 中的状态</li>
<li>若用户设置了 Activity 的 ActivityLifeCycleCallbacks，则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。</li>
</ol>
<p>首先看看步骤 1，该步骤将 Window 对象中的视图树中的各个 View 状态存储到 Bundle 中。</p>
<p>Window 的具体实现在 <code>PhoneWindow</code> 中.以下为 <code>PhoneWindow.saveHierarchyState</code> 的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">saveHierarchyState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Bundle outState = <span class="keyword">new</span> Bundle();</div><div class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> outState;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// SparseArray 相当于一个 key 为 整型的 map</span></div><div class="line">    SparseArray&lt;Parcelable&gt; states = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">    <span class="comment">//此处的 mContentParent 就是我们 setContentView 时设置的 View</span></div><div class="line">    mContentParent.saveHierarchyState(states);</div><div class="line">    outState.putSparseParcelableArray(VIEWS_TAG, states);</div><div class="line"></div><div class="line">    <span class="comment">// 持有焦点的 View 必须设置 id，否则重新进入该界面时不会恢复它的焦点状态</span></div><div class="line">    <span class="keyword">final</span> View focusedView = mContentParent.findFocus();</div><div class="line">    <span class="keyword">if</span> (focusedView != <span class="keyword">null</span> &amp;&amp; focusedView.getId() != View.NO_ID) &#123;</div><div class="line">        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 存储整个面板的状态</span></div><div class="line">    SparseArray&lt;Parcelable&gt; panelStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">    savePanelState(panelStates);</div><div class="line">    <span class="keyword">if</span> (panelStates.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">        outState.putSparseParcelableArray(PANELS_TAG, panelStates);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 保存 actionbar 的状态</span></div><div class="line">    <span class="keyword">if</span> (mDecorContentParent != <span class="keyword">null</span>) &#123;</div><div class="line">        SparseArray&lt;Parcelable&gt; actionBarStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</div><div class="line">        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> outState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看步骤 2 中的 <code>mContentParent.saveHierarchyState</code> 方法，mContentParent 是一个 ViewGroup 但是 saveHierarchyState 方法并不是定义在 ViewGroup 中，而是定义在它的父类——View 中，查看下该方法在 View 中的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveHierarchyState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    dispatchSaveInstanceState(container);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 只有含有 id 的 View，状态才会被存储</span></div><div class="line">    <span class="keyword">if</span> (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == <span class="number">0</span>) &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">        <span class="comment">//2. 调用 onSaveInstanceState 方法获取自身状态</span></div><div class="line">        Parcelable state = onSaveInstanceState();</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Derived class did not call super.onSaveInstanceState()"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//3. 将自身状态存放到 container 中</span></div><div class="line">        <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">            container.put(mID, state);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>View.onSaveInstanceState</code> 方法默认存储的状态为空状态。但是它的子类通常都有定义自身的覆盖方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</div><div class="line">    <span class="keyword">if</span> (mStartActivityRequestWho != <span class="keyword">null</span>) &#123;</div><div class="line">        BaseSavedState state = <span class="keyword">new</span> BaseSavedState(AbsSavedState.EMPTY_STATE);</div><div class="line">        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> BaseSavedState.EMPTY_STATE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤 2 中的 View 的调用大致如下：saveHierarchyState ==》 dispatchSaveInstanceState ==》 onSaveInstanceState</p>
<ul>
<li>其中要注意的是 只有含有 id 的 View，状态才会被存储，如果没有给 view 赋一个 id，那么系统是不会帮忙保存该 view 的状态的。</li>
</ul>
<p>View 类中的 saveHierarchyState 方法调用了dispatchSaveInstanceState 方法用来存储自身状态。 ViewGroup 覆写了 dispatchSaveInstanceState 来存储自身以及子视图的状态。 </p>
<p><code>ViewGroup.dispatchSaveInstanceState</code>具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.dispatchSaveInstanceState(container);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;<span class="comment">//遍历调用子 View 的 dispatchSaveInstanceState 方法</span></div><div class="line">        View c = children[i];</div><div class="line">        <span class="keyword">if</span> ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</div><div class="line">            c.dispatchSaveInstanceState(container);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 ViewGroup 的 <code>dispatchSaveInstanceState</code> 方法会先调用 <code>super.dispatchSaveInstanceState(container);</code> 存储自身的状态。然后遍历调用所有子视图的 <code>dispatchSaveInstanceState(container)</code> 方法来保存它们的状态，如果子 View 也是一个 ViewGroup，则会再次执行这个过程。</p>
<hr>
<p>我们以 TextView 的 saveInstanceState 方法为例，看看具体的控件是如何保存自身状态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</div><div class="line"></div><div class="line">    <span class="comment">// Save state if we are forced to</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> freezesText = getFreezesText();</div><div class="line">    <span class="keyword">boolean</span> hasSelection = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> start = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = -<span class="number">1</span>;</div><div class="line">    <span class="comment">//存储 TextView 的 start、end </span></div><div class="line">    <span class="keyword">if</span> (mText != <span class="keyword">null</span>) &#123;</div><div class="line">        start = getSelectionStart();</div><div class="line">        end = getSelectionEnd();</div><div class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span> || end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 是否存存在选项</span></div><div class="line">            hasSelection = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (freezesText || hasSelection) &#123;</div><div class="line">        SavedState ss = <span class="keyword">new</span> SavedState(superState);</div><div class="line">        <span class="comment">//保存 TextView 的文本内容</span></div><div class="line">        <span class="keyword">if</span> (freezesText) &#123;</div><div class="line">            <span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spanned) &#123;</div><div class="line">                <span class="keyword">final</span> Spannable sp = <span class="keyword">new</span> SpannableStringBuilder(mText);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">                    removeMisspelledSpans(sp);</div><div class="line">                    sp.removeSpan(mEditor.mSuggestionRangeSpan);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ss.text = sp;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ss.text = mText.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储 TextView 的 start、end </span></div><div class="line">        <span class="keyword">if</span> (hasSelection) &#123;</div><div class="line">            <span class="comment">// XXX Should also save the current scroll position!</span></div><div class="line">            ss.selStart = start;</div><div class="line">            ss.selEnd = end;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isFocused() &amp;&amp; start &gt;= <span class="number">0</span> &amp;&amp; end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            ss.frozenWithFocus = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ss.error = getError();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">            ss.editorState = mEditor.saveInstanceState();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回状态对象</span></div><div class="line">        <span class="keyword">return</span> ss;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> superState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 View 的 onSaveInstance 函数之后就得到了 View 要存储的数据，此时执行到 View 的  dispatchSaveInstanceState 方法中的注释 3。这里以 View 的 id 为 key，以状态为 value，存储到 container（ SparseArray 类型）中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3. 将自身状态存放到 container 中</span></div><div class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">    container.put(mID, state);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>存储完 Window 的视图状态信息之后，便会执行存储 Fragment 中的状态信息、回退栈等。Fragment  也是通过调用自身的 onSaveInstaceState 方法来存储自身的 View 视图树状态的。</li>
<li>最后就是调用用户设置的 ActivityLifecycleCallbacks 的 onSaveInstaceState 方法，让用户做一些额外的处理</li>
</ul>
<p>前面我们所提及到的只是备忘录模式中的 Originator 角色，即需要保存备忘录的对象。不过也有涉及到 CareTaker 角色——Activity。下面我们再看看另外两个角色——Memoto 和 CareTaker。</p>
<p>存了状态信息的 Bundle 数据存储在哪？</p>
<ul>
<li>onSaveInstance 方法是在 onStop 方法之前调用的。Activity.onStop 方法是通过 Activity 的 performStopActivity 间接调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</div><div class="line">    <span class="comment">//获取 ActivityClientRecord</span></div><div class="line">    ActivityClientRecord r = mActivities.get(token);</div><div class="line">    <span class="comment">// saveState 表示是否保存状态</span></div><div class="line">    performStopActivityInner(r, <span class="keyword">null</span>, <span class="keyword">false</span>, saveState, reason);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r,</span></span></div><div class="line">        StopInfo info, <span class="keyword">boolean</span> keepShown, <span class="keyword">boolean</span> saveState, String reason) &#123;</div><div class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!keepShown &amp;&amp; r.stopped) &#123;</div><div class="line">            <span class="keyword">if</span> (r.activity.mFinished) &#123;</div><div class="line">                <span class="comment">// 如果正在执行销毁过程，是用户主动销毁。 activity 不打算恢复，我们也没必要调用 onStop 方法</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 在调用 onStop 之前必须先调用 onPause </span></div><div class="line">        performPauseActivityIfNeeded(r, reason);</div><div class="line"></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="comment">// 接下来让 activity 保存它目前的状态和它所管理的 dialogs </span></div><div class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; saveState) &#123;</div><div class="line">            <span class="keyword">if</span> (r.state == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 间接调用 Activity.onSaveInstance()</span></div><div class="line">                callCallActivityOnSaveInstanceState(r);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!keepShown) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 执行 onStop 方法</span></div><div class="line">                r.activity.performStop(<span class="keyword">false</span> <span class="comment">/*preserveWindow*/</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//将 stop 字段置为 true 表示已经调用了 stop 方法。</span></div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callCallActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</div><div class="line">    r.state = <span class="keyword">new</span> Bundle();<span class="comment">//内容就存储在该 Bundle 中</span></div><div class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</div><div class="line">                r.persistentState);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//该方法实际调用了 Activity.onSaveInstanceState 方法</span></div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(Activity activity, Bundle outState,</span></span></div><div class="line">        PersistableBundle outPersistentState) &#123;</div><div class="line">    activity.performSaveInstanceState(outState, outPersistentState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 performStopActivity 与 performStopActivityInner 方法中，首先通过 token 从 mActivities 中获取一个 ActivityClientRecord 对象，状态信息就是存储在这里面的。获取该对象之后，调用了 performStopActivityInner 方法，对于保存状态而言，该方法大概有如下三步</p>
<ol>
<li>判断 Activity 是否需要保存状态</li>
<li>如果需要，则调用 onSaveInstance 方法，该方法会将状态信息存储到 ActivityClientRecord 中</li>
<li>调用 <code>Activity.onStop()</code> 方法</li>
</ol>
<p>执行 onStop 方法之前，系统会根据情况来选择是否存储 Activity 的状态，并且将这些状态（简介地）存储到 mActivities 中。</p>
<p>mActivities 是一个 <code>ArrayMap&lt;IBinder, ActivityClientRecord&gt;</code> ，它维护了一个 Activity 的信息表，当 Activity 重新启动时，会从 mActivities 中查询对应的 ActivityClientRecord，如果这个记录对象中含有状态信息就调用 Activity 的 onRestoreInstanceState 方法。开发人员可以从这个方法中做一些状态恢复操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    Activity activity = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">        <span class="comment">//1. 构建 Activity </span></div><div class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//2. 创建一个 Application 对象</span></div><div class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//创建 appContext，类型为 ContextImpl</span></div><div class="line">            Context appContext = createBaseContextForActivity(r, activity);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            <span class="comment">//3. 关联 appContext、Application 等对象到 Activity 中</span></div><div class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            activity.mCalled = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//4. 调用 Activity.onCreate 方法</span></div><div class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            r.activity = activity;</div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</div><div class="line">                <span class="comment">//调用 onStart 方法</span></div><div class="line">                activity.performStart();</div><div class="line">                r.stopped = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">             <span class="comment">//5. 如果有保存状态的话，调用 Activity.onRestoreInstanceState 方法恢复状态</span></div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</div><div class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">                    <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</div><div class="line">   </div><div class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</div><div class="line">                                r.persistentState);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</div><div class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line">        r.paused = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//6. 将 Activity 的信息记录对象——ActivityClientRecord 存储到 mActivities 中。 </span></div><div class="line">        mActivities.put(r.token, r);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的注释 5 处，系统会判断 Activity 是否调用过了 <code>Activity.finish()</code> 方法、是否是「永久的」以及 ActivityClientRecord 对象中的 state 是否为空，</p>
<ul>
<li>如果满足条件，就会获取存储的状态信息传递给 <code>Activity.onRestoreInstanceState</code> 方法，也会将这些数据传递给 onCreate 方法的 bundle 参数 。</li>
<li>不过 Google 官方推荐调用 onRestoreInstanceState 方法来恢复状态，因为只有在存储有状态信息的时候才会调用该方法，而在 onCreate 方法中还需要先进行判空处理。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上述过程中备忘录模式的三种关键角色分别由什么类扮演？</p>
<ul>
<li><strong>CareTaker</strong>：Activity 负责存储、恢复 UI 的态信息。</li>
<li><strong>Originator</strong>：Activity、Fragment、View、ViewGroup ，是需要存储状态的对象</li>
<li><strong>Memoto</strong>：由 Bundle 类扮演</li>
</ul>
<ul>
<li>Activity 会在停止之前根据 Activity 的退出情景来选择是否需要存储状态</li>
<li>在<strong>重新启动</strong>该 Activity 时会判断 ActivityClientRecord 对象中是否存储了 Activity 的状态<ul>
<li>如果含有状态，调用 <code>Activity.onRestoreInstanceState()</code> 方法恢复状态。从而使得 Activity 的 UI 可以恢复至异常退出前的状态。</li>
</ul>
</li>
</ul>
<h2 id="你可能会问的问题"><a href="#你可能会问的问题" class="headerlink" title="你可能会问的问题"></a>你可能会问的问题</h2><h3 id="onSaveInstanceState-何时被调用"><a href="#onSaveInstanceState-何时被调用" class="headerlink" title="onSaveInstanceState 何时被调用"></a>onSaveInstanceState 何时被调用</h3><p>onSaveInstanceState() 方法会在什么时候被执行？<br>有这么几种情况：</p>
<ol>
<li>当用户按下 HOME 键时。<ul>
<li>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</li>
</ul>
</li>
<li>长按HOME键，选择运行其他的程序时。</li>
<li>按下电源按键（关闭屏幕显示）时。</li>
<li>从 Activity A 中启动一个新的 Activity 时。</li>
<li>屏幕方向切换时，例如从竖屏切换到横屏时。</li>
</ol>
<p>onSaveInstanceState 的调用在 onStop 方法之前，但是与 onPause 方法之间没有既定关系。</p>
<ul>
<li>总而言之，当系统存在「==未经用户许可==」时销毁了我们的 Activity，则 <code>onSaveInstanceState()</code> 会被系统调用，这是系统的责任，因此它必须提供一个机会让用户保存数据。</li>
<li>「经用户许可」的情况不多，通常只有用户按下回退键这一种。这种情况下是用户主动退出某个 Activity，系统不会调用  <code>onSaveInstanceState()</code> 方法。</li>
</ul>
<h3 id="各个-「Originator-」-的-onSaveInstanceState-方法的默认实现是怎么样的？"><a href="#各个-「Originator-」-的-onSaveInstanceState-方法的默认实现是怎么样的？" class="headerlink" title="各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？"></a>各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？</h3><p>在前面的分析中我们知道即使没有覆写 onSaveInstanceState()方法, ViewGroup、View、Fragment、Activity 内部都有自己的默认实现，它们的默认实现也会<strong>保存某些状态数据</strong>。 </p>
<ul>
<li>比如 activity 中各种 UI 控件的状态。android 应用框架中定义的几乎所有 UI 控件都恰当的实现了 onSaveInstanceState() 方法,因此当 Activity 被销毁和重建时, 这些 UI 控件会自动保存和恢复状态数据.<ul>
<li>EditText 控件会自动保存和恢复输入的数据</li>
<li>CheckBox 控件会自动保存和恢复选中状态</li>
<li>…</li>
</ul>
</li>
<li>开发者只<strong>需要为这些控件指定一个唯一的 id</strong>(通过设置 <code>android:id</code> 属性即可), 剩余的事情就可以自动完成了<ul>
<li>注意：如果没有为控件指定ID, 则这个控件就不会进行自动的数据保存和恢复操作。</li>
</ul>
</li>
</ul>
<p>由上所述, 如果我们需要覆写 onSaveInstanceState() 方法, 一般会在第一行代码中调用该方法的默认实现:super.onSaveInstanceState(outState)。</p>
<h3 id="有默认实现，还需要重写-onSaveInstanceState-方法吗？"><a href="#有默认实现，还需要重写-onSaveInstanceState-方法吗？" class="headerlink" title="有默认实现，还需要重写 onSaveInstanceState() 方法吗？"></a>有默认实现，还需要重写 onSaveInstanceState() 方法吗？</h3><p>既然该方法的默认实现可以自动的保存UI控件的状态数据, 那什么时候需要覆写该方法呢? </p>
<p>如果<strong>需要保存额外的数据时</strong>, 就需要覆写 onSaveInstanceState() 方法。大家需要注意的是：onSaveInstanceState()方法<strong>只适合保存瞬态数据</strong>, 比如 UI 控件的状态，成员变量的值等，而不应该用来保存持久化数据，持久化数据应该当用户离开当前的 activity时，在 onPause() 中保存（比如将数据保存到数据库或文件中）。说到这里，还要说一点的就是在onPause()中不适合用来保存比较费时的数据，所以这点要理解。</p>
<p>另外由于 <code>onSaveInstanceState()</code> 方法方法不一定会被调用, 因此<strong>不适合在该方法中保存持久化数据</strong>, 例如向数据库中插入记录等。 保存持久化数据的操作应该放在 onPause() 中。若是永久性值，则在 onPause() 中保存；若有大量要保存的数据，则另开线程，以免阻塞 UI 线程。 </p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/28/2420515.html" target="_blank" rel="external">Android 开发之 instanceState详解</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 ThreadLocal]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/21/%E7%90%86%E8%A7%A3%20ThreadLocal/</url>
      <content type="html"><![CDATA[<h2 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a>ThreadLocal 是什么？</h2><p>ThreadLocal 是一个<strong>线程内部</strong>的<strong>数据存储类</strong>，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<h2 id="为什么要使用-ThreadLocal？"><a href="#为什么要使用-ThreadLocal？" class="headerlink" title="为什么要使用 ThreadLocal？"></a>为什么要使用 ThreadLocal？</h2><p>从定义我们知道 ThreadLocal 是一个用于存储本线程内部数据的类。假设没有 ThreadLocal 的话，每个 Thread 中可以输入自己的一个本地变量，但是在整个 Thread 的生命周期中，如果要穿梭很多 class 的很多 method 来使用这个本地变量的话，就要一直一直向下传送这个变量，显然很麻烦。<br>那么怎么才能在这个 Thread 的生命中，在任何地方都能够方便的访问到这个变量呢，这时候 ThreadLocal 就诞生了。</p>
<a id="more"></a>
<p>ThreadLocal 就是这么个作用，除此之外和通常使用的本地变量没有任何区别。<br>也就是说，没有 ThreadLocal 也是可以解决问题的，但是会比较麻烦，ThreadLocal 的作用便是简化线程内部数据的使用流程。</p>
<h2 id="ThreadLocal-的内部实现"><a href="#ThreadLocal-的内部实现" class="headerlink" title="ThreadLocal 的内部实现"></a>ThreadLocal 的内部实现</h2><p>既然是线程的本地变量，那自然与线程有着密切的联系。</p>
<p>打开 Thread 的源码可以看到，源码中有一个类型为 <code>ThreadLocal.ThreadLocalMap</code> 的变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<h3 id="ThreadLocal-get-流程"><a href="#ThreadLocal-get-流程" class="headerlink" title="ThreadLocal#get 流程"></a>ThreadLocal#get 流程</h3><p>我们以 ThreadLocal#get 方法作为分析的源头。这些方法的逻辑都比较简单，因此直接在注释中说明。可参考小结部分的调用流程图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);<span class="comment">//获取存储该 ThreadLocal 的 Entry</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)e.value;<span class="comment">//获取目标值并返回</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();<span class="comment">//设置初始值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#getMap，该方法返回当前线程的 ThreadLocalMap  对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Entry 类继承自弱引用，防止内存泄漏。其中存储了 ThreadLocal 以及对应的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#setInitialValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    T value = initialValue();<span class="comment">//获取默认的初始值</span></div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);<span class="comment">//当前线程的 ThreadLocalMap 对象不为空，直接设置给目标对象。</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);<span class="comment">//为当前线程创建 ThreadLocalMap 对象。</span></div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#createMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);<span class="comment">//调用构造方法初始化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ThreadLocal-set-流程"><a href="#ThreadLocal-set-流程" class="headerlink" title="ThreadLocal#set 流程"></a>ThreadLocal#set 流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);<span class="comment">//当前线程的 ThreadLocalMap 对象 已经存在直接设置值</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);<span class="comment">//为当前线程创建 ThreadLocalMap </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 ThreadLocal#set 方法的逻辑与 ThreadLocal#setInitialValue 方法中的逻辑如出一辙，这里不再赘述。</p>
<h3 id="ThreadLocalMap-的构造方法"><a href="#ThreadLocalMap-的构造方法" class="headerlink" title="ThreadLocalMap 的构造方法"></a>ThreadLocalMap 的构造方法</h3><p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类。其中以键值对的形式存储数据。可以将它简单理解为一个 HashMap。ThreadLocal#createMap 方法通过调用 ThreadLocalMap 的构造方法为当前线程创建一个 ThreadLocalMap 对象。</p>
<p><code>ThreadLocalMap</code> 的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];<span class="comment">//创建一个长度为 16 的 Entry 数组</span></div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);<span class="comment">//计算 key 的哈希值</span></div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);<span class="comment">//将 Entry 存到指定位置。</span></div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ThreadLocalMap</code> 的构造函数主要做了下面几件事：</p>
<ul>
<li>首先创建了一个 <code>Entry</code> 数组，<ul>
<li><code>Entry</code> 是 <code>ThreadLocalMap</code> 中的一个静态内部类,它以 <code>ThreadLocal</code> 为 key，以要存储的值为 value。</li>
</ul>
</li>
<li>然后根据 key 计算 Hash 值</li>
<li>接着创建一个 Entry 对象存储在数组中</li>
<li>最后设置大小和阈值。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="get-方法调用大致流程"><a href="#get-方法调用大致流程" class="headerlink" title="get 方法调用大致流程"></a>get 方法调用大致流程</h4><p><img src="https://user-images.githubusercontent.com/16668676/30096800-004b9f36-930d-11e7-9c27-c7f17619c3a7.png" alt="threadlocal get"></p>
<p>get 方法中会尝试获取当前线程的 ThreadLocalMap</p>
<ul>
<li>如果 ThreadLocalMap 非空，并且以当前 ThreadLocal 对象为 key 去获取到的 Entry 不为空，就返回该 ThreadLocal 对应的值；</li>
<li>否则，先获取默认的初始值（默认实现为空，可以自己重写 initialValue 方法来设置需要的值）<ul>
<li>然后判断 ThreadLocalMap 是否为空<ul>
<li>如果为空创建一个 ThreadLocalMap 同时将初始值设置进去。</li>
<li>如果不为空，直接把初始值存储在其中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="set-方法调用流程"><a href="#set-方法调用流程" class="headerlink" title="set 方法调用流程"></a>set 方法调用流程</h4><p><img src="https://user-images.githubusercontent.com/16668676/30096799-0047aeee-930d-11e7-8ac5-1927aadeab2d.png" alt="threadlocal set"></p>
<h2 id="你可能存在的疑问"><a href="#你可能存在的疑问" class="headerlink" title="你可能存在的疑问"></a>你可能存在的疑问</h2><h3 id="每个-ThreadLocal-只能放一个对象吗？"><a href="#每个-ThreadLocal-只能放一个对象吗？" class="headerlink" title="每个 ThreadLocal 只能放一个对象吗？"></a>每个 ThreadLocal 只能放一个对象吗？</h3><p>每个 ThreadLocal 只能放一个对象。要是需要放其他的对象，就再 new 一个新的 ThreadLocal 出来，这个新的 ThreadLocal 将作为 key,需要放的对象作为value，放在 ThreadLocalMap 中。也就是说一个线程可以含有多个 ThreadLocal 类。</p>
<p>当然也可以根据需要在 ThreadLocal 存放一些容器对象，比如 List、Set、Map，一个 ThreadLocal 存放一个容器对象，借助该容器对象也可以实现存储多个对象。 </p>
<h3 id="为什么-ThreadLocal-只存储一个对象却要用一个-ThreadLocalMap-来存储值？"><a href="#为什么-ThreadLocal-只存储一个对象却要用一个-ThreadLocalMap-来存储值？" class="headerlink" title="为什么 ThreadLocal  只存储一个对象却要用一个 ThreadLocalMap 来存储值？"></a>为什么 ThreadLocal  只存储一个对象却要用一个 ThreadLocalMap 来存储值？</h3><p>实际上每个线程中都有一个 ThreadLocal.ThreadLocalMap，真正存储数据的类是 ThreadLocalMap ，可以将它看作是一个 HashMap，而 ThreadLocal 是一个<strong>维护类</strong>。我们知道，存储的时候，都是以 ThreadLocal 实例作为 key，然后存储到 ThreadLocalMap 中。当我们调用不同 ThreadLocal 的 set 方法时，如果 ThreadLocalMap 不为空，那么直接在里面存储值就可以了，不需要再创建新的值。也就是说，<strong>同一个线程上的不同 ThreadLocal 对象，存储的值是在同一个 ThreadLocalMap 上</strong>。</p>
<h3 id="没有-ThreadLocal-能不能解决问题？"><a href="#没有-ThreadLocal-能不能解决问题？" class="headerlink" title="没有 ThreadLocal 能不能解决问题？"></a>没有 ThreadLocal 能不能解决问题？</h3><p>能。</p>
<p>可以自己定义一个静态的 map，将当前 thread 作为 key，将目标值作为 value，put 到 map 中，这也是一般人的想法。</p>
<p>ThreadLocal 的实现刚好相反，它是在每个线程中有一个 map，而将 ThreadLocal 实例作为 key，这样每个 map 中的项数很少，而且当线程销毁时相应的东西也一起销毁了。<br>因为各线程访问的 map 是各自不同的 map，所以不需要同步，速度会快些；而如果把所有线程要用的对象都放到一个静态 map中的话 多线程并发访问需要进行同步。</p>
<p>所以说 ThreadLocal 只是实现线程私有变量的一种方式。但是综合来看这种方式相比其他实现方式要更好。</p>
<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>我们通常会用下面的方式为普通线程创建一个 Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> Handler mHandler;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Looper.prepare();<span class="comment">//为当前线程创建一个 Looper</span></div><div class="line">            mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                    <span class="comment">// process incoming messages here</span></div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Looper.loop();<span class="comment">//开启消息循环</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Android 中每个线程中最多只能有一个 Looper，这种限制就是通过 ThreadLocal 来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</div><div class="line">  	<span class="comment">//创建一个 ThreadLocal 对象，其泛型类型为 Looper，在调用 prepare 之前 sThreadLocal.get() 都返回空。</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div><div class="line">  	<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建 Looper 时会同时创建一个泛型类型为 Looper 的 ThreadLocal 对象。</p>
<p>Looper#prepare()，通过 prepare 方法可以为当前线程创建一个 Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;<span class="comment">//如果线程已经存在 Looper 了</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//为当前线程创建一个 Looper 对象，并将它存储在当前线程的 ThreadLocalMap 中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Looper#myLooper() ，通过该方法可以获取当前线程的 Looper 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果一个对象的引用被多个线程持有，那么即使该对象存在 ThreadLocalMap 中也不是线程的本地变量。</p>
<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过 <code>ThreadLocal.set()</code> 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。 </p>
<p>也就是说，其他线程能否访问，还要看你的 set 进去的对象引用是否被其他线程持有。 如果两个线程都存入同一个对象引用，那就会有线程共享问题。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>我们总结 ThreadLocal 具体是怎么一步一步去为每一个线程创建一个~线程私有变量~的：</p>
<ul>
<li>首先，在每个线程 Thread 内部有一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的成员变量 threadLocals，这个 threadLocals 就是用来存储~线程私有变量的~，键值（key）为当前 ThreadLocal 变量，值 value 为~线程的私有变量~（即 T 类型的变量）。</li>
<li>初始时，在 Thread 里面，threadLocals 为空，当通过 ThreadLocal 变量调用 get() 方法或者 set() 方法，就会对 Thread 类中的 threadLocals 进行初始化，并且以当前 ThreadLocal 变量为 key，以 ThreadLocal 要保存的~线程私有变量~为 value，存到 threadLocals 中。<ul>
<li>注意，如果是 先调用 get() 方法而不是 set() 方法的话，会返回 null</li>
</ul>
</li>
<li>然后在当前线程里面，如果要使用~该线程私有变量~，就可以通过 get 方法在 threadLocals 里面查找。</li>
</ul>
<h2 id="参考与学习资源推荐"><a href="#参考与学习资源推荐" class="headerlink" title="参考与学习资源推荐"></a>参考与学习资源推荐</h2><ul>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解 ThreadLocal</a></li>
<li><a href="http://www.iteye.com/topic/82984" target="_blank" rel="external">ThreadLocal and synchronized 补充</a></li>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">ThreadLocal</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">Java并发编程：深入剖析ThreadLocal</a></li>
<li><a href="http://www.jianshu.com/p/95291228aff7" target="_blank" rel="external">Android关于ThreadLocal的思考和总结</a></li>
</ul>
<p>如果本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 并发 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[明白原理,轻松解决内存泄漏]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/19/%E6%98%8E%E7%99%BD%E5%8E%9F%E7%90%86-%E8%BD%BB%E6%9D%BE%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<p>相信「内存泄漏」 问题，是一个挺让开发者头疼的事情，笔者在回顾以为代码时，惊讶发现：初学 Android 时，许多不修边幅的代码习惯，导致了许多内存泄漏问题，借此分析其原因，把自己挖过的坑补一下，也希望奔跑在 Android 开发道路上的你能够优雅避免。</p>
<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><ul>
<li>对于 C++ 来说，内存泄漏就是 new 出来的对象没有 delete，俗称野指针；</li>
<li>而对于 java 而言，就是存放在堆上的 Object 无法被 GC 正常回收；</li>
</ul>
<a id="more"></a>
<p>分析之前我们先来看看两个基础知识点。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="java-的内存分配简述"><a href="#java-的内存分配简述" class="headerlink" title="java 的内存分配简述"></a>java 的内存分配简述</h3><p>运行时数据区域内存模型图<br><img src="http://gityuan.com/images/jvm/jvm_memory_1.png" alt=""></p>
<ul>
<li>方法区（non-heap）：编译时就分配好，在程序<strong>整个运行期间都存在</strong>。它主要存放静态数据和常量；</li>
<li>栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；</li>
<li>堆区（heap）：通常用来存放 new 出来的对象。由 GC 负责回收。</li>
</ul>
<h3 id="四种不同类型的引用"><a href="#四种不同类型的引用" class="headerlink" title="四种不同类型的引用"></a>四种不同类型的引用</h3><p>GC 过程与对象的引用类型有着很大的联系，下面我们就看看 Java 中（Android 中存在差异）的四种引用： </p>
<ul>
<li>强引用（Strong Reference）:JVM 宁愿抛出 OOM，也不会让 GC 回收存在强引用的对象。</li>
<li>软引用（Soft Reference） ：只有内存不足时，才会被 GC 回收。 </li>
<li>弱引用（weak Reference）：在 GC 时，如果一个对象只存在弱引用，将会被回收 </li>
<li>虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为 GC 回收 Object 的标志。 </li>
</ul>
<p>与 Android 中的差异：<strong>在 2.3 以后版本中，即使内存够用，Android 系统会优先将 SoftReference 的对象提前回收掉</strong>, 其他和 Java 中是一样的。<br>因此谷歌官方建议用 LruCache(least recentlly use 最少最近使用算法)。会将内存控制在一定的大小内, 超出最大值时会自动回收, 这个最大值开发者自己定。</p>
<h2 id="内存泄漏的危害"><a href="#内存泄漏的危害" class="headerlink" title="内存泄漏的危害"></a>内存泄漏的危害</h2><p>内存泄露是内存溢出(OOM)的重要原因之一，会导致 Crash。<br>如果应用程序在消耗光了所有的可用堆空间，那么再试图在堆上分配新对象时就会引起 OOM(Out Of Memory Error)异常，此时应用程序就会崩溃退出。</p>
<h2 id="内存泄漏的典型案例"><a href="#内存泄漏的典型案例" class="headerlink" title="内存泄漏的典型案例"></a>内存泄漏的典型案例</h2><p>要想避免内存泄漏，首先要知道导致内存泄漏的原因。<br><strong>内存泄漏本质原因</strong>:==长生命周期的对象持有短生命周期对象的强/软引用。导致本应该被回收的短生命周期的对象无法被正常回收==。</p>
<p>这么讲可能比较抽象。举个常见的栗子：单例模式中，我们常常在获取单例对象时需要传一个 Context 。单例对象是一个长生命周期的对象（应用程序结束时才终结），而如果我们传递的是某一个 Activity 作为 context,那么这个 Activity 就会因为引用被持有而无法销毁，从而导致内存泄漏。</p>
<p>下面我们来看看导致内存泄漏的常见例子。</p>
<h3 id="永远的-Singleton"><a href="#永远的-Singleton" class="headerlink" title="永远的 Singleton"></a>永远的 Singleton</h3><p>单例的使用在我们的程序中随处可见，因为使用它可以解决我们在程序中重复创建对象的问题。但是<strong>由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏</strong>。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li>应该把传入的 Context 改为同应用生命周期一样长的 Application 中的 Context。</li>
<li>也可以通过重写 Application，提供 getContext 方法,那样就不需要在获取单例时传入 context。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext sContext;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        sContext = getApplicationContext();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getApplicationContext</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> sContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Handler-引发的内存泄漏"><a href="#Handler-引发的内存泄漏" class="headerlink" title="Handler 引发的内存泄漏"></a>Handler 引发的内存泄漏</h3><p>由于 Handler 属于 TLS（Thread Local Storage）变量，导致它的生命周期和 Activity 不一致。因此通过 Handler 来更新 UI 一般很难保证跟 View 或者 Activity 的生命周期一致，故很容易导致无法正确释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerBadActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler_bad);</div><div class="line">        <span class="comment">// 延迟 5min 发送一个消息</span></div><div class="line">        handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//do something</span></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>);</div><div class="line">        <span class="keyword">this</span>.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码中发送了了一个延时 5 分钟执行的 Message，当该 Activity 退出的时候，延时任务（Message）还在主线程的 MessageQueue 中等待，此时的 Message 持有 Handler 的强引用，并且由于 Handler 是 HandlerBadActivity 的<strong>非静态内部类，所以 Handler 会持有一个指向 HandlerBadActivity 的强引用</strong>，所以虽然此时 HandlerBadActivity 调用了 finish 也无法进行内存回收，造成内存泄漏。</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>将 Handler 声明为<strong>静态内部类</strong>，但是要注意如果用到 Context 等外部类的 非static 对象，还是应该使用 ApplicationContext 或者通过弱引用来持有这些外部对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class HandlerGoodActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private static final class MyHandler extends Handler&#123;</div><div class="line">        private final WeakReference&lt;HandlerGoodActivity&gt; mActivity;</div><div class="line">        public MyHandler(HandlerGoodActivity activity)&#123;</div><div class="line">            this.mActivity = new WeakReference&lt;HandlerGoodActivity&gt;(activity);//使用弱引用</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            super.handleMessage(msg);</div><div class="line">            HandlerGoodActivity activity = mActivity.get();</div><div class="line">            if (activity != null)&#123;</div><div class="line">                // do something</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private final MyHandler myHandler = new MyHandler(this);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler_good);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="慎用-static-成员变量"><a href="#慎用-static-成员变量" class="headerlink" title="慎用 static 成员变量"></a>慎用 static 成员变量</h3><p>从前面的介绍我们知道，static 修饰的变量位于内存的方法区，<strong>其生命周期与 App 的生命周期一致</strong>。<br>这必然会导致一系列问题，如果你的 app 进程设计上是长驻内存的，那即使 app 切到后台，这部分内存也不会被释放。</p>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>不要在类初始时初始化静态成员，也就是可以考虑懒加载。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p>
<p>当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/727790-afde094317e73842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同 Context 的应用场景"></p>
<p>说明： </p>
<ul>
<li>NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要==创建一个新的 task 任务队列==。</li>
<li>对于 Dialog 而言，只有在 Activity 中才能创建</li>
</ul>
<h3 id="远离非静态内部类和匿名类，有需要时请使用静态内部类"><a href="#远离非静态内部类和匿名类，有需要时请使用静态内部类" class="headerlink" title="远离非静态内部类和匿名类，有需要时请使用静态内部类"></a>远离非静态内部类和匿名类，有需要时请使用静态内部类</h3><p>为什么要怎么做呢?因为使用非静态内部类和匿名类都会默认持有外部类的引用，如果生命周期不一致，就会导致内存泄漏。</p>
<p>看一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class NestedClassLeakActivity extends AppCompatActivity &#123;</div><div class="line">    </div><div class="line">    class InnerClass &#123;//非静态内部类</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static InnerClass sInner;//指向非静态内部类的静态引用</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_nested_class);</div><div class="line">        if (sInner == null) &#123;</div><div class="line">           sInner = new InnerClass();//创建非静态内部类的实例</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本例中，因为非静态内部类默认会持有外部类的引用，而外部类中又有一个该非静态内部类的静态实例，该静态实例的生命周期和应用的一样长，而静态实例又持有 Activity 的引用，因此导致 Activity 的内存资源不能正常回收。</p>
<h4 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h4><ol>
<li>将该内部类设为静态内部类</li>
<li>也可以将该内部类抽取出来封装成一个单例</li>
</ol>
<h3 id="集合引发的内存泄漏"><a href="#集合引发的内存泄漏" class="headerlink" title="集合引发的内存泄漏"></a>集合引发的内存泄漏</h3><p>我们通常会把一些对象的引用加入到集合容器（比如ArrayList）中，当我们不再需要该对象时（通常会调用 remove 方法），并没有把它的引用从集合中清理掉（其中的一种情况就是 remove 方法没有将不再需要的引用赋值为 null），下面以 ArrayList 的 remove 方法为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">( <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 数组越界检查</span></div><div class="line">    RangeCheck(index);</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 取出要删除位置的元素，供返回使用</span></div><div class="line">    E oldValue = (E) elementData[index];</div><div class="line">   <span class="comment">// 计算数组要复制的数量</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">   <span class="comment">// 数组复制，就是将index之后的元素往前移动一个位置</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">       System. arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                      numMoved);</div><div class="line">   <span class="comment">// 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收</span></div><div class="line">    elementData[--size ] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>elementData[--size ] = null; // Let gc do its work</code> 如果替换为 <code>--size</code>，就会导致已经「移除」的对象因为强引用被集合持有，而无法正常被 gc 回收。</p>
<h3 id="WebView-引发的内存泄漏"><a href="#WebView-引发的内存泄漏" class="headerlink" title="WebView 引发的内存泄漏"></a>WebView 引发的内存泄漏</h3><p>WebView 解析网页时会申请<strong>Native堆内存</strong>用于保存页面元素，当页面较复杂时会有很大的内存占用。如果页面包含图片，内存占用会更严重。并且打开新页面时，为了能快速回退，<strong>之前页面占用的内存也不会释放</strong>。有时浏览十几个网页，都会占用几百兆的内存。这样加载网页较多时，会导致系统不堪重负，最终强制关闭应用，也就是出现应用闪退或重启。</p>
<p>由于占用的都是 <strong>Native 堆内存</strong>，所以<strong>实际占用的内存大小不会显示在常用的 DDMS Heap 工具中</strong>（ DMS Heap 工具看到的只是Java虚拟机分配的内存，即使Native堆内存已经占用了几百兆，这里显示的还只是几兆或十几兆）。只有使用 adb shell 中的一些命令比如 dumpsys meminfo 包名，或者在程序中使用 <code>Debug.getNativeHeapSize()</code> 才能看到 Native 堆内存信息。</p>
<p>据说由于 WebView 的一个 BUG，即使它所在的 Activity(或者Service) 结束也就是 onDestroy() 之后，或者直接调用 WebView.destroy()之后，它所占用这些内存也不会被释放。</p>
<h4 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h4><p>把使用了 WebView 的 Activity (或者 Service) 放在单独的进程里。</p>
<ul>
<li>系统在检测到应用占用内存过大有可能被系统干掉 </li>
<li>也可以在它所在的 Activity(或者 Service) 结束后，调用 <code>System.exit(0)</code>，主动Kill掉进程。由于系统的内存分配是以进程为准的，进程关闭后，系统会自动回收所有内存。</li>
</ul>
<p>使用 WebView 的页面（Activity），在生命周期结束页面退出（onDestory）的时候，主动调用<strong>WebView.onPause()==以及==WebView.destory()</strong>以便让系统释放 WebView 相关资源。</p>
<h3 id="其他常见的引起内存泄漏原因"><a href="#其他常见的引起内存泄漏原因" class="headerlink" title="其他常见的引起内存泄漏原因"></a>其他常见的引起内存泄漏原因</h3><ul>
<li>Android 3.0 以下，Bitmap 在不使用的时候没有使用 recycle() 释放内存。</li>
<li><strong>非静态内部类的静态实例</strong>容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。</li>
<li>警惕<strong>线程未终止造成的内存泄露</strong>；譬如在 Activity 中关联了一个生命周期超过 Activity 的 Thread，在退出 Activity 时切记结束线程。<ul>
<li>一个典型的例子就是 HandlerThread 的 run 方法。该方法在这里是一个死循环，它不会自己结束，线程的生命周期超过了 Activity 生命周期，我们必须手动在 Activity 的销毁方法中中调用 <code>thread.getLooper().quit()</code> 才不会泄露。</li>
</ul>
</li>
<li><strong>对象的注册与反注册没有成对出现</strong>造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。</li>
<li><strong>创建与关闭没有成对出现造成的泄露</strong>；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。</li>
<li>避免代码设计模式的错误造成内存泄露；譬如循环引用，A 持有 B，B 持有 C，C 持有 A，这样的设计谁都得不到释放。</li>
</ul>
<h2 id="内存泄漏的检测工具"><a href="#内存泄漏的检测工具" class="headerlink" title="内存泄漏的检测工具"></a>内存泄漏的检测工具</h2><ul>
<li>LeakCanary 是一个检查内存泄漏的优秀框架。具体用法可以参考 <a href="https://mp.weixin.qq.com/s/0bO5BZ4CMYJbRuY_xf_osw" target="_blank" rel="external">LeakCanary——如何检测 Activity 是否泄漏</a></li>
<li>使用 AS Monitor + MAT 自己分析内存泄漏原因。具体请移步 Google 或 Baidu</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/XILFalxJsbGJjx-ZOEDi7g" target="_blank" rel="external">Android 性能优化 详解内存优化的来龙去脉</a></li>
<li><a href="http://www.cnblogs.com/liushilin/p/5900089.html" target="_blank" rel="external">内存泄漏全解析，从此拒绝ANR，让OOM远离你的身边，跟内存泄漏say byebye</a></li>
<li><a href="https://goo-yao.github.io/2017/02/11/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/#more" target="_blank" rel="external">明白原理，轻松应对Android内存泄漏</a></li>
</ul>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的代理模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/18/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h2><p>代理模式也称为委托模式，为其他对象提供一种代理以控制对这个对象的访问。</p>
<h2 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h2><p>当无法或不想访问某个对象或者访问某个对象存在困难时可以<strong>通过一个代理对象来间接访问</strong>。</p>
<p>为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口（或继承相同的抽象类）</p>
<a id="more"></a>
<h2 id="代理模式的UML类图"><a href="#代理模式的UML类图" class="headerlink" title="代理模式的UML类图"></a>代理模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29449202-6aed8b00-842c-11e7-8e3f-362ead423f2d.png" alt="proxy uml"></p>
<p>角色介绍：</p>
<ul>
<li>Subject 抽象主题类<ul>
<li>主要职责是声明真实主题类与代理的共同接口方法，该类可以是一个抽象类也可以是一个接口</li>
</ul>
</li>
<li>RealSubject 真实主题类<ul>
<li>也称为被委托类或被代理理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。</li>
</ul>
</li>
<li>ProxySubject 代理类<ul>
<li>也称为委托类，持有一个对真实主题类的引用，在其实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。</li>
</ul>
</li>
<li>Client 使用代理类的类</li>
</ul>
<h2 id="代理模式的简单实现"><a href="#代理模式的简单实现" class="headerlink" title="代理模式的简单实现"></a>代理模式的简单实现</h2><p>代理模式大致可分为两大部分，<strong>静态代理和动态代理</strong>。</p>
<p><strong>动态代理</strong>通过反射机制动态地生成代理者的对象，code 阶段不需要知道代理谁，代理的真正对象会在执行阶段确定。</p>
<p>Java 提供一个便捷的动态代理接口 InvocationHandler，实现该接口需要重写其调用方法 invoke。</p>
<p>动态代理通过一个代理类来代理 N 多个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的的耦合关系。</p>
<h3 id="静态代理-vs-动态代理"><a href="#静态代理-vs-动态代理" class="headerlink" title="静态代理 vs 动态代理"></a>静态代理 vs 动态代理</h3><p>相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂。</p>
<ul>
<li>但是静态代理更符合面向对象的原则。</li>
</ul>
<p>实际开发中具体使用哪种方式来实现代理，看自己的偏好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>静态代理和动态代理是从 code 方面来区分代理模式的。</p>
<p>也可以<strong>从其使用范围来区分</strong>不同类型的代理实现：</p>
<ul>
<li><strong>远程代理</strong>（Remote Proxy）为某个对象<strong>在不同的内存地址空间</strong>提供局部代理。</li>
<li><strong>虚拟代理</strong>（Virtual Proxy）使用一个代理对象<strong>表示一个十分耗资源的对象并在真正需要时才创建</strong>。</li>
<li><strong>保护代理</strong>(Protection Proxy)：使用代理<strong>控制对原始对象的访问</strong>。该类型的代理常被<strong>用于原始对象具有不同访问权限</strong>的情况。</li>
<li>智能引用(Smart Reference)：在访问原始对象时执行一些自己的<strong>附加操作并对指向原始对象的引用计数</strong>。</li>
</ul>
<p>静动态代理都可以应用于上述 4 种情形。</p>
<h2 id="Android源码中的代理模式实现"><a href="#Android源码中的代理模式实现" class="headerlink" title="Android源码中的代理模式实现"></a>Android源码中的代理模式实现</h2><p>以 ActivityManager 为例。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29449446-6771e5ce-842d-11e7-935f-d1e5685d43af.png" alt="source code proxy"></p>
<ul>
<li>抽象接口: IActivityManager</li>
<li>代理类 ActivityManagerProxy</li>
<li>被代理类<ul>
<li>ActivityManagerNative(抽象类，并不处理太多的逻辑，大部分逻辑由其子类——ActivityManagerService 承担)</li>
<li>ActivityManagerService(真实部分)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>ActivityManagerService 是系统级的 Service 并且运行于独立的进程空间中，可以通过 ServiceManger 获取到它。</li>
<li>ActivityManagerProxy 运行于自己所处的进程空间中（也就是说，与 ActivityManagerService 运行在不同的进程中）</li>
<li>所以此处源码所实现的代理实质为==远程代理==。</li>
</ul>
<p>ActivityManagerProxy 在实际的逻辑处理并<strong>没有过多地被外部类</strong>使用，Android 中管理与维护 Activity 相关信息的类是另一个叫做 ActivityManager 的类。不过实质上 ActivityManager 大多数逻辑还是由 ActivityManagerProxy 承担。</p>
<p>以 ActivityManager 的 getAppTasks() 方法为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123;</div><div class="line">    ArrayList&lt;AppTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;AppTask&gt;();</div><div class="line">    List&lt;IAppTask&gt; appTasks;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());</div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> numAppTasks = appTasks.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAppTasks; i++) &#123;</div><div class="line">        tasks.add(<span class="keyword">new</span> AppTask(appTasks.get(i)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ActivityManagerNative.getDefault();</code>方法 返回一个 <code>IActivityManager</code> 类型的对象，通过该对象调用其 getAppTasks 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> gDefault.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gDefault 到底是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);<span class="comment">//获取 AMS</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        IActivityManager am = asInterface(b);<span class="comment">//完成创建一个 AMS 的客户端端代理对象—— ActivityManagerProxy</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">return</span> am;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述代码中构造了一个 <code>Singleton&lt;IActivityManager&gt;</code> 类型的 gDefault 对象，其中通过 <code>ServiceManager.getService(&quot;activity&quot;);</code> 获取一个系统级的 Service，而该 Service 实质上就是 AMS，接着调用 asInterface 方法，创建一个 ActivityManagerProxy 对象。</p>
<p>ActivityManagerNative.asInterface 方法的具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static public IActivityManager asInterface(IBinder obj) &#123;</div><div class="line">    if (obj == null) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);</div><div class="line">    if (in != null) &#123;</div><div class="line">        return in;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new ActivityManagerProxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ActivityManagerProxy 的 <code>getTasks</code> 方法，将数据打包跨进程传递给 Server 端的 AMS 处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.RunningTaskInfo&gt; getTasks(<span class="keyword">int</span> maxNum, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException &#123;</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        data.writeInt(maxNum);</div><div class="line">        data.writeInt(flags);</div><div class="line">        mRemote.transact(GET_TASKS_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        reply.readException();</div><div class="line">        ArrayList&lt;ActivityManager.RunningTaskInfo&gt; list = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> N = reply.readInt();</div><div class="line">        <span class="keyword">if</span> (N &gt;= <span class="number">0</span>) &#123;</div><div class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</div><div class="line">                ActivityManager.RunningTaskInfo info =</div><div class="line">                        ActivityManager.RunningTaskInfo.CREATOR</div><div class="line">                                .createFromParcel(reply);</div><div class="line">                list.add(info);</div><div class="line">                N--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        data.recycle();</div><div class="line">        reply.recycle();</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看看 AMS 中的 getTasks 方法的具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;IAppTask&gt; <span class="title">getAppTasks</span><span class="params">(String callingPackage)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> callingUid = Binder.getCallingUid();</div><div class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        ArrayList&lt;IAppTask&gt; list = <span class="keyword">new</span> ArrayList&lt;IAppTask&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"getAppTasks"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mRecentTasks.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                TaskRecord tr = mRecentTasks.get(i);</div><div class="line">                <span class="comment">// Skip tasks that do not match the caller.  We don't need to verify</span></div><div class="line">                <span class="comment">// callingPackage, because we are also limiting to callingUid and know</span></div><div class="line">                <span class="comment">// that will limit to the correct security sandbox.</span></div><div class="line">                <span class="keyword">if</span> (tr.effectiveUid != callingUid) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                Intent intent = tr.getBaseIntent();</div><div class="line">                <span class="keyword">if</span> (intent == <span class="keyword">null</span> ||</div><div class="line">                        !callingPackage.equals(intent.getComponent().getPackageName())) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                ActivityManager.RecentTaskInfo taskInfo =</div><div class="line">                        createRecentTaskInfoFromTaskRecord(tr);</div><div class="line">                AppTaskImpl taskImpl = <span class="keyword">new</span> AppTaskImpl(taskInfo.persistentId, callingUid);</div><div class="line">                list.add(taskImpl);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(ident);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Android-中的-Binder-跨进程通信机制与-AIDL"><a href="#Android-中的-Binder-跨进程通信机制与-AIDL" class="headerlink" title="Android 中的 Binder 跨进程通信机制与 AIDL"></a>Android 中的 Binder 跨进程通信机制与 AIDL</h2><p>四个重要类：</p>
<ul>
<li>Binder Client 类比 PC、终端设备</li>
<li>Binder Server 类比 服务器</li>
<li>Binder Driver（实现在内核中） 类比 路由器</li>
<li>Binder Manager 类比 DNS 服务器</li>
</ul>
<p>因为依赖于抽象，加上本地代理类的存在，所以调用远程方法时，还是与调用本地的普通的方法一样。但是代理类内部需要对参数什么的进行打包处理，然后再通过 Binder 机制，跨进程将数据传递给远程方法，远程方法执行完毕再返回数据。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29453380-021cc0ea-843c-11e7-901d-a7490d12f9ea.jpg" alt="binder 通信大致模型图"></p>
<p>Binder Driver 实现在内核中，主要负责 Binder 通信的建立，以及 Binder数据在进程间的传递和 Binder 引用计数管理/数据包的传输等。</p>
<p>Binder Client 和 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发，</p>
<ul>
<li>对于 Binder Client 而言，它只需要知道自己要使用的 Binder 的名字以及该 <strong>Binder 实体</strong>在 ServerManager 中的 0 号引用即可。<ul>
<li>访问原理：<ul>
<li>通过 0 号引用去访问 ServerManager <strong>获取该 Binder 的引用</strong>，</li>
<li>得到引用后就可以像普通方法调用那样调用 Binder 实体的方法</li>
</ul>
</li>
</ul>
</li>
<li>ServerManager 用来管理 Binder Server（Android 中通常是一个 Service）<ul>
<li>Binder Client 通过它来查询 Binder Server 的引用</li>
<li>ServerManager <strong>是一个标准的 Binder Server</strong>，并且在 Android 中约定其在 Binder 通信过程中的唯一标识（类似于 IP 地址）永远为 0。<ul>
<li>在 IServiceManager 接口中定义有对外开放的接口方法，供客户端访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong>匿名 Binder</strong>。很多时候 Binder Server 会将一个 Binder 实体封装进数据包传递给 Binder Client，而此时 Binder Server 会在该数据包中标注 Binder 实体的位置，Binder Driver 会为该匿名的 Binder 生成实体结点和实体引用，并将该引用传递给 Binder Client。</li>
</ul>
<p>IServiceManager 接口(声明 ServerManger 对外提供的方法、数据 )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IServiceManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">checkService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line"></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></div><div class="line">                <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> String[] listServices() <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPermissionController</span><span class="params">(IPermissionController controller)</span></span></div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String descriptor = <span class="string">"android.os.IServiceManager"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">4</span>;</div><div class="line">    <span class="keyword">int</span> SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Andorid 源码设计模式解析与实战》</p>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 LayoutInflater]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20LayoutInflater/</url>
      <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="系统服务的注册"><a href="#系统服务的注册" class="headerlink" title="系统服务的注册"></a>系统服务的注册</h2><p>什么时候初始化 ContextImpl？</p>
<p>ContextImpl 中有这样一个成员变量，缓存系统服务。<br><code>final Object[] mServiceCache = SystemServiceRegistry.createServiceCache();</code></p>
<p>在 <code>SystemServiceRegistry</code> 中的静态代码块中注册。注册方法如下所示。在 static 代码块中，会注册所有的系统服务。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Statically registers a system service with the context.</div><div class="line"> * This method must be called during static initialization only.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></div><div class="line">        ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</div><div class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</div><div class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以 <code>LAYOUT_INFLATER_SERVICE</code> 为例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">    <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">        &#125;&#125;);</div></pre></td></tr></table></figure></p>
<p><code>CachedServiceFetcher</code> 是一个实现了 <code>ServiceFetcher&lt;T&gt;</code> 接口的抽象类 </p>
<ul>
<li><code>createService</code> 为 <code>CachedServiceFetcher</code> 中的抽象方法，当初始化时会调用该方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Base interface for classes that fetch services.</div><div class="line"> * These objects must only be created during static initialization.</div><div class="line"> */</div><div class="line">static abstract interface ServiceFetcher&lt;T&gt; &#123;</div><div class="line">    T getService(ContextImpl ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;</div><div class="line">    private final int mCacheIndex;</div><div class="line"></div><div class="line">    public CachedServiceFetcher() &#123;</div><div class="line">        mCacheIndex = sServiceCacheSize++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public final T getService(ContextImpl ctx) &#123;</div><div class="line">        final Object[] cache = ctx.mServiceCache;</div><div class="line">        synchronized (cache) &#123;</div><div class="line">            // Fetch or create the service.</div><div class="line">            Object service = cache[mCacheIndex];</div><div class="line">            if (service == null) &#123;//使用了延时加载,第一次调用时才初始化，并将相应服务缓存起来。</div><div class="line">                service = createService(ctx);</div><div class="line">                cache[mCacheIndex] = service;</div><div class="line">            &#125;</div><div class="line">            return (T)service;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract T createService(ContextImpl ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="系统服务的获取"><a href="#系统服务的获取" class="headerlink" title="系统服务的获取"></a>系统服务的获取</h2><p>平时我们都是通过 <code>Context.getSystemService(&quot;服务名字&quot;)</code> 来获取服务。</p>
<p>具体为 ContextImpl 中的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Object getSystemService(String name) &#123;</div><div class="line">    return SystemServiceRegistry.getSystemService(this, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 getSystemService 的实际实现是在 <code>SystemServiceRegistry</code> 中的。</p>
<p><code>SystemServiceRegistry</code> 中有一个 <code>HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;</code> ，该 HashMap 以服务名称为 key，以服务相对应的 ServiceFetcher 作为 value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</div><div class="line">        new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</div></pre></td></tr></table></figure>
<p>具体的获取方法为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Gets a system service from a given context.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</div><div class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</div><div class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据服务名称去获取相应的 ServiceFetcher，</p>
<ul>
<li>如果 <code>ServiceFetcher</code> 不为空，则调用 <code>ServiceFetcher.getService</code> 方法获取相应服务的引用。<ul>
<li>如果是第一次调用会先创建，然后直接返回</li>
<li>否则直接返回缓存的值</li>
</ul>
</li>
<li>如果 <code>ServiceFetcher</code> 为空，则返回 null。</li>
</ul>
<h2 id="深入理解-LayoutInflater"><a href="#深入理解-LayoutInflater" class="headerlink" title="深入理解 LayoutInflater"></a>深入理解 LayoutInflater</h2><h2 id="LayoutInflater的创建"><a href="#LayoutInflater的创建" class="headerlink" title="LayoutInflater的创建"></a>LayoutInflater的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">    &#125;&#125;);</div></pre></td></tr></table></figure>
<p>可见实际实现为 <code>PhoneLayoutInflater</code>（继承了 LayoutInflater）</p>
<p>onCreateView 是其中最重要的方法。为什么说它重要，后面会提到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Override onCreateView to instantiate names that correspond to the</span></div><div class="line">    widgets known to the Widget factory. If we don't find a match,</div><div class="line">    call through to our super class.</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">//为系统内置的控件添加前缀。比如为 TextView 添加前缀，结果为 android.widget.TextView</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">    <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            View view = createView(name, prefix, attrs);</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> view;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            <span class="comment">// In this case we want to let the base class take a crack</span></div><div class="line">            <span class="comment">// at it.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="渲染过程解析"><a href="#渲染过程解析" class="headerlink" title="渲染过程解析"></a>渲染过程解析</h2><p>一般我们在渲染 ListView 或者 RecyclerView 中的列表时，都会调用 <code>inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code> 方法（有时也会使用两个参数的方法）。可以看到该方法内部会调用 <code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</div><div class="line">    return inflate(resource, root, root != null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    final Resources res = getContext().getResources();</div><div class="line">    //代码省略</div><div class="line">    //获取 xml 解析器</div><div class="line">    final XmlResourceParser parser = res.getLayout(resource);</div><div class="line">    try &#123;</div><div class="line">        return inflate(parser, root, attachToRoot);</div><div class="line">    &#125; finally &#123;</div><div class="line">        parser.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    synchronized (mConstructorArgs) &#123;</div><div class="line"></div><div class="line">        final Context inflaterContext = mContext;</div><div class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">        Context lastContext = (Context) mConstructorArgs[0];</div><div class="line">        mConstructorArgs[0] = inflaterContext;</div><div class="line">        //存储父视图</div><div class="line">        View result = root;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 查找根标签</div><div class="line">            int type;</div><div class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line">                // Empty</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String name = parser.getName();</div><div class="line">            if (TAG_MERGE.equals(name)) &#123;</div><div class="line">                //1. 解析 merge 标签</div><div class="line">                rInflate(parser, root, inflaterContext, attrs, false);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 2. 不是 merge 元素就直接解析布局中的视图</div><div class="line"> // Temp is the root view that was found in the xml</div><div class="line">                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                    ViewGroup.LayoutParams params = null;</div><div class="line"></div><div class="line">                    if (root != null) &#123;</div><div class="line">                        // 生成布局参数</div><div class="line">                        params = root.generateLayoutParams(attrs);</div><div class="line">                        if (!attachToRoot) &#123;</div><div class="line">                            //如果 attachToRoot 为 false，就给 temp 设置布局参数</div><div class="line">                            temp.setLayoutParams(params);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // 解析 temp 视图下的所有子 View</div><div class="line">                    rInflateChildren(parser, temp, attrs, true);</div><div class="line"></div><div class="line">                    // 如果 root 不为空并且 attachToRoot 为 true，那么将 temp 添加到 父视图中</div><div class="line">                    if (root != null &amp;&amp; attachToRoot) &#123;</div><div class="line">                        root.addView(temp, params);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    //如果 root 为空 或者 attachToRoot 为 false，返回 xml 中的 root，而不是父视图</div><div class="line">                    if (root == null || !attachToRoot) &#123;</div><div class="line">                        result = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的 inflate 方法主要有以下几步</p>
<ol>
<li>解析 xml 的根标签</li>
<li>如果根标签是 merge，调用 rInflate 进行解析，rInflate 会将 merge 标签下的所有子 View 直接添加到根标签中</li>
<li>如果标签是普通元素，调用 createFromTag </li>
<li>调用 rInflate 解析 temp 根元素下的所有子 View，并且将这些子 View 都添加到 temp 下</li>
<li>返回解析到的根视图。</li>
</ol>
<p>我们先从解析单个元素的 <code>createViewFromTag</code> 方法看起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</div><div class="line">        boolean ignoreThemeAttr) &#123;</div><div class="line">    if (name.equals(&quot;view&quot;)) &#123;</div><div class="line">        name = attrs.getAttributeValue(null, &quot;class&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Apply a theme wrapper, if allowed and one is specified.</div><div class="line">    if (!ignoreThemeAttr) &#123;</div><div class="line">        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</div><div class="line">        final int themeResId = ta.getResourceId(0, 0);</div><div class="line">        if (themeResId != 0) &#123;</div><div class="line">            context = new ContextThemeWrapper(context, themeResId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        View view;</div><div class="line">        //用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段</div><div class="line">        if (mFactory2 != null) &#123;</div><div class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125; else if (mFactory != null) &#123;</div><div class="line">            view = mFactory.onCreateView(name, context, attrs);</div><div class="line">        &#125; else &#123;</div><div class="line">            view = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null) &#123;</div><div class="line">            final Object lastContext = mConstructorArgs[0];</div><div class="line">            mConstructorArgs[0] = context;</div><div class="line">            try &#123;</div><div class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class="line">                    // 解析内置 View 控件</div><div class="line">                    view = onCreateView(parent, name, attrs);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // 解析自定义控件</div><div class="line">                    view = createView(name, null, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mConstructorArgs[0] = lastContext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line">    //代码省略</div></pre></td></tr></table></figure></p>
<p><strong>onCreateView 方法和 createView 方法有何不同</strong>？<br>前面的介绍中，我们有提到 LayoutInlflater 创建的实际类型为 <code>PhoneLayoutInlflater</code> ，PhoneLayoutInlflater 覆写了 onCreateView 方法，该方法就是在 View 的标签名前添加一个 <code>&quot;android.widget.&quot; 或 &quot;android.webkit.&quot; 或 &quot;android.app.&quot;</code>前缀。然后再传递给 createView 解析。</p>
<ul>
<li>也就是说<strong>内置 View 和自定义 View 最终都调用了 createView 进行解析</strong>。</li>
</ul>
<p><strong>为什么要这么设计呢</strong>？<br>这是为了方便开发者在 xml 文件中更方便使用系统内置的 View（只需要写 View 名称而不需要写完整的路径），如果是自定义控件或者第三方库，写完整路径。</p>
<p>createView 的具体实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//根据完整路径的类名通过反射机制构造 View 对象</div><div class="line">public final View createView(String name, String prefix, AttributeSet attrs)</div><div class="line">        throws ClassNotFoundException, InflateException &#123;</div><div class="line">    //从缓存中获取构造函数</div><div class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</div><div class="line">    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123;</div><div class="line">        constructor = null;</div><div class="line">        sConstructorMap.remove(name);</div><div class="line">    &#125;</div><div class="line">    Class&lt;? extends View&gt; clazz = null;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</div><div class="line"></div><div class="line">        // 缓存中找不到构造函数</div><div class="line">        if (constructor == null) &#123;</div><div class="line">            //如果前缀（prefix）不为空，构造完整路径，并且加载该类</div><div class="line">            clazz = mContext.getClassLoader().loadClass(</div><div class="line">                    prefix != null ? (prefix + name) : name).asSubclass(View.class);</div><div class="line">            //代码省略</div><div class="line">            //从 class 对象中获取构造函数</div><div class="line">            constructor = clazz.getConstructor(mConstructorSignature);</div><div class="line">            constructor.setAccessible(true);</div><div class="line">            sConstructorMap.put(name, constructor);</div><div class="line">        &#125; else &#123;</div><div class="line">            //代码省略</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Object[] args = mConstructorArgs;</div><div class="line">        args[1] = attrs;</div><div class="line">        //通过反射构造 View</div><div class="line">        final View view = constructor.newInstance(args);</div><div class="line">        if (view instanceof ViewStub) &#123;</div><div class="line">            // Use the same context when inflating ViewStub later.</div><div class="line">            final ViewStub viewStub = (ViewStub) view;</div><div class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));</div><div class="line">        &#125;</div><div class="line">        return view;</div><div class="line"></div><div class="line">    &#125; </div><div class="line">    //省略各种 catch、finally 代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>createView 方法中，如果控件名有前缀就先构造 View 的完整路径，并且将该类加载到虚拟机中</p>
<ul>
<li>然后获取该类的构造函数并缓存起来，再通过构造函数来创建该 View 的对象，</li>
<li>最后将 View 对象返回，这就是解析单个 View 的过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">void rInflate(XmlPullParser parser, View parent, Context context,</div><div class="line">        AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</div><div class="line">    //获取树的深度</div><div class="line">    final int depth = parser.getDepth();</div><div class="line">    int type;</div><div class="line">    //逐个元素解析</div><div class="line">    while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line"></div><div class="line">        if (type != XmlPullParser.START_TAG) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final String name = parser.getName();</div><div class="line">        </div><div class="line">        if (TAG_REQUEST_FOCUS.equals(name)) &#123;</div><div class="line">            parseRequestFocus(parser, parent);</div><div class="line">        &#125; else if (TAG_TAG.equals(name)) &#123;</div><div class="line">            parseViewTag(parser, parent, attrs);</div><div class="line">        &#125; else if (TAG_INCLUDE.equals(name)) &#123;//解析 include 标签</div><div class="line">            if (parser.getDepth() == 0) &#123;</div><div class="line">                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</div><div class="line">            &#125;</div><div class="line">            parseInclude(parser, context, parent, attrs);</div><div class="line">        &#125; else if (TAG_MERGE.equals(name)) &#123;解析 merge 标签</div><div class="line">            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            //根据元素名进行解析</div><div class="line">            final View view = createViewFromTag(parent, name, context, attrs);</div><div class="line">            final ViewGroup viewGroup = (ViewGroup) parent;</div><div class="line">            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div class="line">            //递归调用进行解析，即深度优先遍历</div><div class="line">            rInflateChildren(parser, view, attrs, true);</div><div class="line">            //将解析到的 View 添加到它的父视图中</div><div class="line">            viewGroup.addView(view, params);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (finishInflate) &#123;</div><div class="line">        parent.onFinishInflate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rInflate() 通过深度优先遍历来构造视图树。每解析到一个 View 元素就会递归调用 rInflate，直到这条路径下的最后一个元素，<br>然后在回溯过来将每个 View 元素添加到它们的 parent 中。</p>
<ul>
<li>通过 rInflate 的解析之后，整棵视图树就构建完毕。当调用了 Activity 的 onResume 之后，之前通过 setContentView 设置的内容就会出现在我们的视野中。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>渲染流程大致如下：</p>
<p>inflate 查找根标签</p>
<ul>
<li>如果是 merge，调用 rInflate</li>
<li>否则，调用 <code>createViewFromTag</code><ul>
<li>如果是系统内置控件（通过名称中是否含有「.」来判断），调用 <code>PhoneLayoutInflater.onCreateView()</code> 方法添加前缀，<ul>
<li>处理后将完整路径传给 <code>LayoutInflater.createView()</code> 方法</li>
</ul>
</li>
<li>否则，直接调用 <code>LayoutInflater.createView()</code> 进行解析。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Android 源码设计模式解析与实战》</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 中子线程真的不能更新UI吗？]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/16/Android%20%E4%B8%AD%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97/</url>
      <content type="html"><![CDATA[<h1 id="Android中子线程真的不能更新UI吗？"><a href="#Android中子线程真的不能更新UI吗？" class="headerlink" title="Android中子线程真的不能更新UI吗？"></a>Android中子线程真的不能更新UI吗？</h1><p>先说结论：Android 中子线程在满足一定的条件下可以更新 UI。</p>
<a id="more"></a>
<h2 id="一个栗子："><a href="#一个栗子：" class="headerlink" title="一个栗子："></a>一个栗子：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.btn1)</div><div class="line">    Button mBtn1;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                mBtn1.setText(<span class="string">"worker thread"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上在 onCreate 方法中新建一个线程对 mBtn1 进行了操作，成功从子线程更新了 ui。</p>
<p>但是如果让线程 sleep 一段时间（比如 300ms），<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        mBtn1.setText(<span class="string">"worker thread"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>那么就很可能会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</div><div class="line">    at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:4788)</div><div class="line">    at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:865)</div><div class="line">    at android.view.ViewGroup.invalidateChild(ViewGroup.java:4106)</div><div class="line">    at android.view.View.invalidate(View.java:10386)</div><div class="line">    at android.view.View.invalidate(View.java:10341)</div><div class="line">    at android.widget.TextView.checkForRelayout(TextView.java:6657)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3696)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3554)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3529)</div><div class="line">    at com.android.rdc.androidsamples.MainActivity$1.run(MainActivity.java:63)</div></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么会报这个错误呢？<br>从出错的堆栈信息中可以异常看到是 <code>ViewRootImpl.checkThread()</code> 方法中抛出的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void checkThread() &#123;</div><div class="line">    if (mThread != Thread.currentThread()) &#123;</div><div class="line">        throw new CalledFromWrongThreadException(</div><div class="line">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在访问UI的时候，ViewRootImpl会去检查当前是哪个线程访问的UI，如果不是主线程，那就会抛出异常：</p>
<p>分析到了这里，其实异常信息对我们帮助也不大了，它只告诉了我们子线程中访问UI在哪里抛出异常。 </p>
<p>而我们会思考：当访问UI时，ViewRootImpl 会调用 checkThread 方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，这是没问题的。但是为什么一开始在 MainActivity 的 onCreate 方法中创建一个子线程访问UI，程序还是正常能跑起来呢？<br>答案就是执行 onCreate 方法的那个时候 ViewRootImpl 还没创建，无法去检查当前线程。那么，ViewRootImpl 创建之前的，程序对 UI 的更新操作是如何进行的呢？这个问题我暂时还没有找出答案，希望有了解的同学能指导一下。</p>
<p>回过头看，抛异常的方法既然是 ViewRootImpl 中的方法，那首先应该去看看 ViewRootImpl 是在哪里、在什么时候被创建的。<br>在 AS 中对 ViewRootImpl 进行查找，发现唯一一个初始化了它的地方是 <code>WindowManagerGlobal.addView()</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void addView(View view, ViewGroup.LayoutParams params,</div><div class="line">        Display display, Window parentWindow) &#123;</div><div class="line">    //代码省略</div><div class="line">    root = new ViewRootImpl(view.getContext(), display);</div><div class="line"></div><div class="line">    view.setLayoutParams(wparams);</div><div class="line"></div><div class="line">    mViews.add(view);</div><div class="line">    mRoots.add(root);</div><div class="line">    mParams.add(wparams);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，该方法创建了一个 ViewRootImpl 并将它添加到一个列表中。</p>
<p>该方法又是什么被调用的呢？对 Window 和 WindowManager 有所了解的同学应该知道，Window 的添加过程。</p>
<p>先来看看 ActivityThread 中的 handleResumeActivity 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final void handleResumeActivity(IBinder token,</div><div class="line">            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</div><div class="line">    //代码省略</div><div class="line">    r = performResumeActivity(token, clearHide, reason);</div><div class="line">    //代码省略</div><div class="line">    </div><div class="line">    r.activity.mVisibleFromServer = true;</div><div class="line">    mNumVisibleActivities++;</div><div class="line">    if (r.activity.mVisibleFromClient) &#123;</div><div class="line">        r.activity.makeVisible();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法内部调用了 <code>performResumeActivity</code> 方法，看这个方法名可以揣测该方法最终会调用 Activity 的 onResume 方法，大致流程如下。</p>
<ul>
<li><code>ActivityThread.performResumeActivity</code>  ==》  <code>ActivityClientRecord.Activity.performResume();</code>  ==》 <code>Instrumentation.callActivityOnResume(this);</code> ==》 <code>Activity.onResume();</code></li>
</ul>
<p>回归正题。执行完 performResumeActivity 方法后，会执行 <code>r.activity.makeVisible()</code>，即调用 Activity 的 makeVisible() 。该方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void makeVisible() &#123;</div><div class="line">    if (!mWindowAdded) &#123;</div><div class="line">        ViewManager wm = getWindowManager();</div><div class="line">        wm.addView(mDecor, getWindow().getAttributes());</div><div class="line">        mWindowAdded = true;</div><div class="line">    &#125;</div><div class="line">    mDecor.setVisibility(View.VISIBLE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此处调用了 <code>WindowManager.addView()</code> 方法。而 WindowManger 是一个接口，它的具体实现为 WindowManagerImpl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</div><div class="line">    applyDefaultToken(params);</div><div class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 mGlobal 为 WindowManagerGlobal，也就是说调用了 <code>WindowManagerGlobal.addView()</code> 创建 ViewRootImpl</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>ViewRootImpl 的创建在 onResume 方法回调之后，而我们一开篇是在 onCreate 方法中创建了子线程并访问 UI，在那个时刻，ViewRootImpl 还没有创建，无法检测当前线程是否是 UI 线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了 300 毫秒后，程序就崩了。很明显 300 毫秒后 ViewRootImpl 已经创建了，可以执行 checkThread 方法检查当前线程。</p>
<p>开篇的例子中我们在 onCreate 方法中创建的子线程访问 UI 是一种极端的情况。实际开发中不会这么做。</p>
<p>下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答：</p>
<blockquote>
<p>子线程可以更新UI，但是需要创建子线程的根视图（RootView），并添加到 WindowManager，还要创建子线程的 Looper。以上条件都满足时，它可以修改它自己创建的根视图中的 UI。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/xyh269/article/details/52728861" target="_blank" rel="external">Android中子线程真的不能更新UI吗？</a></li>
<li><a href="http://blog.csdn.net/u010198148/article/details/51779567" target="_blank" rel="external">多线程学习之–真的不能在子线程里更新UI吗？</a></li>
<li><a href="https://www.zybuluo.com/natsumi/note/736165" target="_blank" rel="external">互联网笔记 Android中子线程真的不能更新UI吗？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的观察者模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/09/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="解决、解耦的钥匙——观察者模式"><a href="#解决、解耦的钥匙——观察者模式" class="headerlink" title="解决、解耦的钥匙——观察者模式"></a>解决、解耦的钥匙——观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式定义了对象间一种<strong>一对多</strong>的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>关联行为场景<ul>
<li>需要注意的是，关联行为是可拆分的，而不是“组合”关系</li>
</ul>
</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>
<a id="more"></a>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p>UML 类图如下所示：<br><img src="https://user-images.githubusercontent.com/16668676/29015194-a1c0db10-7b7f-11e7-99a0-437680f88188.png" alt="uml"></p>
<p>四个角色：</p>
<ul>
<li>Subject 抽象主题（抽象的被观察者）。把所有观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，提供接口供添加和删除观察者对象。</li>
<li>ConcreteSubject 具体主题（具体的被观察者）。将有关状态存入具体观察者对象，在具体主题的内部实现发生改变时，给所有注册过的观察者发出通知</li>
<li>Observer 抽象观察者。定义一个更新接口，用来接收主题更改时做出相应的操作（比如更新自身的状态）</li>
<li>ConcreteObserver 具体观察者（实现抽象观察者所定义的更新接口，以便在主题状态更改时更新自身的状态）</li>
</ul>
<h2 id="Android-ListView-的观察者模式"><a href="#Android-ListView-的观察者模式" class="headerlink" title="Android ListView 的观察者模式"></a>Android ListView 的观察者模式</h2><p>ListView 和 RecyclerView 在 Android 中都占据着很重要的地位。</p>
<p>使用这两个组件时，总免不了数据更新的情况：当要更新数据时我们通常都会调用 <code>Adapter.notifyDataSetChanged()</code>，这其中的原理又是怎么样的呢？</p>
<p>下面以 ListView 作为一个栗子，看看其中的具体实现是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void notifyDataSetChanged() &#123;</div><div class="line">    mDataSetObservable.notifyChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void notifyChanged() &#123;</div><div class="line">    synchronized(mObservers) &#123;</div><div class="line">        // since onChanged() is implemented by the app, it could do anything, including</div><div class="line">        // removing itself from &#123;@link mObservers&#125; - and that could cause problems if</div><div class="line">        // an iterator is used on the ArrayList &#123;@link mObservers&#125;.</div><div class="line">        // to avoid such problems, just march thru the list in the reverse order.</div><div class="line">        for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">            mObservers.get(i).onChanged();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>notifyDataSetChanged 方法会调用  <code>DataSetObservable.notifyChanged()</code> 方法,notifyChanged() 内部会遍历调用观察者的 onChanged() 方法。通知数据更新。</li>
<li>但是观察者又是什么时候注册的呢？</li>
</ul>
<p>以下为 setAdapter 的方法的具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setAdapter(ListAdapter adapter) &#123;</div><div class="line">    //如果 已经有 Adapter 存在，先解除注册</div><div class="line">    if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123;</div><div class="line">        mAdapter.unregisterDataSetObserver(mDataSetObserver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resetList();</div><div class="line">    mRecycler.clear();</div><div class="line"></div><div class="line">    if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123;</div><div class="line">        mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter);</div><div class="line">    &#125; else &#123;</div><div class="line">        mAdapter = adapter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mOldSelectedPosition = INVALID_POSITION;</div><div class="line">    mOldSelectedRowId = INVALID_ROW_ID;</div><div class="line"></div><div class="line">    // AbsListView#setAdapter will update choice mode states.</div><div class="line">    super.setAdapter(adapter);</div><div class="line"></div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = mAdapter.getCount();</div><div class="line">        checkFocus();</div><div class="line">        // 构建一个 AdapterDataSetObserver </div><div class="line">        mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">        mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者</div><div class="line"></div><div class="line">        mRecycler.setViewTypeCount(mAdapter.getViewTypeCount());</div><div class="line"></div><div class="line">        int position;</div><div class="line">        if (mStackFromBottom) &#123;</div><div class="line">            position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">        &#125; else &#123;</div><div class="line">            position = lookForSelectablePosition(0, true);</div><div class="line">        &#125;</div><div class="line">        setSelectedPositionInt(position);</div><div class="line">        setNextSelectedPositionInt(position);</div><div class="line"></div><div class="line">        if (mItemCount == 0) &#123;</div><div class="line">            // Nothing selected</div><div class="line">            checkSelectionChanged();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        mAreAllItemsSelectable = true;</div><div class="line">        checkFocus();</div><div class="line">        // Nothing selected</div><div class="line">        checkSelectionChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过源码可以看到，setAdapter 方法内部会构建一个 <code>AdapterDataSetObserver</code> ，然后注册为观察者。我们还可以看到注册的时候是通过 Adapter 来注册的。</p>
<p>Adapter 接口中声明了注册和解注册的方法签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface Adapter &#123;</div><div class="line">    /**</div><div class="line">     * Register an observer that is called when changes happen to the data used by this adapter.</div><div class="line">     *</div><div class="line">     * @param observer the object that gets notified when the data set changes.</div><div class="line">     */</div><div class="line">    void registerDataSetObserver(DataSetObserver observer);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Unregister an observer that has previously been registered with this</div><div class="line">     * adapter via &#123;@link #registerDataSetObserver&#125;.</div><div class="line">     *</div><div class="line">     * @param observer the object to unregister.</div><div class="line">     */</div><div class="line">    void unregisterDataSetObserver(DataSetObserver observer);</div><div class="line">    //代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 BaseAdapter 实现了 ListAdapter 接口，ListAdapter 接口又继承自 Adapter 接口。<br>BaseAdapter 中注册方法和解除注册方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void registerDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.registerObserver(observer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void unregisterDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.unregisterObserver(observer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseAdapter 中注册方法和解除注册方法的具体实现都是通过 mDataSetObservable 来完成的。查看一下 DataSetObservable 的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123;</div><div class="line">    public void notifyChanged() &#123;</div><div class="line">        synchronized(mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void notifyInvalidated() &#123;</div><div class="line">        synchronized (mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onInvalidated();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该类继承了 <code>android.database</code> 包下的 Observable 类，而 Observable 类中存有所有观察者的引用，以及注册和解注册方法。</p>
<p>ListView 中的 onChange 方法具体实现又是什么样的?</p>
<ul>
<li>还记得前面我们说 Observer 是如何注册的吗？注册时，我们构建的是 AdapterDataSetObserver。</li>
<li>该类是 AbsListView 的内部类。<ul>
<li>AbsListView.AdapterDataSetObserver 继承自 AdapterView<listadapter>.AdapterDataSetObserver </listadapter></li>
<li>onChange 方法的主要逻辑都在 AdapterDataSetObserver 中</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class AdapterDataSetObserver extends DataSetObserver &#123;</div><div class="line">    //代码省略 ...</div><div class="line">    @Override</div><div class="line">    public void onChanged() &#123;</div><div class="line">        mDataChanged = true;</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = getAdapter().getCount();</div><div class="line"></div><div class="line">        // Detect the case where a cursor that was previously invalidated has</div><div class="line">        // been repopulated with new data.</div><div class="line">        if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null</div><div class="line">                &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123;</div><div class="line">            AdapterView.this.onRestoreInstanceState(mInstanceState);</div><div class="line">            mInstanceState = null;</div><div class="line">        &#125; else &#123;</div><div class="line">            rememberSyncState();</div><div class="line">        &#125;</div><div class="line">        checkFocus();</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div><div class="line">    //代码省略 ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>onChange 方法中，会获取当前 Adapter 中的数据集的新数量，方法的最后调用 ListView 的 requestLayout() 方法重新进行布局。</p>
<p>从上面的分析中，我们可以看到</p>
<ul>
<li>AbsListView 是抽象的观察者</li>
<li>ListView 是具体的观察者</li>
<li>Adapter 接口是抽象的被观察者</li>
<li>BaseAdapter 是具体的被观察者，其内部实际上是通过 <code>android.database</code> 包下的 Observerable 来实现注册和监听的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>AdapterView 中有一个 AdapterDataSetObserver 内部类，</li>
<li>在 ListView 中设置 Adapter（即调用 ListView 的 setAdapter 方法）时，其内部会构建一个 AdapterDataSetObserver，并注册到 Adapter 中。可见该场景中 ListView 扮演一个观察者角色。</li>
<li>而 Adapter 中有一个数据集可观察者 DataSetObserable。即一个被观察者。</li>
<li>数据集发生变化时，开发者手动调用 Adapter.notifyDataSetChanged 方法，notifyDataSetChanged 会调用 <code>DataSetObserverable.notifyChanged()</code><ul>
<li>notifyChanged() 方法会遍历所有观察者，并调用观察者的 <code>onChanged</code> 方法，</li>
<li>onChanged 会获取 Adapter 中数据集的新数量，同时会调用 View.requestLayout 方法通知 ListView 更新布局，刷新用户界面。</li>
</ul>
</li>
</ul>
<p>虽然 RecyclerView 直接继承自 ViewGroup，而不是 AdapterView ，但是更新列表数据集方法的内部也是通过观察者模式来实现的。只是在其中多提供了单个数据或者指定范围数据更新等回调接口，供开发者使用。感兴趣的同学可以去看看 RecyclerView 中观察者模式的实现。</p>
<p>作者水平有限，疏漏之处，恳请指出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Android 源码设计模式解析与实战》 第十二章 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Toast 原理]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/07/28/Toast%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Toast.makeText(context,”msg”,Toast.Length_SHORT).show();`<br>我们都知道调用了这行代码，便会触发显示 Toast 信息，但是从调用开始到显示出来的具体过程是怎么样的，里面具体实现又是怎么样的呢？</p>
<a id="more"></a>
<p>在 Toast 内部有两类 IPC 过程。</p>
<ul>
<li>第一类： Toast 访问 NotificationManagerService</li>
<li>第二类：NotificationManagerService 回调 Toast 里的 TN 接口。</li>
</ul>
<p>Toast 属于系统 Window，它内部的视图由两种方式指定，一种是系统默认的样式，另一种是自定义一个 view 然后通过 setView 方法将 view 设置进去。<br>不管哪一种方式，它们都对应 Toast 的一个 View 类型的内部成员 mNextView。</p>
<p>Toast 提供 show 和 cancel 方法分别用于显示和隐藏 view，它们的内部都是一个 IPC 过程。</p>
<p>Toast 有定时取消功能，所以系统采用了 Handler（利用其中的 sendMessageDelayed() 方法）</p>
<p>Toast.show() 调用流程大致如下：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28705462-7393612a-73a2-11e7-92b0-5d0ebfb237f0.jpg" alt="toast show"></p>
<p>先来看看 Toast.makeText 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</div><div class="line">    Toast result = new Toast(context);//创建一个新的 Toast 对象</div><div class="line"></div><div class="line">    LayoutInflater inflate = (LayoutInflater)</div><div class="line">            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取 LayoutInflater</div><div class="line">    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); //渲染出系统默认的布局</div><div class="line">    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</div><div class="line">    tv.setText(text);//将我们的信息设置到 TextView 中去</div><div class="line">    </div><div class="line">    result.mNextView = v;//把 view 赋给 Toast 内部的View</div><div class="line">    result.mDuration = duration;//设置 toast 时长</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再瞧一瞧 Toast.show(); 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void show() &#123;</div><div class="line">    if (mNextView == null) &#123;//判断，如果没有设置 Toast 的 view，就抛出异常</div><div class="line">        throw new RuntimeException(&quot;setView must have been called&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INotificationManager service = getService();//获取 INotificationManager </div><div class="line">    String pkg = mContext.getOpPackageName();// 获取调用者的包名</div><div class="line">    TN tn = mTN;//给 TN 赋值</div><div class="line">    tn.mNextView = mNextView;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        service.enqueueToast(pkg, tn, mDuration);</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        // Empty</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面有几个地方看起来比较陌生 INotificationManager 是什么，TN 又是什么？</p>
<p>INotificationManager 的值是从 getService() 方法中得来的。我们先查看下 getService() 的内部实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static private INotificationManager getService() &#123;</div><div class="line">    if (sService != null) &#123;</div><div class="line">        return sService;</div><div class="line">    &#125;</div><div class="line">    sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;));</div><div class="line">    return sService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>了解 Binder 的同学应该一看便知道，这里用到了 Binder。</li>
<li>INotificationManager 的具体实现在 NotificationManagerService 中，简便起见，后续内容将 NotificationManagerService 称为 NMS。</li>
</ul>
<p>TN 又是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TN</span> <span class="keyword">extends</span> <span class="title">ITransientNotification</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable mHide = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            handleHide();</div><div class="line">            <span class="comment">// Don't do this in handleHide() because it is also invoked by handleShow()</span></div><div class="line">            mNextView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManager.LayoutParams mParams = <span class="keyword">new</span> WindowManager.LayoutParams();</div><div class="line">    <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            IBinder token = (IBinder) msg.obj;</div><div class="line">            handleShow(token);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mGravity;</div><div class="line">    <span class="keyword">int</span> mX, mY;</div><div class="line">    <span class="keyword">float</span> mHorizontalMargin;</div><div class="line">    <span class="keyword">float</span> mVerticalMargin;</div><div class="line"></div><div class="line"></div><div class="line">    View mView;</div><div class="line">    View mNextView;</div><div class="line">    <span class="keyword">int</span> mDuration;</div><div class="line"></div><div class="line">    WindowManager mWM;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SHORT_DURATION_TIMEOUT = <span class="number">5000</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LONG_DURATION_TIMEOUT = <span class="number">1000</span>;</div><div class="line"></div><div class="line">    TN() &#123;</div><div class="line">        <span class="comment">// XXX This should be changed to use a Dialog, with a Theme.Toast</span></div><div class="line">        <span class="comment">// defined that sets up the layout params appropriately.</span></div><div class="line">        <span class="keyword">final</span> WindowManager.LayoutParams params = mParams;</div><div class="line">        params.height = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.width = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.format = PixelFormat.TRANSLUCENT;</div><div class="line">        params.windowAnimations = com.android.internal.R.style.Animation_Toast;</div><div class="line">        params.type = WindowManager.LayoutParams.TYPE_TOAST;</div><div class="line">        params.setTitle(<span class="string">"Toast"</span>);</div><div class="line">        params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleShow into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"SHOW: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.obtainMessage(<span class="number">0</span>, windowToken).sendToTarget();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleHide into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HIDE: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.post(mHide);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE SHOW: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView</div><div class="line">                + <span class="string">" mNextView="</span> + mNextView);</div><div class="line">        <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">            <span class="comment">// remove the old view if necessary</span></div><div class="line">            handleHide();</div><div class="line">            mView = mNextView;</div><div class="line">            Context context = mView.getContext().getApplicationContext();</div><div class="line">            String packageName = mView.getContext().getOpPackageName();</div><div class="line">            <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</div><div class="line">                context = mView.getContext();</div><div class="line">            &#125;</div><div class="line">            mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">            <span class="comment">// We can resolve the Gravity here by using the Locale for getting</span></div><div class="line">            <span class="comment">// the layout direction</span></div><div class="line">            <span class="keyword">final</span> Configuration config = mView.getContext().getResources().getConfiguration();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</div><div class="line">            mParams.gravity = gravity;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</div><div class="line">                mParams.horizontalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</div><div class="line">                mParams.verticalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            mParams.x = mX;</div><div class="line">            mParams.y = mY;</div><div class="line">            mParams.verticalMargin = mVerticalMargin;</div><div class="line">            mParams.horizontalMargin = mHorizontalMargin;</div><div class="line">            mParams.packageName = packageName;</div><div class="line">            mParams.hideTimeoutMilliseconds = mDuration ==</div><div class="line">                Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</div><div class="line">            mParams.token = windowToken;</div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeView(mView);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"ADD! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.addView(mView, mParams);</div><div class="line">            trySendAccessibilityEvent();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trySendAccessibilityEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">        AccessibilityManager accessibilityManager =</div><div class="line">                AccessibilityManager.getInstance(mView.getContext());</div><div class="line">        <span class="keyword">if</span> (!accessibilityManager.isEnabled()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// treat toasts as notifications since they are used to</span></div><div class="line">        <span class="comment">// announce a transient piece of information to the user</span></div><div class="line">        AccessibilityEvent event = AccessibilityEvent.obtain(</div><div class="line">                AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);</div><div class="line">        event.setClassName(getClass().getName());</div><div class="line">        event.setPackageName(mView.getContext().getPackageName());</div><div class="line">        mView.dispatchPopulateAccessibilityEvent(event);</div><div class="line">        accessibilityManager.sendAccessibilityEvent(event);</div><div class="line">    &#125;        </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE HIDE: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView);</div><div class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// note: checking parent() just to make sure the view has</span></div><div class="line">            <span class="comment">// been added...  i have seen cases where we get here when</span></div><div class="line">            <span class="comment">// the view isn't yet added, so let's try not to crash.</span></div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeViewImmediate(mView);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TN 是 Toast 的一个私有的静态内部类，继承自 ITransientNotification.Stub </p>
<ul>
<li>也是用到了 Binder 机制。</li>
</ul>
<p>在回到 show 方法。该方法最后调用了 <code>service.enqueueToast(pkg, tn, mDuration);</code> 方法。我们到 NMS 看看该方法的主要实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueToast</span><span class="params">(String pkg, ITransientNotification callback, <span class="keyword">int</span> duration)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="comment">//....</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isSystemToast = isCallerSystem() || (<span class="string">"android"</span>.equals(pkg));<span class="comment">//是否是 android 系统的 toast</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPackageSuspended =</div><div class="line">            isPackageSuspendedForUser(pkg, Binder.getCallingUid());</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">synchronized</span> (mToastQueue) &#123;</div><div class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">        <span class="keyword">long</span> callingId = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ToastRecord record;</div><div class="line">            <span class="keyword">int</span> index = indexOfToastLocked(pkg, callback);<span class="comment">//根据包名和回调来获取的对应包名的 Toast 的在 mToastQueue 中的位置（如果有的话）</span></div><div class="line">            <span class="comment">//如果对应包名的 Toast 已经存在了，则直接在原位更新，不会把它排到队尾</span></div><div class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">                record = mToastQueue.get(index);</div><div class="line">                record.update(duration);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//限制非系统应用的数量（不能超过 50），防止 DOS 攻击同时也是为了解决内存泄漏问题</span></div><div class="line">                <span class="keyword">if</span> (!isSystemToast) &#123;</div><div class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = mToastQueue.size();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">                         <span class="keyword">final</span> ToastRecord r = mToastQueue.get(i);</div><div class="line">                         <span class="keyword">if</span> (r.pkg.equals(pkg)) &#123;</div><div class="line">                             count++;</div><div class="line">                             <span class="keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;</div><div class="line">                                 Slog.e(TAG, <span class="string">"Package has already posted "</span> + count</div><div class="line">                                        + <span class="string">" toasts. Not showing more. Package="</span> + pkg);</div><div class="line">                                 <span class="keyword">return</span>;</div><div class="line">                             &#125;</div><div class="line">                         &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Binder token = <span class="keyword">new</span> Binder();</div><div class="line">                mWindowManagerInternal.addWindowToken(token,</div><div class="line">                        WindowManager.LayoutParams.TYPE_TOAST);</div><div class="line">                record = <span class="keyword">new</span> ToastRecord(callingPid, pkg, callback, duration, token);<span class="comment">//将 Toast 包装为 ToastRecord</span></div><div class="line">                mToastQueue.add(record);<span class="comment">//加入 mToastQueue</span></div><div class="line">                index = mToastQueue.size() - <span class="number">1</span>;</div><div class="line">                keepProcessAliveIfNeededLocked(callingPid);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</div><div class="line">                showNextToastLocked();<span class="comment">//显示下一条 Toast</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(callingId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会将 Toast 请求封装为 ToastRecord 并将其添加进 mToastQueue 队列中。</p>
<ul>
<li>mToastQueue 是一个 ArrayList</li>
<li>注意：每个非系统应用最多只能有 50 个ToastRecord。如果超出了最大值，就会出错。<ul>
<li>这样做主要是为了 防止 DOS（Denial Of Service）</li>
</ul>
</li>
</ul>
<blockquote>
<p>拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
</blockquote>
<p>将 ToastRecord 加入队列之后， <code>enqueueToast</code> 还调用了 <code>showNextToastLocked();</code> 方法, 该方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void showNextToastLocked() &#123;</div><div class="line">    ToastRecord record = mToastQueue.get(0);</div><div class="line">    while (record != null) &#123;</div><div class="line">        if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback);</div><div class="line">        try &#123;</div><div class="line">            record.callback.show(record.token);//调用 record 对象中 callback 的 show 方法</div><div class="line">            scheduleTimeoutLocked(record); //超时提醒，控制显示时间</div><div class="line">            return;</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            //...代码省略</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 callBack 是什么？</p>
<ul>
<li>它是在 ToastRecord 中的，瞅瞅 ToastRecord 的构造方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ToastRecord(<span class="keyword">int</span> pid, String pkg, ITransientNotification callback, <span class="keyword">int</span> duration,</div><div class="line">            Binder token) &#123;</div><div class="line">    <span class="keyword">this</span>.pid = pid;</div><div class="line">    <span class="keyword">this</span>.pkg = pkg;</div><div class="line">    <span class="keyword">this</span>.callback = callback;</div><div class="line">    <span class="keyword">this</span>.duration = duration;</div><div class="line">    <span class="keyword">this</span>.token = token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在 enqueueToast 方法中，将 Toast 包装为 ToastRecord ，创建了 ToastRecord 对象。</p>
<ul>
<li><code>record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord</code> </li>
<li>callBack 是 enqueueToast 中的一个参数，我们的调用如下： <code>service.enqueueToast(pkg, tn, mDuration);</code> </li>
<li><p>没错，callBack 实际上就是前面讲到的 Toast 的内部类 TN。</p>
<ul>
<li>回到前面看看，TN 确实继承了 <code>ITransientNotification.Stub</code>。</li>
</ul>
</li>
<li><p>showNextToastLocked() 方法调用 callBack 的 show() 方法来显示 Toast。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void show(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</div><div class="line">    mHandler.obtainMessage(0, windowToken).sendToTarget();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final Handler mHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        IBinder token = (IBinder) msg.obj;</div><div class="line">        handleShow(token);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其具体实现又是在 handleShow(token);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">        <span class="comment">// 如果有必要的话，将还在显示的 toast 隐藏掉</span></div><div class="line">        handleHide();</div><div class="line">        mView = mNextView;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);<span class="comment">//获取 windowManager</span></div><div class="line">        <span class="comment">//省略代码，给布局参数赋值</span></div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.removeView(mView);</div><div class="line">        &#125;</div><div class="line">        mWM.addView(mView, mParams);</div><div class="line">        trySendAccessibilityEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码核心在于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);`</div><div class="line">`mWM.addView(mView, mParams);`</div></pre></td></tr></table></figure></p>
<p>将 Toast 的视图添加到 Window 中。 这样 View 就能顺利显示出来了。</p>
<p>你可能会问，为什么 TN 调用 show 方法要用到的 Handler ？</p>
<ul>
<li>因为该方法是被是被 NMS 以跨进程方式调用的，因此它们运行在 Binder 线程池中。为了将执行环境切换到 Toast 请求所在的线程，在它们内部使用了 Handler。</li>
</ul>
<p>那么时间到了 Toast 又是怎么样取消的呢？</p>
<ul>
<li><p>在令 Toast 显示方法调用过程中 我们也调用了 <code>scheduleTimeoutLocked(record);</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void scheduleTimeoutLocked(ToastRecord r)&#123;</div><div class="line">    mHandler.removeCallbacksAndMessages(r);</div><div class="line">    Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</div><div class="line">    long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;//设置 延迟时间</div><div class="line">    mHandler.sendMessageDelayed(m, delay);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SHORT_DELAY 为 2s</p>
</li>
<li>LONG_DELAY 为 3.5s</li>
</ul>
<p>scheduleTimeoutLocked 会发出消息给 hanlder,收到相应的信息后 handleMessage 方法会调用<code>handleTimeout((ToastRecord)msg.obj);</code>, 该方法又会调用 <code>cancelToastLocked(index);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelToastLocked</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    ToastRecord record = mToastQueue.get(index);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        record.callback.hide();<span class="comment">//</span></div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到隐藏 Toast 的实现也是在 TN 中的。与 handleShow 对应，有一个 handleHide 方法。<br>该方法会将 Toast 的视图从 Window 中移除。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            mWM.removeViewImmediate(mView);</div><div class="line">        &#125;</div><div class="line">        mView = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建型模式之单例模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/07/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、什么是单例模式？"><a href="#一、什么是单例模式？" class="headerlink" title="一、什么是单例模式？"></a>一、什么是单例模式？</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">wiki</a> 给出的定义如下：单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
<ul>
<li>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</li>
</ul>
<a id="more"></a>
<h2 id="二、为什么要使用单例模式？"><a href="#二、为什么要使用单例模式？" class="headerlink" title="二、为什么要使用单例模式？"></a>二、为什么要使用单例模式？</h2><ul>
<li>有一些对象的内存消耗比较大，创建多次会造成很大的资源开支。</li>
<li>方便配置。<ul>
<li>例如 网络请求经常要用到 cookie，如果使用 OkHttp 可以将其封装为一个单例工具类，内部使用 CookJar 对 cookie  进行管理，这样后续的请求就会方便很多。 </li>
</ul>
</li>
</ul>
<h2 id="三、单例模式的实现方式"><a href="#三、单例模式的实现方式" class="headerlink" title="三、单例模式的实现方式"></a>三、单例模式的实现方式</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明静态对象时就把它初始化。（因为饿，所以迫不及待先把它 new 出来）</p>
<h3 id="2-懒汉模式-26"><a href="#2-懒汉模式-26" class="headerlink" title="2. 懒汉模式 26"></a>2. 懒汉模式 26</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>getInstance</code> 方法中添加了 <code>synchronized</code> 关键字，也就是 </p>
<ul>
<li>一个问题：即使 instance 已经被初始化，之后的每次调用还是会 进行同步，这样会消耗不必要的资源</li>
</ul>
<p>懒汉单例模式的</p>
<ul>
<li>优点：单例只有在使用时才会被实例化，在一定程度上节约了资源。</li>
<li>缺点：第一次加载时需要及时地实例化，反应稍慢，最大的问题是：<strong>每次调用都会进行同步，造成不必要的同步开销</strong>。</li>
</ul>
<h3 id="3-双重校验锁-DCL"><a href="#3-双重校验锁-DCL" class="headerlink" title="3. 双重校验锁 ( DCL )"></a>3. 双重校验锁 ( DCL )</h3><p>DCL 既能够在需要时才初始化实例，又能够保证线程安全，而且单例对象初始化后才调用 getInstance 不进行同步锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class)&#123;</div><div class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="为什么在同步块内还要再进行判空？"><a href="#为什么在同步块内还要再进行判空？" class="headerlink" title="为什么在同步块内还要再进行判空？"></a>为什么在同步块内还要再进行判空？</h4><p>因为<strong>可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了</strong>。</p>
<h4 id="为什么要加-volitale-关键字？"><a href="#为什么要加-volitale-关键字？" class="headerlink" title="为什么要加 volitale 关键字？"></a>为什么要加 volitale 关键字？</h4><p><code>sInstance = new Singleton();</code>这句代码会被编译成多条汇编指令，它大致做了 3 件事情</p>
<ol>
<li>给 Singleton 实例分配内存</li>
<li>调用 Singleton 的构造函数，初始化成员字段</li>
<li>将 sInstance 对象指向分配的内存空间</li>
</ol>
<p>但是由于 Java 编译器允许处理器乱序执行，以及 JDK 1.5 之前 JMM（Java Memory Model， Java 内存模型） 中 cache、寄存器到主内存回写顺序的规定，<br>上面的 2 和 3 的顺序是无法保证的。 如果是 1-3-2，那么当 3 执行完，并且 2 还没有执行的话，被切换到到线程 B，这时 sInstance 已经非空（因为 3 已经被执行了嘛），若 此时线程 B 直接取走 sInstance 使用时就会报错。</p>
<p>解决：JDK 1.5 之后，SUN 官方调整了 JVM，具体化了 volatile 关键字（禁止指令重排序）。 </p>
<ul>
<li>如果是在 JDK 1.5 之后，那么只需要把 sInstance 的声明 改为 <code>private volatile static Singleton sInstance;</code> 即可</li>
</ul>
<h3 id="4-静态内部类单例模式"><a href="#4-静态内部类单例模式" class="headerlink" title="4. 静态内部类单例模式"></a>4. 静态内部类单例模式</h3><p>DCL 在某些情况下会出现失效的问题。这个问题被称为双重检查锁定（DCL）失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123; &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次调用 Singleton 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 SingletonHolder 类，这种方式不仅能够确保线程安全，也能保证单例对象的唯一性。</p>
<p>所以这是推荐使用的单例模式实现方式</p>
<h3 id="5-枚举单例"><a href="#5-枚举单例" class="headerlink" title="5. 枚举单例"></a>5. 枚举单例</h3><p>对枚举不了解可以先看看<a href="https://www.ibm.com/developerworks/cn/java/j-lo-enum/" target="_blank" rel="external">枚举</a>这篇文章</p>
<p>写法简单是枚举单例 最大的优点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    <span class="comment">//枚举内部可以定义成员；</span></div><div class="line">    <span class="keyword">private</span> String mString;</div><div class="line">    <span class="comment">//枚举内部可以定义方法；</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//do sth</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取对象：只需要 Singleton singleton = <code>Singleton.INSTANCE</code>;</p>
<p>枚举在 Java 中与普通的类是一样的，不仅能够有字段，还能定义自己的方法。<br>最重要的是<strong>默认枚举实例的创建是线程安全的</strong>，并且任何情况下它都是一个单例。</p>
<p>上述几种方式中，在一个情况下都会重新创建对象的情况，那就是<strong>反序列化</strong>。</p>
<p>即使构造函数是私有的，反序列化是依然可以通过特殊的途径去创建类的一个新的实例，相当于 调用该类的构造函数。</p>
<p>反序列化操作提供了一耳光很特别的<strong>钩子函数</strong>，类中具有一个私有的、被实例化的方法 <code>readResolve()</code>,这个方法可以让开发人员控制对象的反序列化。</p>
<p>上述几种单例方法中如果要杜绝单例对象在被反序列化时重新生成对象，那必须加入如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">    <span class="keyword">return</span> sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是在 readResolve 方法中将 sInstance 对象返回，而不是默认的重新生成一个新的对象。</p>
<p>而<strong>对于枚举</strong>，并不存在这个问题，因为<strong>即使反序列化也不会重新生成新的实例</strong>。</p>
<h3 id="6-使用容器实现单例模式"><a href="#6-使用容器实现单例模式" class="headerlink" title="6. 使用容器实现单例模式"></a>6. 使用容器实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; sObjectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!sObjectMap.containsKey(key)) &#123;</div><div class="line">            sObjectMap.put(key, instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sObjectMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类型注入到一个统一的管理类中，使用时格根据 key 获取对象对应类型的对象。</p>
<ul>
<li>这种实现方式主要是方便对单例对象进行统一管理。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>不管使用哪一种形式实现单例模式，核心原理都是==将构造函数私有化==，并且==通过静态方法获取唯一的的实例==。</li>
<li>在获取的过程中必须保证线程安全、<strong>防止反序列化导致重新生成实例对象</strong>等问题。</li>
</ul>
<h2 id="使用时的注意点"><a href="#使用时的注意点" class="headerlink" title="使用时的注意点"></a>使用时的注意点</h2><p>避免内存泄漏</p>
<ul>
<li>Android 开发中使用单例模式，如果获取单例对象需要使用 Context，那么尽量使用 ApplicationContext(只要用 <code>contxt.getApplicationContext()</code> 即可获取)。<br>因为如果使用其他 Context（如 Activity)  可能会造成 Activiity 生命周期 执行完成之后，因为其引用被单例所持有，而无法被回收。</li>
<li>多进程环境下，单例模式会失效。</li>
</ul>
<h2 id="Android-源码中的单例模式简述"><a href="#Android-源码中的单例模式简述" class="headerlink" title="Android 源码中的单例模式简述"></a>Android 源码中的单例模式简述</h2><p>我们经常会通过 Context 去获取系统服务，如 LayoutInflater、NetworkStatsManager，这些服务在创建时会以键值对的形式缓存到 HashMap 中，便于管理。</p>
<p>需要时就通过调用  <code>context.getSystemService(String name)</code> 方法获取 。首先会以 name 作为 key，到 hashMap 中查找中相应的服务，如果对应的服务为 null 就创建一个实例，并将该实例缓存到 HashMap 中；如果对应的服务已经存在，则直接返回。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">wiki 单例模式</a></li>
<li><a href="">Android 源码设计模式 单例模式</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 消息机制解析]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>提起 Handler，相信大家都不会陌生，日常开发中不可避免地要使用到它。今天要讲的是消息机制。消息机制？咋听起来有点抽象。其实我们在使用 Handler 的时候，就使用了 Android 的消息机制。</p>
<p>从开发的角度来看，Handler 是 Android 消息机制的<strong>上层接口</strong>，这使得开发过程中只需要设计这方面的内容即可。但是作为一名合格的开发者，弄清它的实现原理是很有必要的。</p>
<a id="more"></a>
<p>俗话说得好，一图胜千言，我们先来看下 Android 消息机制简单示意图（参考自<a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">网络</a>）吧。</p>
<p><img src="http://img.blog.csdn.net/20150801014511416" alt=""></p>
<p>我们把 Thread 比作是一个 发动机，MessageQueue 看作是一条流水线，Message 就像是流水线上的工人，Looper 是流水线下的滚筒，Handler 像是一个工人，它负责把 Message 这个产品送到流水线上，最后又负责把它取走。</p>
<p>这幅图中的各个组件的说明如下：</p>
<ul>
<li>Looper ==》 滚轮</li>
<li>MessageQueue ==》 流水线</li>
<li>Message ==&gt; 流水线上的产品</li>
<li>Handler ==》 扮演把『产品』送进流水线，完了以后又把『产品』取走的角色</li>
<li>Thread ==》 动力</li>
</ul>
<p>另外还有一个重要概念 ——ThreadLocal 图中没有标明出来。下面对各个部分进行详细介绍。</p>
<h1 id="Android-的消息机制分析"><a href="#Android-的消息机制分析" class="headerlink" title="Android 的消息机制分析"></a>Android 的消息机制分析</h1><h2 id="从-Handler-出发"><a href="#从-Handler-出发" class="headerlink" title="从 Handler 出发"></a>从 Handler 出发</h2><p>相信很多做 Android 开发的同学都写过与下面相似的代码。在子线程中做一些耗时操作，比如网络请求，操作完成之后，将返回的数据包装为 Message 对象然后调用 sendMessageXxx 方法，最后在 handleMessage 方法中对结果进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            	<span class="comment">//handle </span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//do sth</span></div><div class="line">            Message message = mHandler.obtainMessage();</div><div class="line">            message.what = <span class="number">1</span>;</div><div class="line">            message.obj = result;</div><div class="line">            mHandler.sendMessage(message);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>Handler.sendMessage(message)</code>  到 <code>Handler.handlerMessage</code>方法经历了什么样的过程？</p>
<p>我们先看看 sendMessage 方法内部是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">        delayMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">      msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个调用流程是这样的 <code>sendMessage ==》 sendMessageDelayed ==》 sendMessageAtTime ==》 enqueueMessage ==》  MessageQueue.enqueueMessage</code></p>
<p>我们可能还会调用 <code>Handler.post(Runnable)</code>方法到目标线程中执行 run 方法。post 方法会先调用 <code>getPostMessage</code>方法将 Runable 包装为 一个 Message 对象，（Runnable 就存储在 callback 中）。其他的 <code>postXxx(Runnable)</code>方法内部实现也是这样的流程，首先将 Runnable 包装为一个 Message 对象然后调用相应的 sendXxx 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;<span class="comment">//将 Runnable 包装为一个 Message 对象</span></div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.callback = r;</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述的调用流程可以看出 sendXxx  或者 postXxx 方法最终都会调用 MessageQueue 的 <code>enqueueMessage</code>方法，将 Message 追加到 MessageQueue 中。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>Handler 的消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。<ul>
<li>post 系列方法最终是通过 send 的一系列方法来实现的。</li>
</ul>
</li>
</ul>
<p><strong>Handler 的发送消息的过程仅仅是向消息队列插入了一条消息</strong>。</p>
<h3 id="MessageQueue-对象是从哪里来的？"><a href="#MessageQueue-对象是从哪里来的？" class="headerlink" title="MessageQueue 对象是从哪里来的？"></a>MessageQueue 对象是从哪里来的？</h3><p>mQueue 是 Handler 的一个成员变量，它是在哪里初始化的呢？先看看 Handler 的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    mLooper = Looper.myLooper();<span class="comment">//获取当前线程的 Looper </span></div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="comment">//抛出异常，不能在没有 Looper 的线程创建 Handler </span></div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;<span class="comment">//从本线程的 Looper 中获取 MessageQueue</span></div><div class="line">    mCallback = callback;<span class="comment">//回调</span></div><div class="line">    mAsynchronous = async;<span class="comment">//是否异步</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到 mQueue 是从 Looper 中取出的。在解说 Looper 之前，我们先看看前面提到的 MessageQueue 。</p>
<h2 id="MessageQueue-的工作原理"><a href="#MessageQueue-的工作原理" class="headerlink" title="MessageQueue 的工作原理"></a>MessageQueue 的工作原理</h2><p>MessageQueue 主要包含两个操作：插入和读取（分别对应 enqueueMessage 和 next 方法）。</p>
<ul>
<li>顾名思义，enqueueMessage 的作用是往队列中插入一条信息。</li>
<li>next() 的作用是从队列中取出一条信息并将其从消息队列中移除。</li>
</ul>
<p>虽然 MessageQueue 名为消息队列，但是它的<strong>内部实现并不是用队列</strong>，而是通过一个<strong>单链表的数据结构</strong>来维护消息列表。</p>
<ul>
<li>为什么选择使用单链表结构？ 因为 Message 是可以定时发送的，若使用普通的队列，当插入一个发送时间晚于队首 Message  发送时间的新 Message，那么就需要插队，实现起来不方便，而使用优先队列又显得比较复杂。因此就采用了单链表实现。</li>
</ul>
<p>接下来我们重点看看 enqueueMessage 方法和 next 方法。</p>
<h3 id="enqueueMessage-方法："><a href="#enqueueMessage-方法：" class="headerlink" title="enqueueMessage 方法："></a>enqueueMessage 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 要进入队列的消息对象的目标 handler 不能为空</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">        <span class="comment">// 要进入队的消息不能处在使用状态</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">            <span class="comment">// 已经调用过 Looper.quit / Looper.quitSafely 方法。 MessageQueue 中不能再追加 Message 对象</span></div><div class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();<span class="comment">//回收消息</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//返回 false 表示入队失败</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 标记消息为使用状态；设置消息发送的时间；是否需要唤醒</span></div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            <span class="comment">//将消息插入到队首</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">          	<span class="comment">//通过该循环找到合适的插入位置（以发送的时间作为排序的标准）</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">//插入队列的指定位置中</span></div><div class="line">            msg.next = p; </div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中不难看出，enqueueMessaege 虽然有点长，但是逻辑还是比较清晰的。它先做了一些状态判断以及一些边界检测，完了以后再进行单链表的插入操作。</p>
<h3 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">      <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>; </div><div class="line">      &#125; </div><div class="line"><span class="comment">//代码省略</span></div><div class="line">      <span class="keyword">for</span> (;;) &#123; </div><div class="line">          <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">              Binder.flushPendingCommands();</div><div class="line">          &#125; </div><div class="line">		<span class="comment">//处理 native 层事件</span></div><div class="line">          nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"> </div><div class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">              <span class="comment">// Try to retrieve the next message.  Return if found. </span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">              Message prevMsg = <span class="keyword">null</span>;</div><div class="line">              Message msg = mMessages;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//如果消息的目标 Handler 为空</span></div><div class="line">                  <span class="keyword">do</span> &#123; <span class="comment">// 找出队列中下一个异步 Message 对象</span></div><div class="line">                      prevMsg = msg;</div><div class="line">                      msg = msg.next;</div><div class="line">                  &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">              &#125; </div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                      <span class="comment">// 计算下一条消息的执行时间，设置一个唤醒的延迟</span></div><div class="line">                      nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123; </div><div class="line">                      <span class="comment">// 队首 Message 执行的时机到了，获取一条消息 </span></div><div class="line">                      mBlocked = <span class="keyword">false</span>; </div><div class="line">                      <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                          prevMsg.next = msg.next;</div><div class="line">                      &#125; <span class="keyword">else</span> &#123; </div><div class="line">                          mMessages = msg.next;</div><div class="line">                      &#125; </div><div class="line">                      msg.next = <span class="keyword">null</span>;</div><div class="line">                      <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                      msg.markInUse();<span class="comment">//标记 Message 为正在使用状态</span></div><div class="line">                      <span class="keyword">return</span> msg;<span class="comment">//返回消息</span></div><div class="line">                  &#125; </div><div class="line">              &#125; <span class="keyword">else</span> &#123; </div><div class="line">                  <span class="comment">// 队列中没有消息了</span></div><div class="line">                  nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">              &#125; </div><div class="line"> </div><div class="line">              <span class="comment">// 既然所有待消息都已经处理好了，那就处理退出消息。 </span></div><div class="line">              <span class="keyword">if</span> (mQuitting) &#123; </div><div class="line">                  dispose(); <span class="comment">//处理底层消息队列。实际上移除了 native 层的消息队列</span></div><div class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>; </div><div class="line">              &#125; </div><div class="line"> </div><div class="line"></div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                      &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                  pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">              &#125; </div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// 没有可运行的闲置 handler。跳出本次循环再等待。</span></div><div class="line">                  mBlocked = <span class="keyword">true</span>; </div><div class="line">                  <span class="keyword">continue</span>; </div><div class="line">              &#125; </div><div class="line">		<span class="comment">//代码省略</span></div><div class="line">          &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>next 方法的主要逻辑如下： 从消息队列中依次取出消息，如果这个消息到了执行时间，那么就将该消息返回给 Looper，并且将消息队列链表的指针后移。</p>
<p>next 方法中有一个死循环，其主要逻辑如下:</p>
<ul>
<li>如果消息队列中没有消息，那么 next 会一直阻塞在那里。<ul>
<li>当队首的消息设置了延迟执行时，会造成短时间的阻塞。</li>
</ul>
</li>
<li>当有新消息到来时，next 方法会返回这条信息并将其从单链表中移除。</li>
</ul>
<p>当调用了 quit 方法之后，mQuitting 为 true ，next 方法会移除 native 层的消息队列并返回 null。</p>
<p>我们是不是该说下 Looper 了，下下个就到它了，在此之前需要先看看 ThreadLocal 相关知识。</p>
<h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><p>ThreadLocal  是一个<strong>线程内部的数据存储类</strong>，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>使用场景：</p>
<ol>
<li>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑采用 ThrradLocal。<ul>
<li>在 Android 中，Looper 类就是利用了 ThreadLocal 的特性，保证<strong>每个线程只存在一个 Looper 对象</strong>。</li>
</ul>
</li>
<li>复杂逻辑下的对象传递。<ul>
<li>比如监听器的传递。</li>
</ul>
</li>
</ol>
<p>从 ThreadLocal 的 set 和 get 方法 可以看出，它们所操作的对象都是<strong>当前线程的 localValues 对象的 table 数组</strong>，因此在不同的线程中访问同一个 ThreadLocal 的 get 和 set 方法，他们对 ThreadLocal 所做的读/写操作仅限于各自线程的内部。</p>
<p>关于 ThreadLocal 的具体介绍请见 <a href="https://ivanljt.github.io/blog/2017/08/21/谈谈-ThreadLocal/#more">这篇文章</a></p>
<p>理解 ThreadLocal 对后面理解 Looper 有很大的帮助，建议先细看 ThreadLocal  的内容再看后面的内容。</p>
<h2 id="Looper-的工作原理"><a href="#Looper-的工作原理" class="headerlink" title="Looper 的工作原理"></a>Looper 的工作原理</h2><p>Android 的官方文档中是这么介绍 Looper 的：</p>
<blockquote>
<p>  Looper 是一个用来为单个线程运行消息循环的类。<strong>默认情况下线程是没有一个 Looper 跟他们相关联的</strong>。如果一个线程需要 looper 的话，可以通过先调用 prepare() 方法初始化一个本线程的 Looper 实例。然后调用 loop 方法让它开始处理信息，一直到循环结束。</p>
<p>  我们通常通过 Handler 类与 Looper 的打交道。</p>
</blockquote>
<p>一个 线程最多只能有一个 Looper，一个 Looper 中有一个消息队列（前面 Hanlder 中的 MessageQueue 对象就是从 Looper 中取出的），并且持有它所在线程的引用。Looper 就像一个「死循环」（通过 quit 或者 quitSafely 方法可以退出），它会不断地从 MessageQueue 中查看是否有新消息。如果有，就调用 handler.dispatchMessage 方法进行处理；如果没有，就一直阻塞在那里。</p>
<h3 id="创建-Looper"><a href="#创建-Looper" class="headerlink" title="创建 Looper"></a>创建 Looper</h3><p>我们先看看 Looper 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建一个消息队列</span></div><div class="line">    mThread = Thread.currentThread(); <span class="comment">//把当前线程的对象保存起来</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Looper 构造方法中创建了一个消息队列，并且会保存当前线程对象。</p>
<h4 id="创建普通线程上的-Looper"><a href="#创建普通线程上的-Looper" class="headerlink" title="创建普通线程上的 Looper"></a>创建普通线程上的 Looper</h4><p>Looper 的构造方法是私有的，那么要创建一个 Looper。？<br><strong>调用 <code>Looper.prepare()</code>即可为当前线程创建一个 Looper 对象，接着通过 <code>Looper.loop()</code> 方法开启消息循环</strong>。要注意的是：在子线程中，如果手动为其创建了 Looper，那么在所有的任务完成之后，需要调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待状态。</p>
<p>我们看下 prepare 方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);<span class="comment">//一个线程最多只能有一个 Looper</span></div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//为当前线程创建一个 Looper </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;<span class="comment">//获取当前线程的 Looper 对象</span></div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建主线程上的-Looper"><a href="#创建主线程上的-Looper" class="headerlink" title="创建主线程上的 Looper"></a>创建主线程上的 Looper</h4><p>有一个要注意的地方就是 Looper 的另一个创建方法 —— prepareMainLooper。</p>
<p>prepareMainLooper 在应用的入口方法（ActivityThread.main() ）中被调用，用来启动主线程的消息循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line"></div><div class="line">    Looper.prepareMainLooper();<span class="comment">//创建主线程的 Looper</span></div><div class="line"></div><div class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">    thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();<span class="comment">//创建主线程的 Handler</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    Looper.loop();<span class="comment">//开启主线程消息循环</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法使得在任何地方都可以获得主线程的消息循环</span></div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">return</span> sMainLooper;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>在应用启动时会开启一个主线程（UI 线程），并且<strong>开启消息循环</strong>，应用不断地从该消息队列中取出、处理消息达到程序运行的结果。</p>
<h3 id="loop-方法"><a href="#loop-方法" class="headerlink" title="loop 方法"></a>loop 方法</h3><p>前面所讲都是 Looper 自身的一些特性，没有提到它是怎么跟其他部分交互的。Looper 与其他 MessageQueue 、Hanlder 的交互主要在 loop 方法中。下面我们来看看 loop 方法的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//获取本线程的 Looper</span></div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);<span class="comment">//调用 loop 方法之前必须先调用 Looper.prepare() 方法创建 Looper</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//获取所在线程的消息队列</span></div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123; </div><div class="line">        Message msg = queue.next(); <span class="comment">// 阻塞方法，如果没有获取到消息，就一直阻塞在这里</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;  <span class="comment">//只有当 msg == null 时才会退出循环</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            msg.target.dispatchMessage(msg);<span class="comment">// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 代码省略</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">        msg.recycleUnchecked();<span class="comment">//调用 Message 的回收方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由源码可见 loop 方法是一个死循环，<strong>唯一跳出循环的方式是 MessageQueue 的 next 方法返回了 null</strong>。</p>
<p>当我们调用 Looper 的 quit 方法时，Looper 会调用 MessageQueue 的 quit 或 quitSafely 方法来通知消息队列退出，否则 loop 方法会一直循环下去。</p>
<p>另外，代码中可以看到，loop 调用了 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 方法会一直阻塞在那里，这也导致了 loop 方法一直阻塞在那里。</p>
<p><code>msg.target.dispatchMessage(msg);</code>// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 <strong>Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理</strong>了。</p>
<p>绕了这么一个大圈意义何在？<br>通常我们都会在子线程中调用 Handler.sendMessageXxx 或者 Handler.postXxx 方法， 而<strong>Handler 的 dispatchMessage 方法是在创建 Handler 的那个线程中执行的，这样就顺利地将代码切换到目标线程中去执行了</strong>。</p>
<h3 id="退出-Looper"><a href="#退出-Looper" class="headerlink" title="退出 Looper"></a>退出 Looper</h3><p>Looper 也是可以退出的（这里的退出 Looper 主要是指跳出 loop 方法中的死循环）。通过调用 Looper 的 quit 方法或者 quitSafely 方法即可。那么这二者有什么区别？</p>
<ul>
<li>调用 Looper 的 quit 方法可以<strong>直接退出</strong>Looper。</li>
<li>调用 Looper 的 quitSafely 方法只是设定了一个<strong>退出标记</strong>，然后把消息队列中<strong>已有的消息处理完才退出</strong> Looper。</li>
</ul>
<p>我们来看看这两个方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Looper.quit</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</div><div class="line">    mQueue.quit(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//Looper.quitSafely</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</div><div class="line">    mQueue.quit(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mQueue 的实际类型为 MessageQueue，Looper 的两个 quit 方法都是通过调用 MessageQueue 的 quit 方法来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);<span class="comment">//主线程的  Looper 无法退出。主线程的 Looper 是通过 prepareMainLooper 方法创建的，创建时调用了 prepare（false），也就是令 mQuitAllowed = false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//是否正在退出</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mQuitting = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (safe) &#123;</div><div class="line">          	<span class="comment">//安全退出,不会取消执行时机早于或等于当前时间的 Message</span></div><div class="line">            removeAllFutureMessagesLocked();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            removeAllMessagesLocked();<span class="comment">//移除 MessageQueue 中所有的消息</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></div><div class="line">        nativeWake(mPtr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MessageQueue.next()</code> 方法片段。当调用了 quit 方法之后会使得 mQuitting 为 true，从而导致  next 方法返回 null，一旦 next 方法返回 null， <code>Looper.loop</code> 就跳出了死循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">    dispose();<span class="comment">//消息 native 层的消息队列。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>MessageQueue.enqueueMessage</code> 方法片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">    IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">            msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">    Log.w(TAG, e.getMessage(), e);</div><div class="line">    msg.recycle();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里实现可以看到，调用了 Looper.quit / quitSafely 方法之后，再通过 Handler 发送的消息无法添加到 MessageQueue 中，此时 Handler 的 send 方法会返回 false。</p>
<h2 id="回到-Handler"><a href="#回到-Handler" class="headerlink" title="回到 Handler"></a>回到 Handler</h2><p> Looper 的 loop 方法中有这样一行代码 <code>msg.target.dispatchMessage(msg);</code>该方法调用的就是 Handler.dispatchMessage 方法。dispatchMessage 方法会根据情况对 Message 进行分发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);<span class="comment">//回调执行 Runnable 的 run 方法</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;<span class="comment">//执行创建 Handler 时指定的 Callback.handleMessage 方法</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);<span class="comment">//执行 handleMessage(msg) 方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;<span class="comment">// Callback 接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;<span class="comment">//空实现，需要由子类覆写</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">    message.callback.run(); <span class="comment">// callback 的实际类型为 Runnable，这行代码的作用就是回调 Runnable 的 run 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler 的工作主要包含<strong>消息的发送</strong>和<strong>接收</strong>过程（还有一个「分发过程」）。  </p>
<ul>
<li>消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。<ul>
<li>post 系列方法最终是通过 send 的一系列方法来实现的。</li>
</ul>
</li>
</ul>
<p>查看源码不难发现，Handler 的发送消息的过程仅仅是向 MessageQueue 插入了一条 Message，MessageQueue 的 next 方法就会返回此 Message 给 Looper， Looper 在 loop 方法中对 Message 进行处理，最终由 Looper 交回给 Handler 处理（调用 Handler 的 dispatchMessage 方法）。</p>
<h2 id="数量关系"><a href="#数量关系" class="headerlink" title="数量关系"></a>数量关系</h2><p>一个线程最多只能有一个 Looper ，一个 MessageQueue，可以有多个 Handler。</p>
<p>MessageQueue 封装在 Looper 中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Looper 对象封装了消息队列，Looper 对象被封装在 ThreadLocal 中，是线程私有的，不同线程之间的 Looper 无法共享。Handler 通过与 Looper 之间的绑定来实现与执行线程之间的绑定，handler 发送消息时会将 Message 对象追加到与线程相关的消息队列中，然后由 Looper 回调它的分发消息方法，根据情况处理消息。</p>
<p>最后我们看一张完整的流程图（图片参考自<a href="http://www.jianshu.com/p/9fe944ee02f7" target="_blank" rel="external">Handler 异步通信机制全面解析</a>），笔者修改了原图中的 Handler dispatchMessage  方法描述。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29739304-0513811c-8a6d-11e7-8a78-510d3c98feb7.png" alt=""></p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">理解 Java 中的 ThreadLocal </a></li>
<li><a href="https://ivanljt.github.io/blog/2017/08/21/%E8%B0%88%E8%B0%88-ThreadLocal/#more">谈谈 ThreadLocal</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47115879" target="_blank" rel="external">Android 中 Handler 的使用</a></li>
<li><a href="http://www.jianshu.com/p/9fe944ee02f7" target="_blank" rel="external">Handler 异步通信机制全面解析</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">深入源码解析 Android 中的 Handler,Message,MessageQueue,Looper</a></li>
<li>《Android 开发艺术探索》</li>
<li>《Android 源码设计模式解析与实战》</li>
</ul>
<p>如果本文中有不正确的结论、说法或者表述不清晰的地方，恳请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
