<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[firstblog]]></title>
      <url>https://ivanljt.github.io/tim-lin.github.io/tim-lin.github.io/2017/03/27/firstblog/</url>
      <content type="html"><![CDATA[<p><strong>时间 空间</strong> 折中</p>
<h1 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h1><h2 id="1-1-基础编程模型-4"><a href="#1-1-基础编程模型-4" class="headerlink" title="1.1　基础编程模型　　4"></a>1.1　基础编程模型　　4</h2><h3 id="1-1-1-Java程序的基本结构-4"><a href="#1-1-1-Java程序的基本结构-4" class="headerlink" title="1.1.1　Java程序的基本结构　　4"></a>1.1.1　Java程序的基本结构　　4</h3><h3 id="1-1-2-原始数据类型与表达式-6"><a href="#1-1-2-原始数据类型与表达式-6" class="headerlink" title="1.1.2　原始数据类型与表达式　　6"></a>1.1.2　原始数据类型与表达式　　6</h3><h3 id="1-1-3-语句-8"><a href="#1-1-3-语句-8" class="headerlink" title="1.1.3　 语句　　8"></a>1.1.3　 语句　　8</h3><h3 id="1-1-4-简便记法-9"><a href="#1-1-4-简便记法-9" class="headerlink" title="1.1.4　 简便记法　　9"></a>1.1.4　 简便记法　　9</h3><h3 id="1-1-5-数组-10"><a href="#1-1-5-数组-10" class="headerlink" title="1.1.5　 数组　　10"></a>1.1.5　 数组　　10</h3><h3 id="1-1-6-静态方法-12"><a href="#1-1-6-静态方法-12" class="headerlink" title="1.1.6　 静态方法　　12"></a>1.1.6　 静态方法　　12</h3><h4 id="1-1-6-4-递归"><a href="#1-1-6-4-递归" class="headerlink" title="1.1.6.4 递归"></a>1.1.6.4 递归</h4><p>编写递归代码最重要有以下三点：</p>
<ul>
<li>递归总有一个<strong>最简单的情况</strong>——方法的第一条语句总是一个包含return 的条件语句。</li>
<li>递归调用总是尝试去解决一个<strong>规模更小</strong>的子问题，这样递归才能<strong>收敛到最简单的情况</strong></li>
<li>递归调用的父问题 和 尝试解决的 子问题之间 不应该有交集。</li>
</ul>
<h3 id="1-1-7-API-16"><a href="#1-1-7-API-16" class="headerlink" title="1.1.7　 API　　16"></a>1.1.7　 API　　16</h3><h4 id="1-1-7-4-你自己编写的库"><a href="#1-1-7-4-你自己编写的库" class="headerlink" title="1.1.7.4 你自己编写的库"></a>1.1.7.4 你自己编写的库</h4><p>API的目的是将<strong>调用和实现分离</strong>：除了API中给出的信息，调用者不需要知道实现的其他细节，而实现也不应考虑特殊的应用场景。</p>
<ul>
<li>程序员可以将API看做调用和实现之间的一份契约，它详细说明了每个方法的作用。实现的目标就是能够遵守这份契约。</li>
</ul>
<h3 id="1-1-8-字符串-20"><a href="#1-1-8-字符串-20" class="headerlink" title="1.1.8　 字符串　　20"></a>1.1.8　 字符串　　20</h3><h3 id="1-1-9-输入输出"><a href="#1-1-9-输入输出" class="headerlink" title="1.1.9 输入输出"></a>1.1.9 输入输出</h3><p>在我们的模型中，Java程序可以从<em>命令行参数</em>或者一个名为标准输入流的抽象字符流中获得输入，并将输出写入另一个为<em>标准输出流</em>的字符流中。</p>
<h4 id="1-1-9-4-标准输入"><a href="#1-1-9-4-标准输入" class="headerlink" title="1.1.9.4 标准输入"></a>1.1.9.4 标准输入</h4><p>标准输入流最重要的特点是这些值会在你的程序读取之后消失。只要程序读取一个值，它就不能回退并再次读取它。</p>
<h4 id="1-1-9-5-重定向与管道"><a href="#1-1-9-5-重定向与管道" class="headerlink" title="1.1.9.5 重定向与管道"></a>1.1.9.5 重定向与管道</h4><h3 id="1-1-10-二分查找-28"><a href="#1-1-10-二分查找-28" class="headerlink" title="1.1.10　 二分查找　　28"></a>1.1.10　 二分查找　　28</h3><h3 id="1-1-11-展望-3"><a href="#1-1-11-展望-3" class="headerlink" title="1.1.11　 展望　　3"></a>1.1.11　 展望　　3</h3><h3 id="1-1答疑："><a href="#1-1答疑：" class="headerlink" title="1.1答疑："></a>1.1答疑：</h3><ol>
<li><p>1 / 0 与 1.0 / 0.0 的结果是什么？</p>
<ul>
<li>1.0 / 0.0 = INFINITY</li>
<li>1 / 0编译出错 除零异常 ， <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.ArithmeticException: / by zero</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>一个for循环 和 while形式有什么区别？</p>
</li>
</ol>
<ul>
<li>答：while 循环中的 “递增变量”  在<strong>循环结束后还可以继续使用</strong>。</li>
</ul>
<h4 id="习题1-1-25-使用数学归纳法证明欧几里得算法"><a href="#习题1-1-25-使用数学归纳法证明欧几里得算法" class="headerlink" title="习题1.1.25 使用数学归纳法证明欧几里得算法"></a>习题1.1.25 使用数学归纳法证明欧几里得算法</h4><ul>
<li>欧几里得算法的关键在于证明 gcd(a, b) = gcd(b,a mod b) 的正确性</li>
<li><p>定理：a,b 是整数，则gcd(a, b) = gcd(b,a mod b) </p>
</li>
<li><p>设k，r为整数。设r = a mod b ,则a可表示为  a = r + k*b</p>
</li>
<li>假设d 是{a,b}的公约数，则d整除a，b。而r = a - k*b; 所以d整除r， d也是b和r的公约数。</li>
<li>假设d 是{b,r}的公约数，则d整除b，r。而a = r + k*b  所以d也是a，b的公约数。</li>
<li>所以{a，b}，{b, r}的公因子集合是一样的。特别地{a,b}的最大公因子也是{b,r}的最大公因子。即 gcd(a, b) = gcd(b,a mod b)</li>
</ul>
<h2 id="1-2-数据抽象"><a href="#1-2-数据抽象" class="headerlink" title="1.2 数据抽象"></a>1.2 数据抽象</h2><p><strong>数据类型</strong>指的是一组值和一组对这些值的操作的集合。</p>
<ul>
<li>Java编程的基础主要是使用class关键字构造被称为 <em>引用类型</em> 的数据类型。</li>
<li><em>抽象数据类型（ADT</em>）是一种能够对使用者隐藏数据表示的数据类型。</li>
</ul>
<h3 id="1-2-1-使用抽象数据类型"><a href="#1-2-1-使用抽象数据类型" class="headerlink" title="1.2.1　 使用抽象数据类型"></a>1.2.1　 使用抽象数据类型</h3><h4 id="1-2-1-4-对象"><a href="#1-2-1-4-对象" class="headerlink" title="1.2.1.4 对象"></a>1.2.1.4 对象</h4><ul>
<li>对象是能够承载数据类型的值的实体。</li>
<li>所有对象都有<strong>三大特性</strong>：<ol>
<li><strong>状态</strong>：即类型中的值(实例变量) </li>
<li><strong>标识</strong>：能够将一个对象区别于另一个对象。可以认为对象的标识就是它在<strong>内存中的位置</strong>(每个类都至少有一个构造函数以创建一个对象的标识)</li>
<li><strong>行为</strong>：数据类型的操作()</li>
</ol>
</li>
<li><strong>引用</strong>是访问对象的一种方式。</li>
</ul>
<h3 id="1-2-2-抽象数据类型举例"><a href="#1-2-2-抽象数据类型举例" class="headerlink" title="1.2.2　 抽象数据类型举例"></a>1.2.2　 抽象数据类型举例</h3><h3 id="1-2-3-抽象数据类型的实现"><a href="#1-2-3-抽象数据类型的实现" class="headerlink" title="1.2.3　 抽象数据类型的实现"></a>1.2.3　 抽象数据类型的实现</h3><h4 id="1-2-3-5-API-用例与实现"><a href="#1-2-3-5-API-用例与实现" class="headerlink" title="1.2.3.5 API 用例与实现"></a>1.2.3.5 API 用例与实现</h4><ul>
<li>我们思考的不是应该采取什么行动来来达成某个计算性的目的，而是<strong>用例的需求</strong>。按照下面三步走的方式用抽象数据类型来满足它们。<ul>
<li>用例一般需要什么操作？</li>
<li>数据类型的值应该是什么才能最好地支持这些操作？</li>
</ul>
</li>
</ul>
<ol>
<li>定义一份API：API的作用是将<em>使用和实现分离</em>，以实现模块化编程。</li>
<li>用一个Java类实现API的定义：首先我们选择适当的实例变量，然后再编写构造函数和实例方法。</li>
<li>实现多个测试用例来验证前两步做出的设计决定。</li>
</ol>
<h3 id="1-2-4-更多抽象数据类型的实现"><a href="#1-2-4-更多抽象数据类型的实现" class="headerlink" title="1.2.4　 更多抽象数据类型的实现"></a>1.2.4　 更多抽象数据类型的实现</h3><h4 id="1-2-4-2-维护多个实现"><a href="#1-2-4-2-维护多个实现" class="headerlink" title="1.2.4.2 维护多个实现"></a>1.2.4.2 维护多个实现</h4><p>同一份api的不同实现。<br>通常采用一种<em>非正式的命名约定</em></p>
<ul>
<li>通过前缀性修饰符区别同一份API的不同实现</li>
<li>维护一个没有前缀的参考实现，它应该适合于大多数用例的需求。</li>
</ul>
<h3 id="1-2-5-数据类型的设计"><a href="#1-2-5-数据类型的设计" class="headerlink" title="1.2.5　 数据类型的设计　　"></a>1.2.5　 数据类型的设计　　</h3><p>抽象数据类型是一种向用例隐藏内部表示的数据类型。</p>
<p>我们提倡的编程风格：将大型程序分解为能够独立开发和调试的小型模块（也促进了代码复用）。</p>
<p>Java系统的新实现往往更新了多种数据类型的或静态方法库的实现，但它们的API并没有变化。</p>
<h4 id="1-2-5-8-等价性"><a href="#1-2-5-8-等价性" class="headerlink" title="1.2.5.8 等价性"></a>1.2.5.8 等价性</h4><p>equals 模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">	@Override</div><div class="line">	public boolean equals(Object obj) &#123;</div><div class="line">		//如果引用相同，直接返回true 不需要其他测试工作</div><div class="line">		if (this == obj) &#123;</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">		//对象为空直接返回false</div><div class="line">		if (obj == null) &#123;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">		//两个对象的类不同</div><div class="line">		if (obj.getClass() != this.getClass()) &#123;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">//		//书上没这么用，还是直接getClass比较好</div><div class="line">//		if (!(obj instanceof Date)) &#123;</div><div class="line">//			return false;</div><div class="line">//		&#125;</div><div class="line">		//强制类型</div><div class="line">		Date that = (Date)obj;</div><div class="line">		if (that.day != day) &#123;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">		if (that.year != year) &#123;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">		if (that.mon != mon) &#123;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">		return true;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h4 id="1-2-5-10-不可变性"><a href="#1-2-5-10-不可变性" class="headerlink" title="1.2.5.10 不可变性"></a>1.2.5.10 不可变性</h4><ul>
<li>不可变数据类型，该类型的对象的值在创建之后就无法再被改变（final修饰）<ul>
<li>eg：String</li>
</ul>
</li>
<li>可变数据类型，能够操作并改变对象中的值<ul>
<li>eg：数组 </li>
</ul>
</li>
</ul>
<h4 id="1-2-5-13-断言"><a href="#1-2-5-13-断言" class="headerlink" title="1.2.5.13 断言"></a>1.2.5.13 断言</h4><p><em>契约式设计</em>的编程模型采用的就是断言的思想。</p>
<ul>
<li>数据类型的设计者需要说明<strong>前提条件</strong>（调用某个方法需要满足的条件，如：二分查找需要满足有序）</li>
<li><strong>后置条件</strong>（实现在方法返回时必须达到的要求）</li>
<li><strong>副作用</strong>（方法可能对对象状态产生的任何变更）</li>
</ul>
<h3 id="答疑："><a href="#答疑：" class="headerlink" title="答疑："></a>答疑：</h3><p>要保证含有一个可变的实例变量的数据类型的不可变性，需要得到一个本地副本，称为<em>保护性复制</em>。</p>
<hr>
<h2 id="1-3背包、队列和栈"><a href="#1-3背包、队列和栈" class="headerlink" title="1.3背包、队列和栈"></a>1.3背包、队列和栈</h2><h3 id="1-3-1-API"><a href="#1-3-1-API" class="headerlink" title="1.3.1　 API　　"></a>1.3.1　 API　　</h3><h3 id="1-3-1-4-背包"><a href="#1-3-1-4-背包" class="headerlink" title="1.3.1.4 背包"></a>1.3.1.4 背包</h3><p>背包是一种不支持从中删除的集合数据类型——它的目的是帮助用例收集元素并迭代遍历所有收集到的元素。（当然可以检查背包是否为空或者获取其中的数量的功能还是有的）。</p>
<hr>
<ol>
<li>进出栈的顺序<ul>
<li>进栈的顺序的已经定死了<ul>
<li>abc 依次进。—— a进 … b 进 … c 进 … <ul>
<li>那么区别就只在于进栈之间的出栈元素。 </li>
</ul>
</li>
<li>如果<strong>后面的元素已经出栈</strong>（这里有一个<strong>隐含的条件就是前面的元素已入栈了</strong>），那么前面的未出栈元素一定是逆序出栈。  <ul>
<li>后元素进了，前元素肯定已经进了（只是不知道出来了没有） </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>入队列和出队列的顺序</li>
</ol>
<ul>
<li><p>使用Collection类的Iterator，可以方便的遍历Vector, ArrayList, LinkedList等集合元素，避免通过get()方法遍历时，针对每一种对象单独进行编码。</p>
</li>
<li><p>迭代器模式</p>
</li>
</ul>
<h3 id="1-3-2-集合类数据类型的实现"><a href="#1-3-2-集合类数据类型的实现" class="headerlink" title="1.3.2　 集合类数据类型的实现　　"></a>1.3.2　 集合类数据类型的实现　　</h3><p><a href="https://www.zhihu.com/question/20928981" target="_blank" rel="external">参考</a></p>
<ul>
<li>Java目前还不支持创建 <strong>泛型数组</strong>。因为java的泛型是擦除实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt;[] l = new ArrayList&lt;String&gt;[10];//错误</div><div class="line">List&lt;String&gt;[] l = (ArrayList&lt;String&gt;[] )new Object[10];</div><div class="line"></div><div class="line">Item[] a = (Item[]) new Object[N];//正确</div></pre></td></tr></table></figure>
<h4 id="1-3-2-3-调整数组大小"><a href="#1-3-2-3-调整数组大小" class="headerlink" title="1.3.2.3 调整数组大小"></a>1.3.2.3 调整数组大小</h4><p>以栈为栗子：</p>
<ul>
<li><p>push()中，检查数组是否太小，如果没有多余的空间，就将数组的长度加倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(N == a.length)&#123;</div><div class="line">    resize(a.length * 2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>pop()中， 首先删除栈顶元素。然后数组太大就将它的长度减半。</p>
<ul>
<li>检测条件为栈的大小是否小于数组的四分之一。 </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Item item = a[--N];</div><div class="line">a[N] = null;//防止游离</div><div class="line">if(N &gt; 0 &amp;&amp; N == a.length / 4)&#123; // 另一条件N &gt; 0 勿忘</div><div class="line">    resize(a.length / 2);</div><div class="line">&#125;</div><div class="line">return item;</div></pre></td></tr></table></figure>
<p>调整数组的函数实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void resize(int size)&#123;</div><div class="line">    Item[] tmp = (Item[]) new Object[size];</div><div class="line">    for(int i = 0 ; i &lt; N; i++)&#123;</div><div class="line">        tmp[i] = a[i];</div><div class="line">    &#125;</div><div class="line">    a = tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="1-3-2-4-对象游离"><a href="#1-3-2-4-对象游离" class="headerlink" title="1.3.2.4 对象游离"></a>1.3.2.4 对象游离</h4><p>用数组实现的栈的栗子：</p>
<ul>
<li>对pop的实现中，被弹出的元素的引用仍然在数组中，应该将其置为null。</li>
</ul>
<h4 id="1-3-2-5-迭代"><a href="#1-3-2-5-迭代" class="headerlink" title="1.3.2.5 迭代"></a>1.3.2.5 迭代</h4><p>任意可迭代的集合数据类型需要实现的东西</p>
<ol>
<li>通过实现Iterable接口<ul>
<li>实现iterator方法,返回Iterator</li>
</ul>
</li>
<li>定义一个实现了Iterator接口的 嵌套内部类<ul>
<li>实现 hasNext方法</li>
<li>实现 next方法</li>
<li>remove方法可以放空，或者抛异常</li>
</ul>
</li>
</ol>
<p>数组实现的迭代 栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Iterator&lt;Item&gt; iterator() &#123;</div><div class="line">	return new ReverseArrayIterator();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private class ReverseArrayIterator&lt;Item&gt; implements Iterator&lt;Item&gt;&#123;</div><div class="line">	private int i = N;</div><div class="line">	@Override</div><div class="line">	public boolean hasNext() &#123;</div><div class="line">		return i &gt; 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Item next() &#123;</div><div class="line">		return (Item) a[--i];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void remove()&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>链表实现的迭代栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private class Itr implements Iterator&lt;Item&gt; &#123;</div><div class="line">	Node current = first;</div><div class="line">	@Override</div><div class="line">	public boolean hasNext() &#123;</div><div class="line">		return current != null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Item next() &#123;</div><div class="line">		Item i = current.item;</div><div class="line">		current = current.next;</div><div class="line">		return i;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	public void remove() &#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-3-3-链表"><a href="#1-3-3-链表" class="headerlink" title="1.3.3　 链表　　"></a>1.3.3　 链表　　</h3><blockquote>
<p>定义：链表是一种递归的数据结构，或者为空，或者是一个指向一个结点的引用，该结点含有一个泛型元素和一个指向另一条链表的引用。</p>
</blockquote>
<h3 id="1-3-4-综述"><a href="#1-3-4-综述" class="headerlink" title="1.3.4　 综述"></a>1.3.4　 综述</h3><ul>
<li>使用链式一般都是从某个固定的点开始访问。例如树的根结点。</li>
<li>使用数组，可以随机访问。</li>
</ul>
<p>在研究一个新的应用领域的时，我们将会按照以下步骤识别目标并使用数据结构对象<strong>解决问题</strong>。</p>
<ol>
<li>定义API。</li>
<li><strong>根据特定的应用场景开发用例代码</strong>，先确定客户怎么使用（跟以往的思路有些不同）</li>
<li>描述一种数据结构。（一组值的表示）， 并在API所对应的抽象数据类型的实现中根据它定义类的实例变量。</li>
<li>描述算法（实现一组操作方式），并根据它实现类中的实例方法</li>
<li>分析算法的性能优点。</li>
</ol>
<h2 id="1-4-算法分析"><a href="#1-4-算法分析" class="headerlink" title="1.4 算法分析"></a>1.4 算法分析</h2><p>时间 空间 </p>
<h3 id="1-4-1-科学方法"><a href="#1-4-1-科学方法" class="headerlink" title="1.4.1　 科学方法　　"></a>1.4.1　 科学方法　　</h3><ul>
<li>所设计的实验必须是<em>可重现的</em></li>
<li>所有的假设必须是<em>可证伪的</em></li>
</ul>
<h3 id="1-4-2-观察"><a href="#1-4-2-观察" class="headerlink" title="1.4.2　 观察　　"></a>1.4.2　 观察　　</h3><h3 id="1-4-3-数学模型"><a href="#1-4-3-数学模型" class="headerlink" title="1.4.3　 数学模型　　"></a>1.4.3　 数学模型　　</h3><p>D.E.Knuth 的基本见地：<br>一个程序运行的时间主要和两点有关：</p>
<ul>
<li>执行每条语句的耗时<ul>
<li>取决于计算机、Java编译器和操作系统 </li>
</ul>
</li>
<li>执行每条语句的频率<ul>
<li>取决程序本身 和 输入</li>
</ul>
</li>
</ul>
<blockquote>
<p>定义： 我们用~f(N)表示所有随着N的增大除以f(N)的结果趋近于1的函数。我们用g(N)~f(N)表示g(N)/f(N)的随着N的·增大趋近于1。</p>
</blockquote>
<p>执行最频繁的指令决定了程序执行的时间，称这些指令为<em>内循环</em>。</p>
<p>本书中 </p>
<ul>
<li><strong>性质</strong>表示需要用实验验证的猜想</li>
<li><strong>命题</strong>表示 在某个成本模型下算法的数学性质。</li>
</ul>
<h4 id="附：-循环计算"><a href="#附：-循环计算" class="headerlink" title="附： 循环计算"></a>附： 循环计算</h4><p><a href="https://www.douban.com/note/91775206/" target="_blank" rel="external">ref</a></p>
<h5 id="1-复杂度是线性级别的循环体"><a href="#1-复杂度是线性级别的循环体" class="headerlink" title="1. 复杂度是线性级别的循环体"></a>1. 复杂度是线性级别的循环体</h5><ul>
<li>如果某个循环结构<strong>以线性方式运行n次</strong>,并且循环体的时间复杂度都是O(1),那么该循环的复杂度就是O(n).</li>
<li>即使该循环跳过某些常数部分,只要跳过的部分是线性的,那么该循环体的时间复杂度仍就是O(n).<ul>
<li>下面第二个栗子 以线性方式运行 N/2 次数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(int i = 0; i &lt; N ; i++)&#123;</div><div class="line">    //一系列复杂度为O(1)的步骤....</div><div class="line">&#125;</div><div class="line"></div><div class="line">for(int i = 0; i &lt; N ; i+=2)&#123;</div><div class="line">    //一系列复杂度为O(1)的步骤....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="2-复杂度是对数级别的循环体"><a href="#2-复杂度是对数级别的循环体" class="headerlink" title="2. 复杂度是对数级别的循环体"></a>2. 复杂度是对数级别的循环体</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(int i = 0; i &lt; N ; i*=2)&#123;</div><div class="line">    //一系列复杂度为O(1)的步骤....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>关键概念<br>　　- 循环的时间复杂度等于该<strong>循环体的复杂度</strong>乘以<strong>循环的次数</strong>…</li>
</ul>
<h5 id="3-嵌套循环复杂度分析"><a href="#3-嵌套循环复杂度分析" class="headerlink" title="3. 嵌套循环复杂度分析"></a>3. 嵌套循环复杂度分析</h5><p>先计算内层循环的时间复杂度,然后用内层的复杂度乘以外层循环的次数</p>
<p><a href="http://blog.csdn.net/liulangcheshou/article/details/53243789" target="_blank" rel="external">三层循环参考</a></p>
<h5 id="3-方法调用的复杂度分析"><a href="#3-方法调用的复杂度分析" class="headerlink" title="3. 方法调用的复杂度分析"></a>3. 方法调用的复杂度分析</h5><p>先计算方法体的的时间复杂度.<br><img src="http://algs4.cs.princeton.edu/14analysis/images/classifications.png" alt=""></p>
<h3 id="1-4-4-增长数量级的分类"><a href="#1-4-4-增长数量级的分类" class="headerlink" title="1.4.4　 增长数量级的分类　　"></a>1.4.4　 增长数量级的分类　　</h3><p>各种级别的对应的经典算法是什么</p>
<h4 id="1-4-4-1-常数级别"><a href="#1-4-4-1-常数级别" class="headerlink" title="1.4.4.1 常数级别"></a>1.4.4.1 常数级别</h4><p>普通语句 两个数相加</p>
<h4 id="1-4-4-2-对数级别"><a href="#1-4-4-2-对数级别" class="headerlink" title="1.4.4.2 对数级别"></a>1.4.4.2 对数级别</h4><p>对数的底数和增长的数量级无关（因为不同底数仅相当于一个常数因子）</p>
<h4 id="1-4-4-3-线性级别"><a href="#1-4-4-3-线性级别" class="headerlink" title="1.4.4.3 线性级别"></a>1.4.4.3 线性级别</h4><p>一维数组找出最大元素</p>
<h4 id="1-4-4-4-线性对数级别"><a href="#1-4-4-4-线性对数级别" class="headerlink" title="1.4.4.4 线性对数级别"></a>1.4.4.4 线性对数级别</h4><p>归并排序</p>
<h4 id="1-4-4-5-平方级别"><a href="#1-4-4-5-平方级别" class="headerlink" title="1.4.4.5 平方级别"></a>1.4.4.5 平方级别</h4><p>检查所有元素对</p>
<h4 id="1-4-4-6-立方级别"><a href="#1-4-4-6-立方级别" class="headerlink" title="1.4.4.6 立方级别"></a>1.4.4.6 立方级别</h4><p>检查所有三元组</p>
<h4 id="1-4-4-7-指数级别"><a href="#1-4-4-7-指数级别" class="headerlink" title="1.4.4.7 指数级别"></a>1.4.4.7 指数级别</h4><p>检查所有子集</p>
<h3 id="1-4-5-设计更快的算法"><a href="#1-4-5-设计更快的算法" class="headerlink" title="1.4.5　 设计更快的算法　　"></a>1.4.5　 设计更快的算法　　</h3><p>2sum 计算出数组中和为0的整数对的数量（假设所有元素都是不同的）</p>
<ul>
<li>先进行排序</li>
<li>然后进行二分查找<ul>
<li>二分查找不成功，返回-1，我们不改变计数器的值</li>
<li>二分查找返回的j &gt; i， 计数器的值+1</li>
<li>二分查找的j 在 0 和 i之间，也有a[i] + a[j] = 0;但是不能改变计数器的值,以免重复计数</li>
</ul>
</li>
<li>复杂度 NlogN + logN<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public int twoSumFast(int[] a)&#123;</div><div class="line">    Arrays.sort(a);</div><div class="line">    int cnt = 0;</div><div class="line">    for(int i = 0 ;i&lt;a.length; i++)&#123;</div><div class="line">        if(Binarysearch.rank(-a[i],a) &gt; i) &#123;</div><div class="line">            cnt++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>3sum问题快速解法</p>
<ul>
<li>(假设所有元素各不相同)</li>
<li>复杂度 N^2logN<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int threeSumFast(int[] a)&#123;</div><div class="line">    Arrays.sort(a);</div><div class="line">    int cnt = 0;</div><div class="line">    for(int i = 0; i &lt; a.length; i++)&#123;</div><div class="line">        for(int j = i+1; j &lt; a.length; i++)&#123;</div><div class="line">            if(Binarysearch.rank(-(a[i] + a[j]), a) &gt; j) &#123;</div><div class="line">                cnt++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>本书中会尝试按照以下的方式解决各种算法问题</p>
<ol>
<li>实现并分析问题的一种简单解法，通常称它们为暴力解法</li>
<li>考察算法的各种改进</li>
<li>用实验证明新的算法更快。</li>
</ol>
<h3 id="1-4-6-倍率实验"><a href="#1-4-6-倍率实验" class="headerlink" title="1.4.6　 倍率实验　　"></a>1.4.6　 倍率实验　　</h3><p>开发一个输入生成器来产生实际情况下的各种可能的输入</p>
<ul>
<li>例如使用循环，每次将问题的输入规模增长一倍，再调用方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static double timeTrail(int N) &#123;</div><div class="line">	int MAX = 100000;</div><div class="line">	int[] a = new int[N];</div><div class="line">	for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">		a[i] = StdRandom.uniform(-MAX, MAX);</div><div class="line">	&#125;</div><div class="line">	Stopwatch stopwatch = new Stopwatch();</div><div class="line">	ThreeSum.count(a);</div><div class="line">	return stopwatch.elapsedTime();</div><div class="line">&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	double prev = timeTrail(125);</div><div class="line">	for(int N = 250 ; true; N+=N)&#123;</div><div class="line">		double time = timeTrail(N);</div><div class="line">		StdOut.printf(&quot;%6d %7.1f &quot;, N , time);</div><div class="line">		StdOut.printf(&quot;%5.1f\n&quot;, time / prev);</div><div class="line">		prev = time;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>命题C (倍率定理) 如果T(N) ~ aN^blgN,那么T(2N)/T(N) ~ 2^b。</p>
<ul>
<li>注：一般而言，数学模型的对数项是不能忽略的，但在倍率假设中它在预测性能的公式中并不那么重要。</li>
</ul>
</blockquote>
<h3 id="1-4-7-注意事项"><a href="#1-4-7-注意事项" class="headerlink" title="1.4.7　 注意事项　　"></a>1.4.7　 注意事项　　</h3><p>性能分析无法得到正确的结果 </p>
<ul>
<li>一般都是由于我们的猜想基于的一个或多个假设并不完全正确所造成的。</li>
</ul>
<h3 id="1-4-8-处理对于输入的依赖"><a href="#1-4-8-处理对于输入的依赖" class="headerlink" title="1.4.8　 处理对于输入的依赖　　"></a>1.4.8　 处理对于输入的依赖　　</h3><p>问题所要处理对输入建模。困难点：</p>
<ul>
<li>建立输入模型是不切实际的</li>
<li>对输入的分析可能极端困难 </li>
</ul>
<h4 id="1-4-8-2-对最坏情况下的性能保证"><a href="#1-4-8-2-对最坏情况下的性能保证" class="headerlink" title="1.4.8.2 对最坏情况下的性能保证"></a>1.4.8.2 对最坏情况下的性能保证</h4><blockquote>
<p>命题D。 在Bag、Stack、Queue的链表实现中所有的操作在最坏情况下都是常数级别的</p>
</blockquote>
<h4 id="1-4-8-3-随机化算法"><a href="#1-4-8-3-随机化算法" class="headerlink" title="1.4.8.3 随机化算法"></a>1.4.8.3 随机化算法</h4><p>随机打乱输入</p>
<h4 id="1-4-8-4-操作序列"><a href="#1-4-8-4-操作序列" class="headerlink" title="1.4.8.4 操作序列"></a>1.4.8.4 操作序列</h4><p>例如：栈。先入栈N个值再将它们弹出所得到的性能 跟 N次压入弹出的混合操作序列所得到的性能可能是不同的。</p>
<h4 id="1-4-8-5-均摊分析"><a href="#1-4-8-5-均摊分析" class="headerlink" title="1.4.8.5 均摊分析"></a>1.4.8.5 均摊分析</h4><blockquote>
<p>命题E。在基于可调整大小的数组实现的Stack数据结构中，对空数据结构所进行的任意操作序列对数组的平均访问次数 在最坏情况下 均为常数</p>
<ul>
<li>证明：P125</li>
</ul>
</blockquote>
<h3 id="1-4-9内存"><a href="#1-4-9内存" class="headerlink" title="1.4.9内存"></a>1.4.9内存</h3><table>
<thead>
<tr>
<th>类型</th>
<th>所占字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象的引用 （一般是一个内存的地址）</td>
<td>8</td>
</tr>
<tr>
<td>对象开销</td>
<td>16</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>对象开销</strong>包括<ul>
<li>一个指向对象的类的引用（Mark word）</li>
<li>垃圾回收信息</li>
<li>同步信息</li>
</ul>
</li>
<li><p><strong>填充字节</strong>用来填充字节数 </p>
<ul>
<li>HotSpot的对齐方式是以8字节对齐,所有没有对象最终大小没有到8个字节的倍数的,都会被填充</li>
<li>一般内存的使用都会被填充为8字节（64位计算机中的机器字）</li>
</ul>
</li>
<li><p>当我们说明一个引用所占的内存时，会<em>单独说明</em>它所指向的对象所占用的内存</p>
</li>
</ul>
<h4 id="1-4-9-2链表"><a href="#1-4-9-2链表" class="headerlink" title="1.4.9.2链表"></a>1.4.9.2链表</h4><p>嵌套的非静态（内部)类,还需额外的8个字节（用于一个指向外部类的引用）</p>
<h4 id="1-4-9-3数组"><a href="#1-4-9-3数组" class="headerlink" title="1.4.9.3数组"></a>1.4.9.3数组</h4><p>分析时，画出图像，一个一个对应写出来。</p>
<table>
<thead>
<tr>
<th>数组</th>
<th>字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象开销</td>
<td>16</td>
</tr>
<tr>
<td>int 数组长度</td>
<td>4</td>
</tr>
<tr>
<td>填充字节</td>
<td>？</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>eg：<br>数组 |字节<br>—|—<br>对象开销 | 16<br>int 数组长度 | 4<br>填充字节| 4<br>double|8<br>double|8<br>。。。|<br>double|8</p>
<ul>
<li><p>一个<strong>原始数据类型的数组</strong>一般需要24字节的<strong>头信息</strong></p>
<ul>
<li>16字节的对象开销</li>
<li>4字节（int类型）保存数组长度</li>
<li>4个填充字节</li>
</ul>
</li>
<li><p>一个对象的数组（一个对象的引用的数组），一般需要24字节的头信息</p>
</li>
</ul>
<p>小结</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>近似</th>
</tr>
</thead>
<tbody>
<tr>
<td>int[]</td>
<td>24+4N</td>
<td>~4N</td>
</tr>
<tr>
<td>double[]</td>
<td>24+8N</td>
<td>~8N </td>
</tr>
<tr>
<td>long[]</td>
<td>24+8N</td>
<td>~8N</td>
</tr>
<tr>
<td>Date[]</td>
<td>24+8N + 32N</td>
<td>~40N</td>
</tr>
<tr>
<td>double[][]</td>
<td>24+8M + (24+8N)*M</td>
<td>~8MN</td>
</tr>
</tbody>
</table>
<h4 id="1-4-9-4字符串对象"><a href="#1-4-9-4字符串对象" class="headerlink" title="1.4.9.4字符串对象"></a>1.4.9.4字符串对象</h4><p>三个int值：</p>
<ul>
<li>偏移量</li>
<li>计数器（字符串的长度）</li>
<li>散列值<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//String对象</div><div class="line">public class String&#123;</div><div class="line">    char[] value;</div><div class="line">    int offset;</div><div class="line">    int count;</div><div class="line">    int hash;</div><div class="line">    ....</div><div class="line">|</div></pre></td></tr></table></figure>
</li>
</ul>
<table>
<thead>
<tr>
<th>字符串对象</th>
<th>字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象开销</td>
<td>16</td>
</tr>
<tr>
<td>字符串的值（引用）</td>
<td>8</td>
</tr>
<tr>
<td>偏移量 （int）</td>
<td>4</td>
</tr>
<tr>
<td>字符串的长度（int）</td>
<td>4</td>
</tr>
<tr>
<td>散列值 （int）</td>
<td>4</td>
</tr>
<tr>
<td>填充字节</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>一个长度为N的String对象一般需要使用40字节（String对象本身），加上（24+2N）字节（字符数组），总共（64+2N）字节。</p>
<p>调用subString方法时，会创建一个新的String对象（40字节），但是它会重用相同的value数组（通过偏移量和它的字符串长度来指定 ），因此只占40字节内存。</p>
<h3 id="1-4-10-展望"><a href="#1-4-10-展望" class="headerlink" title="1.4.10　 展望　　"></a>1.4.10　 展望　　</h3><ul>
<li>不要过早优化。</li>
<li>应该注重写出正确清晰的代码。</li>
<li>但是也不能完全忽略性能</li>
</ul>
<h2 id="1-5-案例研究：union-find算法-136"><a href="#1-5-案例研究：union-find算法-136" class="headerlink" title="1.5　 案例研究：union-find算法　　136"></a>1.5　 案例研究：union-find算法　　136</h2><p>先画出图来，再写代码，易理解。</p>
<ul>
<li>用<em>节点</em>（带标签的圆圈）表示触点</li>
<li>用一个节点到另一个结点的箭头表示 <em>链接</em></li>
</ul>
<p>由此得到的<em>数据结构的图像表示</em>使我们<em>理解算法的操作</em>变得相对容易。</p>
<h3 id="1-5-1-动态连通性-136"><a href="#1-5-1-动态连通性-136" class="headerlink" title="1.5.1　 动态连通性　　136"></a>1.5.1　 动态连通性　　136</h3><p>等价关系能够将对象分为多个<strong>等价类</strong>。</p>
<ul>
<li>当且仅当两个对象相连时他们才属于同一个等价类。</li>
</ul>
<h4 id="动态连通性的应用场景"><a href="#动态连通性的应用场景" class="headerlink" title="动态连通性的应用场景"></a>动态连通性的应用场景</h4><h5 id="1-5-1-1-网络"><a href="#1-5-1-1-网络" class="headerlink" title="1.5.1.1 网络"></a>1.5.1.1 网络</h5><p>此程序能够判定我们是否需要在p和q之间架设一条新的连接才能进行通信，或是我们可以通过已有的连接在两者之间建立通信线路。</p>
<h5 id="1-5-1-2-变量名等同性"><a href="#1-5-1-2-变量名等同性" class="headerlink" title="1.5.1.2 变量名等同性"></a>1.5.1.2 变量名等同性</h5><p>在程序中，可以声明多个引用来指向同一对象，这个时候就可以通过为程序中声明的引用和实际对象建立动态连通图来判断哪些引用实际上是指向同一对象。</p>
<h5 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a><a href="http://blog.csdn.net/dm_vincent/article/details/7769159" target="_blank" rel="external">并查集的应用</a></h5><h4 id="对问题的建模"><a href="#对问题的建模" class="headerlink" title="对问题的建模"></a>对问题的建模</h4><p><a href="http://blog.csdn.net/dm_vincent/article/details/7655764" target="_blank" rel="external">并查集 笔记</a></p>
<p>对问题进行建模的时候，先尽量想清楚要解决的问题是什么。<br>就动态连接性这个场景而言，我们要解决的问题可能是：</p>
<ul>
<li>给出两个结点，判断他们是否连通，==如果连通，需要给出具体的路径==<ul>
<li>union-find 属于第一种</li>
</ul>
</li>
<li>给出两个结点，判断他们是否连通，==如果连通，不需要给出具体的路径==<ul>
<li>使用基于DFS的算法</li>
</ul>
</li>
</ul>
<h4 id="1-5-1-3-数学集合"><a href="#1-5-1-3-数学集合" class="headerlink" title="1.5.1.3 数学集合"></a>1.5.1.3 数学集合</h4><p>更高的抽象层次上，可以将输入的所有整数 看做属于不同的数学集合。</p>
<ul>
<li><p>在处理一个整数对p和q时，我们是在<em>判断</em>它们是否<em>属于相同的集合</em></p>
<ul>
<li>如果不是，就将p所属的集合和q所属的集合归并到同一个集合中。</li>
</ul>
</li>
<li><p>将 整数对 称为<em>连接</em></p>
</li>
<li>将 对象 称为<em>触点</em></li>
<li>将 等价类 称为<em>连通分量</em>（简称 分量）</li>
</ul>
<blockquote>
<p><strong>union-find</strong>的成本模型。在研究实现union-find的API的各种算法时，我们统计的是数组的访问次数（无论读写）</p>
</blockquote>
<h4 id="对于动态连通图几种可能的操作"><a href="#对于动态连通图几种可能的操作" class="headerlink" title="对于动态连通图几种可能的操作"></a>对于动态连通图几种可能的操作</h4><ul>
<li>查找节点所属于的组<ul>
<li>数组的位置对应值，即为组号</li>
</ul>
</li>
<li>判断是否属于同一个组<ul>
<li>两个组的组号是否相同</li>
</ul>
</li>
<li>连接两个节点使之属于同一个组<ul>
<li>分别得到两个节点的组号，组号同时 操作结束；不同时，将其中的一个节点的组号换成另一个节点的组号</li>
</ul>
</li>
<li>获取组的总数量<ul>
<li>初始化为节点的总数。每次成功连接两个节点之后，递减1.</li>
</ul>
</li>
</ul>
<p>API<br><img src="http://my.csdn.net/uploads/201206/12/1339479136_7058.png" alt=""></p>
<p>注意其中使用整数来表示节点，如果需要使用其他的数据类型表示节点，比如使用字符串，那么<strong>可以用哈希表来进行映射</strong>，即将String映射成这里需要的Integer类型。</p>
<h3 id="1-5-2-实现-140"><a href="#1-5-2-实现-140" class="headerlink" title="1.5.2　 实现　　140"></a>1.5.2　 实现　　140</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public boolean connected(int p, int q) &#123;</div><div class="line">	return find(q) == find(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int find(int p) &#123;</div><div class="line">	return id[p];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第一种方法， 当且仅当id[p] 与 id[q]的值相等时，p和q是连通的。</div><div class="line">// 即以id[]的值来区分不同的分量。值同就属于同一个分量，不同就属于不同的分量</div><div class="line">public void union(int p, int q) &#123;</div><div class="line">	// 将p和q归并到到相同的分量中</div><div class="line">	int pID = find(p);</div><div class="line">	int qID = find(q);</div><div class="line">	// 如果p和q在同一个分量之中，则不需要采取任何行动。</div><div class="line">	if (pID == qID) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	// 将p的分量重命名为q的名称</div><div class="line">	for (int i = 0; i &lt; id.length; i++) &#123;</div><div class="line">		if (id[i] == qID) &#123;</div><div class="line">			id[i] = pID;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	count--; //前面“局部”操作完以后，需要对“全局”的统计量进行更改</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-5-2-1-quick-find算法"><a href="#1-5-2-1-quick-find算法" class="headerlink" title="1.5.2.1 quick-find算法"></a>1.5.2.1 quick-find算法</h4><p>在同一个连通分量中的所有触点的id[] 中的值必须全部相同。</p>
<h4 id="1-5-2-2-quick-find算法分析"><a href="#1-5-2-2-quick-find算法分析" class="headerlink" title="1.5.2.2 quick-find算法分析"></a>1.5.2.2 quick-find算法分析</h4><blockquote>
<p>命题F。在quick-find算法中，每次find()调用只需访问数组一次，归并两个分量的union操作访问数组的次数在(N+3) 和 (2N+1)之间。</p>
</blockquote>
<h4 id="1-5-2-3-quick-union算法"><a href="#1-5-2-3-quick-union算法" class="headerlink" title="1.5.2.3 quick-union算法"></a>1.5.2.3 quick-union算法</h4><p>考虑一下，为什么以上的quick-find 解法会造成“牵一发而动全身”？因为每个节点所属的组号都是单独记录，各自为政的，没有将它们以更好的方式组织起来，当涉及到修改的时候，除了逐一通知、修改，别无他法。</p>
<p>所以现在的问题就变成了，如何将节点以更好的方式组织起来，组织的方式有很多种，但是最直观的还是将组号相同的节点组织在一起，想想所学的数据结构，什么样子的数据结构能够将一些节点给组织起来？常见的就是链表，图，树，什么的了。但是哪种结构对于查找和修改的效率最高？毫无疑问是树，因此考虑如何将节点和组的关系以树的形式表现出来。</p>
<p>union与find算法是互补的。<br>赋予id[] 数组的值 不同的意义，每一个触点所对应的id[]元素 都是同一个分量中另一个的触点的名称（也可能是自己）</p>
<p>“根节点”作为连通分量的标识。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//建立链接，每一个触点所对应的id[]元素 都是同一个分量中另一个的触点的名称（也可能是自己）</div><div class="line">public int quick_find(int p) &#123;</div><div class="line">	//找出分量的名称</div><div class="line">	while (id[p] != p) &#123;</div><div class="line">		p = id[p]; </div><div class="line">	&#125;</div><div class="line">	return p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//</div><div class="line">public void quick_union(int p ,int q) &#123;</div><div class="line">	//p和q的根触点 （类似于树的根节点）</div><div class="line">	int pRoot = quick_find(p);</div><div class="line">	int qRoot = quick_find(q);</div><div class="line">	if (pRoot == qRoot) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	id[pRoot] = qRoot;</div><div class="line">	</div><div class="line">	count--;// 全局的统计量更改</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="1-5-2-4-森林的表示"><a href="#1-5-2-4-森林的表示" class="headerlink" title="1.5.2.4 森林的表示"></a>1.5.2.4 森林的表示</h4><h4 id="1-5-2-5-quick-union算法分析"><a href="#1-5-2-5-quick-union算法分析" class="headerlink" title="1.5.2.5 quick-union算法分析"></a>1.5.2.5 quick-union算法分析</h4><blockquote>
<p>定义。一棵树的<em>大小</em>是它节点的数量</p>
<ul>
<li>树中的一个节点的<em>深度</em>是它到根节点的路径上的链接数（即 路径节点总数-1） </li>
</ul>
<p>命题G。quick-union算法中的find()方法访问数组的次数为1 加上给触点所对应的节点的深度的两倍。union和connected 访问数组的次数为两次find操作（如果不在同一个分量中还要加1）</p>
</blockquote>
<h4 id="1-5-2-6-加权quick-union算法"><a href="#1-5-2-6-加权quick-union算法" class="headerlink" title="1.5.2.6 加权quick-union算法"></a>1.5.2.6 加权quick-union算法</h4><ul>
<li><p>目的：控制树高。以减少find查询时间。</p>
</li>
<li><p>添加一个数组和一些代码来记录树中的节点数，让比较小（节点数目比较少）的树的根指向比较大（节点数目多）的树的根，（减少find查询时间）改进算法的效率。 </p>
</li>
</ul>
<h4 id="1-5-2-7-加权quick-union算法的分析"><a href="#1-5-2-7-加权quick-union算法的分析" class="headerlink" title="1.5.2.7 加权quick-union算法的分析"></a>1.5.2.7 加权quick-union算法的分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class WeightedQuickUnion &#123;</div><div class="line">	private int[] id;// 父链接数组，由触点索引</div><div class="line">	private int[] sz;// (由触点索引的)各个根节点所对应的分量的大小</div><div class="line">	private int count;// 连通分量的 数量</div><div class="line"></div><div class="line">	public WeightedQuickUnion(int N) &#123;</div><div class="line">		count = N;// 一开始每个节点分属不同的连通分量</div><div class="line">		id = new int[N];</div><div class="line">		for (int i = 0; i &lt; id.length; i++) &#123;</div><div class="line">			id[i] = i;</div><div class="line">		&#125;</div><div class="line">		sz = new int[N];</div><div class="line">		for (int i = 0; i &lt; sz.length; i++) &#123;</div><div class="line">			sz[i] = 1;// 每一个连通分量都只有一个元素，因此均为1</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int count() &#123;</div><div class="line">		return count;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int find(int p) &#123;</div><div class="line">		// 跟随链接找到 根节点</div><div class="line">		while (p != id[p]) &#123;</div><div class="line">			p = id[p];</div><div class="line">		&#125;</div><div class="line">		return p;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void union(int p, int q) &#123;</div><div class="line">		int pRoot = find(p);</div><div class="line">		int qRoot = find(q);</div><div class="line">		if (pRoot == qRoot) &#123;</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		if (sz[pRoot] &gt; sz[qRoot]) &#123;</div><div class="line">			id[qRoot] = pRoot;</div><div class="line">			sz[pRoot] = sz[pRoot] + sz[qRoot];</div><div class="line">		&#125;else if (sz[pRoot] &lt; sz[qRoot]) &#123;</div><div class="line">			id[qRoot] = pRoot;</div><div class="line">			sz[qRoot] = sz[pRoot] + sz[qRoot];</div><div class="line">		&#125;</div><div class="line">		count--;//连通后，连通分量总数少1</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>命题H。对N个触点，加权union算法构造的森林中的任意节点的深度最多为lgN。</p>
<p>推论。对于加权quick-union算法和N个触点，在最坏情况下find connected 和 union 的成本增长数量级为logN。</p>
</blockquote>
<p>命题和它的推论的实际意义在于加权quick-union算法是三种算法中唯一能解决大型实际问题的算法。</p>
<h4 id="1-5-2-8-最优算法"><a href="#1-5-2-8-最优算法" class="headerlink" title="1.5.2.8 最优算法"></a>1.5.2.8 最优算法</h4><p>路径压缩算法，每个结点都直接连接到根节点。</p>
<ul>
<li>实现：在检查节点的同时将它们直接链接到根节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int find(int p)&#123;</div><div class="line">    int root = p;</div><div class="line">    while(root != id[root])&#123;</div><div class="line">        root = id[root];</div><div class="line">    &#125;</div><div class="line">    while(p != root)&#123;</div><div class="line">        int newP = p;</div><div class="line">        id[p] = root;</div><div class="line">        p = newP;</div><div class="line">    &#125;</div><div class="line">    return root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-5-3-展望-148"><a href="#1-5-3-展望-148" class="headerlink" title="1.5.3　 展望　　148"></a>1.5.3　 展望　　148</h3><h1 id="第2章-排序-152"><a href="#第2章-排序-152" class="headerlink" title="第2章　 排序　　152"></a>第2章　 排序　　152</h1><h2 id="2-1-初级排序算法-153"><a href="#2-1-初级排序算法-153" class="headerlink" title="2.1　 初级排序算法　　153"></a>2.1　 初级排序算法　　153</h2><h3 id="2-1-1-游戏规则-153"><a href="#2-1-1-游戏规则-153" class="headerlink" title="2.1.1　 游戏规则　　153"></a>2.1.1　 游戏规则　　153</h3><p>大多数情况下，我们的排序代码只会通过两个方法操作数据： </p>
<ul>
<li>less() 方法对元素进行比较，</li>
<li>exch() 方法将元素交换位置。</li>
</ul>
<p>排序算法类的模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class Example &#123;</div><div class="line">	public static void sort(Comparable[] a) &#123;</div><div class="line">		/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7 */ </div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static boolean less(Comparable v, Comparable w) &#123;</div><div class="line">		return v.compareTo(w) &lt; 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void exch(Comparable[] a, int i, int j) &#123;</div><div class="line">		Comparable t = a[i];</div><div class="line">		a[i] = a[j];</div><div class="line">		a[j] = t;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private static void show(Comparable[] a) &#123; // 在单行中打印数组</div><div class="line">		for (int i = 0; i &lt; a.length; i++)</div><div class="line">			StdOut.print(a[i] + &quot; &quot;);</div><div class="line">		StdOut.println();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static boolean isSorted(Comparable[] a) &#123; // 测试数组元素是否有序</div><div class="line">		for (int i = 1; i &lt; a.length; i++)</div><div class="line">			if (less(a[i], a[i - 1]))</div><div class="line">				return false;</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123; // 从标准输入读取字符串，将它们排序并输出</div><div class="line">		String[] a = In.readStrings();</div><div class="line">		sort(a);</div><div class="line">		assert isSorted(a);</div><div class="line">		show(a);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类展示的是<strong>数组排序实现的框架</strong>。对于我们学习的每种排序算法，我们都会为这样一个类实现<br>一个 sort() 方法并将 Example 改为算法的名称。测试用例会将标准输入得到的字符串排序，但是这段<br>代码使我们的排序方法适用于任意实现了 Comparable 接口的数据类型</p>
<hr>
<h4 id="2-1-1-1-验证"><a href="#2-1-1-1-验证" class="headerlink" title="2.1.1.1 验证"></a>2.1.1.1 验证</h4><p>谨慎起见，我们会在测试代码中添加一条<br>语句 assert isSorted(a); 来确认排序后数组元素都是有序的。</p>
<h4 id="2-1-1-2-运行时间"><a href="#2-1-1-2-运行时间" class="headerlink" title="2.1.1.2 运行时间"></a>2.1.1.2 运行时间</h4><blockquote>
<p>排序成本模型。在研究排序算法时，我们需要计算比较和交换的数量。对于不交换元素的算法，<br>我们会计算访问数组的次数。</p>
</blockquote>
<h4 id="2-1-1-3-额外的内存使用"><a href="#2-1-1-3-额外的内存使用" class="headerlink" title="2.1.1.3 额外的内存使用"></a>2.1.1.3 额外的内存使用</h4><p>排序算法可以分为两类：</p>
<ul>
<li>除了<strong>函数调用所需的 栈和固定数目的实例变量</strong>之外无需额外内存的<strong>原地排序</strong>算法，</li>
<li>以及需要<strong>额外内存空间来存储</strong>另一份数组副本的<strong>其他排序算法</strong>。</li>
</ul>
<h4 id="2-1-1-4-数据类型"><a href="#2-1-1-4-数据类型" class="headerlink" title="2.1.1.4 数据类型"></a>2.1.1.4 数据类型</h4><p>只要实现Comparable接口就能保证用例代码可以将其排序。</p>
<p>compareTo() 必须实现一个全序关系，即：</p>
<ul>
<li>自反性，对于所有的 v ， v=v ；</li>
<li>反对称性，对于所有的 v<w 都="" 有="" v="">w ，且 v=w 时 w=v ；</w></li>
<li>传递性，对于所有的 v 、 w 和 x ，<br>如果 v&lt;=w 且 w&lt;=x ，则 v&lt;=x 。</li>
</ul>
<h3 id="2-1-2-选择排序-155"><a href="#2-1-2-选择排序-155" class="headerlink" title="2.1.2　 选择排序　　155"></a>2.1.2　 选择排序　　155</h3><p>每次交换都能排定一个元素，因此<strong>交换的总次数是 N</strong> 。所以算法的时间效率取决于比较的次数</p>
<blockquote>
<p>命题A。对于长度为 N 的数组，选择排序需要大约 N^2/2 次比较和 N 次交换。</p>
</blockquote>
<p>选择排序有两个很鲜明的特点:</p>
<ol>
<li><strong>运行时间和输入无关</strong>。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。<ul>
<li>其他算法会更善于利用输入的初始状态。</li>
</ul>
</li>
<li><strong>数据移动是最少的</strong>。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——<strong>交换次数和数组的大小是线性关系</strong>（正比例）。</li>
</ol>
<p>我们将研究的其他算法（大部分的增长数量级都是<strong>线性对数或是平方级别</strong>）</p>
<h3 id="2-1-3-插入排序-157"><a href="#2-1-3-插入排序-157" class="headerlink" title="2.1.3　 插入排序　　157"></a>2.1.3　 插入排序　　157</h3><p>插入排序所需的时间取决于输入中的元素的初始顺序。</p>
<ul>
<li>当倒置的数量很少的时候，插入排序的很可能比本章中的任何说法都快</li>
</ul>
<blockquote>
<p>命题 B。对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要～ N^2 /4 次比<br>较以及～ N^2 /4 次交换。最坏情况下需要～ N 2 /2 次比较和～ N^ 2/2次交换，最好情况下需要 N-1次比较和 0 次交换。</p>
<p>命题 C。插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的<br>数量，小于等于倒置的数量加上数组的大小再减一.</p>
</blockquote>
<p>证明均是画出一个N X N的 的轨迹表，分析</p>
<h3 id="2-1-4-排序算法的可视化-159"><a href="#2-1-4-排序算法的可视化-159" class="headerlink" title="2.1.4　 排序算法的可视化　　159"></a>2.1.4　 排序算法的可视化　　159</h3><p><img src="http://algs4.cs.princeton.edu/21elementary/images/bars.png" alt=""></p>
<ul>
<li>插入排序不会访问索引右边的元素</li>
<li>选择排序不会访问索引左边的元素</li>
</ul>
<h3 id="2-1-5-比较两种排序算法-159"><a href="#2-1-5-比较两种排序算法-159" class="headerlink" title="2.1.5　 比较两种排序算法　　159"></a>2.1.5　 比较两种排序算法　　159</h3><h3 id="2-1-6-希尔排序-162"><a href="#2-1-6-希尔排序-162" class="headerlink" title="2.1.6　 希尔排序　　162"></a>2.1.6　 希尔排序　　162</h3><p>本质上是<strong>对插入排序的改进</strong>，交换不相邻的元素以对数组的 局部 进行排序，并最终用插入排序将局部有序的数组排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void sort(Comparable[] a) &#123;</div><div class="line">	int h = 1;</div><div class="line">	int N = a.length;</div><div class="line">	while (h &lt; N / 3) &#123;</div><div class="line">		h = 3 * h + 1;</div><div class="line">	&#125;</div><div class="line">	while (h &gt;= 1) &#123;</div><div class="line">		// 将数组变为h有序</div><div class="line">		for (int i = h; i &lt; N; i++) &#123;</div><div class="line">		    //将 a[i] 插入到 a[i-h] a[i-2*h] a[i-3*h]...之中</div><div class="line">			for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</div><div class="line">				exch(a, j, j - h);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		h /= 3;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>引入一个新的概念：<strong>增幅 h</strong>的初始值是数组长度乘以一个常数因子，最小为1。</p>
<ul>
<li>可供参考的递增序列 <ul>
<li>1,4,13,40,121,364…. h = 3*h + 1</li>
<li>1,5,19,41,109,209，505…  通过 9 <em> 4^k - 9</em>2^k+1 和 4^k-3*2^k+1 综合得到<br><img src="http://algs4.cs.princeton.edu/21elementary/images/shell.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>算法的性能不仅取决于h，还取决于h之间的数学性质</p>
<ul>
<li>在输入数组随机的情况下，数学上还不知道希尔排序所需要的平均比较次数。</li>
</ul>
</li>
<li><p>与选择、插入排序不同的是：希尔排序<strong>也适用于大型数组</strong>。它对任意排序的数组表现也很好</p>
</li>
<li>如果需要解决一个排序问题而又没有系统排序函数可用，可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。</li>
</ul>
<h2 id="实验题"><a href="#实验题" class="headerlink" title="实验题"></a>实验题</h2><h3 id="2-1-24-插入排序的哨兵。"><a href="#2-1-24-插入排序的哨兵。" class="headerlink" title="2.1.24 插入排序的哨兵。"></a>2.1.24 插入排序的哨兵。</h3><p>在其实现中先找出最小的元素并将其置于数组的最左边，这样能去掉内循环的判断条件 j &gt; 0.</p>
<ul>
<li>这是一种常见的规避边界测试的方法，能够<strong>省略判断条件的元素</strong>通常称为<strong>哨兵</strong>。</li>
</ul>
<h2 id="2-2-归并排序-170"><a href="#2-2-归并排序-170" class="headerlink" title="2.2　 归并排序　　170"></a>2.2　 归并排序　　170</h2><p>要将一个数组排序，可以先（递归地）把它分成两部分，分别排序，然后将结果归并起来。</p>
<ul>
<li>优点： 将任意长度为N的数组排序所需时间和NlogN成正比</li>
<li>缺点：所需的额外空间和N成正比</li>
</ul>
<h3 id="2-2-1-原地归并的抽象方法-170"><a href="#2-2-1-原地归并的抽象方法-170" class="headerlink" title="2.2.1　 原地归并的抽象方法　　170"></a>2.2.1　 原地归并的抽象方法　　170</h3><p>用到了一个辅助数组啊，还算原地？</p>
<ul>
<li><p>实现归并一种直截了当的方法，将两个不同的有序数组，归并到第三个数组</p>
<ul>
<li>问题：大数组排序需要多次归并，每次创建新数组，会有问题</li>
</ul>
</li>
<li><p>一种解决方案。</p>
<ul>
<li>先将数组中的内容 复制到一个辅助数组中，再把归并的结果放回原数组。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">初始化时的i ，j</div><div class="line">    _________________</div><div class="line">    |_______________|</div><div class="line">    </div><div class="line">    lo    mid+1     hi</div><div class="line">    i               j</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>归并时的条件判断</p>
<ul>
<li>左半边用尽</li>
<li>右半边用尽</li>
<li>右半边当前元素 &lt; 左半边当前元素</li>
<li>右半边当前元素 &gt;= 左半边当前元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 原地归并。将涉及的所有元素复制到一个辅助数组中，再把归并的结果放回原数组中</div><div class="line">public static void merge(Comparable[] a, int lo, int mid, int hi) &#123;</div><div class="line">	int i = lo;</div><div class="line">	int j = mid + 1;</div><div class="line"></div><div class="line">	for (int k = lo; k &lt;= hi; k++) &#123;// 注意是lo 和 hi 而不是a.length</div><div class="line">		aux[k] = a[k];//辅助数组是“全局”的</div><div class="line">	&#125;</div><div class="line">	for (int k = lo; k &lt;= hi; k++) &#123;</div><div class="line">		if (i &gt; mid) &#123; // 左半部分已经“越界”了,即左半部分已经用尽</div><div class="line">			a[k] = aux[j++];</div><div class="line">		&#125; else if (j &gt; hi) &#123;// 右半部分已经“越界”了,即右半部分已经用尽</div><div class="line">			a[k] = aux[i++];</div><div class="line">		&#125; else if (less(aux[j], aux[i])) &#123;</div><div class="line">			a[k] = aux[j++];</div><div class="line">		&#125; else &#123;</div><div class="line">			a[k] = aux[i++];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-2-自顶向下的归并排序-171"><a href="#2-2-2-自顶向下的归并排序-171" class="headerlink" title="2.2.2　 自顶向下的归并排序　　171"></a>2.2.2　 自顶向下的归并排序　　171</h3><h4 id="——分治思想-递归"><a href="#——分治思想-递归" class="headerlink" title="——分治思想 递归"></a>——分治思想 递归</h4><p>sort方法的作用其实在于安排多次merge()方法调用的顺序。</p>
<ul>
<li><p>因为有序的数组merge才会是有序的嘛。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public static void sort(Comparable[] a) &#123;</div><div class="line">	aux = new Comparable[a.length];// 一次性分配空间</div><div class="line">	sort(a, 0, a.length - 1);// length-1 要记得，不然越界</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 自顶向下的归并排序</div><div class="line">/**</div><div class="line"> * 分治思想 是归纳证明算法能正确将数组排序的基础： 如果能将两个子数组排序，那么就能通过归并两个子数组来将整个数组排序</div><div class="line"> */</div><div class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</div><div class="line">	// if (hi &lt;= lo) &#123;</div><div class="line">	// return;</div><div class="line">	// &#125;</div><div class="line">	if (hi - lo &lt;= CUTOFF - 1) &#123;</div><div class="line">		Insertion.sort(a);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	int mid = lo + (hi - lo) / 2;</div><div class="line">	sort(a, lo, mid);// 左边排序</div><div class="line">	sort(a, mid + 1, hi);// 右边排序</div><div class="line">	if (less(a[mid], a[mid + 1])) &#123;// 改进 如果左子数组 末元素小于 右子数组起始元素 那么就不需进行本次排序</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	merge(a, lo, mid, hi);// 归并结果</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>长度为N</strong>的任意数组，把对merge方法的调用表示为<strong>树状图</strong>，每一个节点对应 自顶向下排序通过merge方法归并而成的子数组。</p>
</li>
<li><strong>树有n层</strong>（n = lgN），（假设根节点为0层）</li>
<li>自顶向下的 第k层有 2^k个子数组，</li>
<li>每个子数组的 长度为 2^(n-k)，每个子数组归并最多需要 2^(n-k) 次比较</li>
</ul>
<p>因此每层的比较次数为 2^k *  2^(n-k) = 2^n</p>
<h4 id="2-2-2-1-对小规模数组使用插入排序。"><a href="#2-2-2-1-对小规模数组使用插入排序。" class="headerlink" title="2.2.2.1 对小规模数组使用插入排序。"></a>2.2.2.1 对小规模数组使用插入排序。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sort 方法中使用判断</div><div class="line"></div><div class="line">if(hi - lo &lt; CUTOFF - 1)&#123;</div><div class="line">    Insertion.sort(a);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-2-2测试数组是否已经有序"><a href="#2-2-2-2测试数组是否已经有序" class="headerlink" title="2.2.2.2测试数组是否已经有序"></a>2.2.2.2测试数组是否已经有序</h4><p>判断a[mid] 与 a[mid+1] 的大小，如果a[mid] &lt; a[mid+1]<br>则左右数组已经有序，不需要进行merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</div><div class="line">//		if (hi &lt;= lo) &#123;</div><div class="line">//			return;</div><div class="line">//		&#125;</div><div class="line">	if (hi - lo &lt;= CUTOFF-1) &#123;</div><div class="line">		Insertion.sort(a);</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	int mid = lo + (hi - lo) / 2;</div><div class="line">	sort(a, lo, mid);// 左边排序</div><div class="line">	sort(a, mid + 1, hi);// 右边排序</div><div class="line">	//改进 如果左子数组 末元素小于 右子数组起始元素 那么就不需进行本次排序</div><div class="line">	if (less(a[mid], a[mid+1])) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	merge(a, lo, mid, hi);// 归并结果</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-2-2-3-不将元素复制到辅助数组"><a href="#2-2-2-3-不将元素复制到辅助数组" class="headerlink" title="2.2.2.3 不将元素复制到辅助数组"></a>2.2.2.3 不将元素复制到辅助数组</h4><p>减少交换次数， aux与a交换角色</p>
<h3 id="2-2-3-自底向上的归并排序-175"><a href="#2-2-3-自底向上的归并排序-175" class="headerlink" title="2.2.3　 自底向上的归并排序　　175"></a>2.2.3　 自底向上的归并排序　　175</h3><p>多次遍历数组，根据子数组的大小进行两两归并。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void sort(Comparable[] a) &#123;</div><div class="line">    int N = a.length;</div><div class="line">    aux = new Comparable[N];</div><div class="line">    for(int sz = 1; sz &lt; N; sz = sz + sz)&#123;//通过改变sz的大小 来 控制归并 子数组的大小 1 2 4 ...</div><div class="line">        for(int lo = 0; lo &lt; N - sz; lo += sz + sz)&#123; </div><div class="line">            merge(a,lo,lo+sz-1,Math.min(lo + sz + sz - 1, N - 1)); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="自顶向下与自底向上-对比"><a href="#自顶向下与自底向上-对比" class="headerlink" title="自顶向下与自底向上 对比"></a>自顶向下与自底向上 对比</h4><ul>
<li><strong>当数组长度为2的幂时</strong>，自顶向下和自底向上的归并排序所需要的比较次数和数组访问次数正好相同，只是顺序不同。</li>
<li><p>其他时候会有所不同</p>
</li>
<li><p>自底向上 的归并排序比较适合 <strong>链表</strong> 组织的数据。 只需要重新组织链表链接就能完成排序，不需要创建任何新的链表结点。</p>
</li>
</ul>
<h3 id="2-2-4-排序算法的复杂度-177"><a href="#2-2-4-排序算法的复杂度-177" class="headerlink" title="2.2.4　 排序算法的复杂度　　177"></a>2.2.4　 排序算法的复杂度　　177</h3><p>任何一种基于比较的排序算法都对应着一棵高h的比较树。</p>
<p>结论</p>
<ol>
<li>这棵树应该至少有N！个叶子节点，因为N中不同的主键会有N!个不同的排列<ul>
<li>如果少于 叶子结点少于 N! ，那肯定有一些排序顺序被遗漏了。算法对于遗漏的输入肯定会失败。</li>
</ul>
</li>
<li>从根节点到叶子节点的一条路径上 的 内部节点的数量 即是 某种输入下算法 进行比较的次数。</li>
</ol>
<p>如图：<br><img src="http://ofucm8avi.bkt.clouddn.com/%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E6%9E%84%E6%88%90%E7%9A%84%E6%A0%91.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中 N! &lt; 叶子节点数量 &lt; 2^h</div></pre></td></tr></table></figure>
<ul>
<li>h的值就是最坏情况下的比较次数</li>
</ul>
<h2 id="2-3-快速排序-182"><a href="#2-3-快速排序-182" class="headerlink" title="2.3　 快速排序　　182"></a>2.3　 快速排序　　182</h2><h4 id="——分治思想-递归-1"><a href="#——分治思想-递归-1" class="headerlink" title="——分治思想 递归"></a>——分治思想 递归</h4><p>快排流行的原因在于其实现简单、适用于各种不同的输入数据且在一般应用中比其他算法快得多。</p>
<ul>
<li>引人注目的特点是：<ul>
<li>它是原地排序（只需要一个很小的辅助栈）</li>
<li>且将长度为N的数组排序所需要的时间与 NlogN 成正比。<ul>
<li>很多算法都没法将这两个优点结合起来 </li>
</ul>
</li>
<li>内循环比其他排序算法要短小。</li>
</ul>
</li>
<li>主要的缺点是 不稳定。 最坏情况 为平方级别。</li>
</ul>
<h3 id="2-3-1-基本算法-182"><a href="#2-3-1-基本算法-182" class="headerlink" title="2.3.1　 基本算法　　182"></a>2.3.1　 基本算法　　182</h3><p>关键在于切分，此过程结果：</p>
<ol>
<li>对于某个j，a[j]已经排定</li>
<li>a[lo.. j-1] &lt; a[j]</li>
<li><p>a[j+1.. hi] &gt; a[j]</p>
</li>
<li><p>原地切分</p>
</li>
<li>别越界<ul>
<li>eg： 如果切分元素是数组中最大或者最小的那个元素，小心别让扫描指针跑出数组边界。</li>
</ul>
</li>
<li>保持随机性。<ol>
<li>排序前对数组进行 shuffle() 操作</li>
<li>对数组partition()中随机选择一个 切分元素。</li>
</ol>
</li>
<li>终止循环</li>
<li>处理切分元素值有重复的情况</li>
<li>终止递归</li>
</ol>
<h3 id="2-3-2-性能特点-185"><a href="#2-3-2-性能特点-185" class="headerlink" title="2.3.2　 性能特点　　185"></a>2.3.2　 性能特点　　185</h3><blockquote>
<p>命题K。将长度为N的无重复数组排序，快排平均需要 ~2NlnN次比较，以及1/6的交换</p>
<p>命题L。快排最多需要N^2次比较，但随机打乱数组能够预防这种情况。</p>
</blockquote>
<h3 id="2-3-3-算法改进-187"><a href="#2-3-3-算法改进-187" class="headerlink" title="2.3.3　 算法改进　　187"></a>2.3.3　 算法改进　　187</h3><h4 id="2-3-3-1-切换到插入排序"><a href="#2-3-3-1-切换到插入排序" class="headerlink" title="2.3.3.1. 切换到插入排序"></a>2.3.3.1. 切换到插入排序</h4><pre><code>- 原因：
    1. 对于小数组 插入排序比快速排序要快
    2. 因为递归，快排的sort方法在小数组中也会调用自己。
- 实现：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</div><div class="line">//		if (hi&lt;=lo) &#123;</div><div class="line">//			return;</div><div class="line">//		&#125;</div><div class="line">		//注： 转换参数M的最佳值与 系统有关，但是5~15之间的任意值通常都能令人满意。</div><div class="line">		if (hi - lo &lt;=  M) &#123;//改进：小数组使用插入排序 </div><div class="line">			Insertion.sort(a);</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		int j = partition(a, lo, hi);</div><div class="line">		sort(a, lo, j-1);</div><div class="line">		sort(a, j+1, hi);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-3-2-三取样切分"><a href="#2-3-3-2-三取样切分" class="headerlink" title="2.3.3.2 三取样切分"></a>2.3.3.2 三取样切分</h4><pre><code>- 将取样大小设为3并用大小居中的元素 作为 切分元素 效果最好 
- **还可将取样元素放在数组末尾作为“哨兵”来去掉 partition() 中的数组的边界**。
    - 应该是先将 最大元素 找出来 然后放到数组右边 a[N-1]
</code></pre><h4 id="2-3-3-3-熵最优的排序"><a href="#2-3-3-3-熵最优的排序" class="headerlink" title="2.3.3.3 熵最优的排序"></a>2.3.3.3 熵最优的排序</h4><ul>
<li>将数组切分为 <strong>三部分</strong> ，分别对应<strong>小于、等于和大于</strong>切分元素的数组元素。    </li>
<li>“荷兰国旗” 三色旗</li>
</ul>
<p>含有大量重复元素的数组中，使用三向切分能将当前实现的线性对数级别的算法 提高到 线性级别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *     &lt; v     = v -------未排序 ---  ---- &gt; v </div><div class="line"> * lo  --      lt  --     i    --- gt   --    hi</div><div class="line"> * </div><div class="line"> * */</div><div class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</div><div class="line">	if (hi &lt;= lo) &#123;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">	int lt = lo;</div><div class="line">	int i = lo+1;</div><div class="line">	int gt = hi;</div><div class="line">	Comparable v = a[lo];</div><div class="line">	while (i&lt;=gt) &#123;</div><div class="line">		int cmp = a[i].compareTo(v);</div><div class="line">		if (cmp &lt; 0) &#123;</div><div class="line">			exch(a, i++, lt++);</div><div class="line">		&#125;else if (cmp &gt; 0) &#123;</div><div class="line">			exch(a, i, gt--);</div><div class="line">		&#125;else &#123;</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">	&#125;//现在 a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi] 成立</div><div class="line">	sort(a, lo, lt-1);</div><div class="line">	sort(a, gt+1, hi);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>为什么没有流行开来？<ul>
<li>重复元素不多的普通情况下它比标准的二分法 多使用了很多次交换。 </li>
<li>不过已经有人解决这个问题 </li>
</ul>
</li>
</ul>
<h2 id="2-4-优先队列"><a href="#2-4-优先队列" class="headerlink" title="2.4 优先队列"></a>2.4 优先队列</h2><blockquote>
<p>定义：优先队列：支持删除最大元素和插入元素操作的数据结构。</p>
</blockquote>
<h3 id="2-4-1-API-195"><a href="#2-4-1-API-195" class="headerlink" title="2.4.1　 API　　195"></a>2.4.1　 API　　195</h3><p><strong>优先队列调用示例</strong></p>
<ul>
<li>从N个输入中  找到最大的（或者最小）的 M 个<ol>
<li>先排序然后从中找出 M 个最大元素<ul>
<li>但是输入过于庞大，不实际</li>
</ul>
</li>
<li>将每个新的输入和已知的 M个 最大元素比较，除非M较小，否则这种比较代价 高昂<ul>
<li>实现优先队列 可以解决这个比较代价大的问题 ，因为树高为h<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//一个优先队列的用例</div><div class="line">public class TopM &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// 打印输入流中最大的M行</div><div class="line">		int M = Integer.parseInt(args[0]);</div><div class="line">		MinPQ&lt;Transaction&gt; pq = new MinPQ&lt;&gt;(M + 1);</div><div class="line">		while (StdIn.hasNextLine()) &#123;</div><div class="line">			pq.insert(new Transaction(StdIn.readLine()));</div><div class="line">			if (pq.size() &gt; M) &#123;</div><div class="line">				pq.delMin();//如果优先队列中存在M+1个元素则删除其中最小的元素</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		Stack&lt;Transaction&gt; stack = new Stack&lt;&gt;();</div><div class="line">		while (!pq.isEmpty()) &#123;</div><div class="line">			stack.push(pq.delMin());</div><div class="line">		&#125;</div><div class="line">		for(Transaction t : stack)&#123;</div><div class="line">			System.out.println(t);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-4-2-初级实现："><a href="#2-4-2-初级实现：" class="headerlink" title="2.4.2 初级实现："></a>2.4.2 初级实现：</h3><h4 id="2-4-2-1-数组实现（无序）"><a href="#2-4-2-1-数组实现（无序）" class="headerlink" title="2.4.2.1 数组实现（无序）"></a>2.4.2.1 数组实现（无序）</h4><p><strong>惰性方法</strong></p>
<ul>
<li>就是找个空位直接存进来，不管顺序，等到有需要了（例如删除最大元素）再找出最大元素，让它跟末尾元素交换 ，然后进行删除</li>
</ul>
<p>类似于下压栈的代码。 </p>
<ul>
<li>插入元素 insert(); 同push()</li>
<li>实现删除最大元素，可以添加一段类似于选择排序的内循环的代码。将最大元素和边界元素交换然后删除它。和我们对栈的pop()方法实现一样。</li>
</ul>
<h4 id="2-4-2-2-数组实现（有序）"><a href="#2-4-2-2-数组实现（有序）" class="headerlink" title="2.4.2.2 数组实现（有序）"></a>2.4.2.2 数组实现（有序）</h4><p><strong>积极方法</strong>：“未雨绸缪”</p>
<ul>
<li>在insert方法中添加代码，将所有较大的元素向右边移动一格以使数组保持有序（和插入排序一样）</li>
<li>那么删除最大元素的操作同pop()</li>
</ul>
<h4 id="2-4-2-3-链表表示法"><a href="#2-4-2-3-链表表示法" class="headerlink" title="2.4.2.3 链表表示法"></a>2.4.2.3 链表表示法</h4><p>基于链表的下压栈的代码为基础，</p>
<ul>
<li>修改pop（）找到并返回最大元素，</li>
<li>修改push() 来保证所有元素为逆序并用pop()来删除并返回链表的首元素。</li>
</ul>
<p><strong>优先队列的各种实现在最坏的情况下运行时间的增长数量级</strong><br>数据结构 | 插入元素 | 删除最大元素<br>—|—|—|<br>有序数组|N|1<br>无序数组|1|N<br>堆|logN|logN<br>理想状况|1|1</p>
<h3 id="2-4-3-堆的定义"><a href="#2-4-3-堆的定义" class="headerlink" title="2.4.3 堆的定义"></a>2.4.3 堆的定义</h3><p>数据结构<em>二叉堆</em>能够很好地实现优先队列的基本操作。</p>
<blockquote>
<p>定义：当一棵二叉树的每个节点都大于它的两个子节点时，它被称为 堆有序</p>
</blockquote>
<h4 id="二叉堆的表示方法"><a href="#二叉堆的表示方法" class="headerlink" title="二叉堆的表示方法"></a>二叉堆的表示方法</h4><ul>
<li>如果使用指针来表示，那么每个元素都需要三个指针 来找到它的上下结点 </li>
<li>如果使用数组 则会方便很多，不过结点需要按照 层序顺序 放入数组。</li>
</ul>
<blockquote>
<p>定义：二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）</p>
</blockquote>
<p>不使用指针的情况下，我们可以通过计算数组的索引在树中上下移动</p>
<ul>
<li>从a[k]上移一层就令k等于k/2</li>
<li>向下一层就令k 等于 2*k 或者 （2*k+1）</li>
</ul>
<blockquote>
<p>命题P。 一棵大小为N的完全二叉树的高度为 logN （向下取整）</p>
</blockquote>
<ul>
<li><p><strong>堆的有序化</strong>： 对堆进行操作后，当堆序性被破坏时，遍历堆，再按照要求恢复堆序性 的过程。</p>
<ul>
<li>当某结点的优先级上升（或者在堆底加入一个新的元素）时，需要 从下至上 恢复堆的顺序<ul>
<li>升级 </li>
</ul>
</li>
<li>当某结点的优先级下降（或者在堆底加入一个新的元素）时，需要 从上至下 恢复堆的顺序<ul>
<li>降级 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-4-堆的算法-199"><a href="#2-4-4-堆的算法-199" class="headerlink" title="2.4.4　 堆的算法　　199"></a>2.4.4　 堆的算法　　199</h3><p>==本例具体实现中，数组的第一个元素不使用==</p>
<ul>
<li>从一开始计算的 结点关系比较好确定</li>
<li><p>将a[0]作为哨兵（作为a[1]的父节点）在某些堆的应用中是很有用的</p>
</li>
<li><p>位置k的结点</p>
<ul>
<li>其 父节点为 (k/2) 向下取整 </li>
<li>左右 子节点 分别为 （2*k) (2*k+1)</li>
</ul>
</li>
</ul>
<h4 id="2-4-4-1-由下至上的堆有序化（上浮）"><a href="#2-4-4-1-由下至上的堆有序化（上浮）" class="headerlink" title="2.4.4.1 由下至上的堆有序化（上浮）"></a>2.4.4.1 由下至上的堆有序化（上浮）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void swim(int k)&#123;</div><div class="line">    while(k &gt; 1 &amp;&amp; less(a[k/2], a[k]) &#123;//根节点为1 ，得到其父节点 需要除以2，故k不能小于1</div><div class="line">        exch(a, k/2, k);</div><div class="line">        k /= 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-4-4-1-由上至下的堆有序化（下沉）"><a href="#2-4-4-1-由上至下的堆有序化（下沉）" class="headerlink" title="2.4.4.1 由上至下的堆有序化（下沉）"></a>2.4.4.1 由上至下的堆有序化（下沉）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private void sink(int k)&#123;</div><div class="line">    while(2*k &lt;= N)&#123;</div><div class="line">        int j = 2*k;</div><div class="line">        if(j &lt; N &amp;&amp; less(j, j+1))&#123;//先找出左右孩子中 比较大的元素，注意判断j &lt; N, 而不是 &lt;= 因为如果j=N，那么必然不能再加1</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        if(!less(k,j))&#123;//父子节点对比一下，如果顺序没错，直接brea;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        exch(j,k);</div><div class="line">        k = j;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>插入元素</strong>，<em>将新元素加到数组末尾</em>，增加堆的大小 并让这个元素 上浮</p>
</li>
<li><p><strong>删除元素</strong>，<em>从数组顶端删去最大的元素，将数组末尾元素放到顶端</em>，减小堆的大小， 并让这个元素 下沉</p>
</li>
</ul>
<p>//基于堆的优先队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">package sorting;</div><div class="line">public class MaxPQ&lt;T extends Comparable&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">	private T[] pq;// 基于堆的完全二叉树</div><div class="line">	private int N = 0;// 存储于pq[1..N], pq[0]没有使用</div><div class="line"></div><div class="line">	public MaxPQ(int maxN) &#123;</div><div class="line">		pq = (T[]) new Comparable[maxN];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private boolean less(int i, int j) &#123;</div><div class="line">		return pq[i].compareTo(pq[j]) &lt; 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void exch(int i, int j) &#123;</div><div class="line">		T tmp = pq[i];</div><div class="line">		pq[i] = pq[j];</div><div class="line">		pq[j] = tmp;</div><div class="line">	&#125;</div><div class="line">	//上浮只要看这个“儿子”与父节点</div><div class="line">	private void swim(int k) &#123;</div><div class="line">		while (k &gt; 1 &amp;&amp; less(k / 2, k)) &#123;// 父 小于 子</div><div class="line">			exch(k / 2, k);</div><div class="line">			k /= 2;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//下沉需要先看“两个孩子”谁比较大，取大者跟父节点交换</div><div class="line">	private void sink(int k) &#123;</div><div class="line">		while (2 * k &lt;= N) &#123;</div><div class="line">			int j = 2 * k;</div><div class="line">			if (less(j, j + 1)) &#123;// 左右孩子谁大？</div><div class="line">				j++;</div><div class="line">			&#125;</div><div class="line">			if (!less(k, j)) &#123;// 如果孩子比父节点小，跳出循环</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">			exch(k, j);</div><div class="line">			k = j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void insert(T v) &#123;</div><div class="line">		pq[++N] = v;</div><div class="line">		swim(N);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">//	public T max() &#123;</div><div class="line">//		return pq[1];</div><div class="line">//	&#125;</div><div class="line"></div><div class="line">	public T delMax() &#123;</div><div class="line">		T max = pq[1];//从根节点得到最大元素</div><div class="line">		exch(1, N--);//根节点与最后一个节点交换</div><div class="line">		pq[N+1] = null;        //防止对象游离</div><div class="line">		sink(1);//恢复堆序性</div><div class="line">		return max;</div><div class="line">	&#125;</div><div class="line">		</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		return N == 0;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public int size() &#123;</div><div class="line">		return N;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>命题Q。对于一个含有N个元素的基于堆的优先队列，插入元素只需不超过（logN + 1）次比较，删除最大元素的操作需要不超过2logN次比较。</p>
</blockquote>
<p>对于需要大量混杂插入和删除最大元素操作的典型应用来说，基于堆的优先队列是一个不错的选择。</p>
<h4 id="2-4-4-3-多叉堆"><a href="#2-4-4-3-多叉堆" class="headerlink" title="2.4.4.3 多叉堆"></a>2.4.4.3 多叉堆</h4><h4 id="2-4-4-4-调整数组的大小"><a href="#2-4-4-4-调整数组的大小" class="headerlink" title="2.4.4.4 调整数组的大小"></a>2.4.4.4 调整数组的大小</h4><p>添加一个没有参数的构造函数，</p>
<ul>
<li>在insert 中添加数组长度加倍的代码，</li>
<li>在delMax()中添加数组长度减半的代码。</li>
</ul>
<h4 id="2-4-4-5-元素的不可变性"><a href="#2-4-4-5-元素的不可变性" class="headerlink" title="2.4.4.5 元素的不可变性"></a>2.4.4.5 元素的不可变性</h4><p>优先队列存储了用例创建的对象，但是提示假设用例代码不会改变他们。（否则可能会打破堆序性）</p>
<h4 id="2-4-4-6-带索引的优先队列"><a href="#2-4-4-6-带索引的优先队列" class="headerlink" title="2.4.4.6 带索引的优先队列"></a>2.4.4.6 带索引的优先队列</h4><p><a href="http://www.cnblogs.com/bethunebtj/p/4856563.html" target="_blank" rel="external">参考1</a><br><a href="http://www.voidcn.com/blog/u010087886/article/p-5048265.html" target="_blank" rel="external">参考2</a></p>
<p>给每个元素一个索引。<br>用例已经有了总量为N的多个元素，而且可能还同时使用了多个（平行）数组来存储这些元素的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//key[pq[1] pq[2] ... pq[n]] 遍历pq将其值作为 keys的索引 可以刻画出堆</div><div class="line">/**</div><div class="line"> * pq是堆，下标是堆中位置，值是插入顺序（即索引）</div><div class="line"> * qp是索引数组，下标是插入顺序（即索引），值是堆中位置</div><div class="line"> * key是对象数组，下标是插入顺序（即索引），值是对象本身</div><div class="line"> **/</div><div class="line">private int[] pq;        // binary heap using 1-based indexing</div><div class="line">private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i</div><div class="line">private Key[] keys;      // keys[i] = priority of i</div></pre></td></tr></table></figure>
<h3 id="2-4-5-堆排序-205"><a href="#2-4-5-堆排序-205" class="headerlink" title="2.4.5　 堆排序　　205"></a>2.4.5　 堆排序　　205</h3><p>两个阶段：</p>
<ol>
<li>堆的构造阶段</li>
<li>下沉排序阶段</li>
</ol>
<p>在排序时将需要排序的数组本身作为堆，因此无需任何额外的空间。</p>
<h4 id="2-4-5-1-堆的构造"><a href="#2-4-5-1-堆的构造" class="headerlink" title="2.4.5.1 堆的构造"></a>2.4.5.1 堆的构造</h4><ol>
<li>从左到右遍历数组，用swim() 保证扫描指针左侧的元素已经是一棵堆有序的完全树<ul>
<li>就像往优先队列插入元素一样。</li>
</ul>
</li>
<li>聪明而高效的方法：右至左调用sink函数构造子堆。数组的每个节点都是一个子堆的根节点了。只需要扫描数组中一半的元素（非叶子节点）。<ul>
<li>注： 大小为1的子堆(即叶子结点)，从 N/2 ~ N</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void sort(Comparable[] a) &#123;</div><div class="line">    int N = a.length;</div><div class="line">    for(int k = N / 2; k &gt;=1; k-- )&#123;</div><div class="line">        sink(a,k,n);</div><div class="line">    &#125;</div><div class="line">    while(N &gt; 1)&#123;</div><div class="line">        exch(a,1,N--);</div><div class="line">        sink(a,1,N);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>命题R：用下沉操作有N个元素构造堆只需少于2N次比较 和 少于 N次交换</p>
</blockquote>
<p>证明： 画一个堆 就行。</p>
<h4 id="2-4-5-2-下沉排序"><a href="#2-4-5-2-下沉排序" class="headerlink" title="2.4.5.2 下沉排序"></a>2.4.5.2 下沉排序</h4><blockquote>
<p>命题S。将N个元素排序，堆排序只需要少于（2NlgN+2N）次比较（以及一般次数的交换）</p>
</blockquote>
<h4 id="2-4-5-3-先下沉后上浮"><a href="#2-4-5-3-先下沉后上浮" class="headerlink" title="2.4.5.3  先下沉后上浮"></a>2.4.5.3  先下沉后上浮</h4><p>大多数在下沉排序期间重新插入堆的元素会直接加入到堆底</p>
<p>下沉中总是直接提升较大的子结点直至到达堆底，然后在使元素上浮到正确的位置。这样可以<strong>将比较次数减少一半</strong>。</p>
<p>但是这种方法需要额外的空间，只有在比较代价大时，才会考虑使用。</p>
<p><strong>堆排序是我们已知的唯一能够同时最优地利用空间和时间的方法</strong></p>
<ul>
<li>在最坏情况下它能也保证 ~2NlgN 次比较和恒定的额外空间。<ul>
<li>空间紧张时（比如嵌入式系统或低成本的移动设备中），它很流行。因为只要几行代码就能得到很好的性能</li>
</ul>
</li>
<li>但是现代系统中很少使用它，因为它<strong>无法利用缓存</strong>，<ul>
<li>这是因为堆排序的 数组元素很少和相邻的元素进行比较。缓存未命中的次数远高于 其他 比较 都在相邻元素间进行的算法。</li>
</ul>
</li>
</ul>
<p>另一方面，<strong>用堆实现的优先队列在现代应用程序中越来越重要</strong>。因为其能在 插入操作和删除最大元素操作混合的动态场景中保证对数级别的运行。</p>
<h2 id="2-5-应用"><a href="#2-5-应用" class="headerlink" title="2.5 应用"></a>2.5 应用</h2><p>排序如此有用的一个主要的原因是，在<strong>一个有序的数组中查找一个元素要比在一个无序的数组中查找简单很多</strong>。</p>
<h3 id="2-5-1-将各种数据排序"><a href="#2-5-1-将各种数据排序" class="headerlink" title="2.5.1 将各种数据排序"></a>2.5.1 将各种数据排序</h3><h4 id="2-5-1-2-指针排序"><a href="#2-5-1-2-指针排序" class="headerlink" title="2.5.1.2 指针排序"></a>2.5.1.2 指针排序</h4><p>我们使用的方法在经典教材中被称为<strong>指针排序</strong>，因为我们只处理数组的引用而不移动数据本身。</p>
<ul>
<li>注Java中，指针操作是隐式的。除了原始数据类型之外，我们操作的总是数据的引用（指针）。</li>
<li><p>指针排序增加了一层间接性，因为数组保存的是待排序对象的引用而非对象本身。</p>
</li>
<li><p>对于原始数据类型排序而言，直接交换内容效率更高。</p>
</li>
</ul>
<h4 id="2-5-1-5-多种排序方法"><a href="#2-5-1-5-多种排序方法" class="headerlink" title="2.5.1.5 多种排序方法"></a>2.5.1.5 多种排序方法</h4><p>Java的Comparator接口允许我们在一个类中实现多种排序算法。</p>
<p>例如使用String 类型中定义的 CASE_INSENSITIVE_ORDER<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">eg:</div><div class="line">静态内部类</div><div class="line"></div><div class="line">public static class WhoOrder implements Comparator&lt;Transaction&gt; &#123;</div><div class="line">	@Override</div><div class="line">	public int compare(Transaction o1, Transaction o2) &#123;</div><div class="line">		return o1.who.compareTo(02.who);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">public static class HowMuchOrder implements Comparator&lt;Transaction&gt; &#123;</div><div class="line">	@Override</div><div class="line">	public int compare(Transaction o1, Transaction o2) &#123;</div><div class="line">		if (o1.amount &lt; o2.amount) &#123;</div><div class="line">			return -1;</div><div class="line">		&#125;</div><div class="line">		if (o1.amount &gt; o2.amount) &#123;</div><div class="line">			return 1;</div><div class="line">		&#125;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-5-1-7-使用比较器实现优先队列"><a href="#2-5-1-7-使用比较器实现优先队列" class="headerlink" title="2.5.1.7 使用比较器实现优先队列"></a>2.5.1.7 使用比较器实现优先队列</h3><ul>
<li>添加一个实例变量 comparator，和一个构造方法将其初始化</li>
<li>less中检查comparator 是否为null，如果不是，就用它进行比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private Comparator&lt;T&gt; mComparator;</div><div class="line">public MaxPQ(Comparator&lt;T&gt; comparator) &#123;</div><div class="line">	mComparator = comparator;</div><div class="line">&#125;</div><div class="line">private boolean less(int i, int j) &#123;</div><div class="line">	if (mComparator == null) &#123;</div><div class="line">		return pq[i].compareTo(pq[j]) &lt; 0;</div><div class="line">	&#125;else&#123;</div><div class="line">		return mComparator.compare(pq[i], pq[j]) &lt; 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-5-1-8-稳定性"><a href="#2-5-1-8-稳定性" class="headerlink" title="2.5.1.8 稳定性"></a>2.5.1.8 稳定性</h4><p>如果一个算法能够<strong>保留数组中重复元素的相对位置则可以被称为是</strong>稳定的*</p>
<ul>
<li>eg：一组数据，原本按照时间排序，然后改为按照地理位置排序，<ul>
<li>如果是稳定 那么第二次排序后，仍然保持时间（相对）有序</li>
<li>不稳定     那么不再时间有序。</li>
</ul>
</li>
<li>很多办法能够将任意排序算法变成稳定的，但一般只有在稳定性是必要的情况下稳定的排序算法才有优势。（为了达到稳定的目标，需要大量额外的时间和空间）</li>
</ul>
<h3 id="2-5-2-我应该使用哪种排序方法"><a href="#2-5-2-我应该使用哪种排序方法" class="headerlink" title="2.5.2 我应该使用哪种排序方法"></a>2.5.2 我应该使用哪种排序方法</h3><p>各种排序算法的性能比较，<br><img src="http://algs4.cs.princeton.edu/25applications/images/sort-characteristics.png" alt=""></p>
<table>
<thead>
<tr>
<th>算法</th>
<th>稳定？</th>
<th>原地排序？</th>
<th>时间复杂度</th>
<th>extra space</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>N</td>
<td>√</td>
<td>N^2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>√</td>
<td>√</td>
<td>N~N^2</td>
<td>1</td>
<td>取决于输入元素的排列情况</td>
</tr>
<tr>
<td>希尔排序</td>
<td>N</td>
<td>√</td>
<td>NlogN 或 N^(5/6)</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td>N</td>
<td>√</td>
<td>NlogN</td>
<td>logN</td>
<td>运行效率由概率提供保证</td>
</tr>
<tr>
<td>三向（切分）快速排序</td>
<td>N</td>
<td>√</td>
<td>N~NlogN</td>
<td>logN</td>
<td>运行效率由概率保证，同时也取决于输入元素的分布情况</td>
</tr>
<tr>
<td>归并排序</td>
<td>√</td>
<td>× 辅助数组</td>
<td>NlogN</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>N</td>
<td>√</td>
<td>NlogN</td>
<td>1 数组</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="2-5-2-2-Java系统库的排序算法"><a href="#2-5-2-2-Java系统库的排序算法" class="headerlink" title="2.5.2.2 Java系统库的排序算法"></a>2.5.2.2 Java系统库的排序算法</h4><p>Java.uitl.Arrays.sort();<br>根据不同的参数类型，它实际上代表了一系列的排序方法</p>
<ul>
<li>每种原始数据类型都有一个不同的排序方法。</li>
<li>一个适用于所有实现了Comparable接口的数据类型的排序方法</li>
<li>一个适用于所有实现了比较器Comparator 的数据类型的排序方法</li>
</ul>
<p>系统的选择</p>
<ul>
<li>原始数据类型（三向切分的）快速排序</li>
<li>引用数据类型，使用归并</li>
</ul>
<h3 id="2-5-3-问题的归约"><a href="#2-5-3-问题的归约" class="headerlink" title="2.5.3 问题的归约"></a>2.5.3 问题的归约</h3><p><strong>归约</strong>：指的是为解决某个问题而发明的算法，正好可以用来解决另一种问题。</p>
<p>即根据本质 举一反三</p>
<h4 id="2-5-3-2-排名"><a href="#2-5-3-2-排名" class="headerlink" title="2.5.3.2 排名"></a>2.5.3.2 排名</h4><p>中位数与顺序查找</p>
<blockquote>
<p>平均而言，基于切分的选择算法的运行时间是线性级别的。</p>
</blockquote>
<p>查找数组中第k小的元素。</p>
<p>partition方法 将a[lo] ~ a[hi]进行重新 返回 j, a[lo ..j-1] &lt; a[j] &lt;  a[j+1..hi]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public static Comparable select(Comparable[] a, int k) &#123;</div><div class="line">	StdRandom.shuffle(a);</div><div class="line">	int lo = 0, hi = a.length-1;</div><div class="line">	while (hi &gt; lo) &#123;</div><div class="line">		int j = partition(a, lo, hi);</div><div class="line">		if (j == k) &#123;</div><div class="line">			return a[j];</div><div class="line">		&#125;else if (j &lt; k) &#123;</div><div class="line">			lo = j + 1;</div><div class="line">		&#125;else if (j &gt; k) &#123;</div><div class="line">			hi = j - 1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return a[k];</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static int partition(Comparable[] a, int lo, int hi) &#123;</div><div class="line">	int i = lo;</div><div class="line">	int j = hi+1;</div><div class="line">	while (true) &#123;</div><div class="line">		while (less(a, ++i, lo)) &#123;</div><div class="line">			if (i == hi) &#123;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		while (less(a, lo, --j)) &#123;</div><div class="line">			if (j == lo) &#123;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		if (i &gt;= j) &#123;</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		exch(a, i, j);</div><div class="line">	&#125;</div><div class="line">	exch(a, lo, j);</div><div class="line">	return j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-5-4-排序应用一览-221"><a href="#2-5-4-排序应用一览-221" class="headerlink" title="2.5.4　 排序应用一览　　221"></a>2.5.4　 排序应用一览　　221</h3><h4 id="2-5-4-2-信息搜索"><a href="#2-5-4-2-信息搜索" class="headerlink" title="2.5.4.2 信息搜索"></a>2.5.4.2 信息搜索</h4><p>有序的信息确保我们可以使用经典的 二分查找法 来进行高效的搜索。</p>
<h4 id="2-5-4-2-组合搜索"><a href="#2-5-4-2-组合搜索" class="headerlink" title="2.5.4.2 组合搜索"></a>2.5.4.2 组合搜索</h4><p>人工智能领域一个解决“疑难杂症”的经典范式就是定义一组<strong>状态</strong>、由一组状态演化到另一种状态可能的步骤以及每个步骤的优先级，然后定义一个<strong>起始状态</strong>和<strong>目标状态</strong>（即问题的解决方法）</p>
<p>A*算法：将初始状态放入优先队列中，然后重复下面的方法直到到达目的地：</p>
<ul>
<li>删除优先级最高的状态，然后将能够从该状态在一步之内达到的所有状态全部加入优先队列（除了刚刚删除的那个状态之外）</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://ivanljt.github.io/tim-lin.github.io/tim-lin.github.io/2017/03/25/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
