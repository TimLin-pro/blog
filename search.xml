<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java 线程安全与锁优化]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/11/Java%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全的定义：当<strong>多个线程访问一个对象</strong>时，如果<strong>不用考虑这些线程在运行时环境下的调度和交替执行</strong>，也不需要进行<strong>额外</strong>的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p>
<h3 id="Java-语言中的线程安全"><a href="#Java-语言中的线程安全" class="headerlink" title="Java 语言中的线程安全"></a>Java 语言中的线程安全</h3><p>可将 Java 语言中的各种操作共享的数据分为以下 5 类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<a id="more"></a>
<h4 id="1-不可变"><a href="#1-不可变" class="headerlink" title="1. 不可变"></a>1. 不可变</h4><p>只要一个不可变对象被正确地构建出来（没有 this 引用逃的情况），那么其外部的可见状态永远也不会改变。</p>
<p>final  + 基本数据类型，则该变量为不可变变量<br>final  + 对象，无法保证对象是不可变的</p>
<p>如何保证对象的行为不会对其状态产生任何影响？最简单的就是<strong>将对象中带有状态的变量都声明为 final</strong>。</p>
<p>Java API 中属于不可变的类有以下几种：</p>
<ul>
<li>String</li>
<li>基础数据类型包装类</li>
<li>BigInteger</li>
<li>BigDecimal </li>
</ul>
<p>注意：同为 Number 的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。因为它们都有 set 方法，可以改变对象的状态。</p>
<h4 id="2-绝对线程安全"><a href="#2-绝对线程安全" class="headerlink" title="2. 绝对线程安全"></a>2. 绝对线程安全</h4><p>绝对线程安全的定义是很严格的。Java API 中标注自己的是线程安全的类，大多数都不是绝对的线程安全。</p>
<p>栗子：Vector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> jvm.ch13;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Vector;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; sIntegerVector = <span class="keyword">new</span> Vector&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                sIntegerVector.add(i);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sIntegerVector.size(); i++) &#123;</div><div class="line">                    sIntegerVector.remove(i);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sIntegerVector.size(); i++) &#123;</div><div class="line">                    System.out.println(sIntegerVector.get(i));</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            removeThread.start();</div><div class="line">            printThread.start();</div><div class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码可能会报 ArrayIndexOutOfBoundException</p>
<p>因为可能出现一个线程恰好在一个错误的时间删除了一个元素，导致 i 元素已经不再可用。因为可能出现这样的情况：get(i) 进入等待锁期间，remove(i) 刚好执行了。</p>
<p>解决：操作时加上锁，使得复合操作变为原子操作。</p>
<p>原子操作与复合操作简介：</p>
<ul>
<li>原子操作：不可分割的操作，要么成功要么失败</li>
<li>复合操作：可分割的操作，可能出现数据失效的问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Thread removeThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">    <span class="keyword">synchronized</span> (sIntegerVector) &#123;<span class="comment">//加上锁使之成为原子操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sIntegerVector.size(); i++) &#123;</div><div class="line">            sIntegerVector.remove(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">Thread printThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">    <span class="keyword">synchronized</span> (sIntegerVector) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sIntegerVector.size(); i++) &#123;</div><div class="line">            System.out.println(sIntegerVector.get(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为什么是使用 Vector 对象作为锁？因为 Vector  内部是使用自带的锁来实现的。</p>
<h4 id="3-相对线程安全"><a href="#3-相对线程安全" class="headerlink" title="3. 相对线程安全"></a>3. 相对线程安全</h4><p>即通常意义上所讲的线程安全。它需要保证对这个对象单独操作是线程安全的，调用时就不需要做额外的保障措施。</p>
<p>对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确=性。</p>
<p>Java API 中大部分线程安全的类都属于这种类型：</p>
<ul>
<li>Vector HashTable Collections.sychronizedCollection()</li>
</ul>
<h4 id="4-线程兼容"><a href="#4-线程兼容" class="headerlink" title="4. 线程兼容"></a>4. 线程兼容</h4><p>也就是平常所说的线程不安全类。对象本身并不安全，但是可以通过在调用端正确地使用同步手段来保证对象子啊并发环境中可以安全地使用。</p>
<p>比如：ArrayList HashKMap</p>
<h4 id="5-线程对立"><a href="#5-线程对立" class="headerlink" title="5. 线程对立"></a>5. 线程对立</h4><p>在调用端是否使用同步手段都无法再多线程环境下使用。</p>
<ul>
<li>这种排斥多线程代码很少出现。</li>
</ul>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><p>线程安全的实现方法主要有以下几种：互斥同步、非阻塞同步、无同步方案。</p>
<h4 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1. 互斥同步"></a>1. 互斥同步</h4><p>「互斥同步」的意思是通过互斥来实现同步。<br><strong>同步</strong>是指在多个线程并发访问共享数据的时候，保证共享数据在同一时刻只能有一个（或者一些，使用信号量的时候）线程使用。临界区、互斥量、信号量都是主要的互斥实现方式。</p>
<p>最基本的互斥同步实现方法就是使用 synchronized 关键字。synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter、monitorexit 两条指令。根据虚拟机规范的要求，</p>
<ul>
<li>在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，</li>
</ul>
<ul>
<li>在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，那当前线程就要<strong>阻塞等待</strong>，直到对象锁被另外一个线程释放为止。</li>
</ul>
<p>上述描述中有两点是需要特别注意的。</p>
<ul>
<li>首先，synchronized 同步块对同一条线程来说是<strong>可重入的</strong>，不会出现自己把自己锁死的问题。</li>
<li>其次，同步块在已进入的线程执行完之前，会<strong>阻塞后面其他线程的进入</strong>。</li>
</ul>
<p>Java 的线程是映射到<strong>操作系统的原生线程</strong>之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要<strong>从用户态转换到核心态中</strong>，因此<strong>状态转换需要耗费很多的处理器时间</strong>。</p>
<p>除了 synchronized 之外，我们还可以使用 java.util.concurrent（简称 J.U.C）包中的重入锁（ReentrantLock）来实现同步，在基本用法上，ReentrantLock 与 synchronized 很相似，他们<strong>都具备一样的线程重入特性</strong>，不同点表现在代码写法上</p>
<ul>
<li>一个表现为 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成），</li>
<li>另一个表现为原生语法层面的互斥锁。</li>
</ul>
<p>相比 synchronized,ReentrantLock 增加了一些<strong>高级功能</strong>，主要有以下 3 项：</p>
<ul>
<li><strong>等待可中断</strong>,如果持有锁的线程长时间不释放锁，正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li>公平锁<ul>
<li>多个线程在等待同一个锁时，必须<strong>按照申请锁的时间顺序来依次获得锁</strong>; </li>
<li>非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。</li>
<li>synchronized 中的锁是非公平的，</li>
<li>ReentrantLock <strong>默认情况下也是非公平的</strong>，但可以通过带布尔值的构造函数要求使用公平锁。</li>
</ul>
</li>
<li>锁<strong>可以绑定多个条件</strong><ul>
<li>一个 ReentrantLock 对象<strong>可以同时绑定多个 Condition 对象</strong></li>
<li>而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法<strong>可以实现一个隐含的条件</strong>，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，</li>
</ul>
</li>
</ul>
<h5 id="ReentrantLock-还是-synchronized？"><a href="#ReentrantLock-还是-synchronized？" class="headerlink" title="ReentrantLock 还是 synchronized？"></a>ReentrantLock 还是 synchronized？</h5><p>关于性能：Java 1.6 发布之后，synchronized 与 ReentrantLock 的性能基本上是完全持平了。因此，Java 1.6 或以上，性能因素就不再是选择 ReentrantLock 的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized。</p>
<p>因此在不需要用到 ReentrantLock 三个特性的情况下，优先考虑使用 synchronized 来进行同步。</p>
<h4 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2. 非阻塞同步"></a>2. 非阻塞同步</h4><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为<strong>阻塞同步</strong>（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种<strong>悲观的并发策略</strong>，<strong>总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题</strong>。</p>
<p><strong>基于冲突检测</strong>的<strong>乐观并发策略</strong>，通俗地说，就是先进行操作，</p>
<ul>
<li>如果没有其他线程争用共享数据，那操作就成功了；</li>
<li>如果共享数据有争用，产生了冲突，那就再采取其他的<strong>补偿措施</strong>（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的<strong>许多实现都不需要把线程挂起</strong>，因此这种同步操作称为<strong>非阻塞同步</strong>（Non-Blocking Synchronization）。</li>
</ul>
<p>为什么说使用乐观并发策略需要 “硬件指令集的发展” 才能进行呢？</p>
<ul>
<li>因为我们<strong>需要操作和冲突检测这两个步骤具备原子性</strong>，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，<strong>硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成</strong>。</li>
<li>这类指令常用的有：<ul>
<li>测试并设置（Test-and-Set）。</li>
<li>获取并增加（Fetch-and-Increment）。</li>
<li>交换（Swap）。</li>
<li>==比较并交换（Compare-and-Swap，下文称 CAS==）。</li>
<li>加载链接/条件存储（Load-Linked/Store-Conditional，下文称 LL/SC）。</li>
</ul>
</li>
</ul>
<p>Java 1.5 之后，Java 程序中才可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 <code>compareAndSwapInt()</code>和 <code>compareAndSwapLong()</code> 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令。</p>
<p><strong>CAS 指令</strong>需要有 <strong>3 个操作数</strong>，分别是<strong>内存位置</strong>（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、<strong>旧的预期值</strong>（用 A 表示）和<strong>新值</strong>（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个<strong>原子操作</strong>。</p>
<p>Unsafe 类<strong>不是提供给用户程序调用的类</strong>（Unsafe.getUnsafe()的代码中限制了只有启动类加载器（Bootstrap  ClassLoader）加载的 Class 才能访问它），因此，如果不采用反射手段，我们只能通过其他的 Java  API 来间接使用它。</p>
<ul>
<li>如 J.U.C（java.util.concurrent） 包里面的整数原子类，其中的 compareAndSet()和 getAndIncrement()等方法都使用了 Unsafe 类的 CAS 操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>（;;）&#123;</div><div class="line">        <span class="keyword">int</span> current = get()；</div><div class="line">        <span class="keyword">int</span> next = current+<span class="number">1</span>；</div><div class="line">        <span class="keyword">if</span>（compareAndSet（current,next））</div><div class="line">            <span class="keyword">return</span> next；</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CAS 存在的问题：</p>
<ul>
<li>无法涵盖互斥同步的所有使用场景</li>
<li>存在==ABA 问题==，值改了但是自己却不知道。<ul>
<li>怎么解决？<ul>
<li>加入引用计数。</li>
<li>加入修改记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>可重入代码</strong>（Reentrant Code）：这种代码也叫做<strong>纯代码</strong>（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
<p><strong>可重入代码的一些共同的特征</strong>：</p>
<ul>
<li>不依赖存储在堆上的数据和公用的系统资源、</li>
<li>用到的状态量都由参数中传入、</li>
<li>不调用非可重入的方法等。</li>
</ul>
<p><strong>判断代码是否具备可重入性</strong>：如果一个方法，它的<strong>返回结果是可以预测的</strong>，也就是说只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p>
<h4 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3. 无同步方案"></a>3. 无同步方案</h4><p>一个数据的可见范围局限在同一个线程之内， 不会存在多线程竞争问题，也就不需要进行同步了。</p>
<p>如果一个变量要被某个线程独享，Java 中可以通过 <code>java.lang.ThreadLocal</code> 类来实现线程本地存储的功能。每一个线程的 Thread 对象中都有一个 ThreadLocalMap 对象，这个对象存储了一组以 <code>ThreadLocal.threadLocalHashCode</code> 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值，使用这个值就可以在线程 K-V 值对中找回对应的本地线程变量。</p>
<h2 id="Java-中锁的分类与优化"><a href="#Java-中锁的分类与优化" class="headerlink" title="Java 中锁的分类与优化"></a>Java 中锁的分类与优化</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>又称为「递归锁」，指的是当同一个线程的外层方法获取锁时，进入内层方法会自动获取锁。</p>
<p>可重入锁的一个好处就是可以在一定程度上避免死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Thread.sleep(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="独享-占-锁-共享锁"><a href="#独享-占-锁-共享锁" class="headerlink" title="独享(占)锁/共享锁"></a>独享(占)锁/共享锁</h3><p>根据能够同时被多少线程持有来区分。</p>
<ul>
<li>独享锁就是指该锁一次仅能被一个线程所持有。</li>
<li>共享锁可以同时被多个线程持有。</li>
</ul>
<h3 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h3><p>上面讲的<strong>独享锁/共享锁</strong>就是一种<strong>广义的说法</strong>，<strong>互斥锁/读写锁</strong>就是<strong>具体的实现</strong>。</p>
<ul>
<li>互斥锁：在 Java 中的具体就是 ReentrantLock</li>
<li>读写锁：在 Java 中的具体实现就是 ReadWriteLock。其读锁是共享锁，其写锁是独享锁。<ul>
<li>读锁的共享可保证高效并发。</li>
<li>读写、写读、写写的过程是<strong>互斥的</strong></li>
</ul>
</li>
</ul>
<p>独享锁与共享锁也是使用 AQS 来实现的。通过实现不同的方法来实现独享或者共享。</p>
<h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h3><p>并不是指具体类型的锁，而是指<strong>看待并发同步的态度</strong>。</p>
<p><strong>悲观锁</strong>采用一种悲观的并发策略<strong>，</strong>总是<strong>认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题</strong>。<br>所谓乐观锁就是，每次不加锁而是<strong>假设没有冲突而去完成某项操作</strong>，如果因为<strong>冲突失败就重试，直到成功为止</strong>。乐观锁不能解决脏读的问题。</p>
<h4 id="二者之间如何选择选择？"><a href="#二者之间如何选择选择？" class="headerlink" title="二者之间如何选择选择？"></a>二者之间如何选择选择？</h4><p>首先要弄清楚，事实是悲观的还是乐观的？</p>
<p>假如你的资源竞争很激烈，并且无法共享的话，乐观锁不过是让大量请求的希望落空罢了。——如果事实是悲观的，但是采用了乐观锁，那就只会导致大量请求落空罢了。</p>
<p>假如你的资源没什么竞争（这个和并发高低没必然的关联，业务的影响更大），那悲观锁意味着不必要地加锁。如果原本是可共享的资源（比如资源支持多个只读方），那么悲观锁意味着失去原本的可以使用的时间。——如果事实是乐观的，但是使用了悲观锁，那么就损失一些本来可以使用的时间。</p>
<p>再详细点可以从以下几个方面来判断：</p>
<ol>
<li><strong>响应速度</strong>：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。</li>
<li><strong>冲突频率</strong>：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li>
<li><strong>重试代价</strong>：如果重试代价大，建议采用悲观锁。</li>
</ol>
<p>以上内容参考自<a href="https://segmentfault.com/q/1010000009251675" target="_blank" rel="external">高并发下悲观锁与乐观锁的选择问题</a></p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种<strong>锁的设计</strong>，并不是具体的一种锁。</p>
<p>我们以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code>中的分段锁称为 Segment，它即类似于 HashMap（Java7 与 Java8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，<strong>数组中的每个元素又是一个链表；同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock)</strong>。<br>当需要 put 元素的时候，并不是对整个 hashmap 进行加锁，而是<strong>先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁</strong>，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p>
<p>但是，在统计 size 的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计<strong>目的是细化锁的粒度</strong>，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>
<h3 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h3><p>这三种锁是指<strong>锁的状态</strong>，并且是针对<code>Synchronized</code>。在 Java5 通过引入<strong>锁升级的机制</strong>来实现高效<code>Synchronized</code>。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p>
<p><strong>偏向锁</strong>：当一段同步代码总是被一个线程访问的时候，那么该线程就会自动获取锁，降低获取锁的代价。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是<strong>在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了</strong>。偏向锁的“偏”，意思是这个锁会<strong>偏向于第一个获得它的线程</strong>，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p><strong>轻量级锁</strong>：当锁是偏向锁时（因为经常被一个线程访问），当另外一个线程需要访问相应的同步代码段时，偏向锁会升级为轻量级锁，其他线程会通过<strong>自旋的方式</strong>尝试去获取锁，轻量级锁并不是用来代替重量级锁的，它的本意是<strong>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>。</p>
<p><strong>重量级锁</strong>：自旋达到一定次数之后，就会膨胀为重量级锁。重量级锁会使其他申请线程进入阻塞状态。</p>
<p>锁<strong>可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p>
<p>锁的升级：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/30313216-2beddbd8-97cf-11e7-8e50-d07dccb4ec21.png" alt="lock update"></p>
<h4 id="偏向锁的实现"><a href="#偏向锁的实现" class="headerlink" title="偏向锁的实现"></a>偏向锁的实现</h4><p>假设当前虚拟机启用了偏向锁，那么，当锁对象<strong>第一次被线程获取的时候</strong>，虚拟机将会把对象头中的标志位设为“01”，即<strong>偏向模式</strong>。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，</p>
<ul>
<li>如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking、Unlocking 及对 Mark Word 的 Update 等）。</li>
<li>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</li>
<li>根据锁对象目前是否处于被锁定的状态，<strong>撤销偏向</strong>（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，</li>
<li>后续的同步操作就如上面介绍的轻量级锁那样执行。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/30313215-2bede358-97cf-11e7-84bd-2eeff1472644.png" alt="lock"></p>
<p>图片参考自<a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="external">聊聊并发（二）——Java SE1.6中的Synchronized</a></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="轻量级锁的加锁过程"><a href="#轻量级锁的加锁过程" class="headerlink" title="轻量级锁的加锁过程"></a>轻量级锁的加锁过程</h5><p>在代码进入同步块的时候，</p>
<ul>
<li>如果此同步对象<strong>没有被锁定</strong>（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为<strong>锁记录</strong>（Lock  Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），这时候线程堆栈与对象头的状态如图 13-3 所示。</li>
<li>然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。<ul>
<li>如果这个<strong>更新动作成功了</strong>，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后 2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示。</li>
<li>如果这个<strong>更新操作失败了</strong>，虚拟机首先会检查对象的 <strong>Mark Word 是否指向当前线程的栈帧</strong>，<ul>
<li>如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，</li>
</ul>
</li>
<li>否则说明这个锁对象已经被其他线程抢占了。<ul>
<li>如果有<strong>两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁</strong>，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/28906024-2978ad6c-7847-11e7-88d2-30d22e7babb0.png" alt="cas"></p>
<p><img src="https://user-images.githubusercontent.com/16668676/30313218-2c1d4698-97cf-11e7-9765-6d1ffdc9b915.png" alt="light weight"></p>
<p>图片参考自<a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="external">聊聊并发（二）——Java SE1.6中的Synchronized</a></p>
<h5 id="轻量级锁的解锁过程"><a href="#轻量级锁的解锁过程" class="headerlink" title="轻量级锁的解锁过程"></a>轻量级锁的解锁过程</h5><p><strong>解锁过程也是通过 CAS 操作来进行的</strong></p>
<ul>
<li>如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作<strong>把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来</strong>，<ul>
<li>如果替换成功，整个同步过程就完成了。</li>
<li>如果替换失败，说明有其他线程<strong>尝试过获取该锁</strong>，那就要在释放锁的同时，唤醒被挂起的线程。（如何唤醒？ <code>notify()</code> ）</li>
</ul>
</li>
</ul>
<p>轻量级锁能提升程序同步性能的<strong>依据</strong>是“<strong>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</strong>”，这是一个经验数据。</p>
<ul>
<li>如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，</li>
<li>如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在==有竞争的情况下，轻量级锁会比传统的重量级锁更慢==。</li>
</ul>
<h4 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU</td>
<td>追求响应时间,锁占用时间很短</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗 CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量,锁占用时间较长</td>
</tr>
</tbody>
</table>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>在 Java 中，自旋锁是指<strong>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</strong>，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。<br>典型的自旋锁实现的例子，可以参考<a href="http://ifeve.com/java_lock_see1/" target="_blank" rel="external">自旋锁的实现</a></p>
<p>如果线程<strong>竞争不激烈</strong>，并且保持锁的时间段。适合使用自旋锁。这样可以避免线程挂起和恢复(挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力)，从而降低性能开销。</p>
<ul>
<li>自旋次数的默认值是 10 次，用户可以使用参数<code>-XX：PreBlockSpin</code> 来更改。</li>
</ul>
<p>在 Java 1.6 中引入了<strong>自适应的自旋锁</strong>。自适应意味着<strong>自旋的时间不再固定了</strong>，而是<strong>由前一次在同一个锁上的自旋时间及锁的拥有者的状态</strong>来决定。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p><strong>锁消除</strong>是指虚拟机<strong>即时编译器在运行时</strong>，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p>
<p>锁消除的<strong>主要判定依据</strong>来源于<strong>逃逸分析的数据支持</strong>（第 11 章已经讲解过逃逸分析技术），如果判断在一段代码中，<strong>堆上的所有数据都不会逃逸出去</strong>从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String concatString（String s1，String s2，String s3）&#123;</div><div class="line">    StringBuffer sb=<span class="keyword">new</span> StringBuffer()；</div><div class="line">    sb.append（s1）；</div><div class="line">    sb.append（s2）；</div><div class="line">    sb.append（s3）；</div><div class="line">    <span class="keyword">return</span> sb.toString()；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个 StringBuffer.append()方法中都有一个同步块，锁就是 sb 对象。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString()方法内部。sb 的所有引用永远不会“逃逸”到 concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在<strong>即时编译之后，这段代码就会忽略掉所有的同步而直接执行</strong>了。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为<strong>使得需要同步的操作数量尽可能变小</strong>。</p>
<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，<strong>频繁地进行互斥同步操作也会导致不必要的性能损耗</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String concatString（String s1，String s2，String s3）&#123;</div><div class="line">    StringBuffer sb=<span class="keyword">new</span> StringBuffer()；</div><div class="line">    sb.append（s1）；</div><div class="line">    sb.append（s2）；</div><div class="line">    sb.append（s3）；</div><div class="line">    <span class="keyword">return</span> sb.toString()；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面连续的 append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会<strong>把加锁同步的范围扩展（粗化）到整个操作序列的外部</strong>，以上述代码为例，就是扩展到第一个 append()操作之前直至最后一个 append()操作之后，这样只需要加锁一次就可以了。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.importnew.com/20472.html" target="_blank" rel="external">乐观锁的一种实现方式——CAS</a></li>
<li><a href="http://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="external">Java 中的锁分类</a></li>
<li><a href="http://blog.csdn.net/vernonzheng/article/details/8275624" target="_blank" rel="external">Java多线程（七）之同步器基础：AQS框架深入分析</a></li>
<li><a href="https://segmentfault.com/q/1010000009251675" target="_blank" rel="external">高并发下悲观锁与乐观锁的选择问题</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="external">聊聊并发（二）——Java SE1.6中的Synchronized</a></li>
<li>《深入理解 Java 虚拟机》</li>
</ul>
<p>如果本文中存在不正确的说法，请提出，共同讨论，共同进步，谢谢！</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 并发 </category>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 集合框架之 HashMap 工作原理]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/10/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8B%20HashMap%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>概括的说，<code>HashMap</code> 是一个<strong>关联数组、哈希表</strong>，它是<strong>线程不安全</strong>的，允许<strong>key 为 null</strong>,<strong>value 为 null</strong>。遍历时<strong>无序</strong>。<br>其底层数据结构是<strong>数组</strong>称之为<strong>哈希桶</strong>，每个<strong>桶里面放的是链表</strong>，链表中的<strong>每个节点</strong>，就是哈希表中的<strong>每个元素</strong>。<br>在 JDK8 中，当链表长度达到 8，会转化成红黑树，以提升它的查询、插入效率，它实现了<code>Map&lt;K,V&gt;, Cloneable, Serializable</code>接口。</p>
<p>因其底层哈希桶的数据结构是数组，所以也会涉及到<strong>扩容</strong>的问题。</p>
<p>当<code>HashMap</code>的容量达到<code>threshold</code>域值时，就会触发扩容。扩容前后，哈希桶的<strong>长度一定会是 2 的次方</strong>。<br>这样在根据 key 的 hash 值寻找对应的哈希桶时，可以<strong>用位运算替代取余操作</strong>，<strong>更加高效</strong>。</p>
<p>而 key 的 hash 值，并不仅仅只是 key 对象的<code>hashCode()</code>方法的返回值，还会经过<strong>扰动函数</strong>的扰动，以使 hash 值更加均衡。<br>因为<code>hashCode()</code>是<code>int</code>类型，取值范围是 40 多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。<br>但就算原本的<code>hashCode()</code>取得很好，每个 key 的<code>hashCode()</code>不同，但是由于<code>HashMap</code>的哈希桶的长度远比 hash 取值范围小，默认是 16，所以当对 hash 值以桶的长度取余，以找到存放该 key 的桶的下标时，由于取余是通过与操作完成的，会忽略 hash 值的高位。因此只有<code>hashCode()</code>的低位参加运算，发生不同的 hash 值，但是得到的 index 相同的情况的几率会大大增加，这种情况称之为<strong>hash 碰撞。</strong> 即，碰撞率会增大。</p>
<p><strong>扰动函数</strong>就是为了解决 hash 碰撞的。它会综合 hash 值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少 hash 碰撞的概率。（在 JDK8 之前，扰动函数会扰动四次，JDK8 简化了这个操作）</p>
<a id="more"></a>
<p>执行扩容操作时，会 new 一个新的<code>Node</code>数组作为哈希桶，然后将原哈希表中的所有数据(<code>Node</code>节点)移动到新的哈希桶中，相当于对原哈希表中所有的数据重新做了一个 put 操作。所以性能消耗很大，<strong>可想而知，在哈希表的容量越大时，性能消耗越明显。</strong></p>
<p>扩容时，如果发生过哈希碰撞，节点数小于 8 个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。<br>因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位= low 位+原哈希桶容量<br>如果追加节点后，链表数量》=8，则转化为红黑树</p>
<p>由迭代器的实现可以看出，遍历 HashMap 时，顺序是按照哈希桶从低到高，链表从前往后，依次遍历的。属于<strong>无序</strong>集合。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="两个重要的参数"><a href="#两个重要的参数" class="headerlink" title="两个重要的参数"></a>两个重要的参数</h3><blockquote>
<p>  An instance of <code>HashMap</code> has two parameters that affect its performance: <em>initial capacity</em> and <em>load factor</em>. <strong>The <em>capacity</em> is the number of buckets in the hash table</strong>, and the initial capacity is simply the capacity at the time the hash table is created. The <em>load factor</em> is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is <em>rehashed</em> (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.</p>
</blockquote>
<ul>
<li>capacity：容量。也就是哈希桶数组的长度。默认初始化容量为 16。</li>
<li>loadFactor：加载因子。  扩容的阈值 <code>threshold = capacity * loadFactor</code><ul>
<li>加载因子默认为 0.75，这是时间和空间上的折衷点。大于 0.75，能提高空间利用率，但是会导致查找效率降低。</li>
</ul>
</li>
</ul>
<p>当 hashMap 中元素的总数大于 capacity * loadFactor  时，就会发生扩容（将 buckets 的数目调整为当前的两倍）。</p>
<p>capacity 被控制为 2 的 n 次方（一定是合数），这有点不合常规。常规的做法是将桶数组的长度设置为素数，因为相对而言使用素数发生冲突的概率要比使用合数要小一些。HashTable 默认初始化容量就为 11（素数，Hashtable 扩容后不能保证还是素数）。之所以这样设计是取模和扩容时进行优化（使用位运算<strong>提高效率</strong>），同时也是为了<strong>减少冲突</strong>，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<h3 id="put-函数的实现"><a href="#put-函数的实现" class="headerlink" title="put 函数的实现"></a>put 函数的实现</h3><p>1.8 对 HashMap 的底层实现进行了修改（当相同 hash 值的元素大于 8 个时，会将链表转换为 红黑树，以提高查找效率），所以 put 函数看起来相对复杂了点，通过以下流程图能帮助理解。</p>
<p>图片出自<a href="https://tech.meituan.com/img/java-hashmap/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" target="_blank" rel="external">这篇文章</a>。</p>
<p><img width="858" alt="hashmap put" src="https://user-images.githubusercontent.com/16668676/30247192-dbfc4bf8-9640-11e7-9fd6-0aca25db077c.png"></p>
<p>注意：对于 resize 方法的是否需要执行有两次判断：</p>
<p>第一次判断桶数组是否为空，如果为空，则通过 resize 方法执行初始化操作。<br>第二次判断是在插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p>
<p>put 方法具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定的值与该映射中指定的键关联起来。</div><div class="line"> * 如果该 key 对应的 value 存在，则替换旧值</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt;[] tab; java.util.HashMap.Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//桶数组为空或者长度为 0（说明还未初始化）</span></div><div class="line">        n = (tab = resize()).length;<span class="comment">//调用扩容方法进行初始化，并获取初始化后桶数组的长度</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)<span class="comment">//根据 hash 值与 n-1 进行「模运算」获取插入数组的索引的 i。</span></div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//创建新结点</span></div><div class="line">    <span class="keyword">else</span> &#123; <span class="comment">//发生碰撞</span></div><div class="line">        java.util.HashMap.Node&lt;K,V&gt; e; K k;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;        <span class="comment">//key 值相同，替换旧值</span></div><div class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> java.util.HashMap.TreeNode)<span class="comment">//该链为树</span></div><div class="line">            e = ((java.util.HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;<span class="comment">//该链为链表</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);<span class="comment">//转换为红黑树</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">      </div><div class="line">        <span class="comment">//如果本身存在相同的 key，则将旧值返回</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;<span class="comment">//结构化修改次数加 1</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//如果当前数量超过阈值，则进行扩容</span></div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);<span class="comment">//默认为空实现</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//原先 key 不存在，也就是说没有旧值，直接返回 null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get-函数的实现"><a href="#get-函数的实现" class="headerlink" title="get 函数的实现"></a>get 函数的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取给定 key 的 hash 值，获取相应位置 value</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> java.util.HashMap.<span class="function">Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt;[] tab; java.util.HashMap.Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; </div><div class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//先检查对应位置的「头结点」，如果匹配直接返回对应的值</span></div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> java.util.HashMap.TreeNode)<span class="comment">//该链是红黑树，根据 hash 和 key 到 树中查找相应的 value,直接返回</span></div><div class="line">                <span class="keyword">return</span> ((java.util.HashMap.TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="comment">//该链是链表，到链表中遍历查找</span></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 get 方法的大致逻辑是这样的：</p>
<ul>
<li>先计算出当前 key 的 hash 值，然后通过 getNode 方法去获取当前对应的结点</li>
<li>如果对应的节点为 null，直接返回 null，</li>
<li>否则返回节点中的  value。</li>
</ul>
<p>getNode 方法的实现思路是这样的：</p>
<ul>
<li>通过 hash 跟 当前容量进行 <strong>与运算</strong> 得到数组下标</li>
<li>使用指定下标去获取对应的节点（从头结点开始）<ul>
<li>如果首个元素就命中，直接返回结点。</li>
<li>存在冲突：<br>如果该 hash 值对应的是一棵<strong>红黑树</strong>，则到红黑树中去获取相应的结点。<br>如果该 hash 值对应的是一个<strong>链表</strong>，则遍历该链表，直到取得相应的结点或者到达链尾。</li>
</ul>
</li>
</ul>
<h3 id="hash-函数的实现"><a href="#hash-函数的实现" class="headerlink" title="hash 函数的实现"></a>hash 函数的实现</h3><p>在 HashMap 中，哈希桶数组 table 的长度 length 大小必须为 2 的 n 次方(一定是合数)，这是一种<strong>非常规的设计</strong>，<strong>常规的设计是把桶的大小设计为素数</strong>。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable 初始化桶大小为 11，就是桶大小设计为素数的应用（Hashtable 扩容后不能保证还是素数）。HashMap 采用这种非常规设计，<strong>主要是为了在取模和扩容时做优化，同时为了减少冲突</strong>，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<p>通过 <code>h &amp; (table.length -1)</code> 来得到该对象的保存位，而 <code>HashMap</code> 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。当 length 总是 2 的 n 次方时，h&amp; (length-1) 运算等价于对 length 取模，也就是 h%length，但是&amp;比%具有更高的效率。</p>
<ul>
<li><code>h &amp; (length - 1) 《==》 h % length</code></li>
</ul>
<p>在 JDK1.8 的实现中，优化了高位运算的算法，通过 <code>hashCode()</code>的高 16 位（其实是完整的） 异或 低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。</p>
<p>hash 是 int 类型的（32 位），原 hashcode 异或 右移 16 位后的 hashcode，高低位兼顾</p>
<ul>
<li>右移 16 位，那么高 16 位均为 0，所以高十六位的取值均取决于 key 的 hashCode 高十六位，</li>
<li>低 16 位的值由 hashcode 的低十六位与高十六位</li>
</ul>
<p>在 get 和 put 的过程中，计算下标时，先对 hashCode 进行 hash 操作，然后再通过 hash 值进一步计算下标，如下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6957712/293b52fc-d932-11e4-854d-cb47be67949a.png" alt="hash"></p>
<p>在对 hashCode()计算 hash 时具体实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">  	<span class="comment">//因为 h &gt;&gt;&gt; 16 右移了 16 位(高 16 位都为 0)，因此结果的高 16 位仍然是 key.hashCode() 的高 16 位</span></div><div class="line">  	<span class="comment">//而低 16 位取决于 key.hashCode() 的高十六位和低十六位进行异或的结果</span></div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到这个函数大概的作用就是：高 16bit 不变，低 16bit 和高 16bit 做了一个异或。这样做的目的就在于你求余的时候<strong>包含了高 16 位和第 16 位的特性</strong> 也就是说你所计算出来的 hash 值包含从而使得你的 hash 值更加「随机」以降低碰撞的概率</p>
<h4 id="计算下标"><a href="#计算下标" class="headerlink" title="计算下标"></a>计算下标</h4><p>存储结点时，计算得到的 hash 值可能远大于哈希桶数组的长度，为了避免数组越界，我们需要进行<strong>取模运算</strong>。计算下标的时候，是这样实现的(使用<code>&amp;</code>位操作，而非<code>%</code>求余)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(n - <span class="number">1</span>) &amp; hash</div></pre></td></tr></table></figure>
<p>上面的计算实际上等价于<code>hash % n</code>，但是前者的效率比较高。前面我们提到过，HashMap 的数组长度一定是 2 的 ？次方。也就是说 (n - 1) 可以化为 0…0011…1，这样跟 hash 进行与运算，就相当于取模运算。</p>
<h4 id="Java-8-所做的优化"><a href="#Java-8-所做的优化" class="headerlink" title="Java 8 所做的优化"></a>Java 8 所做的优化</h4><p>hash 函数设计得再好，也无法避免冲突的。如何解决冲突也是一门学问。</p>
<p>在 Java 8 之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行 get 时，两步的时间复杂度是 O(1)+O(n)。因此，当碰撞很厉害的时候 n 很大，O(n)的速度显然是影响速度的。</p>
<p>因此在 Java 8 中，当链表长度大于 8 时，就利用红黑树替换链表，这样复杂度就变成了 O(1)+O(logn)了，这样在 n 很大的时候，能够比较理想的解决这个问题，在<a href="http://www.importnew.com/14417.html" target="_blank" rel="external">Java 8：HashMap 的性能提升</a>一文中有性能测试的结果。</p>
<h3 id="resize-（扩容）实现"><a href="#resize-（扩容）实现" class="headerlink" title="resize （扩容）实现"></a>resize （扩容）实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 初始化或者扩容一倍</div><div class="line"> * */</div><div class="line"><span class="keyword">final</span> java.util.HashMap.Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//旧长度</span></div><div class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧阈值</span></div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="comment">//这一段用于确定新容量,并根据新容量重新确定阈值</span></div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//旧容量大于最大允许容量，将阈值赋值为最大允许容量</span></div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//直接返回旧表</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="comment">//扩容后小于允许的最大容量，且大于默认初始容量（16），则修改 threshold</span></div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// threshold 增大一倍</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 原有阈值大于 0，但是原容量小于 0</span></div><div class="line">        newCap = oldThr;<span class="comment">//将新容量赋值为就旧阈值</span></div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// 原阈值、原容量均为 0 ，使用默认的初始化参数来创建 map</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//默认的初始化容量 （16）</span></div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//新的阈值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新阈值为 0</span></div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;<span class="comment">//重新计算</span></div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE); <span class="comment">//如果阈值大于最大容量，修改阈值为 int 的最大值(2^31-1)，这样以后就不会扩容了</span></div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">    java.util.HashMap.Node&lt;K,V&gt;[] newTab = (java.util.HashMap.Node&lt;K,V&gt;[])<span class="keyword">new</span> java.util.HashMap.Node[newCap];<span class="comment">//按照新容量 创建数组</span></div><div class="line">    table = newTab;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原有的 map 上的元素不为空，将原有 map 上面的数据复制到新的 map 上面</span></div><div class="line">        <span class="comment">//遍历旧元素</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            java.util.HashMap.Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;<span class="comment">//释放，防止内存泄漏</span></div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//该桶中只有一个元素，获取的 hash 值并与（新容量 -1）进行 与运算</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> java.util.HashMap.TreeNode)<span class="comment">//如果该元素是一个树节点（说明该桶对应有一棵红黑树），将树存储到新数组上</span></div><div class="line">                    ((java.util.HashMap.TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 保持顺序</span></div><div class="line">                    <span class="comment">//因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位 = low 位+原哈希桶容量</span></div><div class="line">                    <span class="comment">//低位链表的头结点、尾节点</span></div><div class="line">                    java.util.HashMap.Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    <span class="comment">//高位链表的头结点、尾节点</span></div><div class="line">                    java.util.HashMap.Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    <span class="comment">//临时结点</span></div><div class="line">                    java.util.HashMap.Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//根据 hash 值与 oldCap 的运算结果，将链表中集结的元素分开，可认为结果是随机的</span></div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//在原索引处存放 「低位链表」</span></div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//在原索引加上原容量处，存放「高位链表」</span></div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="hashMap 1.8 哈希算法例图 1"></p>
<p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt="hashMap 1.8 哈希算法例图 2"></p>
<p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图：</p>
<p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt="jdk1.8 hashMap 扩容例图"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>此部分内容参考自<a href="http://yikun.github.io/2015/04/01/Java-HashMap 工作原理及实现/" target="_blank" rel="external">HashMap 的工作原理</a></p>
<p><strong>1. 什么时候会使用 HashMap？他有什么特点？</strong><br>是基于 Map 接口的实现，存储键值对时，它可以接收 null 的键值，是非同步的，HashMap 存储着 Entry(hash, key, value, next)对象。</p>
<p><strong>2. 你知道 HashMap 的工作原理吗？</strong><br>通过 hash 的方法，通过 put 和 get 存储和获取对象。存储对象时，我们将 K/V 传给 put 方法时，它调用 hashCode 计算 hash 从而得到 bucket 位置，进一步存储，HashMap 会根据当前 bucket 的占用情况自动调整容量(超过 Load Facotr 则 resize 为原来的 2 倍)。获取对象时，我们将 K 传给 get，它调用 hashCode 计算 hash 从而得到 bucket 位置，并进一步调用 equals()方法确定键值对。如果发生碰撞的时候，Hashmap 通过链表将产生碰撞冲突的元素组织起来，在 Java 8 中，如果一个 bucket 中碰撞冲突的元素超过某个限制(默认是 8)，则使用红黑树来替换链表，从而提高速度。</p>
<p><strong>3. 你知道 get 和 put 的原理吗？equals()和 hashCode()的都有什么作用？</strong><br>通过对 key 的 hashCode()进行 hashing，并计算下标( n-1 &amp; hash)，从而获得 buckets 的位置。如果产生碰撞，则利用 key.equals()方法去链表或树中去查找对应的节点</p>
<p><strong>4. 你知道 hash 的实现吗？为什么要这样实现？</strong><br>在 Java 1.8 的实现中，是通过 hashCode()的高 16 位异或低 16 位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在 bucket 的 n 比较小的时候，也能保证考虑到高低 bit 都参与到 hash 的计算中，同时不会有太大的开销。</p>
<p><strong>5. 如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认 0.75)，则会重新 resize 一个原来长度两倍的 HashMap，并且重新调用 hash 方法。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://blog.csdn.net/zxt0601/article/details/77413921" target="_blank" rel="external">面试必备：HashMap 源码解析（JDK8）</a></li>
<li><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="external">HashMap 的 hash 函数原理</a></li>
<li><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">重新认识 HashMap</a></li>
<li><a href="http://yikun.github.io/2015/04/01/Java-HashMap 工作原理及实现/" target="_blank" rel="external">HashMap 的工作原理</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> java </category>
            
            <category> 集合框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM 垃圾收集器与内存分配策略]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/08/JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h2 id="确定回收的对象"><a href="#确定回收的对象" class="headerlink" title="确定回收的对象"></a>确定回收的对象</h2><p><strong>「死去」的对象</strong>即不可能再被任何途径使用的对象。</p>
<p>几乎所有对象的实例都存在堆中。（部分 String 对象存在于字符串常量池中，JDK1.7 以前，字符串常量池存放在方法区中）。</p>
<p>进行回收的第一步就是确定哪些对象还活着，哪些已经死亡。</p>
<a id="more"></a>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，</p>
<ul>
<li>每当有一个地方引用它时，计数器值就加 1；</li>
<li>当引用失效时，计数器值就减 1；</li>
<li>任何时刻计数器为 0 的对象就是不可能再被使用的。</li>
</ul>
<p><strong>缺点</strong>：很难解决对象之间<strong>相互循环引用的问题</strong>。因此 Java 虚拟机中没有采用引用计数算法来管理内存。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>主流的商用程序语言的主流实现中，都是通过<strong>可达性分析</strong>来判断对象是否存活的。</p>
<p>算法的基本思路：</p>
<ul>
<li>通过一系列的称为 GC Root 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为『引用链』（Reference Chain）</li>
<li><p><strong>当一个对象到 GC Root 没有任何引用链相连时，则证明此对象是不可用的</strong>。</p>
<p>GC Root 对象的定义是什么？  <a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;cp=37_2_3" target="_blank" rel="external">Help - Eclipse Platform</a> 上给的定义是这样的：</p>
</li>
</ul>
<blockquote>
<p>  A garbage collection root is an object that is accessible from outside the heap</p>
</blockquote>
<p>也就是说 GC Roots 是可以从堆外访问的对象。</p>
<p>GC Roots 对象包含以下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象，也就是局部变量引用的对象。</li>
<li>本地方法栈中 JNI 引用的对象</li>
<li>方法区中<strong>类静态属性</strong>引用的对象</li>
<li>方法区中<strong>常量引用</strong>的对象</li>
</ul>
<h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>JDK 1.2 之后对，Java 对引用的概念进行了扩充（不再是仅有被引用或者没有被引用两种）：</p>
<p>共有四种：</p>
<ul>
<li><strong>强引用</strong><ul>
<li>只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
</ul>
</li>
<li><strong>软引用</strong> SoftReference <ul>
<li>内存不够时被回收<ul>
<li>在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
</ul>
</li>
</ul>
</li>
<li><strong>弱引用</strong> WeakReference<ul>
<li>只要一执行 GC 就会被回收</li>
</ul>
</li>
<li><strong>虚引用</strong>，也称为<strong>幽灵引用、幻影引用</strong>  PhantomReference<ul>
<li>『形同虚设』。一个对象被持有虚引用对其生命周期毫无影响</li>
<li>虚引用的作用仅仅是在该对象被回收时，收到一个系统通知而已</li>
</ul>
</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>一个对象的 finalize 方法最多只会被系统调用一次。</p>
<p>即使在可达性分析算法中不可达的对象，也并非是「非死不可」的，<strong>要真正宣告一个对象死亡，至少要经历两次标记过程</strong>：</p>
<ul>
<li>如果对象在进行<strong>可达性分析</strong>后发现没有与 GCRoots 相连接的引用链，那它将会被<strong>第一次标记并且进行一次筛选</strong>，<ul>
<li><strong>筛选的条件</strong>是此对象<strong>是否有必要执行 finalize 方法</strong>。当对象<strong>没有覆盖 finalize 方法</strong>，或者 <strong>finalize 方法已经被虚拟机调用过</strong>，虚拟机将这两种情况都视为「<strong>没有必要执行</strong>」。</li>
<li>如果这个对象被判定为<strong>有必要执行 finalize 方法</strong>，那么这个对象将会放置在一个叫做 <strong>F-Queue 的队列</strong>之中，并在稍后由一个由虚拟机自动建立的、低优先级的 <strong>Finalizer 线程</strong>去执行它。</li>
</ul>
</li>
</ul>
<p>这里所谓的「<strong>执行</strong>」是指虚拟机 <strong>会触发</strong>这个方法，但并<strong>不承诺会等待它运行结束</strong>，为什么要这么做？</p>
<ul>
<li>因为如果承诺得到 finalize 方法执行结束，那么当一个对象在 finalize 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。</li>
</ul>
<p>finalize 方法是<strong>对象逃脱死亡命运的==最后一次机会==</strong>，稍后 GC 将对 F-Queue 中的对象进行<strong>第二次小规模的标记</strong>，</p>
<ul>
<li>如果对象要在 finalize 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在<strong>第二次标记时它将被移除出「即将回收」的集合</strong>；</li>
<li>如果对象这时候还没有逃脱，那基本上它就真的被回收了。</li>
</ul>
<p>任何一个对象的 finalize 方法只会被系统调用一次。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久代的垃圾回收主要回收两部分的内容：</p>
<ul>
<li>废弃常量</li>
<li>无用的类</li>
</ul>
<h4 id="回收废弃常量"><a href="#回收废弃常量" class="headerlink" title="回收废弃常量"></a>回收废弃常量</h4><p>回收废弃常量与回收 Java 堆中对象很相似。以常量池中字面量的回收为例，假如一个字符串「abc」已经进入了常量池中，它<strong>没有被引用</strong>，如果这时<strong>发生内存回收，而且必要的话</strong>，这个「abc」常量<strong>就会被系统清理出常量池</strong>。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<h4 id="回收无用类"><a href="#回收无用类" class="headerlink" title="回收无用类"></a>回收无用类</h4><p>类需要<strong>同时满足下面 3 个条件才能算是「无用的类</strong>」：</p>
<ol>
<li>该类所有的<strong>实例都已经被回收</strong>，也就是 Java 堆中不存在该类的任何实例。</li>
<li><strong>加载该类的 ClassLoader 已经被回收</strong>。</li>
<li>该类<strong>对应的 java.lang.Class 对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><strong>标记-清除</strong> (Mark-Sweep) 算法是<strong>最基础的收集算法</strong>，分为标记和清除两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象，</li>
<li>在标记完成后统一回收所有被标记的对象</li>
</ul>
<p>之所以说它基础，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。</p>
<p>主要不足有两个：</p>
<ul>
<li><strong>效率问题</strong>：标记和清除两个过程的效率都不高；</li>
<li><strong>空间问题</strong>（确切而言是空间碎片问题）：标记清除之后会<strong>产生大量不连续的内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要<strong>分配较大对象时，无法找到足够的连续内存</strong>而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/30166872-34869854-9417-11e7-9586-95308fa7820c.png" alt="mark-sweep"></p>
<p>仅有 CMS 收集器使用了标记-清除算法。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法主要是为了解决效率问题，它<strong>将可用内存按容量划分为大小相等的两块</strong>，<strong>每次只使用其中的一块</strong>。  当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得<strong>每次都是对整个半区进行内存回收</strong>，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p><strong>商业虚拟机</strong>都采用复制收集算法来<strong>回收新生代</strong>，但并不是按照 1:1 的比例来划分内存空间，而是<strong>将内存分为一块较大的 Eden 空间和==两块==较小的 ==Survivor==</strong> 空间，<strong>每次使用 Eden 和其中一块 Survivor</strong>，当回收时，将 Eden 和 Survivor 中还存活着的对象<strong>一次性地复制到==另外一块==Survivor 空间上</strong>，最后清理掉 Eden 和刚才用过的 Survivor 空间。</p>
<ul>
<li>HotSpot 虚拟机<strong>默认 Eden 和 Survivor 的大小比例是 8:1</strong>，也就是<strong>每次新生代中可用内存空间为整个新生代容量的</strong> 90%（80%+10%），只有 10%的内存会被「浪费」。当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保</strong>（Handle Promotion）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用<strong>空间换取时间</strong>，这种算法<strong>将内存缩小为了原来的一半</strong>。</li>
<li>复制收集算法在<strong>对象存活率较高时</strong>就要进行<strong>较多的复制操作</strong>，效率将会变低。更关键的是，如果不想浪费 50%的空间，就需要有<strong>额外的空间进行分配担保</strong>，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在<strong>老年代一般不能直接选用这种复制算法</strong>。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/30166943-6af312e6-9417-11e7-8b7a-8a53bb607625.png" alt="copy sweep"></p>
<h3 id="标记-整理-算法"><a href="#标记-整理-算法" class="headerlink" title="标记-==整理==算法"></a>标记-==整理==算法</h3><p>「<strong>标记-整理」算法</strong>的标记过程仍然与「标记-清除」算法一样，但<strong>后续步骤不是直接对可回收对象进行清理</strong>，而是<strong>让所有存活的对象都向一端移动</strong>，然后直接清理掉端边界以外的内存。(先移动到『安全位置』再清除掉安全区域边界外的无用位置)</p>
<p><img src="https://user-images.githubusercontent.com/16668676/30166870-34829cb8-9417-11e7-99ae-276d0e6cd96c.png" alt="mark-compact"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>目前商业虚拟机的垃圾收集<strong>都采用「分代收集」（Generational  Collection）算法</strong>，</p>
<p>只是<strong>根据对象存活周期的不同将内存划分为几块</strong>。一般是把 Java 堆分为新生代和老年代，这样就可以<strong>根据各个年代的特点采用最适当的收集算法</strong>。</p>
<ul>
<li>在<strong>新生代</strong>中，因为对象存活率比较低，只需要付出少量存活对象的复制成本就可以完成收集。选用<strong>复制算法</strong>。</li>
<li>而<strong>老年代</strong>中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用「标记-清理」或者「标记-整理」算法来进行回收。</li>
</ul>
<h2 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h2><p>如何发起内存回收？首先要知道回收的哪些对象。</p>
<h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p>
<h4 id="分析期间引用不可变导致-GC-停顿"><a href="#分析期间引用不可变导致-GC-停顿" class="headerlink" title="分析期间引用不可变导致 GC 停顿"></a>分析期间引用不可变导致 GC 停顿</h4><p>可达性分析对执行时间的敏感还体现在 <strong>GC 停顿</strong> 上，因为这项分析工作必须在一个能确保一致性的快照中进行。</p>
<ul>
<li>「<strong>一致性</strong>」的意思是指在<strong>整个分析期间</strong>，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程（Sun 将这件事情称为「<strong>Stop The World</strong>」）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li>
</ul>
<p>由于目前的主流 Java 虚拟机使用的都是<strong>准确式 GC</strong>，也就是说，虚拟机可以准确的知道内存中某个位置的数据类型是什么。所以当执行系统停顿下来后，并<strong>不需要一个不漏地检查完所有执行上下文和全局的引用位置</strong>，虚拟机只要直接扫描存放对象引用的区域。</p>
<ul>
<li>在 HotSpot 的实现中，使用一组称为 <strong>OopMap</strong> 的数据结构来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在<strong>特定的位置记录</strong>下栈和寄存器中哪些位置是引用。这样，GC 在扫描时就可以直接得知这些信息了。</li>
</ul>
<p>使用空间换时间。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>从线程角度看，safepoint 可以理解成是在代码执行过程中的<strong>一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的</strong>，（就好像高速公路上的服务区，可以安全地停下来休息）</p>
<ul>
<li>如果有需要，可以在这个位置暂停，比如发生 GC 时，需要暂停暂停所以活动线程，</li>
<li>但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待 GC 结束。（还在马路上，就不能休息，要到下一个服务区才能休息）</li>
</ul>
<h4 id="安全的选取"><a href="#安全的选取" class="headerlink" title="安全的选取"></a>安全的选取</h4><p>安全点是怎么选的？基本上是以程序「<strong>是否具有让程序长时间执行的特征」为标准</strong>进行选定的。</p>
<ul>
<li>「<strong>长时间执行</strong>」的<strong>最明显特征就是指令序列复用</strong>，例如：方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint。 </li>
</ul>
<h4 id="GC-时让线程停止的方式"><a href="#GC-时让线程停止的方式" class="headerlink" title="GC 时让线程停止的方式"></a>GC 时让线程停止的方式</h4><p>如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都「跑」到最近的安全点上再停顿下来？</p>
<p>这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），</p>
<ul>
<li><strong>抢先式中断</strong><br>在 GC 发生时，首先把所有线程全部中断，如果<strong>发现有线程中断的地方不在安全点上</strong>，就恢复线程，<strong>让它「跑」到安全点上</strong>。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。</li>
<li><strong>主动式中断</strong><br>主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，<strong>仅仅简单地设置一个标志</strong>，<strong>各个线程执行时主动去轮询这个标志</strong>，发现中断标志为真时就自己中断挂起。<ul>
<li>轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ul>
</li>
</ul>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域是一个安全点连续的代码段。</p>
<p>安全区域是指在<strong>一段代码片段</strong>之中，<strong>引用关系不会发生变化</strong>。在这个区域中的任意地方开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p>
<p>在线程<strong>执行到 Safe Region 中的代码时</strong>，首先<strong>标识</strong>自己<strong>已经进入了 Safe Region</strong>，</p>
<ul>
<li>那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。<ul>
<li>（那些没标记为安全区域的怎么处理？）</li>
</ul>
</li>
<li>在线程要离开 Safe Region 时，它要<strong>检查系统是否已经完成了==根节点枚举==（或者是整个 GC 过程</strong>）[因为其他步骤可能不需要 stop the world ]<ul>
<li>如果完成了，那线程就继续执行，</li>
<li>否则它就必须等待直到<strong>收到可以安全离开 Safe Region 的信号</strong>为止。</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>内存回收如何进行是由虚拟机所采用的 GC 收集器决定的，而通常虚拟机中往往不止有一种 GC 收集器。</p>
<p>如果说<strong>收集算法是内存回收的方法论</strong>，那么垃圾回收器就是<strong>内存回收的具体实现</strong>。</p>
<p>虚拟机规范中对于垃圾回收器应该如何实现并没有任何规定。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28901528-5469b7bc-782b-11e7-856b-62c876707344.png" alt="hotspot"></p>
<p>图 3-5 展示了 7 种作用于不同分代的收集器，<strong>如果两个收集器之间存在连线，就说明它们可以搭配使用</strong>。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p>
<p>我们选择的只是对具体应用最合适的收集器。</p>
<p>以下分析的关注点：</p>
<ul>
<li>收集器的特点：<ul>
<li>工作线程数?</li>
<li>工作过程中需不需要 stop the word？<ul>
<li>需要的话具体是哪个过程需要？</li>
</ul>
</li>
</ul>
</li>
<li>能与哪个收集器搭配使用?</li>
</ul>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>一个单线程的收集器。单线程指的是它用<strong>单条线程</strong>去完成垃圾收集工作</p>
<ul>
<li>重点：在它进行垃圾收集时，必须<strong>暂停其他所有工作线程</strong>，直到它收集结束。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/28901652-5c798f30-782c-11e7-9394-6944abe6a65e.png" alt="serial serial old"></p>
<p>实际上到现在为止，它依然是<strong>虚拟机运行在 Client 模式下的默认新生代收集器</strong>。</p>
<p>优点：简单而高效（与其他收集器的单线程比），对于<strong>限定单个 CPU 的环境</strong>来说，Serial 收集器专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<p><strong>Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择</strong><br>因为在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 <strong>Serial 收集器的多线程版本</strong></p>
<p><img src="https://user-images.githubusercontent.com/16668676/28901651-5c7621ec-782c-11e7-8feb-b98516448962.png" alt="parnew serial old"></p>
<p><strong>是许多运行在 Server 模式下的虚拟机中首选的新生代收集器</strong>，其中有一个与性能无关但<br>很重要的原因是，<strong>除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作</strong>。</p>
<p>两个名词：并发和并行。</p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程<strong>并行工作</strong>，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程<strong>同时执行</strong>（但<strong>不一定是并行的，可能会交替执行</strong>），用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。</li>
<li>二者关系：并行是并发的一个子集</li>
</ul>
<h3 id="ParallelScavenge-收集器"><a href="#ParallelScavenge-收集器" class="headerlink" title="ParallelScavenge 收集器"></a>ParallelScavenge 收集器</h3><p>Parallel Scavenge 收集器是一个新生代收集器， 与 ParNew 很相似。但它的<strong>关注点与其他收集器不同</strong>，CMS 等收集器的关注点是<strong>尽可能地缩短垃圾收集时用户线程的停顿时间</strong>，而 Parallel Scavenge 收集器的目标是达到<strong>一个可控制的吞吐量</strong>（Throughput）。</p>
<p><strong>吞吐量</strong>就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即</p>
<ul>
<li><code>吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）</code>，假设虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</li>
<li>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<strong>适合在后台运算</strong>而不需要太多交互的任务。</li>
</ul>
<p><code>MaxGCPauseMillis</code> 参数允许的值是一个大于 0 的毫秒数，收集器将<strong>尽可能地保证内存回收花费的时间不超过设定值</strong>。注意：GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：<strong>系统把新生代调小一些，这也直接导致垃圾收集发生得更频繁一些</strong>。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p>GCTimeRatio 参数的值是一个大于 0 且小于 100 的整数，也就是<strong>垃圾收集时间占总时间的比率</strong>，相当于是<strong>吞吐量的倒数</strong>。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1/（1+19）），默认值为 99，就是允许最大 1 %（即 1/（1+99））的垃圾收集时间。</p>
<p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为「<strong>吞吐量优先」收集器</strong>。</p>
<p>Parallel Scavenge 收集器还有一个开关参数 <code>-XX：+UseAdaptiveSizePolicy</code>当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，<strong>虚拟机会根据当前系统的运行情况</strong>收集性能监控信息，<strong>动态调整这些参数</strong>以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 ==<strong>GC 自适应的调节策略</strong>==（GC Ergonomics）。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。</p>
<h3 id="SerialOld-收集器"><a href="#SerialOld-收集器" class="headerlink" title="SerialOld 收集器"></a>SerialOld 收集器</h3><p>Serial  Old 是 Serial 收集器的老年代版本，使用「标记-整理」算法。</p>
<ul>
<li><p>这个收集器的主要意义也是在于<strong>给 Client 模式下的虚拟机使用</strong>。</p>
</li>
<li><p>如果在 Server 模式下，那么它主要还有两大用途：</p>
<ul>
<li><p>一种用途是在 JDK 1.5 以及之前的版本中<strong>与 Parallel Scavenge 收集器</strong>搭配使用</p>
</li>
<li><p>另一种用途就是<strong>作为 CMS 收集器的后备预案</strong>，在并发收集发生 Concurrent Mode Failure 时使用。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28901652-5c798f30-782c-11e7-9394-6944abe6a65e.png" alt="serial serial old"></p>
</li>
</ul>
</li>
</ul>
<p>Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集，<strong>并非直接使用了 Serial Old 收集器，但是这个 PS MarkSweep 收集器与 Serial Old 的实现非常接近</strong>。</p>
<h3 id="ParallelOld-收集器"><a href="#ParallelOld-收集器" class="headerlink" title="ParallelOld 收集器"></a>ParallelOld 收集器</h3><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和「标记-整理」算法。</p>
<p>这个收集器是在 JDK 1.6 中才开始提供的，此前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。因为 JDK1.6 以前只能选择 serial old 作为老年代收集器。（唯一能选择的队友不行）</p>
<p>直到 Parallel  Old 收集器出现后，「吞吐量优先」收集器终于有了比较名副其实的应用组合，在<strong>注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器</strong>。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28902291-989d0c04-7830-11e7-8c0f-68559b75a4d4.png" alt="parallel scavenge parallel old"></p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS 收集器（Concurrent Mark Sweep）在 JDK1.5 时期被推出，这款收集器是 HotSpot 虚拟机中<strong>第一款真正意义上的==并发==收集器</strong>，它<strong>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</strong>。</p>
<p>CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作。</p>
<p><strong>CMS（Concurrent Mark Sweep</strong>）收集器是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。适合于交互型的应用。希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。<br>从名字（包含「Mark Sweep」）上就可以看出，CMS 收集器是<strong>基于「标记—==清除==」算法</strong>实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark） ,需要「Stop The World」<br>仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快</li>
<li><strong>并发</strong>标记（CMS concurrent mark）<br>进行 GC RootsTracing </li>
<li>重新标记（CMS remark）,需要「Stop The World」<br><strong>为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</li>
<li><strong>并发</strong>清除（CMS concurrent sweep）</li>
</ul>
<p>由于整个过程中<strong>耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作</strong>，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。通过图 3-10 可以比较清楚地看到 CMS 收集器的运作步骤中并发和需要停顿的时间。<br><img src="https://user-images.githubusercontent.com/16668676/28902476-a8394528-7831-11e7-8fae-73813a57bc06.png" alt="concurrent mark sweep"></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><strong>对 CPU 资源非常敏感</strong><br>其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是<strong>会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢</strong>，总吞吐量会降低。<ul>
<li>CMS 默认启动的回收线程数是（<code>CPU 数量 + 3）/ 4</code>，<ul>
<li>也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25%的 CPU 资源，并且随着 CPU 数量的增加而下降。</li>
<li>但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大.</li>
</ul>
</li>
<li>用户程序在 GC 过程中执行 缓慢的问题，推出了<strong>增量式 CMS</strong>（i-CMS），在并发标记、清除时让 GC 线程与用户线程交替执行，尽量减少 GC 线程独占资源的时间，虽然这样会导致整个垃圾回收过程变长。但是效果不明显，目前版本中已经不再推荐使用。</li>
</ul>
</li>
<li><strong>无法处理浮动垃圾</strong>（Floating  Garbage）<br>可能出现「Concurrent  Mode Failure」失败而导致另一次 Full GC 的产生。<ul>
<li>由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为「<strong>浮动垃圾</strong>」。</li>
</ul>
</li>
<li><strong>收集结束时会产生大量空间碎片</strong>。（因为使用了「标记-清除」算法）<br>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC 。<ul>
<li>为了解决这个问题，CMS 收集器提供了一个<code>-XX：+UseCMSCompactAtFullCollection</code> 开关参数（默认就是开启的），用于在 CMS 收集器<strong>顶不住要进行 FullGC 时开启内存碎片的合并整理过程</strong>，内存整理的过程是无法并发的，<strong>空间碎片问题没有了，但停顿时间不得不变长</strong>。</li>
<li>另外一个参数<code>-XX：CMSFullGCsBeforeCompaction</code>，这个参数是用于设置<strong>执行多少次不压缩的 Full GC 后，跟着来一次带压缩的</strong>（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</li>
</ul>
</li>
</ul>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>G1（<strong>Garbage-First</strong>）是一款<strong>面向服务端应用</strong>的垃圾收集器。它有以下几个优点：</p>
<ul>
<li><strong>并行与并发</strong>：<br>G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短<code>Stop-The-World</code>停顿的时间</li>
<li><strong>分代收集</strong>：<br><strong>不需要其他收集器配合就能独立管理整个 GC 堆</strong>，能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。</li>
<li>空间整合：无内存碎片。<br>与 CMS 的「标记—清理」算法不同，G1<ul>
<li>从<strong>整体</strong>来看是<strong>基于「标记—整理」算法实现</strong>的收集器</li>
<li>从<strong>局部</strong>（两个 Region 之间）上来看是<strong>基于「复制」算法</strong>实现的</li>
<li>这两种算法都意味着<strong>G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存</strong>。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。</li>
</ul>
</li>
<li><strong>可预测的停顿</strong>：<br>降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，<strong>还能建立可预测的停顿时间模型</strong>，能让使用者<strong>明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒</strong>。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别（其他收集器都是对整一个老年代或者新生代进行操作），它<strong>将整个 Java  堆划分为多个大小相等的独立区域</strong>（Region），虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合</strong>。</li>
</ul>
<p>之所以能建立可预测的停顿时间模型，是因为它<strong>可以有计划地避免</strong>在整个 Java 堆中<strong>进行全区域的垃圾收集</strong>。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表</strong>，<strong>每次根据允许的收集时间，优先回收价值最大的 Region</strong>（这也就是 Garbage-First 名称的来由）。这种<strong>使用 Region 划分内存空间以及有优先级的区域回收方式</strong>，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<p>Region 不可能是孤立的。一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。那在做可达性判定确定对象是否存活的时候，岂不是还得扫描整个 Java 堆才能保证准确性？在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象<br>引用，虚拟机都是<strong>使用 ==Remembered Set== 来避免全堆扫描</strong>的。</p>
<ul>
<li>G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在<strong>对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作</strong>，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 <strong>CardTable</strong> 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。</li>
<li>当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</li>
</ul>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li><strong>筛选回收</strong>（Live Data Counting and Evacuation）<ul>
<li>哪一块回收的收益大就选哪一块。</li>
</ul>
</li>
</ul>
<p>G1 的前几个步骤的运作过程和 CMS 有很多相似之处。</p>
<ul>
<li><strong>初始标记阶段</strong><br>仅仅只是标记一下 GC Roots <strong>能直接关联到的对象</strong>，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段<strong>需要停顿线程，但耗时很短</strong>。</li>
<li><strong>并发标记阶段</strong><br>是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但<strong>可与用户程序并发执行</strong>。</li>
<li><strong>最终标记阶段</strong><br>是为了<strong>修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</strong>，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 <strong>Remembered Set Logs 的数据合并到 Remembered Set 中</strong>，这阶段<strong>需要停顿线程</strong>，但是<strong>可并行执行</strong>。</li>
<li><strong>筛选回收阶段</strong><br>对各个 Region 的<strong>回收价值和成本进行排序</strong>，根据用户所期望的 GC 停顿时间来制定回收计划。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/16668676/28903495-d71fceb0-7837-11e7-8e8e-6f26da762c22.png" alt="g1"></p>
<h3 id="组合策略"><a href="#组合策略" class="headerlink" title="组合策略"></a>组合策略</h3><p>在进行 JVM 调优的过程中，并非任何一种新生代 GC 策略都可以和另一种年老代 GC 策略进行配合工作，所以，我们应该知道，哪些种组合可以有效地进行 GC，而且应该在什么样的应用场景下选择哪一种组合，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:left"><strong>新生代 GC 策略</strong></th>
<th><strong>年老代 GC 策略</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">组合 1</td>
<td style="text-align:left">Serial</td>
<td>Serial Old</td>
<td style="text-align:left">Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。</td>
</tr>
<tr>
<td style="text-align:center">组合 2</td>
<td style="text-align:left">Serial</td>
<td>CMS+Serial Old</td>
<td style="text-align:left">CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。</td>
</tr>
<tr>
<td style="text-align:center">组合 3</td>
<td style="text-align:left">ParNew</td>
<td>CMS</td>
<td style="text-align:left">使用-XX:+UseParNewGC 选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用-XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC 选项，则新生代默认使用 ParNew GC 策略。</td>
</tr>
<tr>
<td style="text-align:center">组合 4</td>
<td style="text-align:left">ParNew</td>
<td>Serial Old</td>
<td style="text-align:left">使用-XX:+UseParNewGC 选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。</td>
</tr>
<tr>
<td style="text-align:center">组合 5</td>
<td style="text-align:left">Parallel Scavenge</td>
<td>Serial Old</td>
<td style="text-align:left">Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td>
</tr>
<tr>
<td style="text-align:center">组合 6</td>
<td style="text-align:left">Parallel Scavenge</td>
<td>Parallel Old</td>
<td style="text-align:left">Parallel Old 是 Parallel Scavenge 收集器的老年代版本。适用于注重吞吐量以及 CPU 资源敏感的场合</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">G1</td>
<td></td>
<td style="text-align:left">G1 是 Garbage First 垃圾收集器。</td>
</tr>
</tbody>
</table>
<h3 id="理解-GC-日志"><a href="#理解-GC-日志" class="headerlink" title="理解 GC 日志"></a>理解 GC 日志</h3><p>GC 日志开头的 「[GC」和「[Full  GC」<strong>说明了这次垃圾收集的==停顿类型==，而不是用来区分新生代 GC 还是老年代 GC 的</strong>。</p>
<ul>
<li>如果有「Full」，<strong>说明这次 GC 是发生了 Stop-The-World 的</strong>，这段新生代收集器 ParNew 的日志也会出现「[Full GC」（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW）。</li>
<li>如果是调用 System.gc（）方法所触发的收集，那么在这里将显示「[Full GC（System）」。</li>
</ul>
<p>接下来的「[DefNew」、「[Tenured」、「[Perm」表示 <strong>GC 发生的区域</strong>，这里显示的区域名称与使用的 GC 收集器是密切相关的，</p>
<ul>
<li>Serial 收集器中的新生代名为 「Default New  Generation」，所以显示的是「[DefNew」。</li>
<li>如果是 ParNew 收集器，新生代名称就会变为「[ParNew」，意为 「Parallel New Generation」。</li>
<li>如果采用 Parallel Scavenge 收集器，那它配套的新生代称为「PSYoungGen」</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地栈上分配），<strong>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配*。少数情况下也可能会直接分配在老年代中</strong>，</p>
<ul>
<li>注: TLAB 全称为 Thread Local Allocation Buffered</li>
</ul>
<p>分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。以下为几条最普遍的内存分配规则。</p>
<ul>
<li>对象优先在 Eden 分配、 </li>
<li>大对象直接进入老年代、 </li>
<li>长期存活的对象将进入老年代 、</li>
<li>动态对象年龄判定 、</li>
<li>空间分配担保</li>
</ul>
<h3 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 <strong>Minor GC</strong>。</p>
<h4 id="Minor-GC-和-Full-GC-有什么不一样吗？"><a href="#Minor-GC-和-Full-GC-有什么不一样吗？" class="headerlink" title="Minor GC 和 Full GC 有什么不一样吗？"></a>Minor GC 和 Full GC 有什么不一样吗？</h4><ul>
<li><strong>新生代 GC</strong>（Minor GC）：指发生在<strong>新生代的垃圾收集动作</strong>，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li>
<li><strong>老年代 GC</strong>（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，<strong>经常会伴随至少一次的 Minor GC</strong>（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。<strong>Major GC 的速度一般会比 Minor GC 慢 10 倍以上</strong>。</li>
</ul>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象是指，<strong>需要大量连续内存空间的 Java 对象</strong>，最典型的大对象就是那种很长的字符串以及数组。</p>
<p>虚拟机提供了一个<code>-XX：PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是<strong>避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制</strong>（复习一下：新生代采用复制算法收集内存）。</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>为了做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>。</p>
<ul>
<li>如果对象在 Eden 出生并<strong>经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话</strong>，将被移动到 Survivor 空间中，并且对象年龄设为 1。</li>
<li><strong>对象在 Survivor 区中每「熬过」一次 Minor GC，年龄就增加 1 岁</strong>，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。<ul>
<li>对象晋升老年代的年龄阈值，可以通过参数 <code>-XX：MaxTenuringThreshold</code> 设置。</li>
</ul>
</li>
</ul>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了 <code>MaxTenuringThreshold</code>才能晋升老年代，<strong>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到 <code>MaxTenuringThreshold</code>中要求的年龄。</p>
<p>也就是说，同龄的小伙伴的内存大于总内存的一半。那么 &gt;= 该年龄的就算老了。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生 Minor GC 之前，</p>
<ul>
<li>虚拟机会先<strong>检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，<ul>
<li>如果这个条件成立，那么 Minor GC 可以确保是安全的。</li>
<li>如果不成立，则虚拟机会查看  <code>Handlailure</code> 设置值是否允许担保失败。<ul>
<li>如果允许，那么会继续检查<strong>老年代最大可用的连续空间</strong>是否大于<strong>历次晋升到老年代对象容量</strong>的==平均大小==，<ul>
<li>如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；</li>
<li>如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 <code>Full GC</code>。</li>
</ul>
</li>
<li>如果不成立，改为进行一次 <code>Full GC</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>「冒险」是冒了什么风险？  </p>
<ul>
<li>一句话就是：老年代的最大可用连续空间可能小于新生代所有存活对象总空间，就会导致 Full GC，本来是应该直接执行 Full GC 的，但是没有直接执行，导致浪费了时间。</li>
<li>具体而言：<br>新生代使用复制收集算法，但为了内存利用率，<strong>只使用其中一个 Survivor 空间来作为轮换备份</strong>，因此当出现<strong>大量对象在 Minor GC 后仍然存活的情况</strong>（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。</li>
</ul>
<p>取平均值进行比较其实仍然是<strong>一种动态概率的手段</strong>，也就是说，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。<br>如果出现了 HandlePromotionFailure 失败，那就只好在失败后重新发起一次 Full GC。</p>
<p>虽然担保失败时绕的圈子是最大的，但<strong>大部分情况下都还是会将 HandlePromotionFailure 开关打开，避免 Full GC 过于频繁</strong>。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="你能不能谈谈，GC-是在什么时候，对什么东西，做了什么事情？"><a href="#你能不能谈谈，GC-是在什么时候，对什么东西，做了什么事情？" class="headerlink" title="你能不能谈谈，GC 是在什么时候，对什么东西，做了什么事情？"></a>你能不能谈谈，GC 是在什么时候，对什么东西，做了什么事情？</h3><p>此问题摘自《深入理解 Java 虚拟机》作者的一篇博文详见 <a href="http://icyfenix.iteye.com/blog/715301" target="_blank" rel="external">一个面试官对面试问题的分析</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。</p>
<p>学习虚拟机内存知识，如果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《深入理解 Java 虚拟机》</li>
</ul>
<p>本文大部分内容都出自《深入理解 Java 虚拟机》 第三章，若文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM 运行时数据区域与对象创建布局]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/07/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h2 id="java-运行时数据区域"><a href="#java-运行时数据区域" class="headerlink" title="java 运行时数据区域"></a>java 运行时数据区域</h2><p>根据《Java 虚拟机规范》规定，Java 虚拟机锁管理的内存包含以下以下几个运行时数据区域，如下图所示：<br><img src="https://user-images.githubusercontent.com/16668676/30062052-64dd918e-927c-11e7-9ec8-a82e507dc3ce.png" alt="java runtime memory"></p>
<a id="more"></a>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是<strong>线程私有的</strong>，各线程独立存储，以便线程切换后能恢复到正确的执行位置。可以看作是<strong>当前线程</strong>所执行的<strong>字节码的行号指示器</strong>。</p>
<ul>
<li>如果正在执行的是一个 Java 方法，该计数器记录的是正在执行的虚拟机字节码指令的地址。</li>
<li>如果正在执行的是一个 Native 方法，则该计数器值为空。</li>
</ul>
<p>==此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域==</p>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈是==线程私有的==。生命周期与线程相同。</p>
<p>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）。每一个方法从调用到执行都对应着一个栈帧在虚拟机栈中入栈和出栈的过程。</p>
<p>注：栈帧（Stack Frame ）是方法运行时基础数据结构，其中存储了局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>平时所讲的栈内存，就是现在讲的 Java 虚拟机栈，或者说是<strong>虚拟机栈中局部变量表部分</strong>。</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 SOF（Stack Over Flow） 异常</li>
<li>如果扩展时，无法申请到足够的内存，就会抛 OOMError 异常</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>发挥的作用与虚拟机栈相似。只不过一个是针对 Java 方法，一个是针对本地方法。</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>对于大多数应用而言，Java 堆是 Java 虚拟机所管理的内存中最大的一块。同时它也是==所有线程共享==的一块内存区域。Java 虚拟机规定，Java 堆<strong>可以是物理上不连续的</strong>内存空间，只要逻辑上连续即可。</p>
<p>按照虚拟机规范中的描述，<strong>所有对象实例以及数组都要在堆上分配</strong>。不过随着 JIT 编译器的发展和逃逸分析技术的逐渐成熟，未来或许会有所改变。</p>
<p>从内存分配角度来看，线程共享的 Java 堆中可能会划分出多个<strong>线程私有的分配缓冲区</strong>（Thread Local Allocation Buffer，TLAB）。<strong>不管怎么划分，其中存储的都是对象</strong>，进行划分的目的只是为了更好地回收/分配内存。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区有一个别名：non-heap，与 Java 堆区分开来。它是==所有线程共享==的，用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。</p>
<p>Hotspot 虚拟机设计团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区。因为这样就不用专门为方法区编写内存管理的代码的工作。对于其他虚拟机而言是不存在永久代这个概念的。</p>
<p>使用永久代来实现方法区的<strong>好处</strong>在于可以直接像管理 Java 堆那样管理这部分内存，而不需要再专门为方法区编写内存管理代码。<strong>坏处</strong>在于这样<strong>更容易导致 OOM</strong>，因为永久代有 <code>-XX：MaxPermSize</code> 的上限。在 JDK 1.8  HotSpot 虚拟机的实现中已经将整个永久代移除，取而代之的是一个叫元空间（Metaspace）的区域。</p>
<p>当方法区无法满足内存分配需求时，将抛出 <code>java.lang.OutOfMemoryError: PermGen space</code> 。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是<strong>常量池</strong>，用于存放<strong>编译期生成的</strong>各种<strong>字面量和符号引用</strong>。JDK 1.8 前运行时常量池是方法区的一部分。</p>
<p>虚拟机规范中对 Class 文件中的每一个部分的<strong>格式</strong>都有严格规定。但是<strong>对于运行时常量池，并没有做任何细节的要求</strong>。一般而言，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的的另一特征在于<strong>具备动态性</strong>。java <strong>运行期间也可以把新的常量放入池中</strong>。比如使用 String.intern() 将堆中的字符串加入常量池中。</p>
<p>JDK1.7 中把原本放在永久代的字符串常量池移到 Java 堆中。<strong>常量池位置的不同影响到了 String 的 intern()方法的表现</strong>。不同版本的 JDK  使用「==」去比较 String 字符串的结果会有不同。具体情况可参考这篇文章——<a href="http://blog.csdn.net/seu_calvin/article/details/52291082" target="_blank" rel="external">Java 技术——你真的了解 String 类的 intern()方法吗</a></p>
<h3 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a>Metaspace（元空间）</h3><p>介绍元空间之前先说点题外话。其实，移除永久代的工作从 JDK1.7 就开始了。JDK1.7 中，存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。譬如符号引用(Symbols)转移到了 native heap、字面量(interned strings)转移到了 java heap、类的静态变量(class statics)转移到了 java heap。但 JDK1.7 并没有完全移除将永久代完全移除。直到 JDK1.8 才将永久代完整地移除。</p>
<p>元空间的本质和永久代类似，<strong>都是对 JVM 规范中方法区的实现</strong>。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是<strong>使用本地内存</strong>。因此，<strong>默认情况下，元空间的大小仅受本地内存限制</strong>，但可以通过以下参数来指定元空间的大小：</p>
<ul>
<li><code>-XX:MetaspaceSize</code>，<strong>初始空间大小</strong>，<strong>达到该值就会触发垃圾收集进行类型卸载</strong>，同时 <strong>GC 会对该值进行调整</strong>：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 MaxMetaspaceSize 时，适当提高该值。</li>
<li><code>-XX:MaxMetaspaceSize</code>，<strong>最大空间</strong>，默认是没有限制的。</li>
</ul>
<p>如果本地空间的内存用尽了会收到<code>java.lang.OutOfMemoryError: Metadata space</code> 的错误信息。<br>JDK1.8 中持久代相关的 JVM 参数 <code>-XX:PermSize</code> 及 <code>-XX:MaxPermSize</code> 将会被忽略掉。</p>
<h4 id="为什么移除持久代？"><a href="#为什么移除持久代？" class="headerlink" title="为什么移除持久代？"></a>为什么移除持久代？</h4><ul>
<li>它的大小只能在启动时指定，运行时无法修改——很难进行调优。-XX:MaxPermSize，设置成多少好呢？</li>
<li>HotSpot 的内部类型也是 Java 对象：它可能会在 Full GC 中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。</li>
<li>简化 Full GC：每一个回收器有专门的元数据迭代器。</li>
<li>可以在 GC 不进行暂停的情况下并发地释放类数据。</li>
<li>使得原来受限于持久代的一些改进未来有可能实现</li>
</ul>
<h4 id="元空间的内存分配模型"><a href="#元空间的内存分配模型" class="headerlink" title="元空间的内存分配模型"></a>元空间的内存分配模型</h4><ul>
<li>绝大多数的类元数据的空间都从本地内存中分配</li>
<li>用来描述类元数据的类（klasses)也被删除了</li>
<li>分元数据分配了多个虚拟内存空间</li>
<li>给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些</li>
<li>归还内存块，释放内存块列表</li>
<li>一旦元空间的数据被清空了，虚拟内存的空间会被回收掉</li>
<li>减少碎片的策略</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并<strong>不是虚拟机运行时数据区的一部分</strong>，也不是虚拟机规范中定义的内存区域。</p>
<p>JDK 1.4 新添加的 NIO（New Input/Output） 可以使用 Native 函数库直接分配堆外存，然后通过一个存储在 Java 堆中的 DireByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场合能够显著提高性能。</p>
<p>本机直接内存<strong>不受 Java 堆大小的限制</strong>，但是受到本机总内存的大小以及处理器寻址空间的限制。</p>
<h2 id="HotSpot-虚拟机中对象创建、初始化与布局"><a href="#HotSpot-虚拟机中对象创建、初始化与布局" class="headerlink" title="HotSpot 虚拟机中对象创建、初始化与布局"></a>HotSpot 虚拟机中对象创建、初始化与布局</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="类加载检查、判断"><a href="#类加载检查、判断" class="headerlink" title="类加载检查、判断"></a>类加载检查、判断</h4><p>遇到一条 new 指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载。</p>
<h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>类加载检查通过后，将<strong>为新生对象分配内存</strong>。也就是划分出一块内存区域。</p>
<ul>
<li>如果 java 堆中的内存是绝对规整的，那么会使用<strong>指针碰撞</strong>的分配方式</li>
<li>如果 java 堆中的内存不规整的，虚拟机必须维护一个列表，记录哪些内存块可用，在分配时从列表中，找到一块足够大的空间划分给对象。即，使用<strong>空闲列表</strong>的分配方式。</li>
</ul>
<p>选择哪种分配方式由 java 堆是否规整决定，而 <strong>Java 堆是否规整</strong>又由所采用的<strong>垃圾收集器</strong>是否带有<strong>压缩整理功能</strong>决定。</p>
<ul>
<li>在使用 Serial、ParNew 等<strong>带 Compact 过程</strong>的收集器时，系统采用的分配算法是<strong>指针碰撞</strong></li>
<li>而使用 CMS 这种<strong>基于 Mark-Sweep 算法</strong>的收集器时，通常采用<strong>空闲列表</strong>。</li>
</ul>
<p><strong>线程安全问题</strong>：<br>另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有<strong>两种方案</strong>：</p>
<ul>
<li>一种是<strong>对分配内存空间的动作进行同步处理</strong>——实际上虚拟机采用 <strong>CAS 配上失败重试的方式</strong>保证更新操作的原子性；</li>
<li>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即<strong>每个线程在 Java 堆中预先分配一小块内存</strong>，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer,TLAB）。<ul>
<li>哪个线程要分配内存，就在哪个线程的 TLAB 上分配，<strong>只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定</strong>。<ul>
<li>虚拟机是否使用 TLAB，可以通过<code>-XX：+/-UseTLAB</code> 参数来设定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>此处的初始化指的是将分配到的内存空间初始化为<strong>零值</strong>。（不包括对象头）。如果使用 TLAB，该过程也可以提前至 TLAB 分配时进行。初始化为零值的操作保证了对象的<strong>实例字段</strong>在 Java 代码中可不赋初值就使用。</p>
<p>对象头的设置：</p>
<ul>
<li>对象是哪个类的实例</li>
<li>如何才能找到类的元数据信息</li>
<li>对象的哈希码</li>
<li>对象的 GC 分代年龄等信息。</li>
<li>…</li>
</ul>
<p>从虚拟机的视角来看，一个新的对象已经创建完毕。  </p>
<ul>
<li>但从 Java 程序视角来看，对象的创建才刚刚开始——<init> 方法还没有执行、所有字段都还为零.<ul>
<li>一般来说（由字节码中是否跟随 invokespecial 指令所决定），执行 <strong>new 指令</strong>之后会接着执行 <strong><init> 方法</init></strong>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ul>
</init></li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>HotSpot 中，对象在内存中存储的布局可以<strong>分为 3 块区域</strong>：</p>
<ul>
<li>对象头 Header</li>
<li>实例数据 Instance Data</li>
<li>对齐填充 Padding (并不是必然存在)</li>
</ul>
<h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1. 对象头"></a>1. 对象头</h4><p><strong>对象头包括两部分信息</strong>：第一部分为存储对象自身得运行时数据，第二部分为类型指针。</p>
<ol>
<li><strong>存储对象自身的运行时数据</strong>。如：<ul>
<li>哈希码（HashCode）</li>
<li>GC 分代年龄、</li>
<li>锁状态标志、</li>
<li>线程持有的锁、</li>
<li>偏向线程 ID、</li>
<li>偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit，官方称它为「<strong>Mark Word</strong>」。</li>
<li>对象头信息是<strong>与对象自身定义的数据无关的额外存储成本</strong>，考虑到虚拟机的空间效率，Mark Word 被设计成一个<strong>非固定的数据结构以便在极小的空间内存储尽量多的信息</strong>，它会根据对象的状态复用自己的存储空间。</li>
</ul>
</li>
<li><strong>类型指针</strong>，即对象指向它的<strong>类元数据的指针</strong>，虚拟机通过该指针来确定这个对象是哪个类的实例。<ul>
<li>如果对象是一个数组，那么对象头中还需要有一块用于记录数据长度的数据<ul>
<li>因为从数据的元数据无法确定数组的大小</li>
</ul>
</li>
<li>注意：并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，<strong>查找对象的元数据信息并不一定要经过对象本身</strong><ul>
<li>比如：通过句柄访问对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-实例数据"><a href="#2-实例数据" class="headerlink" title="2. 实例数据"></a>2. 实例数据</h4><p>接下来的<strong>实例数据部分</strong>是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
<ul>
<li>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>这部分的<strong>存储顺序</strong>会<strong>受到虚拟机分配策略参数</strong>（FieldsAllocationStyle）和<strong>字段在 Java 源码中定义顺序的影响</strong>。<ul>
<li>HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），<ul>
<li>可以看出，<strong>相同宽度的字段总是被分配到一起</strong>。</li>
<li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</li>
<li>如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-对齐填充"><a href="#3-对齐填充" class="headerlink" title="3. 对齐填充"></a>3. 对齐填充</h4><p><strong>对齐填充</strong>并不是必然存在的，也没有特别的含义，它仅仅<strong>起着占位符的作用</strong>。</p>
<p>由于 HotSpot VM 的自动内存管理系统<strong>要求对象起始地址必须是 8 字节的整数倍</strong>，换句话说，就是<strong>对象的大小必须是 8 字节的整数倍</strong>。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>由于 reference 类型在 Java 虚拟机规范中<strong>只规定了一个指向对象的引用</strong>，并<strong>没有定义这个引用应该通过何种方式去定位</strong>、访问堆中的对象的具体位置，所以<strong>对象访问方式也是取决于虚拟机实现而定的</strong>。</p>
<p>主流的访问方式有两种：1. 使用句柄，2. 使用直接指针</p>
<h4 id="使用句柄访问："><a href="#使用句柄访问：" class="headerlink" title="使用句柄访问："></a>使用句柄访问：</h4><ul>
<li>Java 堆中将会划分出来一块内存作为句柄池，reference 中就是存储了<strong>对象的句柄地址</strong>，而句柄中包含了对象<strong>实例数据</strong>和<strong>类型数据</strong>各自的<strong>具体地址</strong>信息。<br><img src="https://user-images.githubusercontent.com/16668676/30117448-d342779e-9352-11e7-8d1e-5d4c44308d8f.png" alt="visit obj with handle"></li>
</ul>
<h4 id="直接指针访问："><a href="#直接指针访问：" class="headerlink" title="直接指针访问："></a>直接指针访问：</h4><ul>
<li>采用这种方式，那么 Java 堆<strong>对象的布局中就必须考虑如何放置访问类型数据的相关信息</strong>，reference 中存储的直接就是对象地址，而<strong>对象中包含</strong>了对象<strong>类型数据的地址信息</strong>。<br><img src="https://user-images.githubusercontent.com/16668676/30117447-d31537ac-9352-11e7-980c-d56f667070e4.png" alt="visit obj with pointer"></li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul>
<li>使用<strong>句柄</strong>访问优点：是 <strong>reference 中存储的是稳定的句柄地址</strong>，在<strong>对象被移动时</strong>，只会改变句柄中的实例数据指针，而 <strong>reference 本身不需要被修改</strong>。</li>
<li>使用<strong>直接指针</strong>的最大好处就是<strong>速度更快</strong>，节省了一次指针定位需要的时间开销，由于 Java 对象访问十分频繁，这类开销积小成多后也是一项非常可观的执行成本。<ul>
<li>Sun HotSpot 虚拟机使用的就是这种访问方式。</li>
</ul>
</li>
</ul>
<h2 id="OutOfMemoryError-异常简析"><a href="#OutOfMemoryError-异常简析" class="headerlink" title="OutOfMemoryError 异常简析"></a>OutOfMemoryError 异常简析</h2><h3 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h3><p>不断创建对象，并且保证 GC Roots 到对象之间有可达路径来<strong>避免垃圾回收机制清除这些对象</strong>。在对象总内存达到 <code>-XmX:heapSize</code>指定的值之后就会 OOM。</p>
<p>一般出现这种情况都是通过 MAT 工具来分析。确定是出现了内存泄漏，还是的最大堆空间的设置不合理。</p>
<ul>
<li>如果是内存泄漏，可进一步通过工具来查看对象到   GC Roots 的引用链，找出内存泄漏的原因</li>
<li>如果不存在内存泄漏，即对象确实必须存活着，那就要检查虚拟机的堆参数（-Xmx 与 -Xms）与机器物理内存比较看是否还可以调大；同时也可以通过检查代码中是否存在一些对象的生命周期过长、持有状态时间过长的情况，尝试·减少程序运行期的内存消耗。</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈。栈容量只由 <code>-Xss</code> 参数设定。</p>
<p>关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
</ul>
<p>导致 SOF 的常见原因有递归、定义大量的局部变量等。</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>可以通过在运行时产生大量的<strong>类</strong>去填满方法区。</p>
<p>由于 JDK1.7 把字符串常量池从方法区移到堆中，在不同的版本的 JDK中<code>String.intern()</code>方法的表现不一。</p>
<ul>
<li>JDK1.6 中调用 <code>String.intern()</code> 方法时，会把<strong>首次遇到的字符串复制到永久代中</strong>。</li>
<li>JDK1.7 中调用 <code>String.intern()</code>方法时，不会再复制实例，只是在常量池中<strong>记录首次出现的实例引用</strong></li>
</ul>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>可以通过 <code>-XX:MaxDirectMemorySize</code> 指定，如果不指定，默认与 Java 堆最大值（<code>-Xmx</code>指定）一样</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">Java8 内存模型—永久代(PermGen)和元空间(Metaspace)</a></li>
<li><a href="http://it.deepinmind.com/gc/2014/05/14/metaspace-in-java-8.html" target="_blank" rel="external">Java 8 的元空间</a></li>
<li>Java 8 的元空间<a href="http://java-latte.blogspot.sg/2014/03/metaspace-in-java-8.html" target="_blank" rel="external">英文原文</a></li>
<li><a href="http://caoyaojun1988-163-com.iteye.com/blog/1969853" target="_blank" rel="external">JAVA 8 ：从永久区（PermGen）到元空间（Metaspace）</a></li>
<li><a href="http://liuwangshu.cn/java/jvm/1-runtime-data-area.html" target="_blank" rel="external">Java虚拟机（一）结构原理与运行时数据区域</a></li>
<li>《深入理解 Java 虚拟机(第 2 版)》</li>
</ul>
<p>若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 集合框架之 ArrayList]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/06/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BArrayList/</url>
      <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>ArrayList 是一个动态数组，它是线程不安全的，允许元素为 null。它的底层数据结构是数组，ArrayList 实现了 <code>List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code> 接口，其中 RandomAccess 代表了其拥有随机快速访问的能力，<code>ArrayList</code> 可以以 O(1) 的时间复杂度去根据下标访问元素。</p>
<h3 id="时间、空间效率"><a href="#时间、空间效率" class="headerlink" title="时间、空间效率"></a>时间、空间效率</h3><p>因为数组内存的连续，可以根据下标以 O1 的时间改查元素，因此<strong>时间效率很高</strong></p>
<p>同样也因为数组要占据一块连续的内存空间，所以它也有数组的缺点——<strong>空间效率不高</strong>。</p>
<a id="more"></a>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>当集合中的元素超出容量时，会进行<strong>扩容操作</strong>，扩容操作是一个性能消耗较大的地方，所以如果能预知数据的规模，最好在初始化时通过 <code>public ArrayList(int initialCapacity)</code> 构造方法指定 ArrayList 的大小，来构造 ArrayList 实例，以<strong>减少扩容次数，提高效率</strong>。</p>
<p>在添加大量元素前，应用程序也可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量，这可以减少递增式再分配的数量。 不过该方法是 ArrayList 中添加的，List 中没有该方法。所以如果声明的类型为 List 的话，需要进行强转。<code>((ArrayList)list).ensureCapacity(number);</code></p>
<p>当每次修改结构时(添加或者删除元素)，都会修改 modCount。</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//空对象数据，用于空对象，如果指定初始容量为 0 就给元素附一个空对象</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Shared empty array instance used for default sized empty instances. We</div><div class="line"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line"> * first element is added.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//共享的空数组对象，使用该对象用以区分 EMPTY_ELEMENTDATA，从而知道第一次添加元素时，应该初始化的数组长度。</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 之所以不声明为 private 是为了简化内部类访问，</span></div><div class="line"><span class="comment">// 所有原本为默认容量的空数组，在第一次添加元素的时候都会被初始化为长度为默认容量的数组</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//包含元素的数量</span></div></pre></td></tr></table></figure>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>ArrayList 提供了三种方式的构造器，可以构造一个默认初始容量为 10 的空列表、构造一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;<span class="comment">//按照指定的初始容量初始化</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//创建数组</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//如果指定初始容量为 0 就给元素附一个空对象</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> +</div><div class="line">                initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化一个初始容量为 10 的 ArrayList</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<span class="comment">//从给定的容器中构建一个 ArrayList</span></div><div class="line">    elementData = c.toArray();<span class="comment">//将容器对象中的元素转换为数组</span></div><div class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;<span class="comment">//长度不为 0，进行判断操作</span></div><div class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);<span class="comment">//如果返回的数组不是 Object[].class 类型的，则进行将数组元素复制到类型为 Object 数组上</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// replace with empty array.</span></div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//长度为 0，则将空数组对象赋值给元素数组</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要注意的是第三个构造方法中对数组元素类型的判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (elementData.getClass() != Object[].class)&#123;</div><div class="line">    elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125; <span class="keyword">else</span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 虽然表面上看起来，c.toArray() 会返回一个  Object[]  对象数组，但是它指向的实际类型并不一定是 Object[]，这样当我们调用 objList[i] =  new Object(); 就会报错   。 比如说如果我们有 1 个 List<string> stringList 对象，当我们调用<code>Object[] objectArray = stringList.toArray()</code>的时候，  objectArray 只能存放 String 类型的数据而不能存储其他类型的对象。</string></p>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p> ArrayList 提供了 add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加元素到列表尾部。</div><div class="line"> * 先确认 ArrayList 的容量</div><div class="line"> * 每次 add 之前，都会判断 add 后的容量，是否需要扩容。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!! 确保容量足以容纳原有元素加上新增的元素</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加元素到列表指定位置。需要将该位置右端的所有元素都往右移动一个单位</div><div class="line"> * 先确认 ArrayList 的容量</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);<span class="comment">//上下界判断</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!! 判断 add 之后的容量，根据情况进行扩容</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,<span class="comment">// 将 index ~ size-1 范围内的元素复制到 index+1 ~ size 范围中。也就是将 index 及其以后的元素后移一个位置</span></div><div class="line">            size - index);</div><div class="line">    elementData[index] = element;<span class="comment">//将给定元素添加到指定元素中</span></div><div class="line">    size++;<span class="comment">//元素数量 + 1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加给定集合中的所有元素到 ArrayList 中</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = c.toArray();<span class="comment">//先转换为数组</span></div><div class="line">    <span class="keyword">int</span> numNew = a.length;<span class="comment">//要添加的元素数量</span></div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount，确保容量足够容纳新添加的所有元素</span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);<span class="comment">//将元素添加到列表尾部</span></div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。  </div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);<span class="comment">//检查上下界</span></div><div class="line"></div><div class="line">    Object[] a = c.toArray();<span class="comment">//转换为数组</span></div><div class="line">    <span class="keyword">int</span> numNew = a.length;<span class="comment">//增加的数量</span></div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index;<span class="comment">//要移动的元素数</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                numMoved);<span class="comment">//移动数组中需要移动的元素</span></div><div class="line"></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);<span class="comment">//插入元素</span></div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>ArrayList 提供了<strong>根据下标</strong>或者<strong>指定对象</strong>两种方式的删除功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除指定位置的元素</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);<span class="comment">//上界判断</span></div><div class="line"></div><div class="line">    modCount++;<span class="comment">//结构修改次数 + 1</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//移动的元素总数</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,<span class="comment">//</span></div><div class="line">                numMoved);<span class="comment">//将要删除的元素的后面的所有元素往前移一个单位</span></div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work 将末元素置为 null，以免内存泄漏</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;<span class="comment">//返回删除掉的值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除此列表中首次出现的指定元素（如果存在的话）。</div><div class="line"> * 先找到指定元素在数组中的位置，然后再调用 fastRemove 删除</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">  	<span class="comment">// 由于 ArrayList 中允许存放 null，因此下面通过两种情况来分别处理。  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  删除 [fromIndex，toIndex) 范围中的所有元素 </div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</div><div class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</div><div class="line">            numMoved);</div><div class="line"></div><div class="line">    <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="keyword">int</span> newSize = size - (toIndex - fromIndex);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</div><div class="line">        elementData[i] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    size = newSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除 ArrayList 中给定指定集合中的所有元素。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(c);</div><div class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 批量删除</div><div class="line"> * complement 为 false 时，删除指定集合 c 中所有的元素。</div><div class="line"> * complement 为 true 时，删除指定集合 c 中以外的所有的元素。</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;<span class="comment">// complement 为 true 时为补集</span></div><div class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;<span class="comment">//将数组引用赋给 elementdata,节省空间</span></div><div class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//遍历，把要保存的元素存在前面</span></div><div class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</div><div class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)<span class="comment">//存储要保留的元素。集合 c 中是否包括该元素 == 删除补集？</span></div><div class="line">                elementData[w++] = elementData[r];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></div><div class="line">        <span class="comment">// even if c.contains() throws.</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (r != size) &#123;<span class="comment">// 此段代码作用为：当 c.contains 抛出异常时（此时 r &lt; size ），保持与 AbstractCollection 的行为兼容性</span></div><div class="line">            System.arraycopy(elementData, r,</div><div class="line">                    elementData, w,</div><div class="line">                    size - r);<span class="comment">//将后面的元素移动到 w 后面</span></div><div class="line">            w += size - r;<span class="comment">//加上移动的元素数，获取「最后的元素」的下标</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (w != size) &#123;<span class="comment">//清除引用，防止内存泄漏</span></div><div class="line">            <span class="comment">// clear to let GC do its work</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)<span class="comment">//将 w 之后的元素都置为 null</span></div><div class="line">                elementData[i] = <span class="keyword">null</span>;</div><div class="line">            modCount += size - w;</div><div class="line">            size = w;</div><div class="line">            modified = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> modified;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h3><p>注意：从数组中移除元素的操作，也会<strong>导致被移除的元素以后的所有元素的向左移动一个位置</strong>。</p>
<h2 id="查-获取"><a href="#查-获取" class="headerlink" title="查/获取"></a>查/获取</h2><p> 获取此列表中指定位置上的元素。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    checkForComodification();</div><div class="line">    <span class="keyword">return</span> java.util.ArrayList.<span class="keyword">this</span>.elementData(offset + index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结、对比"><a href="#小结、对比" class="headerlink" title="小结、对比"></a>小结、对比</h3><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    checkForComodification();</div><div class="line">    E oldValue = java.util.ArrayList.<span class="keyword">this</span>.elementData(offset + index);</div><div class="line">    java.util.ArrayList.<span class="keyword">this</span>.elementData[offset + index] = e;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h2 id="调整数组容量"><a href="#调整数组容量" class="headerlink" title="调整数组容量"></a>调整数组容量</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">            <span class="comment">// any size if not default element table</span></div><div class="line">            ? <span class="number">0</span></div><div class="line">            <span class="comment">// larger than default for default empty table. It's already</span></div><div class="line">            <span class="comment">// supposed to be at default size.</span></div><div class="line">            : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 内部保证容量，如果 ArrayList 是通过无参构造函数创建的，</div><div class="line"> * 那么第一次 add 元素的时候就会调用该方法扩容</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 确保分配指定的容量</div><div class="line"> * */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">//如果指明的最小容量超过数组的长度，就增大容量</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次数组容量的增长大约是其原容量的 1.5 倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造 ArrayList 实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用 ensureCapacity 方法来手动增加 ArrayList 实例的容量。</p>
<h3 id="「压缩」"><a href="#「压缩」" class="headerlink" title="「压缩」"></a>「压缩」</h3><p>   ArrayList 还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过 trimToSize 方法来实现。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将 ArrayList 的容量压缩到当前元素数量，这样可以最大限度节省空间</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;<span class="comment">//定义与父类 AbstractList 中，记录发生结构化修改的次数。如果不打算提供「快速失败的迭代器」，可忽略此域</span></div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</div><div class="line">        elementData = (size == <span class="number">0</span>)</div><div class="line">                ? EMPTY_ELEMENTDATA</div><div class="line">                : Arrays.copyOf(elementData, size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h2><p>ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考我之前的文章<a href="http://zhangshixi.iteye.com/blog/672697" target="_blank" rel="external">深入 Java 集合学习系列：HashMap 的实现原理</a> 中的 Fail-Fast 机制。</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。   <ul>
<li>在 java.util 包下的都是快速失败。</li>
</ul>
</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。<ul>
<li>在 java.util.concurrent 包下的全是安全失败的。</li>
</ul>
</li>
</ul>
<p>即 抛异常是快速失败（util 包下都是快速失败），不抛异常是安全失败。 Java 版本越往后越「安全」，concurrent 包下面全部为<strong>安全失败</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到核心操作在于增加和删除元素。</p>
<ol>
<li>增删改查中， 增导致<strong>扩容</strong>，则<strong>会修改 modCount</strong>，<strong>删一定会修改</strong>。 <strong>改和查一定不会修改 modCount</strong>。</li>
<li>扩容操作会导致数组复制，<strong>批量删除会导致找出两个集合的交集，以及数组复制操作</strong>，因此，增、删都相对低效。 而 改、查都是很高效的操作。</li>
<li>因此，结合特点，在使用中，以 Android 中最常用的展示列表为例，列表滑动时需要展示每一个 Item（element）的数组，<strong>所以 查 操作是最高频的</strong>。相对来说，<strong>增操作只有在列表加载更多时才会用到</strong> ，而且是在列表尾部插入，所以也不需要移动数据的操作。而删操作则更低频。 故选用 ArrayList 作为保存数据的结构。</li>
<li>和<code>Vector</code>的区别，Vector<code>内部也是数组实现的，区别在于</code>Vector<code>在 API 上都加了</code>synchronized<code>所以它是线程安全的，以及</code>Vector<code>扩容时，是翻倍 size，而</code>ArrayList`是扩容 50%。</li>
</ol>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://blog.csdn.net/zxt0601/article/details/77281231" target="_blank" rel="external">面试必备：ArrayList 源码解析（JDK8）</a></li>
<li><a href="http://zhangshixi.iteye.com/blog/674856" target="_blank" rel="external">深入 Java 集合学习系列：ArrayList 的实现原理</a></li>
<li><a href="http://yikun.github.io/2015/04/04/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">Java ArrayList 工作原理及实现</a></li>
</ul>
<p>若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 集合框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的装饰者模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/09/05/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="装饰者模式的定义"><a href="#装饰者模式的定义" class="headerlink" title="装饰者模式的定义"></a>装饰者模式的定义</h2><p>装饰模式（Decorator Pattern） 也称<strong>包装模式</strong>（Wrapper Pattern），是结构型设计模式之一，使用一种对客户端透明的方式来<strong>动态地拓展对象的功能</strong>，同时它也是继承关系的一种替代方案之一。</p>
<p>通过装饰者模式可以动态地给一个对象添加一些额外的职责。就增加功能而言，装饰模式相比生成子类更灵活。因为它装饰者持有一个被装饰者的引用，因此可以方便地调用具体被装饰者对象中的方法，因此可以在不破坏原类层次结构的情况下为类增加一些功能，我们只需要在被装饰者对象的相应方法前后增加相应的功能逻辑即可。</p>
<a id="more"></a>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要透明且动态地拓展类的功能时。</p>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/30046081-a4423c2c-923a-11e7-9dad-170e000c5ece.png" alt="decorator uml"></p>
<ul>
<li>Component  抽象组件<ul>
<li>可以是接口或者抽象类，充当一个被装饰的原始对象。（在该模式中位于继承结构的顶部，大家都直接/间接地继承它）</li>
</ul>
</li>
<li>ConcreteComponent 组件具体实现类<ul>
<li>该类是 Component 类的具体实现，也是我们装饰的具体对象。</li>
</ul>
</li>
<li>Decorator  抽象装饰者<ul>
<li>继承自 Component 并且<strong>必须持有一个指向 Component 的引用</strong></li>
<li>通常会在其方法中调用 ConcreteComponent 的方法。</li>
<li>如果装饰逻辑单一，可以直接省略该类，直接写一个具体的装饰者对象即可。</li>
</ul>
</li>
<li>ConcreteDecoratorA,B,C<ul>
<li>继承自 Decoration， 在父类对 Component 的方法调用基础上上，增加自己的一些功能。（通常都是在基础方法执行前或者后调用自己新增的方法）</li>
</ul>
</li>
</ul>
<p>使用时经常会把 ComponentImpl 或者说 ConcreteComponent 传入给具体的 Decorator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Compoent component = <span class="keyword">new</span> ConponentImpl();</div><div class="line">DecoratorImpl decoratorImpl = <span class="keyword">new</span> DecoratorImpl(component);</div><div class="line">decoratorImpl.xxOperation();</div></pre></td></tr></table></figure>
<h2 id="Android-源码中的模式实现"><a href="#Android-源码中的模式实现" class="headerlink" title="Android 源码中的模式实现"></a>Android 源码中的模式实现</h2><p><img src="https://user-images.githubusercontent.com/16668676/30047048-b4aeb6e2-9241-11e7-9a04-b11bb1acdc44.png" alt="context"></p>
<p>角色简介：</p>
<ul>
<li>Context ：抽象组件</li>
<li>ComtextImpl ：Context 的具体实现类</li>
<li>ContextWrapper ：装饰者的父类（其中的所有方法都只是调用了 ContextImpl 中对应的方法）</li>
<li>ContextThemeWrapper ：继承自 ContextWrapper  的装饰者</li>
<li>Activity ：继承自 ContextThemeWrapper 的装饰者</li>
</ul>
<p>我们以常用的方法为例，看看装饰者模式在其中的具体实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    Context mBase;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="comment">//启动 Activity</span></div><div class="line">   <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</div><div class="line">        mBase.startActivity(intent, options);</div><div class="line">    &#125;</div><div class="line">  	</div><div class="line">    <span class="comment">//发送广播</span></div><div class="line">    <span class="meta">@SystemApi</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent, String receiverPermission, Bundle options)</span> </span>&#123;</div><div class="line">        mBase.sendBroadcast(intent, receiverPermission, options);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">//注册监听器</span></div><div class="line">      <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></div><div class="line">        BroadcastReceiver receiver, IntentFilter filter) &#123;</div><div class="line">        <span class="keyword">return</span> mBase.registerReceiver(receiver, filter);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上的代码中可以看出，ContextWrapper 作为装饰者的父类，持有 Context 的引用 mBase（mBase 的实际类型为 ContextImpl），其中的所有方法都只是调用了 ContextImpl 中对应的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</div><div class="line">     <span class="comment">//启动 Activity 的逻辑实现</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        startActivity(intent, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line"></div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line">        <span class="comment">//调用 Instrumentation.execStartActivity() 方法</span></div><div class="line">        mMainThread.getInstrumentation().execStartActivity(</div><div class="line">                getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</div><div class="line">                (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent, String receiverPermission)</span> </span>&#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</div><div class="line">        String[] receiverPermissions = receiverPermission == <span class="keyword">null</span> ? <span class="keyword">null</span></div><div class="line">                : <span class="keyword">new</span> String[] &#123;receiverPermission&#125;;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            intent.prepareToLeaveProcess(<span class="keyword">this</span>);</div><div class="line">          	<span class="comment">//调用 AMS 的 broadcastIntent 方法</span></div><div class="line">            ActivityManagerNative.getDefault().broadcastIntent(</div><div class="line">                    mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</div><div class="line">                    Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, receiverPermissions, AppOpsManager.OP_NONE,</div><div class="line">                    <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, getUserId());</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//注册广播的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">    &#125;  </div><div class="line">   <span class="comment">//注册广播</span></div><div class="line">  	<span class="meta">@Override</span></div><div class="line">  	<span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter,</span></span></div><div class="line">            String broadcastPermission, Handler scheduler) &#123;</div><div class="line">        <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</div><div class="line">                filter, broadcastPermission, scheduler, getOuterContext());</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//注册广播的具体实现</span></div><div class="line">    <span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span></span></div><div class="line">            IntentFilter filter, String broadcastPermission,</div><div class="line">            Handler scheduler, Context context) &#123;</div><div class="line">        IIntentReceiver rd = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = mPackageInfo.getReceiverDispatcher(</div><div class="line">                    receiver, context, scheduler,</div><div class="line">                    mMainThread.getInstrumentation(), <span class="keyword">true</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</div><div class="line">                    scheduler = mMainThread.getHandler();</div><div class="line">                &#125;</div><div class="line">                rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</div><div class="line">                        receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          	<span class="comment">//调用 AMS 的 registerReceiver 方法</span></div><div class="line">            <span class="keyword">final</span> Intent intent = ActivityManagerNative.getDefault().registerReceiver(</div><div class="line">                    mMainThread.getApplicationThread(), mBasePackageName,</div><div class="line">                    rd, filter, broadcastPermission, userId);</div><div class="line">            <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</div><div class="line">                intent.setExtrasClassLoader(getClassLoader());</div><div class="line">                intent.prepareToEnterProcess();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> intent;</div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，ContextImpl 中提供了具体的方法实现。</p>
<p>ContextWrapper 的子类，例如 Activity 会根据需要对具体方法的实现进行装饰或者修改。</p>
<p>比如 startActivity() 方法，Activity 没有使用被装饰者的实现，而是自己实现了一套逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory2</span>,</div><div class="line">        <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</div><div class="line">        <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks2</span>,</div><div class="line">        <span class="title">Window</span>.<span class="title">OnWindowDismissedCallback</span>, <span class="title">WindowControllerCallback</span> &#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">         <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</div><div class="line">                startActivityForResult(intent, -<span class="number">1</span>, options);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Note we want to go through this call for compatibility with</span></div><div class="line">                <span class="comment">// applications that may have overridden the method.</span></div><div class="line">                startActivityForResult(intent, -<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;   </div><div class="line">             </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,@Nullable Bundle options)</span> </span>&#123;</div><div class="line">              <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</div><div class="line">                  options = transferSpringboardActivityOptions(options);</div><div class="line">                  <span class="comment">//调用 Instrumentation.execStartActivity() 方法</span></div><div class="line">                  Instrumentation.ActivityResult ar =</div><div class="line">                      mInstrumentation.execStartActivity(</div><div class="line">                          <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</div><div class="line">                          intent, requestCode, options);</div><div class="line">                <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ContextImpl-的创建"><a href="#ContextImpl-的创建" class="headerlink" title="ContextImpl 的创建"></a>ContextImpl 的创建</h2><p>从上面解析中我们知道 Context 的实现中使用了装饰者模式也知道了 ContextImpl 是 Context 具体实现类，但是 ContextImpl 是在上面地方被初始化的呢？</p>
<p>我们猜想 Activity 启动之后我们便可以调用 Context 中的方法了，我们猜想 ContextImpl 是在 Activity 创建过程中初始化的。</p>
<p>对 Android FrameWork 层有所了解同学应该知道 Activity 是由 AMS 管理的，AMS 会通过调用 ApplicationThread 与间接地控制 Activity。 ApplicationThread 的 scheduleXxx 方法中会调用 sendMessage 方法将相应的 Message 发送给 H，H 根据不同的 Message 调用 ActivityThread 中相应的 handleXxx 方法。</p>
<p>ActivityThread#H</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</div><div class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</div><div class="line">                <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</div><div class="line">                r.packageInfo = getPackageInfoNoCheck(</div><div class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</div><div class="line">              	<span class="comment">//调用 handleLaunchActivity</span></div><div class="line">                handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</div><div class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</div><div class="line">            &#125; <span class="keyword">break</span>;       </div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当需要启动新的 Activity 时，ApplicationThread 的  scheduleLaunchActivity 方法会先被调用，该方法会通过 H 调用 handleLaunchActivity 方法，而 handleLaunchActivity 方法又会调用  performLaunchActivity 方法。</p>
<p>ActivityThread#performLaunchActivity </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">//代码省略</span></div><div class="line">    Activity activity = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">      	<span class="comment">//创建 Activity</span></div><div class="line">        activity = mInstrumentation.newActivity(</div><div class="line">                cl, component.getClassName(), r.intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">          	<span class="comment">//获取 Context</span></div><div class="line">            Context appContext = createBaseContextForActivity(r, activity);</div><div class="line">			<span class="comment">//将前面准备的值关联到 Activity 中</span></div><div class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window);</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ActivityThread#createBaseContextForActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">final</span> Activity activity)</span> </span>&#123;</div><div class="line">    ContextImpl appContext = ContextImpl.createActivityContext(<span class="comment">//调用 ContextImpl 的静态方法创建 Activity Context</span></div><div class="line">            <span class="keyword">this</span>, r.packageInfo, r.token, displayId, r.overrideConfig);</div><div class="line">    appContext.setOuterContext(activity);<span class="comment">//外部的 context（此处为 Activity）设置给 ContextImpl</span></div><div class="line">    Context baseContext = appContext;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    <span class="keyword">return</span> baseContext;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ContextImpl#createActivityContext()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createActivityContext</span><span class="params">(ActivityThread mainThread,</span></span></div><div class="line">        LoadedApk packageInfo, IBinder activityToken, <span class="keyword">int</span> displayId,</div><div class="line">        Configuration overrideConfiguration) &#123;</div><div class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"packageInfo"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread, packageInfo, activityToken, <span class="keyword">null</span>, <span class="number">0</span>,</div><div class="line">            <span class="keyword">null</span>, overrideConfiguration, displayId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过上面的分析，我们可以得出结论，Activity 的 Context 是在 performLaunchActivity 方法中通过调用 createBaseContextForActivity  初始化的。在 createBaseContextForActivity 方法中，通过调用 ContextImpl 的静态方法 createActivityContext 创建 获取一个 ContextImpl 的实例对象，并通过 setOuterContext 方法将两者建立关联。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学过代理模式的同学可能觉得装饰模式与代理模式有点像（因为同样持有引用）。但是既然是它们是两个不同的设计模式，先看看它们的格子的定义。</p>
<p>装饰模式：以对客户端透明的方式<strong>扩展对象的功能</strong>，是<strong>继承关系的一个替代方案</strong>；<br>代理模式：给一个对象提供一个代理对象，并<strong>由代理对象来控制对原有对象的引用</strong>；</p>
<p>光看定义可能还是比较模糊。二者<strong>区别</strong>在哪里呢？</p>
<ul>
<li>装饰模式应该为所装饰的对象<strong>增强功能</strong></li>
<li>代理模式对代理的对象施加控制，但<strong>不对对象本身的功能进行增强</strong>。</li>
</ul>
<p>可以简单地理解为：你在一个地方写装饰，大家就知道这是在增加功能，你写代理，大家就知道是在限制。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 并发 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的享元模式——Message 复用原理]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/26/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Message%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>享元模式是对象池的一种实现，它的英文名为 Flyweight，代表轻量级的意思。</p>
<p>享元模式用来尽可能==减少内存使用量==，它适合用于可能存在大量对象的场景，来==缓存可共享的对象==（例如 Message、Java 中的字符串常量池）,从而实现对象共享、避免创建过多对象的效果，这样一来就可以提升性能，避免内存移除等。</p>
<p>享元模式中的部分状态是可以共享的，</p>
<ul>
<li>可以共享的状态称为<strong>内部状态</strong>。内部状态不会随着环境变化</li>
<li>不可共享的状态则称之为<strong>外部状态</strong>，他们会随着环境的改变而改变。</li>
</ul>
<p>享元模式会建立一个<strong>对象容器</strong>，在经典的享元模式中，该容器为一个 Map，它的键是享元对象的内部状态，它的值就是享元对象本身。</p>
<a id="more"></a>
<h2 id="享元模式的定义"><a href="#享元模式的定义" class="headerlink" title="享元模式的定义"></a>享元模式的定义</h2><p>享元模式是一种结构型设计模式，以共享的方式高效地支持大量的细粒度对象。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>系统中存在<strong>大量的相似对象</strong></li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要<strong>缓冲池</strong>的场景。</li>
</ol>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29702859-ac3f4f5c-89a5-11e7-92cd-2c26051b399f.png" alt="flyweight uml"></p>
<ul>
<li><strong>Flyweight</strong> ：享元对象抽象基类或者接口。</li>
<li><strong>ConcreteFlyweight</strong>：具体享元对象。</li>
<li><strong>FlyweightFactory</strong> ：享元工厂，负责创建享元对象和管理享元对象池。</li>
</ul>
<h2 id="Android-源码中的享元模式"><a href="#Android-源码中的享元模式" class="headerlink" title="Android 源码中的享元模式"></a>Android 源码中的享元模式</h2><p>在使用 Handler 发送消息之前，我们一般都会使用如下代码调用 <code>mHandler.obtainMessage()</code> 方法获取一个 Message 对象。这其中究竟是怎么实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Handler mHandler = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//do sth</span></div><div class="line">            Message message = mHandler.obtainMessage();</div><div class="line">            message.what = <span class="number">1</span>;</div><div class="line">            message.obj = result;</div><div class="line">            mHandler.sendMessage(message);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Handler.otainMessage()方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Handler.obtainMessage() 实际上调用的是 Message 的 obtain 方法，我们顺着源码看下去。</p>
<p>先看看 Message 类部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sometimes we store linked lists of these things</span></div><div class="line">Message next;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//作为锁对象</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//虽然名称为 sPool 但是实际上是一个指向消息队列队首的指针</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//「对象池」中的最大数量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</div><div class="line">    Message m = obtain();<span class="comment">//调用 obtain 方法获取 message 对象</span></div><div class="line">    m.target = h;<span class="comment">//指定 message 的目标对象</span></div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从消息对象池中取出一个 Message 对象，如果没有就创建一个</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</div><div class="line">            Message m = sPool;</div><div class="line">            sPool = m.next;</div><div class="line">            m.next = <span class="keyword">null</span>;</div><div class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清空 in-use flag</span></div><div class="line">            sPoolSize--;</div><div class="line">            <span class="keyword">return</span> m;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">//消息池中没有可复用的 Message 就创建一个新的 Message</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，从对象池中获取对象的大致流程。无论是 Handler.obtainMessage(参数列表) 方法，还是 Message 的 obtain(参数列表) 方法，最终都会调用 Message.obtain() 方法。在 Message.obtain() 方法的实现中，会先从对象池中获取 Message 对象，如果获取不到，则创建一个新的 Message 对象，然后返回。该对象在后续的执行过程中会被回收到对象池，以便复用。</p>
<p>但是 Message 对象是如何被回收到「对象池」中的呢？    从 Message 类的部分代码中我们看到 sPool 的实际类型是一个 Message 对象，而不是一个容器。另外从 obtain 方法中我们不难看到链表的踪影。难道消息池是使用链表实现的吗？</p>
<p>在 AS 中打开 Message 类的结构图，可以看到其中有一个 recycle 方法，我们看看里面是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isInUse()) &#123;<span class="comment">//判断消息是否还在使用</span></div><div class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;<span class="comment">//如果消息处在使用状态时被 gc 回收，就抛出异常</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span> + <span class="string">"is still in use."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;<span class="comment">//直接返回，取消回收操作</span></div><div class="line">    &#125;</div><div class="line">    recycleUnchecked();<span class="comment">//调用回收方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 回收一个可能还在使用的对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 只要该对象还在回收对象池中，就标记该对象为正在使用状态。</span></div><div class="line">    <span class="comment">// 清空其他状态</span></div><div class="line">    flags = FLAG_IN_USE;</div><div class="line">    what = <span class="number">0</span>;</div><div class="line">    arg1 = <span class="number">0</span>;</div><div class="line">    arg2 = <span class="number">0</span>;</div><div class="line">    obj = <span class="keyword">null</span>;</div><div class="line">    replyTo = <span class="keyword">null</span>;</div><div class="line">    sendingUid = -<span class="number">1</span>;</div><div class="line">    when = <span class="number">0</span>;</div><div class="line">    target = <span class="keyword">null</span>;</div><div class="line">    callback = <span class="keyword">null</span>;</div><div class="line">    data = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//回收消息到消息池中</span></div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">            next = sPool;</div><div class="line">            sPool = <span class="keyword">this</span>;</div><div class="line">            sPoolSize++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>recycle 方法首先会判断 Message 对象是否处在使用状态。如果处在使用状态会直接返回（如果此时 GC 回收该对象会抛出异常），否则调用 recycleUnchecked 方法，具体的回收逻辑是在 recycleUnchecked  方法中实现的。首先会标记 Message 处于使用状态，然后清空对象中的其他状态。将消息存入回收池，主要是链表的操作。大致如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29739978-6c03d780-8a7e-11e7-8aad-3da3590c2ea1.png" alt="msg"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Message 通过在内部构建一个链表来维护一个被会受到  Message 对象的对象池，当用户调用 obtain 方法时，会优先从池中获取。如果池中没有可以复用的对象就创建一个新的对象，该对象使用完之后，会被缓存到对象池中，当下次调用 obtain 方法时，他们就会被复用。</p>
<p>此处 Message 扮演了三个角色。既是 FlyWeight 抽象，又是 ConcreteFlyWeight 对象，同时还担任 FlyWeightFactory 角色，承担着管理对象池的职责。</p>
<p>想进一步了解 Android 消息机制的同学可参考<a href="https://ivanljt.github.io/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/">Android 消息机制解析</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>享元模式的优点：</p>
<ul>
<li>大幅度降低了内存中对象的数量。从而降低了内存的占用，提高了程序的性能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使得系统更加复杂。为了使应用能够共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li>
<li>享元模式将状态外部化，而读取外部状态使得<strong>运行时间稍微变长</strong></li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" target="_blank" rel="external">《JAVA 与模式》之享元模式</a></li>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="https://ivanljt.github.io/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/">Android 消息机制解析</a></li>
</ul>
<p>若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 源码中的模板方法模式——AsyncTask解析]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/24/Android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AsyncTask%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假设我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，<strong>某些步骤的具体实现是未知的</strong>，或者说某些步骤的实现是会<strong>随着环境的变化而改变的</strong>。<br>就好像执行程序的流程：</p>
<ol>
<li>检查代码的正确性</li>
<li>链接相关代码</li>
<li>编译相关代码</li>
<li>执行程序</li>
</ol>
<p>对于不同的语言，上述 4 个步骤都是不一样的，但是它们的执行流程是固定的，这类问题的解决方案就是我们介绍的模板方法模式。</p>
<a id="more"></a>
<h2 id="模板方法模式的定义"><a href="#模板方法模式的定义" class="headerlink" title="模板方法模式的定义"></a>模板方法模式的定义</h2><p>定义一个操作中的<strong>算法的框架</strong>，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<h2 id="模板方法模式的使用场景"><a href="#模板方法模式的使用场景" class="headerlink" title="模板方法模式的使用场景"></a>模板方法模式的使用场景</h2><ol>
<li>多个子类有公有的方法，并且逻辑基本相同时。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，把相同的代码抽取到父类中，然后通过<strong>钩子方法</strong>约束其行为。</li>
</ol>
<h3 id="注：何谓钩子方法？"><a href="#注：何谓钩子方法？" class="headerlink" title="注：何谓钩子方法？"></a>注：何谓钩子方法？</h3><p>基本方法又可以分为三种：抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。</p>
<p>这是《java与模式》书里的一种说法，三种方法也是在书中的模板方法模式中提及到的。</p>
<p>先说这个三个方法的基本定义：</p>
<ul>
<li>抽象方法：由抽象类声明，由具体子类实现。在java语言里一个抽象方法以abstract关键字标示出来。</li>
<li>具体方法：由抽象类声明并实现，而子类并不实现或覆盖。其实就是<strong>一般的方法</strong>，但是不需要子类来实现。</li>
<li>钩子方法：由抽象类<strong>声明并实现</strong>，而子类也会加以扩展。通常抽象类给出的是一个空的钩子方法，也就是方法体为空的方法（也可以根据需要实现部分逻辑）。其实它和具体方法在代码上没有区别，不过是意识上的一种区别。</li>
</ul>
<p>详见<a href="https://www.the5fire.com/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95-%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95.html" target="_blank" rel="external">抽象方法 具体方法 钩子方法</a></p>
<h2 id="模板方法模式的-UML-类图"><a href="#模板方法模式的-UML-类图" class="headerlink" title="模板方法模式的 UML 类图"></a>模板方法模式的 UML 类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29603702-be32185a-8817-11e7-95f3-9cf7ee08c644.png" alt="template method pattern"></p>
<ul>
<li>AbsTemplate：抽象类，定义一套算法框架</li>
<li>ConcreteImplA：具体实现类 A</li>
<li>ConcreteImplB：具体实现类 B</li>
</ul>
<h2 id="模板方法模式的简单示例"><a href="#模板方法模式的简单示例" class="headerlink" title="模板方法模式的简单示例"></a>模板方法模式的简单示例</h2><p>实际上是封装一个固定流程，就像是一套执行模板一样，第一步该做什么，第二步该做什么都已经在抽象类中定义好。而子类可以有不同的算法实现，在框架不被修改的情况下实现某些步骤的算法替换。</p>
<h2 id="Android-源码中的模板方法模式"><a href="#Android-源码中的模板方法模式" class="headerlink" title="Android 源码中的模板方法模式"></a>Android 源码中的模板方法模式</h2><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>使用过 AsyncTask 的同学都知道，我们调用 execute 之后，（如果没有调用 cancel 方法的话）以下三个方法会依次执行：</p>
<ul>
<li>onPreExecute</li>
<li>doInBackground </li>
<li>onPostExecute</li>
</ul>
<p>为什么能让它们依次执行呢？其内部是怎么实现的？我们看看源码，一探究竟。</p>
<p>首先看看异步任务的入口方法 execute。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@MainThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上两个构造方法中主要做了如下几件事：</p>
<ul>
<li>状态判断</li>
<li>判断之后执行 <code>onPreExecute();</code></li>
<li>使用线程池执行 mFuture<ul>
<li>什么样的线程池？<ul>
<li>默认为 SerialExecutor 单线程的线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Result result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);<span class="comment">//设置进程优先级</span></div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                result = doInBackground(mParams);<span class="comment">//调用 doInBackground 方法</span></div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">                mCancelled.set(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">throw</span> tr;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postResult(result);<span class="comment">//调用 postResult 方法</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());<span class="comment">//任务完成</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</div></pre></td></tr></table></figure>
<ul>
<li>mWorker 类型为 <code>WorkerRunnable&lt;Params, Result&gt;</code> ， WorkerRunnable 实现了 Callable</li>
<li>mFuture 类型为 <code>FutureTask&lt;Result&gt;</code></li>
</ul>
<p>简而言之，这个 mFuture 包装了这个 mWorker 对象，而 mFuture 是在线程池中执行的，会调用 mFuture 的 run 方法，该 run 方法中调用了 mWorker 的 call 方法，mWorker 的 call 方法又调用了 doInBackground 方法，所以 doInBackground 是在工作线程执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</div><div class="line">    <span class="keyword">if</span> (!wasTaskInvoked) &#123;</div><div class="line">        postResult(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>doInBackground</code> 执行完成后会通过 <code>postResult(result)</code> 方法将结果传递给主线程。</p>
<ul>
<li><code>postResult(result)</code> 可能通过 call 方法的 finally 块直接调用或者通过 FutureTask 中的 done 方法里面的 <code>postResultIfNotInvoked(get());</code> 来间接调用。</li>
</ul>
<p>接下来我们看看 <code>postResult(result)</code> 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// 调用 AsyncTask 的 finish 方法</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>postResult(result)</code>  方法就是通过发送一条消息（msg.what == MESSAGE_POST_RESULT）给 sHandler，sHandler 为 InternalHanlder。当 InternalHanlder 接收到 MESSAGE_POST_RESULT 时，就会调用 <code>result.mTask.finish(result.mData[0])</code> 方法，result 的类型为 AsyncTaskResult</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> AsyncTask mTask;</div><div class="line">    <span class="keyword">final</span> Data[] mData;</div><div class="line"></div><div class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</div><div class="line">        mTask = task;</div><div class="line">        mData = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 AsyncTaskResult 的具体实现中吗，我们知道 mTask 就是 AsyncTask，finish 方法中又调用了 <code>onPostExecute</code> ，此时整个执行流程就完成了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>execute 方法内部封装了 onPreExecute、doInBackGround、onPostExecute 这个逻辑流程。<br>通过这种方式，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时的操作及更新 UI。实际上就是通过线程池来执行耗时的任务，得到结果之后，通过 Handler 将结果传递给 UI 线程执行。</p>
<h3 id="Activity-的生命周期函数"><a href="#Activity-的生命周期函数" class="headerlink" title="Activity 的生命周期函数"></a>Activity 的生命周期函数</h3><p>除了 AsyncTask 以外，Android 源码中还有不少地方有模板方法的身影，比如说 Activity 的生命周期方法—— onCreate 、onStart、onResume 等，都是按照顺序调用的，我们会在对应的方法中执行合适的操作。</p>
<p>其内部实现涉及到进程间通信，限于篇幅，本文不作深入介绍。有兴趣的同学可以看看 ActivityThread 的 main 方法，以之作为入口，对生命周期方法的调用时机做进一步研究。</p>
<h2 id="模板方法总结"><a href="#模板方法总结" class="headerlink" title="模板方法总结"></a>模板方法总结</h2><p>简单概括模板方法模式就是流程封装。把某一个固定的流程封装到一个固定的 final 方法中。并且让子类能够定制这个过程中的某些甚至所有步骤，这就要求父类提取共用的代码，提升代码的复用率，同时也带来了更高的可扩展性。</p>
<ul>
<li>优点：<ul>
<li>封装不变的部分，扩展可变的部分</li>
<li>提取公共部分代码，便于维护。</li>
</ul>
</li>
<li>缺点：<ul>
<li>提高了代码阅读的难度，会让用户觉得难以理解</li>
</ul>
</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="https://www.the5fire.com/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95-%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95.html" target="_blank" rel="external">抽象方法 具体方法 钩子方法</a></li>
</ul>
<p>若有不正之处请多多谅解，欢迎批评指正。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[行为型设计模式之备忘录模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/21/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="备忘录模式的定义"><a href="#备忘录模式的定义" class="headerlink" title="备忘录模式的定义"></a>备忘录模式的定义</h2><p>备忘录模式是一种<strong>行为型设计模式</strong>，该模式用于保存对象当前的状态，并且在之后可以再次恢复到此状态。</p>
<p>实现效果为：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便后续将对象恢复到原来的状态。</p>
<h2 id="备忘录模式的使用场景"><a href="#备忘录模式的使用场景" class="headerlink" title="备忘录模式的使用场景"></a>备忘录模式的使用场景</h2><ol>
<li>需要保存一个对象在某一个时刻的状态或部分状态</li>
<li>一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。（如果使用接口来让其他对象获取对象的状态，会破坏封装性）</li>
</ol>
<a id="more"></a>
<h2 id="备忘录模式的UML类图"><a href="#备忘录模式的UML类图" class="headerlink" title="备忘录模式的UML类图"></a>备忘录模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29518826-890e58e8-86ad-11e7-9ce8-90ff79fcc071.png" alt="memoto pattern"></p>
<p>三个角色：</p>
<ul>
<li>Originator：需要保存状态的对象。负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。</li>
<li>Memento（类似于 pojo 类）备忘录角色。用于存储 Originator 内部状态，并且可以防止 Originator 以外的对象访问 Memento</li>
<li>Caretaker：负责存储备忘录，不能对<strong>备忘录的内容</strong>进行操作和访问，只能将备忘录传递给其他对象。</li>
</ul>
<h2 id="Android源码中的备忘录模式"><a href="#Android源码中的备忘录模式" class="headerlink" title="Android源码中的备忘录模式"></a>Android源码中的备忘录模式</h2><p>日常开发中如果需要保存什么数据以防止 Activity 意外销毁，第一时间会想到 Activity 中的这两个方法——<code>onSaveInstanceState</code>、<code>onRestoreInstanceState</code>。其内部具体是如何实现数据保存的呢？</p>
<p>先透漏一下，这里面使用到了备忘录模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 存储窗口的视图树的状态</span></div><div class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</div><div class="line">    <span class="comment">//2. 存储 Fragment 中的状态    </span></div><div class="line">    Parcelable p = mFragments.saveAllState();</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//3. 若用户设置了 Activity 的 ActivityLifeCycleCallbacks，</span></div><div class="line">    <span class="comment">//则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。</span></div><div class="line">    getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Activity.onSaveInstanceState 方法中主要做了三件事</p>
<ol>
<li>存储窗口的视图树的状态</li>
<li>存储 Fragment 中的状态</li>
<li>若用户设置了 Activity 的 ActivityLifeCycleCallbacks，则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。</li>
</ol>
<p>首先看看步骤 1，该步骤将 Window 对象中的视图树中的各个 View 状态存储到 Bundle 中。</p>
<p>Window 的具体实现在 <code>PhoneWindow</code> 中.以下为 <code>PhoneWindow.saveHierarchyState</code> 的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">saveHierarchyState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Bundle outState = <span class="keyword">new</span> Bundle();</div><div class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> outState;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// SparseArray 相当于一个 key 为 整型的 map</span></div><div class="line">    SparseArray&lt;Parcelable&gt; states = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">    <span class="comment">//此处的 mContentParent 就是我们 setContentView 时设置的 View</span></div><div class="line">    mContentParent.saveHierarchyState(states);</div><div class="line">    outState.putSparseParcelableArray(VIEWS_TAG, states);</div><div class="line"></div><div class="line">    <span class="comment">// 持有焦点的 View 必须设置 id，否则重新进入该界面时不会恢复它的焦点状态</span></div><div class="line">    <span class="keyword">final</span> View focusedView = mContentParent.findFocus();</div><div class="line">    <span class="keyword">if</span> (focusedView != <span class="keyword">null</span> &amp;&amp; focusedView.getId() != View.NO_ID) &#123;</div><div class="line">        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 存储整个面板的状态</span></div><div class="line">    SparseArray&lt;Parcelable&gt; panelStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">    savePanelState(panelStates);</div><div class="line">    <span class="keyword">if</span> (panelStates.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">        outState.putSparseParcelableArray(PANELS_TAG, panelStates);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 保存 actionbar 的状态</span></div><div class="line">    <span class="keyword">if</span> (mDecorContentParent != <span class="keyword">null</span>) &#123;</div><div class="line">        SparseArray&lt;Parcelable&gt; actionBarStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</div><div class="line">        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</div><div class="line">        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> outState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看步骤 2 中的 <code>mContentParent.saveHierarchyState</code> 方法，mContentParent 是一个 ViewGroup 但是 saveHierarchyState 方法并不是定义在 ViewGroup 中，而是定义在它的父类——View 中，查看下该方法在 View 中的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveHierarchyState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    dispatchSaveInstanceState(container);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="comment">//1. 只有含有 id 的 View，状态才会被存储</span></div><div class="line">    <span class="keyword">if</span> (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == <span class="number">0</span>) &#123;</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</div><div class="line">        <span class="comment">//2. 调用 onSaveInstanceState 方法获取自身状态</span></div><div class="line">        Parcelable state = onSaveInstanceState();</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Derived class did not call super.onSaveInstanceState()"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//3. 将自身状态存放到 container 中</span></div><div class="line">        <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">            container.put(mID, state);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>View.onSaveInstanceState</code> 方法默认存储的状态为空状态。但是它的子类通常都有定义自身的覆盖方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CallSuper</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</div><div class="line">    <span class="keyword">if</span> (mStartActivityRequestWho != <span class="keyword">null</span>) &#123;</div><div class="line">        BaseSavedState state = <span class="keyword">new</span> BaseSavedState(AbsSavedState.EMPTY_STATE);</div><div class="line">        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> BaseSavedState.EMPTY_STATE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>步骤 2 中的 View 的调用大致如下：saveHierarchyState ==》 dispatchSaveInstanceState ==》 onSaveInstanceState</p>
<ul>
<li>其中要注意的是 只有含有 id 的 View，状态才会被存储，如果没有给 view 赋一个 id，那么系统是不会帮忙保存该 view 的状态的。</li>
</ul>
<p>View 类中的 saveHierarchyState 方法调用了dispatchSaveInstanceState 方法用来存储自身状态。 ViewGroup 覆写了 dispatchSaveInstanceState 来存储自身以及子视图的状态。 </p>
<p><code>ViewGroup.dispatchSaveInstanceState</code>具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.dispatchSaveInstanceState(container);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</div><div class="line">    <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;<span class="comment">//遍历调用子 View 的 dispatchSaveInstanceState 方法</span></div><div class="line">        View c = children[i];</div><div class="line">        <span class="keyword">if</span> ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</div><div class="line">            c.dispatchSaveInstanceState(container);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 ViewGroup 的 <code>dispatchSaveInstanceState</code> 方法会先调用 <code>super.dispatchSaveInstanceState(container);</code> 存储自身的状态。然后遍历调用所有子视图的 <code>dispatchSaveInstanceState(container)</code> 方法来保存它们的状态，如果子 View 也是一个 ViewGroup，则会再次执行这个过程。</p>
<hr>
<p>我们以 TextView 的 saveInstanceState 方法为例，看看具体的控件是如何保存自身状态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</div><div class="line">    Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</div><div class="line"></div><div class="line">    <span class="comment">// Save state if we are forced to</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> freezesText = getFreezesText();</div><div class="line">    <span class="keyword">boolean</span> hasSelection = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> start = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = -<span class="number">1</span>;</div><div class="line">    <span class="comment">//存储 TextView 的 start、end </span></div><div class="line">    <span class="keyword">if</span> (mText != <span class="keyword">null</span>) &#123;</div><div class="line">        start = getSelectionStart();</div><div class="line">        end = getSelectionEnd();</div><div class="line">        <span class="keyword">if</span> (start &gt;= <span class="number">0</span> || end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 是否存存在选项</span></div><div class="line">            hasSelection = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (freezesText || hasSelection) &#123;</div><div class="line">        SavedState ss = <span class="keyword">new</span> SavedState(superState);</div><div class="line">        <span class="comment">//保存 TextView 的文本内容</span></div><div class="line">        <span class="keyword">if</span> (freezesText) &#123;</div><div class="line">            <span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spanned) &#123;</div><div class="line">                <span class="keyword">final</span> Spannable sp = <span class="keyword">new</span> SpannableStringBuilder(mText);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">                    removeMisspelledSpans(sp);</div><div class="line">                    sp.removeSpan(mEditor.mSuggestionRangeSpan);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ss.text = sp;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ss.text = mText.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//存储 TextView 的 start、end </span></div><div class="line">        <span class="keyword">if</span> (hasSelection) &#123;</div><div class="line">            <span class="comment">// XXX Should also save the current scroll position!</span></div><div class="line">            ss.selStart = start;</div><div class="line">            ss.selEnd = end;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isFocused() &amp;&amp; start &gt;= <span class="number">0</span> &amp;&amp; end &gt;= <span class="number">0</span>) &#123;</div><div class="line">            ss.frozenWithFocus = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ss.error = getError();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</div><div class="line">            ss.editorState = mEditor.saveInstanceState();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//返回状态对象</span></div><div class="line">        <span class="keyword">return</span> ss;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> superState;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 View 的 onSaveInstance 函数之后就得到了 View 要存储的数据，此时执行到 View 的  dispatchSaveInstanceState 方法中的注释 3。这里以 View 的 id 为 key，以状态为 value，存储到 container（ SparseArray 类型）中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3. 将自身状态存放到 container 中</span></div><div class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</div><div class="line">    container.put(mID, state);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>存储完 Window 的视图状态信息之后，便会执行存储 Fragment 中的状态信息、回退栈等。Fragment  也是通过调用自身的 onSaveInstaceState 方法来存储自身的 View 视图树状态的。</li>
<li>最后就是调用用户设置的 ActivityLifecycleCallbacks 的 onSaveInstaceState 方法，让用户做一些额外的处理</li>
</ul>
<p>前面我们所提及到的只是备忘录模式中的 Originator 角色，即需要保存备忘录的对象。不过也有涉及到 CareTaker 角色——Activity。下面我们再看看另外两个角色——Memoto 和 CareTaker。</p>
<p>存了状态信息的 Bundle 数据存储在哪？</p>
<ul>
<li>onSaveInstance 方法是在 onStop 方法之前调用的。Activity.onStop 方法是通过 Activity 的 performStopActivity 间接调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</div><div class="line">    <span class="comment">//获取 ActivityClientRecord</span></div><div class="line">    ActivityClientRecord r = mActivities.get(token);</div><div class="line">    <span class="comment">// saveState 表示是否保存状态</span></div><div class="line">    performStopActivityInner(r, <span class="keyword">null</span>, <span class="keyword">false</span>, saveState, reason);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r,</span></span></div><div class="line">        StopInfo info, <span class="keyword">boolean</span> keepShown, <span class="keyword">boolean</span> saveState, String reason) &#123;</div><div class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!keepShown &amp;&amp; r.stopped) &#123;</div><div class="line">            <span class="keyword">if</span> (r.activity.mFinished) &#123;</div><div class="line">                <span class="comment">// 如果正在执行销毁过程，是用户主动销毁。 activity 不打算恢复，我们也没必要调用 onStop 方法</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 在调用 onStop 之前必须先调用 onPause </span></div><div class="line">        performPauseActivityIfNeeded(r, reason);</div><div class="line"></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="comment">// 接下来让 activity 保存它目前的状态和它所管理的 dialogs </span></div><div class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; saveState) &#123;</div><div class="line">            <span class="keyword">if</span> (r.state == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 间接调用 Activity.onSaveInstance()</span></div><div class="line">                callCallActivityOnSaveInstanceState(r);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!keepShown) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 执行 onStop 方法</span></div><div class="line">                r.activity.performStop(<span class="keyword">false</span> <span class="comment">/*preserveWindow*/</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//将 stop 字段置为 true 表示已经调用了 stop 方法。</span></div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callCallActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</div><div class="line">    r.state = <span class="keyword">new</span> Bundle();<span class="comment">//内容就存储在该 Bundle 中</span></div><div class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</div><div class="line">                r.persistentState);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//该方法实际调用了 Activity.onSaveInstanceState 方法</span></div><div class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(Activity activity, Bundle outState,</span></span></div><div class="line">        PersistableBundle outPersistentState) &#123;</div><div class="line">    activity.performSaveInstanceState(outState, outPersistentState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 performStopActivity 与 performStopActivityInner 方法中，首先通过 token 从 mActivities 中获取一个 ActivityClientRecord 对象，状态信息就是存储在这里面的。获取该对象之后，调用了 performStopActivityInner 方法，对于保存状态而言，该方法大概有如下三步</p>
<ol>
<li>判断 Activity 是否需要保存状态</li>
<li>如果需要，则调用 onSaveInstance 方法，该方法会将状态信息存储到 ActivityClientRecord 中</li>
<li>调用 <code>Activity.onStop()</code> 方法</li>
</ol>
<p>执行 onStop 方法之前，系统会根据情况来选择是否存储 Activity 的状态，并且将这些状态（简介地）存储到 mActivities 中。</p>
<p>mActivities 是一个 <code>ArrayMap&lt;IBinder, ActivityClientRecord&gt;</code> ，它维护了一个 Activity 的信息表，当 Activity 重新启动时，会从 mActivities 中查询对应的 ActivityClientRecord，如果这个记录对象中含有状态信息就调用 Activity 的 onRestoreInstanceState 方法。开发人员可以从这个方法中做一些状态恢复操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    Activity activity = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">        <span class="comment">//1. 构建 Activity </span></div><div class="line">        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//2. 创建一个 Application 对象</span></div><div class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</div><div class="line"></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//创建 appContext，类型为 ContextImpl</span></div><div class="line">            Context appContext = createBaseContextForActivity(r, activity);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            <span class="comment">//3. 关联 appContext、Application 等对象到 Activity 中</span></div><div class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</div><div class="line">                    r.referrer, r.voiceInteractor, window);</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            activity.mCalled = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//4. 调用 Activity.onCreate 方法</span></div><div class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">            r.activity = activity;</div><div class="line">            r.stopped = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</div><div class="line">                <span class="comment">//调用 onStart 方法</span></div><div class="line">                activity.performStart();</div><div class="line">                r.stopped = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">             <span class="comment">//5. 如果有保存状态的话，调用 Activity.onRestoreInstanceState 方法恢复状态</span></div><div class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</div><div class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</div><div class="line">                    <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</div><div class="line">   </div><div class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</div><div class="line">                                r.persistentState);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</div><div class="line">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//代码省略</span></div><div class="line">        &#125;</div><div class="line">        r.paused = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">//6. 将 Activity 的信息记录对象——ActivityClientRecord 存储到 mActivities 中。 </span></div><div class="line">        mActivities.put(r.token, r);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的注释 5 处，系统会判断 Activity 是否调用过了 <code>Activity.finish()</code> 方法、是否是「永久的」以及 ActivityClientRecord 对象中的 state 是否为空，</p>
<ul>
<li>如果满足条件，就会获取存储的状态信息传递给 <code>Activity.onRestoreInstanceState</code> 方法，也会将这些数据传递给 onCreate 方法的 bundle 参数 。</li>
<li>不过 Google 官方推荐调用 onRestoreInstanceState 方法来恢复状态，因为只有在存储有状态信息的时候才会调用该方法，而在 onCreate 方法中还需要先进行判空处理。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上述过程中备忘录模式的三种关键角色分别由什么类扮演？</p>
<ul>
<li><strong>CareTaker</strong>：Activity 负责存储、恢复 UI 的态信息。</li>
<li><strong>Originator</strong>：Activity、Fragment、View、ViewGroup ，是需要存储状态的对象</li>
<li><strong>Memoto</strong>：由 Bundle 类扮演</li>
</ul>
<ul>
<li>Activity 会在停止之前根据 Activity 的退出情景来选择是否需要存储状态</li>
<li>在<strong>重新启动</strong>该 Activity 时会判断 ActivityClientRecord 对象中是否存储了 Activity 的状态<ul>
<li>如果含有状态，调用 <code>Activity.onRestoreInstanceState()</code> 方法恢复状态。从而使得 Activity 的 UI 可以恢复至异常退出前的状态。</li>
</ul>
</li>
</ul>
<h2 id="你可能会问的问题"><a href="#你可能会问的问题" class="headerlink" title="你可能会问的问题"></a>你可能会问的问题</h2><h3 id="onSaveInstanceState-何时被调用"><a href="#onSaveInstanceState-何时被调用" class="headerlink" title="onSaveInstanceState 何时被调用"></a>onSaveInstanceState 何时被调用</h3><p>onSaveInstanceState() 方法会在什么时候被执行？<br>有这么几种情况：</p>
<ol>
<li>当用户按下 HOME 键时。<ul>
<li>这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</li>
</ul>
</li>
<li>长按HOME键，选择运行其他的程序时。</li>
<li>按下电源按键（关闭屏幕显示）时。</li>
<li>从 Activity A 中启动一个新的 Activity 时。</li>
<li>屏幕方向切换时，例如从竖屏切换到横屏时。</li>
</ol>
<p>onSaveInstanceState 的调用在 onStop 方法之前，但是与 onPause 方法之间没有既定关系。</p>
<ul>
<li>总而言之，当系统存在「==未经用户许可==」时销毁了我们的 Activity，则 <code>onSaveInstanceState()</code> 会被系统调用，这是系统的责任，因此它必须提供一个机会让用户保存数据。</li>
<li>「经用户许可」的情况不多，通常只有用户按下回退键这一种。这种情况下是用户主动退出某个 Activity，系统不会调用  <code>onSaveInstanceState()</code> 方法。</li>
</ul>
<h3 id="各个-「Originator-」-的-onSaveInstanceState-方法的默认实现是怎么样的？"><a href="#各个-「Originator-」-的-onSaveInstanceState-方法的默认实现是怎么样的？" class="headerlink" title="各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？"></a>各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？</h3><p>在前面的分析中我们知道即使没有覆写 onSaveInstanceState()方法, ViewGroup、View、Fragment、Activity 内部都有自己的默认实现，它们的默认实现也会<strong>保存某些状态数据</strong>。 </p>
<ul>
<li>比如 activity 中各种 UI 控件的状态。android 应用框架中定义的几乎所有 UI 控件都恰当的实现了 onSaveInstanceState() 方法,因此当 Activity 被销毁和重建时, 这些 UI 控件会自动保存和恢复状态数据.<ul>
<li>EditText 控件会自动保存和恢复输入的数据</li>
<li>CheckBox 控件会自动保存和恢复选中状态</li>
<li>…</li>
</ul>
</li>
<li>开发者只<strong>需要为这些控件指定一个唯一的 id</strong>(通过设置 <code>android:id</code> 属性即可), 剩余的事情就可以自动完成了<ul>
<li>注意：如果没有为控件指定ID, 则这个控件就不会进行自动的数据保存和恢复操作。</li>
</ul>
</li>
</ul>
<p>由上所述, 如果我们需要覆写 onSaveInstanceState() 方法, 一般会在第一行代码中调用该方法的默认实现:super.onSaveInstanceState(outState)。</p>
<h3 id="有默认实现，还需要重写-onSaveInstanceState-方法吗？"><a href="#有默认实现，还需要重写-onSaveInstanceState-方法吗？" class="headerlink" title="有默认实现，还需要重写 onSaveInstanceState() 方法吗？"></a>有默认实现，还需要重写 onSaveInstanceState() 方法吗？</h3><p>既然该方法的默认实现可以自动的保存UI控件的状态数据, 那什么时候需要覆写该方法呢? </p>
<p>如果<strong>需要保存额外的数据时</strong>, 就需要覆写 onSaveInstanceState() 方法。大家需要注意的是：onSaveInstanceState()方法<strong>只适合保存瞬态数据</strong>, 比如 UI 控件的状态，成员变量的值等，而不应该用来保存持久化数据，持久化数据应该当用户离开当前的 activity时，在 onPause() 中保存（比如将数据保存到数据库或文件中）。说到这里，还要说一点的就是在onPause()中不适合用来保存比较费时的数据，所以这点要理解。</p>
<p>另外由于 <code>onSaveInstanceState()</code> 方法方法不一定会被调用, 因此<strong>不适合在该方法中保存持久化数据</strong>, 例如向数据库中插入记录等。 保存持久化数据的操作应该放在 onPause() 中。若是永久性值，则在 onPause() 中保存；若有大量要保存的数据，则另开线程，以免阻塞 UI 线程。 </p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li>《Android 源码设计模式解析与实战》</li>
<li><a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/28/2420515.html" target="_blank" rel="external">Android 开发之 instanceState详解</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 ThreadLocal]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/21/%E7%90%86%E8%A7%A3%20ThreadLocal/</url>
      <content type="html"><![CDATA[<h2 id="ThreadLocal-是什么？"><a href="#ThreadLocal-是什么？" class="headerlink" title="ThreadLocal 是什么？"></a>ThreadLocal 是什么？</h2><p>ThreadLocal 是一个<strong>线程内部</strong>的<strong>数据存储类</strong>，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<h2 id="为什么要使用-ThreadLocal？"><a href="#为什么要使用-ThreadLocal？" class="headerlink" title="为什么要使用 ThreadLocal？"></a>为什么要使用 ThreadLocal？</h2><p>从定义我们知道 ThreadLocal 是一个用于存储本线程内部数据的类。假设没有 ThreadLocal 的话，每个 Thread 中可以输入自己的一个本地变量，但是在整个 Thread 的生命周期中，如果要穿梭很多 class 的很多 method 来使用这个本地变量的话，就要一直一直向下传送这个变量，显然很麻烦。<br>那么怎么才能在这个 Thread 的生命中，在任何地方都能够方便的访问到这个变量呢，这时候 ThreadLocal 就诞生了。</p>
<a id="more"></a>
<p>ThreadLocal 就是这么个作用，除此之外和通常使用的本地变量没有任何区别。<br>也就是说，没有 ThreadLocal 也是可以解决问题的，但是会比较麻烦，ThreadLocal 的作用便是简化线程内部数据的使用流程。</p>
<h2 id="ThreadLocal-的内部实现"><a href="#ThreadLocal-的内部实现" class="headerlink" title="ThreadLocal 的内部实现"></a>ThreadLocal 的内部实现</h2><p>既然是线程的本地变量，那自然与线程有着密切的联系。</p>
<p>打开 Thread 的源码可以看到，源码中有一个类型为 <code>ThreadLocal.ThreadLocalMap</code> 的变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<h3 id="ThreadLocal-get-流程"><a href="#ThreadLocal-get-流程" class="headerlink" title="ThreadLocal#get 流程"></a>ThreadLocal#get 流程</h3><p>我们以 ThreadLocal#get 方法作为分析的源头。这些方法的逻辑都比较简单，因此直接在注释中说明。可参考小结部分的调用流程图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);<span class="comment">//获取存储该 ThreadLocal 的 Entry</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)e.value;<span class="comment">//获取目标值并返回</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();<span class="comment">//设置初始值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#getMap，该方法返回当前线程的 ThreadLocalMap  对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Entry 类继承自弱引用，防止内存泄漏。其中存储了 ThreadLocal 以及对应的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#setInitialValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    T value = initialValue();<span class="comment">//获取默认的初始值</span></div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);<span class="comment">//当前线程的 ThreadLocalMap 对象不为空，直接设置给目标对象。</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);<span class="comment">//为当前线程创建 ThreadLocalMap 对象。</span></div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal#createMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);<span class="comment">//调用构造方法初始化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ThreadLocal-set-流程"><a href="#ThreadLocal-set-流程" class="headerlink" title="ThreadLocal#set 流程"></a>ThreadLocal#set 流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//获取当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程的 ThreadLocalMap 对象</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);<span class="comment">//当前线程的 ThreadLocalMap 对象 已经存在直接设置值</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);<span class="comment">//为当前线程创建 ThreadLocalMap </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 ThreadLocal#set 方法的逻辑与 ThreadLocal#setInitialValue 方法中的逻辑如出一辙，这里不再赘述。</p>
<h3 id="ThreadLocalMap-的构造方法"><a href="#ThreadLocalMap-的构造方法" class="headerlink" title="ThreadLocalMap 的构造方法"></a>ThreadLocalMap 的构造方法</h3><p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类。其中以键值对的形式存储数据。可以将它简单理解为一个 HashMap。ThreadLocal#createMap 方法通过调用 ThreadLocalMap 的构造方法为当前线程创建一个 ThreadLocalMap 对象。</p>
<p><code>ThreadLocalMap</code> 的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];<span class="comment">//创建一个长度为 16 的 Entry 数组</span></div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);<span class="comment">//计算 key 的哈希值</span></div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);<span class="comment">//将 Entry 存到指定位置。</span></div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ThreadLocalMap</code> 的构造函数主要做了下面几件事：</p>
<ul>
<li>首先创建了一个 <code>Entry</code> 数组，<ul>
<li><code>Entry</code> 是 <code>ThreadLocalMap</code> 中的一个静态内部类,它以 <code>ThreadLocal</code> 为 key，以要存储的值为 value。</li>
</ul>
</li>
<li>然后根据 key 计算 Hash 值</li>
<li>接着创建一个 Entry 对象存储在数组中</li>
<li>最后设置大小和阈值。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="get-方法调用大致流程"><a href="#get-方法调用大致流程" class="headerlink" title="get 方法调用大致流程"></a>get 方法调用大致流程</h4><p><img src="https://user-images.githubusercontent.com/16668676/30096800-004b9f36-930d-11e7-9c27-c7f17619c3a7.png" alt="threadlocal get"></p>
<p>get 方法中会尝试获取当前线程的 ThreadLocalMap</p>
<ul>
<li>如果 ThreadLocalMap 非空，并且以当前 ThreadLocal 对象为 key 去获取到的 Entry 不为空，就返回该 ThreadLocal 对应的值；</li>
<li>否则，先获取默认的初始值（默认实现为空，可以自己重写 initialValue 方法来设置需要的值）<ul>
<li>然后判断 ThreadLocalMap 是否为空<ul>
<li>如果为空创建一个 ThreadLocalMap 同时将初始值设置进去。</li>
<li>如果不为空，直接把初始值存储在其中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="set-方法调用流程"><a href="#set-方法调用流程" class="headerlink" title="set 方法调用流程"></a>set 方法调用流程</h4><p><img src="https://user-images.githubusercontent.com/16668676/30096799-0047aeee-930d-11e7-8ac5-1927aadeab2d.png" alt="threadlocal set"></p>
<h2 id="你可能存在的疑问"><a href="#你可能存在的疑问" class="headerlink" title="你可能存在的疑问"></a>你可能存在的疑问</h2><h3 id="每个-ThreadLocal-只能放一个对象吗？"><a href="#每个-ThreadLocal-只能放一个对象吗？" class="headerlink" title="每个 ThreadLocal 只能放一个对象吗？"></a>每个 ThreadLocal 只能放一个对象吗？</h3><p>每个 ThreadLocal 只能放一个对象。要是需要放其他的对象，就再 new 一个新的 ThreadLocal 出来，这个新的 ThreadLocal 将作为 key,需要放的对象作为value，放在 ThreadLocalMap 中。也就是说一个线程可以含有多个 ThreadLocal 类。</p>
<p>当然也可以根据需要在 ThreadLocal 存放一些容器对象，比如 List、Set、Map，一个 ThreadLocal 存放一个容器对象，借助该容器对象也可以实现存储多个对象。 </p>
<h3 id="为什么-ThreadLocal-只存储一个对象却要用一个-ThreadLocalMap-来存储值？"><a href="#为什么-ThreadLocal-只存储一个对象却要用一个-ThreadLocalMap-来存储值？" class="headerlink" title="为什么 ThreadLocal  只存储一个对象却要用一个 ThreadLocalMap 来存储值？"></a>为什么 ThreadLocal  只存储一个对象却要用一个 ThreadLocalMap 来存储值？</h3><p>实际上每个线程中都有一个 ThreadLocal.ThreadLocalMap，真正存储数据的类是 ThreadLocalMap ，可以将它看作是一个 HashMap，而 ThreadLocal 是一个<strong>维护类</strong>。我们知道，存储的时候，都是以 ThreadLocal 实例作为 key，然后存储到 ThreadLocalMap 中。当我们调用不同 ThreadLocal 的 set 方法时，如果 ThreadLocalMap 不为空，那么直接在里面存储值就可以了，不需要再创建新的值。也就是说，<strong>同一个线程上的不同 ThreadLocal 对象，存储的值是在同一个 ThreadLocalMap 上</strong>。</p>
<h3 id="没有-ThreadLocal-能不能解决问题？"><a href="#没有-ThreadLocal-能不能解决问题？" class="headerlink" title="没有 ThreadLocal 能不能解决问题？"></a>没有 ThreadLocal 能不能解决问题？</h3><p>能。</p>
<p>可以自己定义一个静态的 map，将当前 thread 作为 key，将目标值作为 value，put 到 map 中，这也是一般人的想法。</p>
<p>ThreadLocal 的实现刚好相反，它是在每个线程中有一个 map，而将 ThreadLocal 实例作为 key，这样每个 map 中的项数很少，而且当线程销毁时相应的东西也一起销毁了。<br>因为各线程访问的 map 是各自不同的 map，所以不需要同步，速度会快些；而如果把所有线程要用的对象都放到一个静态 map中的话 多线程并发访问需要进行同步。</p>
<p>所以说 ThreadLocal 只是实现线程私有变量的一种方式。但是综合来看这种方式相比其他实现方式要更好。</p>
<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><p>我们通常会用下面的方式为普通线程创建一个 Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> Handler mHandler;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Looper.prepare();<span class="comment">//为当前线程创建一个 Looper</span></div><div class="line">            mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                    <span class="comment">// process incoming messages here</span></div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Looper.loop();<span class="comment">//开启消息循环</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Android 中每个线程中最多只能有一个 Looper，这种限制就是通过 ThreadLocal 来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</div><div class="line">  	<span class="comment">//创建一个 ThreadLocal 对象，其泛型类型为 Looper，在调用 prepare 之前 sThreadLocal.get() 都返回空。</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div><div class="line">  	<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建 Looper 时会同时创建一个泛型类型为 Looper 的 ThreadLocal 对象。</p>
<p>Looper#prepare()，通过 prepare 方法可以为当前线程创建一个 Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;<span class="comment">//如果线程已经存在 Looper 了</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//为当前线程创建一个 Looper 对象，并将它存储在当前线程的 ThreadLocalMap 中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Looper#myLooper() ，通过该方法可以获取当前线程的 Looper 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果一个对象的引用被多个线程持有，那么即使该对象存在 ThreadLocalMap 中也不是线程的本地变量。</p>
<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过 <code>ThreadLocal.set()</code> 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。 </p>
<p>也就是说，其他线程能否访问，还要看你的 set 进去的对象引用是否被其他线程持有。 如果两个线程都存入同一个对象引用，那就会有线程共享问题。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>我们总结 ThreadLocal 具体是怎么一步一步去为每一个线程创建一个~线程私有变量~的：</p>
<ul>
<li>首先，在每个线程 Thread 内部有一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的成员变量 threadLocals，这个 threadLocals 就是用来存储~线程私有变量的~，键值（key）为当前 ThreadLocal 变量，值 value 为~线程的私有变量~（即 T 类型的变量）。</li>
<li>初始时，在 Thread 里面，threadLocals 为空，当通过 ThreadLocal 变量调用 get() 方法或者 set() 方法，就会对 Thread 类中的 threadLocals 进行初始化，并且以当前 ThreadLocal 变量为 key，以 ThreadLocal 要保存的~线程私有变量~为 value，存到 threadLocals 中。<ul>
<li>注意，如果是 先调用 get() 方法而不是 set() 方法的话，会返回 null</li>
</ul>
</li>
<li>然后在当前线程里面，如果要使用~该线程私有变量~，就可以通过 get 方法在 threadLocals 里面查找。</li>
</ul>
<h2 id="参考与学习资源推荐"><a href="#参考与学习资源推荐" class="headerlink" title="参考与学习资源推荐"></a>参考与学习资源推荐</h2><ul>
<li><a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">正确理解 ThreadLocal</a></li>
<li><a href="http://www.iteye.com/topic/82984" target="_blank" rel="external">ThreadLocal and synchronized 补充</a></li>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">ThreadLocal</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">Java并发编程：深入剖析ThreadLocal</a></li>
<li><a href="http://www.jianshu.com/p/95291228aff7" target="_blank" rel="external">Android关于ThreadLocal的思考和总结</a></li>
</ul>
<p>如果本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 并发 </category>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[明白原理,轻松解决内存泄漏]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/19/%E6%98%8E%E7%99%BD%E5%8E%9F%E7%90%86-%E8%BD%BB%E6%9D%BE%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<p>相信「内存泄漏」 问题，是一个挺让开发者头疼的事情，笔者在回顾以为代码时，惊讶发现：初学 Android 时，许多不修边幅的代码习惯，导致了许多内存泄漏问题，借此分析其原因，把自己挖过的坑补一下，也希望奔跑在 Android 开发道路上的你能够优雅避免。</p>
<h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><ul>
<li>对于 C++ 来说，内存泄漏就是 new 出来的对象没有 delete，俗称野指针；</li>
<li>而对于 java 而言，就是存放在堆上的 Object 无法被 GC 正常回收；</li>
</ul>
<a id="more"></a>
<p>分析之前我们先来看看两个基础知识点。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="java-的内存分配简述"><a href="#java-的内存分配简述" class="headerlink" title="java 的内存分配简述"></a>java 的内存分配简述</h3><p>运行时数据区域内存模型图<br><img src="http://gityuan.com/images/jvm/jvm_memory_1.png" alt=""></p>
<ul>
<li>方法区（non-heap）：编译时就分配好，在程序<strong>整个运行期间都存在</strong>。它主要存放静态数据和常量；</li>
<li>栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；</li>
<li>堆区（heap）：通常用来存放 new 出来的对象。由 GC 负责回收。</li>
</ul>
<h3 id="四种不同类型的引用"><a href="#四种不同类型的引用" class="headerlink" title="四种不同类型的引用"></a>四种不同类型的引用</h3><p>GC 过程与对象的引用类型有着很大的联系，下面我们就看看 Java 中（Android 中存在差异）的四种引用： </p>
<ul>
<li>强引用（Strong Reference）:JVM 宁愿抛出 OOM，也不会让 GC 回收存在强引用的对象。</li>
<li>软引用（Soft Reference） ：只有内存不足时，才会被 GC 回收。 </li>
<li>弱引用（weak Reference）：在 GC 时，如果一个对象只存在弱引用，将会被回收 </li>
<li>虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为 GC 回收 Object 的标志。 </li>
</ul>
<p>与 Android 中的差异：<strong>在 2.3 以后版本中，即使内存够用，Android 系统会优先将 SoftReference 的对象提前回收掉</strong>, 其他和 Java 中是一样的。<br>因此谷歌官方建议用 LruCache(least recentlly use 最少最近使用算法)。会将内存控制在一定的大小内, 超出最大值时会自动回收, 这个最大值开发者自己定。</p>
<h2 id="内存泄漏的危害"><a href="#内存泄漏的危害" class="headerlink" title="内存泄漏的危害"></a>内存泄漏的危害</h2><p>内存泄露是内存溢出(OOM)的重要原因之一，会导致 Crash。<br>如果应用程序在消耗光了所有的可用堆空间，那么再试图在堆上分配新对象时就会引起 OOM(Out Of Memory Error)异常，此时应用程序就会崩溃退出。</p>
<h2 id="内存泄漏的典型案例"><a href="#内存泄漏的典型案例" class="headerlink" title="内存泄漏的典型案例"></a>内存泄漏的典型案例</h2><p>要想避免内存泄漏，首先要知道导致内存泄漏的原因。<br><strong>内存泄漏本质原因</strong>:==长生命周期的对象持有短生命周期对象的强/软引用。导致本应该被回收的短生命周期的对象无法被正常回收==。</p>
<p>这么讲可能比较抽象。举个常见的栗子：单例模式中，我们常常在获取单例对象时需要传一个 Context 。单例对象是一个长生命周期的对象（应用程序结束时才终结），而如果我们传递的是某一个 Activity 作为 context,那么这个 Activity 就会因为引用被持有而无法销毁，从而导致内存泄漏。</p>
<p>下面我们来看看导致内存泄漏的常见例子。</p>
<h3 id="永远的-Singleton"><a href="#永远的-Singleton" class="headerlink" title="永远的 Singleton"></a>永远的 Singleton</h3><p>单例的使用在我们的程序中随处可见，因为使用它可以解决我们在程序中重复创建对象的问题。但是<strong>由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏</strong>。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li>应该把传入的 Context 改为同应用生命周期一样长的 Application 中的 Context。</li>
<li>也可以通过重写 Application，提供 getContext 方法,那样就不需要在获取单例时传入 context。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext sContext;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        sContext = getApplicationContext();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getApplicationContext</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> sContext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Handler-引发的内存泄漏"><a href="#Handler-引发的内存泄漏" class="headerlink" title="Handler 引发的内存泄漏"></a>Handler 引发的内存泄漏</h3><p>由于 Handler 属于 TLS（Thread Local Storage）变量，导致它的生命周期和 Activity 不一致。因此通过 Handler 来更新 UI 一般很难保证跟 View 或者 Activity 的生命周期一致，故很容易导致无法正确释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerBadActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler_bad);</div><div class="line">        <span class="comment">// 延迟 5min 发送一个消息</span></div><div class="line">        handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">//do something</span></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>);</div><div class="line">        <span class="keyword">this</span>.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码中发送了了一个延时 5 分钟执行的 Message，当该 Activity 退出的时候，延时任务（Message）还在主线程的 MessageQueue 中等待，此时的 Message 持有 Handler 的强引用，并且由于 Handler 是 HandlerBadActivity 的<strong>非静态内部类，所以 Handler 会持有一个指向 HandlerBadActivity 的强引用</strong>，所以虽然此时 HandlerBadActivity 调用了 finish 也无法进行内存回收，造成内存泄漏。</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>将 Handler 声明为<strong>静态内部类</strong>，但是要注意如果用到 Context 等外部类的 非static 对象，还是应该使用 ApplicationContext 或者通过弱引用来持有这些外部对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class HandlerGoodActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private static final class MyHandler extends Handler&#123;</div><div class="line">        private final WeakReference&lt;HandlerGoodActivity&gt; mActivity;</div><div class="line">        public MyHandler(HandlerGoodActivity activity)&#123;</div><div class="line">            this.mActivity = new WeakReference&lt;HandlerGoodActivity&gt;(activity);//使用弱引用</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            super.handleMessage(msg);</div><div class="line">            HandlerGoodActivity activity = mActivity.get();</div><div class="line">            if (activity != null)&#123;</div><div class="line">                // do something</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private final MyHandler myHandler = new MyHandler(this);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_handler_good);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="慎用-static-成员变量"><a href="#慎用-static-成员变量" class="headerlink" title="慎用 static 成员变量"></a>慎用 static 成员变量</h3><p>从前面的介绍我们知道，static 修饰的变量位于内存的方法区，<strong>其生命周期与 App 的生命周期一致</strong>。<br>这必然会导致一系列问题，如果你的 app 进程设计上是长驻内存的，那即使 app 切到后台，这部分内存也不会被释放。</p>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>不要在类初始时初始化静态成员，也就是可以考虑懒加载。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。</p>
<p>当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/727790-afde094317e73842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不同 Context 的应用场景"></p>
<p>说明： </p>
<ul>
<li>NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要==创建一个新的 task 任务队列==。</li>
<li>对于 Dialog 而言，只有在 Activity 中才能创建</li>
</ul>
<h3 id="远离非静态内部类和匿名类，有需要时请使用静态内部类"><a href="#远离非静态内部类和匿名类，有需要时请使用静态内部类" class="headerlink" title="远离非静态内部类和匿名类，有需要时请使用静态内部类"></a>远离非静态内部类和匿名类，有需要时请使用静态内部类</h3><p>为什么要怎么做呢?因为使用非静态内部类和匿名类都会默认持有外部类的引用，如果生命周期不一致，就会导致内存泄漏。</p>
<p>看一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class NestedClassLeakActivity extends AppCompatActivity &#123;</div><div class="line">    </div><div class="line">    class InnerClass &#123;//非静态内部类</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static InnerClass sInner;//指向非静态内部类的静态引用</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_nested_class);</div><div class="line">        if (sInner == null) &#123;</div><div class="line">           sInner = new InnerClass();//创建非静态内部类的实例</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本例中，因为非静态内部类默认会持有外部类的引用，而外部类中又有一个该非静态内部类的静态实例，该静态实例的生命周期和应用的一样长，而静态实例又持有 Activity 的引用，因此导致 Activity 的内存资源不能正常回收。</p>
<h4 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h4><ol>
<li>将该内部类设为静态内部类</li>
<li>也可以将该内部类抽取出来封装成一个单例</li>
</ol>
<h3 id="集合引发的内存泄漏"><a href="#集合引发的内存泄漏" class="headerlink" title="集合引发的内存泄漏"></a>集合引发的内存泄漏</h3><p>我们通常会把一些对象的引用加入到集合容器（比如ArrayList）中，当我们不再需要该对象时（通常会调用 remove 方法），并没有把它的引用从集合中清理掉（其中的一种情况就是 remove 方法没有将不再需要的引用赋值为 null），下面以 ArrayList 的 remove 方法为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">( <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 数组越界检查</span></div><div class="line">    RangeCheck(index);</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 取出要删除位置的元素，供返回使用</span></div><div class="line">    E oldValue = (E) elementData[index];</div><div class="line">   <span class="comment">// 计算数组要复制的数量</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">   <span class="comment">// 数组复制，就是将index之后的元素往前移动一个位置</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">       System. arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                      numMoved);</div><div class="line">   <span class="comment">// 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收</span></div><div class="line">    elementData[--size ] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>elementData[--size ] = null; // Let gc do its work</code> 如果替换为 <code>--size</code>，就会导致已经「移除」的对象因为强引用被集合持有，而无法正常被 gc 回收。</p>
<h3 id="WebView-引发的内存泄漏"><a href="#WebView-引发的内存泄漏" class="headerlink" title="WebView 引发的内存泄漏"></a>WebView 引发的内存泄漏</h3><p>WebView 解析网页时会申请<strong>Native堆内存</strong>用于保存页面元素，当页面较复杂时会有很大的内存占用。如果页面包含图片，内存占用会更严重。并且打开新页面时，为了能快速回退，<strong>之前页面占用的内存也不会释放</strong>。有时浏览十几个网页，都会占用几百兆的内存。这样加载网页较多时，会导致系统不堪重负，最终强制关闭应用，也就是出现应用闪退或重启。</p>
<p>由于占用的都是 <strong>Native 堆内存</strong>，所以<strong>实际占用的内存大小不会显示在常用的 DDMS Heap 工具中</strong>（ DMS Heap 工具看到的只是Java虚拟机分配的内存，即使Native堆内存已经占用了几百兆，这里显示的还只是几兆或十几兆）。只有使用 adb shell 中的一些命令比如 dumpsys meminfo 包名，或者在程序中使用 <code>Debug.getNativeHeapSize()</code> 才能看到 Native 堆内存信息。</p>
<p>据说由于 WebView 的一个 BUG，即使它所在的 Activity(或者Service) 结束也就是 onDestroy() 之后，或者直接调用 WebView.destroy()之后，它所占用这些内存也不会被释放。</p>
<h4 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h4><p>把使用了 WebView 的 Activity (或者 Service) 放在单独的进程里。</p>
<ul>
<li>系统在检测到应用占用内存过大有可能被系统干掉 </li>
<li>也可以在它所在的 Activity(或者 Service) 结束后，调用 <code>System.exit(0)</code>，主动Kill掉进程。由于系统的内存分配是以进程为准的，进程关闭后，系统会自动回收所有内存。</li>
</ul>
<p>使用 WebView 的页面（Activity），在生命周期结束页面退出（onDestory）的时候，主动调用<strong>WebView.onPause()==以及==WebView.destory()</strong>以便让系统释放 WebView 相关资源。</p>
<h3 id="其他常见的引起内存泄漏原因"><a href="#其他常见的引起内存泄漏原因" class="headerlink" title="其他常见的引起内存泄漏原因"></a>其他常见的引起内存泄漏原因</h3><ul>
<li>Android 3.0 以下，Bitmap 在不使用的时候没有使用 recycle() 释放内存。</li>
<li><strong>非静态内部类的静态实例</strong>容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。</li>
<li>警惕<strong>线程未终止造成的内存泄露</strong>；譬如在 Activity 中关联了一个生命周期超过 Activity 的 Thread，在退出 Activity 时切记结束线程。<ul>
<li>一个典型的例子就是 HandlerThread 的 run 方法。该方法在这里是一个死循环，它不会自己结束，线程的生命周期超过了 Activity 生命周期，我们必须手动在 Activity 的销毁方法中中调用 <code>thread.getLooper().quit()</code> 才不会泄露。</li>
</ul>
</li>
<li><strong>对象的注册与反注册没有成对出现</strong>造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。</li>
<li><strong>创建与关闭没有成对出现造成的泄露</strong>；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。</li>
<li>避免代码设计模式的错误造成内存泄露；譬如循环引用，A 持有 B，B 持有 C，C 持有 A，这样的设计谁都得不到释放。</li>
</ul>
<h2 id="内存泄漏的检测工具"><a href="#内存泄漏的检测工具" class="headerlink" title="内存泄漏的检测工具"></a>内存泄漏的检测工具</h2><ul>
<li>LeakCanary 是一个检查内存泄漏的优秀框架。具体用法可以参考 <a href="https://mp.weixin.qq.com/s/0bO5BZ4CMYJbRuY_xf_osw" target="_blank" rel="external">LeakCanary——如何检测 Activity 是否泄漏</a></li>
<li>使用 AS Monitor + MAT 自己分析内存泄漏原因。具体请移步 Google 或 Baidu</li>
</ul>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/XILFalxJsbGJjx-ZOEDi7g" target="_blank" rel="external">Android 性能优化 详解内存优化的来龙去脉</a></li>
<li><a href="http://www.cnblogs.com/liushilin/p/5900089.html" target="_blank" rel="external">内存泄漏全解析，从此拒绝ANR，让OOM远离你的身边，跟内存泄漏say byebye</a></li>
<li><a href="https://goo-yao.github.io/2017/02/11/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/#more" target="_blank" rel="external">明白原理，轻松应对Android内存泄漏</a></li>
</ul>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的代理模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/18/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h2><p>代理模式也称为委托模式，为其他对象提供一种代理以控制对这个对象的访问。</p>
<h2 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h2><p>当无法或不想访问某个对象或者访问某个对象存在困难时可以<strong>通过一个代理对象来间接访问</strong>。</p>
<p>为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口（或继承相同的抽象类）</p>
<a id="more"></a>
<h2 id="代理模式的UML类图"><a href="#代理模式的UML类图" class="headerlink" title="代理模式的UML类图"></a>代理模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29449202-6aed8b00-842c-11e7-8e3f-362ead423f2d.png" alt="proxy uml"></p>
<p>角色介绍：</p>
<ul>
<li>Subject 抽象主题类<ul>
<li>主要职责是声明真实主题类与代理的共同接口方法，该类可以是一个抽象类也可以是一个接口</li>
</ul>
</li>
<li>RealSubject 真实主题类<ul>
<li>也称为被委托类或被代理理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。</li>
</ul>
</li>
<li>ProxySubject 代理类<ul>
<li>也称为委托类，持有一个对真实主题类的引用，在其实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。</li>
</ul>
</li>
<li>Client 使用代理类的类</li>
</ul>
<h2 id="代理模式的简单实现"><a href="#代理模式的简单实现" class="headerlink" title="代理模式的简单实现"></a>代理模式的简单实现</h2><p>代理模式大致可分为两大部分，<strong>静态代理和动态代理</strong>。</p>
<p><strong>动态代理</strong>通过反射机制动态地生成代理者的对象，code 阶段不需要知道代理谁，代理的真正对象会在执行阶段确定。</p>
<p>Java 提供一个便捷的动态代理接口 InvocationHandler，实现该接口需要重写其调用方法 invoke。</p>
<p>动态代理通过一个代理类来代理 N 多个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的的耦合关系。</p>
<h3 id="静态代理-vs-动态代理"><a href="#静态代理-vs-动态代理" class="headerlink" title="静态代理 vs 动态代理"></a>静态代理 vs 动态代理</h3><p>相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂。</p>
<ul>
<li>但是静态代理更符合面向对象的原则。</li>
</ul>
<p>实际开发中具体使用哪种方式来实现代理，看自己的偏好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>静态代理和动态代理是从 code 方面来区分代理模式的。</p>
<p>也可以<strong>从其使用范围来区分</strong>不同类型的代理实现：</p>
<ul>
<li><strong>远程代理</strong>（Remote Proxy）为某个对象<strong>在不同的内存地址空间</strong>提供局部代理。</li>
<li><strong>虚拟代理</strong>（Virtual Proxy）使用一个代理对象<strong>表示一个十分耗资源的对象并在真正需要时才创建</strong>。</li>
<li><strong>保护代理</strong>(Protection Proxy)：使用代理<strong>控制对原始对象的访问</strong>。该类型的代理常被<strong>用于原始对象具有不同访问权限</strong>的情况。</li>
<li>智能引用(Smart Reference)：在访问原始对象时执行一些自己的<strong>附加操作并对指向原始对象的引用计数</strong>。</li>
</ul>
<p>静动态代理都可以应用于上述 4 种情形。</p>
<h2 id="Android源码中的代理模式实现"><a href="#Android源码中的代理模式实现" class="headerlink" title="Android源码中的代理模式实现"></a>Android源码中的代理模式实现</h2><p>以 ActivityManager 为例。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29449446-6771e5ce-842d-11e7-935f-d1e5685d43af.png" alt="source code proxy"></p>
<ul>
<li>抽象接口: IActivityManager</li>
<li>代理类 ActivityManagerProxy</li>
<li>被代理类<ul>
<li>ActivityManagerNative(抽象类，并不处理太多的逻辑，大部分逻辑由其子类——ActivityManagerService 承担)</li>
<li>ActivityManagerService(真实部分)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>ActivityManagerService 是系统级的 Service 并且运行于独立的进程空间中，可以通过 ServiceManger 获取到它。</li>
<li>ActivityManagerProxy 运行于自己所处的进程空间中（也就是说，与 ActivityManagerService 运行在不同的进程中）</li>
<li>所以此处源码所实现的代理实质为==远程代理==。</li>
</ul>
<p>ActivityManagerProxy 在实际的逻辑处理并<strong>没有过多地被外部类</strong>使用，Android 中管理与维护 Activity 相关信息的类是另一个叫做 ActivityManager 的类。不过实质上 ActivityManager 大多数逻辑还是由 ActivityManagerProxy 承担。</p>
<p>以 ActivityManager 的 getAppTasks() 方法为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123;</div><div class="line">    ArrayList&lt;AppTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;AppTask&gt;();</div><div class="line">    List&lt;IAppTask&gt; appTasks;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());</div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> numAppTasks = appTasks.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAppTasks; i++) &#123;</div><div class="line">        tasks.add(<span class="keyword">new</span> AppTask(appTasks.get(i)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ActivityManagerNative.getDefault();</code>方法 返回一个 <code>IActivityManager</code> 类型的对象，通过该对象调用其 getAppTasks 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> gDefault.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gDefault 到底是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);<span class="comment">//获取 AMS</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        IActivityManager am = asInterface(b);<span class="comment">//完成创建一个 AMS 的客户端端代理对象—— ActivityManagerProxy</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">return</span> am;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述代码中构造了一个 <code>Singleton&lt;IActivityManager&gt;</code> 类型的 gDefault 对象，其中通过 <code>ServiceManager.getService(&quot;activity&quot;);</code> 获取一个系统级的 Service，而该 Service 实质上就是 AMS，接着调用 asInterface 方法，创建一个 ActivityManagerProxy 对象。</p>
<p>ActivityManagerNative.asInterface 方法的具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static public IActivityManager asInterface(IBinder obj) &#123;</div><div class="line">    if (obj == null) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);</div><div class="line">    if (in != null) &#123;</div><div class="line">        return in;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new ActivityManagerProxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ActivityManagerProxy 的 <code>getTasks</code> 方法，将数据打包跨进程传递给 Server 端的 AMS 处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.RunningTaskInfo&gt; getTasks(<span class="keyword">int</span> maxNum, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException &#123;</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        data.writeInt(maxNum);</div><div class="line">        data.writeInt(flags);</div><div class="line">        mRemote.transact(GET_TASKS_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        reply.readException();</div><div class="line">        ArrayList&lt;ActivityManager.RunningTaskInfo&gt; list = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> N = reply.readInt();</div><div class="line">        <span class="keyword">if</span> (N &gt;= <span class="number">0</span>) &#123;</div><div class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</div><div class="line">                ActivityManager.RunningTaskInfo info =</div><div class="line">                        ActivityManager.RunningTaskInfo.CREATOR</div><div class="line">                                .createFromParcel(reply);</div><div class="line">                list.add(info);</div><div class="line">                N--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        data.recycle();</div><div class="line">        reply.recycle();</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看看 AMS 中的 getTasks 方法的具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;IAppTask&gt; <span class="title">getAppTasks</span><span class="params">(String callingPackage)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> callingUid = Binder.getCallingUid();</div><div class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        ArrayList&lt;IAppTask&gt; list = <span class="keyword">new</span> ArrayList&lt;IAppTask&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"getAppTasks"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mRecentTasks.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                TaskRecord tr = mRecentTasks.get(i);</div><div class="line">                <span class="comment">// Skip tasks that do not match the caller.  We don't need to verify</span></div><div class="line">                <span class="comment">// callingPackage, because we are also limiting to callingUid and know</span></div><div class="line">                <span class="comment">// that will limit to the correct security sandbox.</span></div><div class="line">                <span class="keyword">if</span> (tr.effectiveUid != callingUid) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                Intent intent = tr.getBaseIntent();</div><div class="line">                <span class="keyword">if</span> (intent == <span class="keyword">null</span> ||</div><div class="line">                        !callingPackage.equals(intent.getComponent().getPackageName())) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                ActivityManager.RecentTaskInfo taskInfo =</div><div class="line">                        createRecentTaskInfoFromTaskRecord(tr);</div><div class="line">                AppTaskImpl taskImpl = <span class="keyword">new</span> AppTaskImpl(taskInfo.persistentId, callingUid);</div><div class="line">                list.add(taskImpl);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(ident);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Android-中的-Binder-跨进程通信机制与-AIDL"><a href="#Android-中的-Binder-跨进程通信机制与-AIDL" class="headerlink" title="Android 中的 Binder 跨进程通信机制与 AIDL"></a>Android 中的 Binder 跨进程通信机制与 AIDL</h2><p>四个重要类：</p>
<ul>
<li>Binder Client 类比 PC、终端设备</li>
<li>Binder Server 类比 服务器</li>
<li>Binder Driver（实现在内核中） 类比 路由器</li>
<li>Binder Manager 类比 DNS 服务器</li>
</ul>
<p>因为依赖于抽象，加上本地代理类的存在，所以调用远程方法时，还是与调用本地的普通的方法一样。但是代理类内部需要对参数什么的进行打包处理，然后再通过 Binder 机制，跨进程将数据传递给远程方法，远程方法执行完毕再返回数据。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29453380-021cc0ea-843c-11e7-901d-a7490d12f9ea.jpg" alt="binder 通信大致模型图"></p>
<p>Binder Driver 实现在内核中，主要负责 Binder 通信的建立，以及 Binder数据在进程间的传递和 Binder 引用计数管理/数据包的传输等。</p>
<p>Binder Client 和 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发，</p>
<ul>
<li>对于 Binder Client 而言，它只需要知道自己要使用的 Binder 的名字以及该 <strong>Binder 实体</strong>在 ServerManager 中的 0 号引用即可。<ul>
<li>访问原理：<ul>
<li>通过 0 号引用去访问 ServerManager <strong>获取该 Binder 的引用</strong>，</li>
<li>得到引用后就可以像普通方法调用那样调用 Binder 实体的方法</li>
</ul>
</li>
</ul>
</li>
<li>ServerManager 用来管理 Binder Server（Android 中通常是一个 Service）<ul>
<li>Binder Client 通过它来查询 Binder Server 的引用</li>
<li>ServerManager <strong>是一个标准的 Binder Server</strong>，并且在 Android 中约定其在 Binder 通信过程中的唯一标识（类似于 IP 地址）永远为 0。<ul>
<li>在 IServiceManager 接口中定义有对外开放的接口方法，供客户端访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong>匿名 Binder</strong>。很多时候 Binder Server 会将一个 Binder 实体封装进数据包传递给 Binder Client，而此时 Binder Server 会在该数据包中标注 Binder 实体的位置，Binder Driver 会为该匿名的 Binder 生成实体结点和实体引用，并将该引用传递给 Binder Client。</li>
</ul>
<p>IServiceManager 接口(声明 ServerManger 对外提供的方法、数据 )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IServiceManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">checkService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line"></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></div><div class="line">                <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> String[] listServices() <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPermissionController</span><span class="params">(IPermissionController controller)</span></span></div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String descriptor = <span class="string">"android.os.IServiceManager"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">4</span>;</div><div class="line">    <span class="keyword">int</span> SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Andorid 源码设计模式解析与实战》</p>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 LayoutInflater]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20LayoutInflater/</url>
      <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="系统服务的注册"><a href="#系统服务的注册" class="headerlink" title="系统服务的注册"></a>系统服务的注册</h2><p>什么时候初始化 ContextImpl？</p>
<p>ContextImpl 中有这样一个成员变量，缓存系统服务。<br><code>final Object[] mServiceCache = SystemServiceRegistry.createServiceCache();</code></p>
<p>在 <code>SystemServiceRegistry</code> 中的静态代码块中注册。注册方法如下所示。在 static 代码块中，会注册所有的系统服务。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Statically registers a system service with the context.</div><div class="line"> * This method must be called during static initialization only.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></div><div class="line">        ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</div><div class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</div><div class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以 <code>LAYOUT_INFLATER_SERVICE</code> 为例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">    <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">        &#125;&#125;);</div></pre></td></tr></table></figure></p>
<p><code>CachedServiceFetcher</code> 是一个实现了 <code>ServiceFetcher&lt;T&gt;</code> 接口的抽象类 </p>
<ul>
<li><code>createService</code> 为 <code>CachedServiceFetcher</code> 中的抽象方法，当初始化时会调用该方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Base interface for classes that fetch services.</div><div class="line"> * These objects must only be created during static initialization.</div><div class="line"> */</div><div class="line">static abstract interface ServiceFetcher&lt;T&gt; &#123;</div><div class="line">    T getService(ContextImpl ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;</div><div class="line">    private final int mCacheIndex;</div><div class="line"></div><div class="line">    public CachedServiceFetcher() &#123;</div><div class="line">        mCacheIndex = sServiceCacheSize++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public final T getService(ContextImpl ctx) &#123;</div><div class="line">        final Object[] cache = ctx.mServiceCache;</div><div class="line">        synchronized (cache) &#123;</div><div class="line">            // Fetch or create the service.</div><div class="line">            Object service = cache[mCacheIndex];</div><div class="line">            if (service == null) &#123;//使用了延时加载,第一次调用时才初始化，并将相应服务缓存起来。</div><div class="line">                service = createService(ctx);</div><div class="line">                cache[mCacheIndex] = service;</div><div class="line">            &#125;</div><div class="line">            return (T)service;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract T createService(ContextImpl ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="系统服务的获取"><a href="#系统服务的获取" class="headerlink" title="系统服务的获取"></a>系统服务的获取</h2><p>平时我们都是通过 <code>Context.getSystemService(&quot;服务名字&quot;)</code> 来获取服务。</p>
<p>具体为 ContextImpl 中的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Object getSystemService(String name) &#123;</div><div class="line">    return SystemServiceRegistry.getSystemService(this, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 getSystemService 的实际实现是在 <code>SystemServiceRegistry</code> 中的。</p>
<p><code>SystemServiceRegistry</code> 中有一个 <code>HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;</code> ，该 HashMap 以服务名称为 key，以服务相对应的 ServiceFetcher 作为 value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</div><div class="line">        new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</div></pre></td></tr></table></figure>
<p>具体的获取方法为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Gets a system service from a given context.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</div><div class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</div><div class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据服务名称去获取相应的 ServiceFetcher，</p>
<ul>
<li>如果 <code>ServiceFetcher</code> 不为空，则调用 <code>ServiceFetcher.getService</code> 方法获取相应服务的引用。<ul>
<li>如果是第一次调用会先创建，然后直接返回</li>
<li>否则直接返回缓存的值</li>
</ul>
</li>
<li>如果 <code>ServiceFetcher</code> 为空，则返回 null。</li>
</ul>
<h2 id="深入理解-LayoutInflater"><a href="#深入理解-LayoutInflater" class="headerlink" title="深入理解 LayoutInflater"></a>深入理解 LayoutInflater</h2><h2 id="LayoutInflater的创建"><a href="#LayoutInflater的创建" class="headerlink" title="LayoutInflater的创建"></a>LayoutInflater的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">    &#125;&#125;);</div></pre></td></tr></table></figure>
<p>可见实际实现为 <code>PhoneLayoutInflater</code>（继承了 LayoutInflater）</p>
<p>onCreateView 是其中最重要的方法。为什么说它重要，后面会提到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Override onCreateView to instantiate names that correspond to the</span></div><div class="line">    widgets known to the Widget factory. If we don't find a match,</div><div class="line">    call through to our super class.</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">//为系统内置的控件添加前缀。比如为 TextView 添加前缀，结果为 android.widget.TextView</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">    <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            View view = createView(name, prefix, attrs);</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> view;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            <span class="comment">// In this case we want to let the base class take a crack</span></div><div class="line">            <span class="comment">// at it.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="渲染过程解析"><a href="#渲染过程解析" class="headerlink" title="渲染过程解析"></a>渲染过程解析</h2><p>一般我们在渲染 ListView 或者 RecyclerView 中的列表时，都会调用 <code>inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code> 方法（有时也会使用两个参数的方法）。可以看到该方法内部会调用 <code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</div><div class="line">    return inflate(resource, root, root != null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    final Resources res = getContext().getResources();</div><div class="line">    //代码省略</div><div class="line">    //获取 xml 解析器</div><div class="line">    final XmlResourceParser parser = res.getLayout(resource);</div><div class="line">    try &#123;</div><div class="line">        return inflate(parser, root, attachToRoot);</div><div class="line">    &#125; finally &#123;</div><div class="line">        parser.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    synchronized (mConstructorArgs) &#123;</div><div class="line"></div><div class="line">        final Context inflaterContext = mContext;</div><div class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">        Context lastContext = (Context) mConstructorArgs[0];</div><div class="line">        mConstructorArgs[0] = inflaterContext;</div><div class="line">        //存储父视图</div><div class="line">        View result = root;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 查找根标签</div><div class="line">            int type;</div><div class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line">                // Empty</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String name = parser.getName();</div><div class="line">            if (TAG_MERGE.equals(name)) &#123;</div><div class="line">                //1. 解析 merge 标签</div><div class="line">                rInflate(parser, root, inflaterContext, attrs, false);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 2. 不是 merge 元素就直接解析布局中的视图</div><div class="line"> // Temp is the root view that was found in the xml</div><div class="line">                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                    ViewGroup.LayoutParams params = null;</div><div class="line"></div><div class="line">                    if (root != null) &#123;</div><div class="line">                        // 生成布局参数</div><div class="line">                        params = root.generateLayoutParams(attrs);</div><div class="line">                        if (!attachToRoot) &#123;</div><div class="line">                            //如果 attachToRoot 为 false，就给 temp 设置布局参数</div><div class="line">                            temp.setLayoutParams(params);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // 解析 temp 视图下的所有子 View</div><div class="line">                    rInflateChildren(parser, temp, attrs, true);</div><div class="line"></div><div class="line">                    // 如果 root 不为空并且 attachToRoot 为 true，那么将 temp 添加到 父视图中</div><div class="line">                    if (root != null &amp;&amp; attachToRoot) &#123;</div><div class="line">                        root.addView(temp, params);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    //如果 root 为空 或者 attachToRoot 为 false，返回 xml 中的 root，而不是父视图</div><div class="line">                    if (root == null || !attachToRoot) &#123;</div><div class="line">                        result = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的 inflate 方法主要有以下几步</p>
<ol>
<li>解析 xml 的根标签</li>
<li>如果根标签是 merge，调用 rInflate 进行解析，rInflate 会将 merge 标签下的所有子 View 直接添加到根标签中</li>
<li>如果标签是普通元素，调用 createFromTag </li>
<li>调用 rInflate 解析 temp 根元素下的所有子 View，并且将这些子 View 都添加到 temp 下</li>
<li>返回解析到的根视图。</li>
</ol>
<p>我们先从解析单个元素的 <code>createViewFromTag</code> 方法看起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</div><div class="line">        boolean ignoreThemeAttr) &#123;</div><div class="line">    if (name.equals(&quot;view&quot;)) &#123;</div><div class="line">        name = attrs.getAttributeValue(null, &quot;class&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Apply a theme wrapper, if allowed and one is specified.</div><div class="line">    if (!ignoreThemeAttr) &#123;</div><div class="line">        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</div><div class="line">        final int themeResId = ta.getResourceId(0, 0);</div><div class="line">        if (themeResId != 0) &#123;</div><div class="line">            context = new ContextThemeWrapper(context, themeResId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        View view;</div><div class="line">        //用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段</div><div class="line">        if (mFactory2 != null) &#123;</div><div class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125; else if (mFactory != null) &#123;</div><div class="line">            view = mFactory.onCreateView(name, context, attrs);</div><div class="line">        &#125; else &#123;</div><div class="line">            view = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null) &#123;</div><div class="line">            final Object lastContext = mConstructorArgs[0];</div><div class="line">            mConstructorArgs[0] = context;</div><div class="line">            try &#123;</div><div class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class="line">                    // 解析内置 View 控件</div><div class="line">                    view = onCreateView(parent, name, attrs);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // 解析自定义控件</div><div class="line">                    view = createView(name, null, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mConstructorArgs[0] = lastContext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line">    //代码省略</div></pre></td></tr></table></figure></p>
<p><strong>onCreateView 方法和 createView 方法有何不同</strong>？<br>前面的介绍中，我们有提到 LayoutInlflater 创建的实际类型为 <code>PhoneLayoutInlflater</code> ，PhoneLayoutInlflater 覆写了 onCreateView 方法，该方法就是在 View 的标签名前添加一个 <code>&quot;android.widget.&quot; 或 &quot;android.webkit.&quot; 或 &quot;android.app.&quot;</code>前缀。然后再传递给 createView 解析。</p>
<ul>
<li>也就是说<strong>内置 View 和自定义 View 最终都调用了 createView 进行解析</strong>。</li>
</ul>
<p><strong>为什么要这么设计呢</strong>？<br>这是为了方便开发者在 xml 文件中更方便使用系统内置的 View（只需要写 View 名称而不需要写完整的路径），如果是自定义控件或者第三方库，写完整路径。</p>
<p>createView 的具体实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//根据完整路径的类名通过反射机制构造 View 对象</div><div class="line">public final View createView(String name, String prefix, AttributeSet attrs)</div><div class="line">        throws ClassNotFoundException, InflateException &#123;</div><div class="line">    //从缓存中获取构造函数</div><div class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</div><div class="line">    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123;</div><div class="line">        constructor = null;</div><div class="line">        sConstructorMap.remove(name);</div><div class="line">    &#125;</div><div class="line">    Class&lt;? extends View&gt; clazz = null;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</div><div class="line"></div><div class="line">        // 缓存中找不到构造函数</div><div class="line">        if (constructor == null) &#123;</div><div class="line">            //如果前缀（prefix）不为空，构造完整路径，并且加载该类</div><div class="line">            clazz = mContext.getClassLoader().loadClass(</div><div class="line">                    prefix != null ? (prefix + name) : name).asSubclass(View.class);</div><div class="line">            //代码省略</div><div class="line">            //从 class 对象中获取构造函数</div><div class="line">            constructor = clazz.getConstructor(mConstructorSignature);</div><div class="line">            constructor.setAccessible(true);</div><div class="line">            sConstructorMap.put(name, constructor);</div><div class="line">        &#125; else &#123;</div><div class="line">            //代码省略</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Object[] args = mConstructorArgs;</div><div class="line">        args[1] = attrs;</div><div class="line">        //通过反射构造 View</div><div class="line">        final View view = constructor.newInstance(args);</div><div class="line">        if (view instanceof ViewStub) &#123;</div><div class="line">            // Use the same context when inflating ViewStub later.</div><div class="line">            final ViewStub viewStub = (ViewStub) view;</div><div class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));</div><div class="line">        &#125;</div><div class="line">        return view;</div><div class="line"></div><div class="line">    &#125; </div><div class="line">    //省略各种 catch、finally 代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>createView 方法中，如果控件名有前缀就先构造 View 的完整路径，并且将该类加载到虚拟机中</p>
<ul>
<li>然后获取该类的构造函数并缓存起来，再通过构造函数来创建该 View 的对象，</li>
<li>最后将 View 对象返回，这就是解析单个 View 的过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">void rInflate(XmlPullParser parser, View parent, Context context,</div><div class="line">        AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</div><div class="line">    //获取树的深度</div><div class="line">    final int depth = parser.getDepth();</div><div class="line">    int type;</div><div class="line">    //逐个元素解析</div><div class="line">    while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line"></div><div class="line">        if (type != XmlPullParser.START_TAG) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final String name = parser.getName();</div><div class="line">        </div><div class="line">        if (TAG_REQUEST_FOCUS.equals(name)) &#123;</div><div class="line">            parseRequestFocus(parser, parent);</div><div class="line">        &#125; else if (TAG_TAG.equals(name)) &#123;</div><div class="line">            parseViewTag(parser, parent, attrs);</div><div class="line">        &#125; else if (TAG_INCLUDE.equals(name)) &#123;//解析 include 标签</div><div class="line">            if (parser.getDepth() == 0) &#123;</div><div class="line">                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</div><div class="line">            &#125;</div><div class="line">            parseInclude(parser, context, parent, attrs);</div><div class="line">        &#125; else if (TAG_MERGE.equals(name)) &#123;解析 merge 标签</div><div class="line">            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            //根据元素名进行解析</div><div class="line">            final View view = createViewFromTag(parent, name, context, attrs);</div><div class="line">            final ViewGroup viewGroup = (ViewGroup) parent;</div><div class="line">            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div class="line">            //递归调用进行解析，即深度优先遍历</div><div class="line">            rInflateChildren(parser, view, attrs, true);</div><div class="line">            //将解析到的 View 添加到它的父视图中</div><div class="line">            viewGroup.addView(view, params);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (finishInflate) &#123;</div><div class="line">        parent.onFinishInflate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rInflate() 通过深度优先遍历来构造视图树。每解析到一个 View 元素就会递归调用 rInflate，直到这条路径下的最后一个元素，<br>然后在回溯过来将每个 View 元素添加到它们的 parent 中。</p>
<ul>
<li>通过 rInflate 的解析之后，整棵视图树就构建完毕。当调用了 Activity 的 onResume 之后，之前通过 setContentView 设置的内容就会出现在我们的视野中。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>渲染流程大致如下：</p>
<p>inflate 查找根标签</p>
<ul>
<li>如果是 merge，调用 rInflate</li>
<li>否则，调用 <code>createViewFromTag</code><ul>
<li>如果是系统内置控件（通过名称中是否含有「.」来判断），调用 <code>PhoneLayoutInflater.onCreateView()</code> 方法添加前缀，<ul>
<li>处理后将完整路径传给 <code>LayoutInflater.createView()</code> 方法</li>
</ul>
</li>
<li>否则，直接调用 <code>LayoutInflater.createView()</code> 进行解析。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Android 源码设计模式解析与实战》</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 中子线程真的不能更新UI吗？]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/16/Android%20%E4%B8%AD%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97/</url>
      <content type="html"><![CDATA[<h1 id="Android中子线程真的不能更新UI吗？"><a href="#Android中子线程真的不能更新UI吗？" class="headerlink" title="Android中子线程真的不能更新UI吗？"></a>Android中子线程真的不能更新UI吗？</h1><p>先说结论：Android 中子线程在满足一定的条件下可以更新 UI。</p>
<a id="more"></a>
<h2 id="一个栗子："><a href="#一个栗子：" class="headerlink" title="一个栗子："></a>一个栗子：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.btn1)</div><div class="line">    Button mBtn1;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                mBtn1.setText(<span class="string">"worker thread"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上在 onCreate 方法中新建一个线程对 mBtn1 进行了操作，成功从子线程更新了 ui。</p>
<p>但是如果让线程 sleep 一段时间（比如 300ms），<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        mBtn1.setText(<span class="string">"worker thread"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>那么就很可能会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</div><div class="line">    at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:4788)</div><div class="line">    at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:865)</div><div class="line">    at android.view.ViewGroup.invalidateChild(ViewGroup.java:4106)</div><div class="line">    at android.view.View.invalidate(View.java:10386)</div><div class="line">    at android.view.View.invalidate(View.java:10341)</div><div class="line">    at android.widget.TextView.checkForRelayout(TextView.java:6657)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3696)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3554)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3529)</div><div class="line">    at com.android.rdc.androidsamples.MainActivity$1.run(MainActivity.java:63)</div></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么会报这个错误呢？<br>从出错的堆栈信息中可以异常看到是 <code>ViewRootImpl.checkThread()</code> 方法中抛出的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void checkThread() &#123;</div><div class="line">    if (mThread != Thread.currentThread()) &#123;</div><div class="line">        throw new CalledFromWrongThreadException(</div><div class="line">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在访问UI的时候，ViewRootImpl会去检查当前是哪个线程访问的UI，如果不是主线程，那就会抛出异常：</p>
<p>分析到了这里，其实异常信息对我们帮助也不大了，它只告诉了我们子线程中访问UI在哪里抛出异常。 </p>
<p>而我们会思考：当访问UI时，ViewRootImpl 会调用 checkThread 方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，这是没问题的。但是为什么一开始在 MainActivity 的 onCreate 方法中创建一个子线程访问UI，程序还是正常能跑起来呢？<br>答案就是执行 onCreate 方法的那个时候 ViewRootImpl 还没创建，无法去检查当前线程。那么，ViewRootImpl 创建之前的，程序对 UI 的更新操作是如何进行的呢？这个问题我暂时还没有找出答案，希望有了解的同学能指导一下。</p>
<p>回过头看，抛异常的方法既然是 ViewRootImpl 中的方法，那首先应该去看看 ViewRootImpl 是在哪里、在什么时候被创建的。<br>在 AS 中对 ViewRootImpl 进行查找，发现唯一一个初始化了它的地方是 <code>WindowManagerGlobal.addView()</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void addView(View view, ViewGroup.LayoutParams params,</div><div class="line">        Display display, Window parentWindow) &#123;</div><div class="line">    //代码省略</div><div class="line">    root = new ViewRootImpl(view.getContext(), display);</div><div class="line"></div><div class="line">    view.setLayoutParams(wparams);</div><div class="line"></div><div class="line">    mViews.add(view);</div><div class="line">    mRoots.add(root);</div><div class="line">    mParams.add(wparams);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，该方法创建了一个 ViewRootImpl 并将它添加到一个列表中。</p>
<p>该方法又是什么被调用的呢？对 Window 和 WindowManager 有所了解的同学应该知道，Window 的添加过程。</p>
<p>先来看看 ActivityThread 中的 handleResumeActivity 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final void handleResumeActivity(IBinder token,</div><div class="line">            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</div><div class="line">    //代码省略</div><div class="line">    r = performResumeActivity(token, clearHide, reason);</div><div class="line">    //代码省略</div><div class="line">    </div><div class="line">    r.activity.mVisibleFromServer = true;</div><div class="line">    mNumVisibleActivities++;</div><div class="line">    if (r.activity.mVisibleFromClient) &#123;</div><div class="line">        r.activity.makeVisible();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法内部调用了 <code>performResumeActivity</code> 方法，看这个方法名可以揣测该方法最终会调用 Activity 的 onResume 方法，大致流程如下。</p>
<ul>
<li><code>ActivityThread.performResumeActivity</code>  ==》  <code>ActivityClientRecord.Activity.performResume();</code>  ==》 <code>Instrumentation.callActivityOnResume(this);</code> ==》 <code>Activity.onResume();</code></li>
</ul>
<p>回归正题。执行完 performResumeActivity 方法后，会执行 <code>r.activity.makeVisible()</code>，即调用 Activity 的 makeVisible() 。该方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void makeVisible() &#123;</div><div class="line">    if (!mWindowAdded) &#123;</div><div class="line">        ViewManager wm = getWindowManager();</div><div class="line">        wm.addView(mDecor, getWindow().getAttributes());</div><div class="line">        mWindowAdded = true;</div><div class="line">    &#125;</div><div class="line">    mDecor.setVisibility(View.VISIBLE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此处调用了 <code>WindowManager.addView()</code> 方法。而 WindowManger 是一个接口，它的具体实现为 WindowManagerImpl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</div><div class="line">    applyDefaultToken(params);</div><div class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 mGlobal 为 WindowManagerGlobal，也就是说调用了 <code>WindowManagerGlobal.addView()</code> 创建 ViewRootImpl</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>ViewRootImpl 的创建在 onResume 方法回调之后，而我们一开篇是在 onCreate 方法中创建了子线程并访问 UI，在那个时刻，ViewRootImpl 还没有创建，无法检测当前线程是否是 UI 线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了 300 毫秒后，程序就崩了。很明显 300 毫秒后 ViewRootImpl 已经创建了，可以执行 checkThread 方法检查当前线程。</p>
<p>开篇的例子中我们在 onCreate 方法中创建的子线程访问 UI 是一种极端的情况。实际开发中不会这么做。</p>
<p>下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答：</p>
<blockquote>
<p>子线程可以更新UI，但是需要创建子线程的根视图（RootView），并添加到 WindowManager，还要创建子线程的 Looper。以上条件都满足时，它可以修改它自己创建的根视图中的 UI。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/xyh269/article/details/52728861" target="_blank" rel="external">Android中子线程真的不能更新UI吗？</a></li>
<li><a href="http://blog.csdn.net/u010198148/article/details/51779567" target="_blank" rel="external">多线程学习之–真的不能在子线程里更新UI吗？</a></li>
<li><a href="https://www.zybuluo.com/natsumi/note/736165" target="_blank" rel="external">互联网笔记 Android中子线程真的不能更新UI吗？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的观察者模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/09/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="解决、解耦的钥匙——观察者模式"><a href="#解决、解耦的钥匙——观察者模式" class="headerlink" title="解决、解耦的钥匙——观察者模式"></a>解决、解耦的钥匙——观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式定义了对象间一种<strong>一对多</strong>的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>关联行为场景<ul>
<li>需要注意的是，关联行为是可拆分的，而不是“组合”关系</li>
</ul>
</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>
<a id="more"></a>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p>UML 类图如下所示：<br><img src="https://user-images.githubusercontent.com/16668676/29015194-a1c0db10-7b7f-11e7-99a0-437680f88188.png" alt="uml"></p>
<p>四个角色：</p>
<ul>
<li>Subject 抽象主题（抽象的被观察者）。把所有观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，提供接口供添加和删除观察者对象。</li>
<li>ConcreteSubject 具体主题（具体的被观察者）。将有关状态存入具体观察者对象，在具体主题的内部实现发生改变时，给所有注册过的观察者发出通知</li>
<li>Observer 抽象观察者。定义一个更新接口，用来接收主题更改时做出相应的操作（比如更新自身的状态）</li>
<li>ConcreteObserver 具体观察者（实现抽象观察者所定义的更新接口，以便在主题状态更改时更新自身的状态）</li>
</ul>
<h2 id="Android-ListView-的观察者模式"><a href="#Android-ListView-的观察者模式" class="headerlink" title="Android ListView 的观察者模式"></a>Android ListView 的观察者模式</h2><p>ListView 和 RecyclerView 在 Android 中都占据着很重要的地位。</p>
<p>使用这两个组件时，总免不了数据更新的情况：当要更新数据时我们通常都会调用 <code>Adapter.notifyDataSetChanged()</code>，这其中的原理又是怎么样的呢？</p>
<p>下面以 ListView 作为一个栗子，看看其中的具体实现是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void notifyDataSetChanged() &#123;</div><div class="line">    mDataSetObservable.notifyChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void notifyChanged() &#123;</div><div class="line">    synchronized(mObservers) &#123;</div><div class="line">        // since onChanged() is implemented by the app, it could do anything, including</div><div class="line">        // removing itself from &#123;@link mObservers&#125; - and that could cause problems if</div><div class="line">        // an iterator is used on the ArrayList &#123;@link mObservers&#125;.</div><div class="line">        // to avoid such problems, just march thru the list in the reverse order.</div><div class="line">        for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">            mObservers.get(i).onChanged();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>notifyDataSetChanged 方法会调用  <code>DataSetObservable.notifyChanged()</code> 方法,notifyChanged() 内部会遍历调用观察者的 onChanged() 方法。通知数据更新。</li>
<li>但是观察者又是什么时候注册的呢？</li>
</ul>
<p>以下为 setAdapter 的方法的具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setAdapter(ListAdapter adapter) &#123;</div><div class="line">    //如果 已经有 Adapter 存在，先解除注册</div><div class="line">    if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123;</div><div class="line">        mAdapter.unregisterDataSetObserver(mDataSetObserver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resetList();</div><div class="line">    mRecycler.clear();</div><div class="line"></div><div class="line">    if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123;</div><div class="line">        mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter);</div><div class="line">    &#125; else &#123;</div><div class="line">        mAdapter = adapter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mOldSelectedPosition = INVALID_POSITION;</div><div class="line">    mOldSelectedRowId = INVALID_ROW_ID;</div><div class="line"></div><div class="line">    // AbsListView#setAdapter will update choice mode states.</div><div class="line">    super.setAdapter(adapter);</div><div class="line"></div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = mAdapter.getCount();</div><div class="line">        checkFocus();</div><div class="line">        // 构建一个 AdapterDataSetObserver </div><div class="line">        mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">        mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者</div><div class="line"></div><div class="line">        mRecycler.setViewTypeCount(mAdapter.getViewTypeCount());</div><div class="line"></div><div class="line">        int position;</div><div class="line">        if (mStackFromBottom) &#123;</div><div class="line">            position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">        &#125; else &#123;</div><div class="line">            position = lookForSelectablePosition(0, true);</div><div class="line">        &#125;</div><div class="line">        setSelectedPositionInt(position);</div><div class="line">        setNextSelectedPositionInt(position);</div><div class="line"></div><div class="line">        if (mItemCount == 0) &#123;</div><div class="line">            // Nothing selected</div><div class="line">            checkSelectionChanged();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        mAreAllItemsSelectable = true;</div><div class="line">        checkFocus();</div><div class="line">        // Nothing selected</div><div class="line">        checkSelectionChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过源码可以看到，setAdapter 方法内部会构建一个 <code>AdapterDataSetObserver</code> ，然后注册为观察者。我们还可以看到注册的时候是通过 Adapter 来注册的。</p>
<p>Adapter 接口中声明了注册和解注册的方法签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface Adapter &#123;</div><div class="line">    /**</div><div class="line">     * Register an observer that is called when changes happen to the data used by this adapter.</div><div class="line">     *</div><div class="line">     * @param observer the object that gets notified when the data set changes.</div><div class="line">     */</div><div class="line">    void registerDataSetObserver(DataSetObserver observer);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Unregister an observer that has previously been registered with this</div><div class="line">     * adapter via &#123;@link #registerDataSetObserver&#125;.</div><div class="line">     *</div><div class="line">     * @param observer the object to unregister.</div><div class="line">     */</div><div class="line">    void unregisterDataSetObserver(DataSetObserver observer);</div><div class="line">    //代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 BaseAdapter 实现了 ListAdapter 接口，ListAdapter 接口又继承自 Adapter 接口。<br>BaseAdapter 中注册方法和解除注册方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void registerDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.registerObserver(observer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void unregisterDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.unregisterObserver(observer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseAdapter 中注册方法和解除注册方法的具体实现都是通过 mDataSetObservable 来完成的。查看一下 DataSetObservable 的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123;</div><div class="line">    public void notifyChanged() &#123;</div><div class="line">        synchronized(mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void notifyInvalidated() &#123;</div><div class="line">        synchronized (mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onInvalidated();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该类继承了 <code>android.database</code> 包下的 Observable 类，而 Observable 类中存有所有观察者的引用，以及注册和解注册方法。</p>
<p>ListView 中的 onChange 方法具体实现又是什么样的?</p>
<ul>
<li>还记得前面我们说 Observer 是如何注册的吗？注册时，我们构建的是 AdapterDataSetObserver。</li>
<li>该类是 AbsListView 的内部类。<ul>
<li>AbsListView.AdapterDataSetObserver 继承自 AdapterView<listadapter>.AdapterDataSetObserver </listadapter></li>
<li>onChange 方法的主要逻辑都在 AdapterDataSetObserver 中</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class AdapterDataSetObserver extends DataSetObserver &#123;</div><div class="line">    //代码省略 ...</div><div class="line">    @Override</div><div class="line">    public void onChanged() &#123;</div><div class="line">        mDataChanged = true;</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = getAdapter().getCount();</div><div class="line"></div><div class="line">        // Detect the case where a cursor that was previously invalidated has</div><div class="line">        // been repopulated with new data.</div><div class="line">        if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null</div><div class="line">                &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123;</div><div class="line">            AdapterView.this.onRestoreInstanceState(mInstanceState);</div><div class="line">            mInstanceState = null;</div><div class="line">        &#125; else &#123;</div><div class="line">            rememberSyncState();</div><div class="line">        &#125;</div><div class="line">        checkFocus();</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div><div class="line">    //代码省略 ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>onChange 方法中，会获取当前 Adapter 中的数据集的新数量，方法的最后调用 ListView 的 requestLayout() 方法重新进行布局。</p>
<p>从上面的分析中，我们可以看到</p>
<ul>
<li>AbsListView 是抽象的观察者</li>
<li>ListView 是具体的观察者</li>
<li>Adapter 接口是抽象的被观察者</li>
<li>BaseAdapter 是具体的被观察者，其内部实际上是通过 <code>android.database</code> 包下的 Observerable 来实现注册和监听的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>AdapterView 中有一个 AdapterDataSetObserver 内部类，</li>
<li>在 ListView 中设置 Adapter（即调用 ListView 的 setAdapter 方法）时，其内部会构建一个 AdapterDataSetObserver，并注册到 Adapter 中。可见该场景中 ListView 扮演一个观察者角色。</li>
<li>而 Adapter 中有一个数据集可观察者 DataSetObserable。即一个被观察者。</li>
<li>数据集发生变化时，开发者手动调用 Adapter.notifyDataSetChanged 方法，notifyDataSetChanged 会调用 <code>DataSetObserverable.notifyChanged()</code><ul>
<li>notifyChanged() 方法会遍历所有观察者，并调用观察者的 <code>onChanged</code> 方法，</li>
<li>onChanged 会获取 Adapter 中数据集的新数量，同时会调用 View.requestLayout 方法通知 ListView 更新布局，刷新用户界面。</li>
</ul>
</li>
</ul>
<p>虽然 RecyclerView 直接继承自 ViewGroup，而不是 AdapterView ，但是更新列表数据集方法的内部也是通过观察者模式来实现的。只是在其中多提供了单个数据或者指定范围数据更新等回调接口，供开发者使用。感兴趣的同学可以去看看 RecyclerView 中观察者模式的实现。</p>
<p>作者水平有限，疏漏之处，恳请指出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Android 源码设计模式解析与实战》 第十二章 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Toast 原理]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/07/28/Toast%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Toast.makeText(context,”msg”,Toast.Length_SHORT).show();`<br>我们都知道调用了这行代码，便会触发显示 Toast 信息，但是从调用开始到显示出来的具体过程是怎么样的，里面具体实现又是怎么样的呢？</p>
<a id="more"></a>
<p>在 Toast 内部有两类 IPC 过程。</p>
<ul>
<li>第一类： Toast 访问 NotificationManagerService</li>
<li>第二类：NotificationManagerService 回调 Toast 里的 TN 接口。</li>
</ul>
<p>Toast 属于系统 Window，它内部的视图由两种方式指定，一种是系统默认的样式，另一种是自定义一个 view 然后通过 setView 方法将 view 设置进去。<br>不管哪一种方式，它们都对应 Toast 的一个 View 类型的内部成员 mNextView。</p>
<p>Toast 提供 show 和 cancel 方法分别用于显示和隐藏 view，它们的内部都是一个 IPC 过程。</p>
<p>Toast 有定时取消功能，所以系统采用了 Handler（利用其中的 sendMessageDelayed() 方法）</p>
<p>Toast.show() 调用流程大致如下：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28705462-7393612a-73a2-11e7-92b0-5d0ebfb237f0.jpg" alt="toast show"></p>
<p>先来看看 Toast.makeText 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</div><div class="line">    Toast result = new Toast(context);//创建一个新的 Toast 对象</div><div class="line"></div><div class="line">    LayoutInflater inflate = (LayoutInflater)</div><div class="line">            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取 LayoutInflater</div><div class="line">    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); //渲染出系统默认的布局</div><div class="line">    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</div><div class="line">    tv.setText(text);//将我们的信息设置到 TextView 中去</div><div class="line">    </div><div class="line">    result.mNextView = v;//把 view 赋给 Toast 内部的View</div><div class="line">    result.mDuration = duration;//设置 toast 时长</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再瞧一瞧 Toast.show(); 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void show() &#123;</div><div class="line">    if (mNextView == null) &#123;//判断，如果没有设置 Toast 的 view，就抛出异常</div><div class="line">        throw new RuntimeException(&quot;setView must have been called&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INotificationManager service = getService();//获取 INotificationManager </div><div class="line">    String pkg = mContext.getOpPackageName();// 获取调用者的包名</div><div class="line">    TN tn = mTN;//给 TN 赋值</div><div class="line">    tn.mNextView = mNextView;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        service.enqueueToast(pkg, tn, mDuration);</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        // Empty</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面有几个地方看起来比较陌生 INotificationManager 是什么，TN 又是什么？</p>
<p>INotificationManager 的值是从 getService() 方法中得来的。我们先查看下 getService() 的内部实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static private INotificationManager getService() &#123;</div><div class="line">    if (sService != null) &#123;</div><div class="line">        return sService;</div><div class="line">    &#125;</div><div class="line">    sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;));</div><div class="line">    return sService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>了解 Binder 的同学应该一看便知道，这里用到了 Binder。</li>
<li>INotificationManager 的具体实现在 NotificationManagerService 中，简便起见，后续内容将 NotificationManagerService 称为 NMS。</li>
</ul>
<p>TN 又是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TN</span> <span class="keyword">extends</span> <span class="title">ITransientNotification</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable mHide = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            handleHide();</div><div class="line">            <span class="comment">// Don't do this in handleHide() because it is also invoked by handleShow()</span></div><div class="line">            mNextView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManager.LayoutParams mParams = <span class="keyword">new</span> WindowManager.LayoutParams();</div><div class="line">    <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            IBinder token = (IBinder) msg.obj;</div><div class="line">            handleShow(token);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mGravity;</div><div class="line">    <span class="keyword">int</span> mX, mY;</div><div class="line">    <span class="keyword">float</span> mHorizontalMargin;</div><div class="line">    <span class="keyword">float</span> mVerticalMargin;</div><div class="line"></div><div class="line"></div><div class="line">    View mView;</div><div class="line">    View mNextView;</div><div class="line">    <span class="keyword">int</span> mDuration;</div><div class="line"></div><div class="line">    WindowManager mWM;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SHORT_DURATION_TIMEOUT = <span class="number">5000</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LONG_DURATION_TIMEOUT = <span class="number">1000</span>;</div><div class="line"></div><div class="line">    TN() &#123;</div><div class="line">        <span class="comment">// XXX This should be changed to use a Dialog, with a Theme.Toast</span></div><div class="line">        <span class="comment">// defined that sets up the layout params appropriately.</span></div><div class="line">        <span class="keyword">final</span> WindowManager.LayoutParams params = mParams;</div><div class="line">        params.height = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.width = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.format = PixelFormat.TRANSLUCENT;</div><div class="line">        params.windowAnimations = com.android.internal.R.style.Animation_Toast;</div><div class="line">        params.type = WindowManager.LayoutParams.TYPE_TOAST;</div><div class="line">        params.setTitle(<span class="string">"Toast"</span>);</div><div class="line">        params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleShow into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"SHOW: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.obtainMessage(<span class="number">0</span>, windowToken).sendToTarget();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleHide into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HIDE: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.post(mHide);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE SHOW: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView</div><div class="line">                + <span class="string">" mNextView="</span> + mNextView);</div><div class="line">        <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">            <span class="comment">// remove the old view if necessary</span></div><div class="line">            handleHide();</div><div class="line">            mView = mNextView;</div><div class="line">            Context context = mView.getContext().getApplicationContext();</div><div class="line">            String packageName = mView.getContext().getOpPackageName();</div><div class="line">            <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</div><div class="line">                context = mView.getContext();</div><div class="line">            &#125;</div><div class="line">            mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">            <span class="comment">// We can resolve the Gravity here by using the Locale for getting</span></div><div class="line">            <span class="comment">// the layout direction</span></div><div class="line">            <span class="keyword">final</span> Configuration config = mView.getContext().getResources().getConfiguration();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</div><div class="line">            mParams.gravity = gravity;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</div><div class="line">                mParams.horizontalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</div><div class="line">                mParams.verticalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            mParams.x = mX;</div><div class="line">            mParams.y = mY;</div><div class="line">            mParams.verticalMargin = mVerticalMargin;</div><div class="line">            mParams.horizontalMargin = mHorizontalMargin;</div><div class="line">            mParams.packageName = packageName;</div><div class="line">            mParams.hideTimeoutMilliseconds = mDuration ==</div><div class="line">                Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</div><div class="line">            mParams.token = windowToken;</div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeView(mView);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"ADD! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.addView(mView, mParams);</div><div class="line">            trySendAccessibilityEvent();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trySendAccessibilityEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">        AccessibilityManager accessibilityManager =</div><div class="line">                AccessibilityManager.getInstance(mView.getContext());</div><div class="line">        <span class="keyword">if</span> (!accessibilityManager.isEnabled()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// treat toasts as notifications since they are used to</span></div><div class="line">        <span class="comment">// announce a transient piece of information to the user</span></div><div class="line">        AccessibilityEvent event = AccessibilityEvent.obtain(</div><div class="line">                AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);</div><div class="line">        event.setClassName(getClass().getName());</div><div class="line">        event.setPackageName(mView.getContext().getPackageName());</div><div class="line">        mView.dispatchPopulateAccessibilityEvent(event);</div><div class="line">        accessibilityManager.sendAccessibilityEvent(event);</div><div class="line">    &#125;        </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE HIDE: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView);</div><div class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// note: checking parent() just to make sure the view has</span></div><div class="line">            <span class="comment">// been added...  i have seen cases where we get here when</span></div><div class="line">            <span class="comment">// the view isn't yet added, so let's try not to crash.</span></div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeViewImmediate(mView);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TN 是 Toast 的一个私有的静态内部类，继承自 ITransientNotification.Stub </p>
<ul>
<li>也是用到了 Binder 机制。</li>
</ul>
<p>在回到 show 方法。该方法最后调用了 <code>service.enqueueToast(pkg, tn, mDuration);</code> 方法。我们到 NMS 看看该方法的主要实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueToast</span><span class="params">(String pkg, ITransientNotification callback, <span class="keyword">int</span> duration)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="comment">//....</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isSystemToast = isCallerSystem() || (<span class="string">"android"</span>.equals(pkg));<span class="comment">//是否是 android 系统的 toast</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPackageSuspended =</div><div class="line">            isPackageSuspendedForUser(pkg, Binder.getCallingUid());</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">synchronized</span> (mToastQueue) &#123;</div><div class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">        <span class="keyword">long</span> callingId = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ToastRecord record;</div><div class="line">            <span class="keyword">int</span> index = indexOfToastLocked(pkg, callback);<span class="comment">//根据包名和回调来获取的对应包名的 Toast 的在 mToastQueue 中的位置（如果有的话）</span></div><div class="line">            <span class="comment">//如果对应包名的 Toast 已经存在了，则直接在原位更新，不会把它排到队尾</span></div><div class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">                record = mToastQueue.get(index);</div><div class="line">                record.update(duration);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//限制非系统应用的数量（不能超过 50），防止 DOS 攻击同时也是为了解决内存泄漏问题</span></div><div class="line">                <span class="keyword">if</span> (!isSystemToast) &#123;</div><div class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = mToastQueue.size();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">                         <span class="keyword">final</span> ToastRecord r = mToastQueue.get(i);</div><div class="line">                         <span class="keyword">if</span> (r.pkg.equals(pkg)) &#123;</div><div class="line">                             count++;</div><div class="line">                             <span class="keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;</div><div class="line">                                 Slog.e(TAG, <span class="string">"Package has already posted "</span> + count</div><div class="line">                                        + <span class="string">" toasts. Not showing more. Package="</span> + pkg);</div><div class="line">                                 <span class="keyword">return</span>;</div><div class="line">                             &#125;</div><div class="line">                         &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Binder token = <span class="keyword">new</span> Binder();</div><div class="line">                mWindowManagerInternal.addWindowToken(token,</div><div class="line">                        WindowManager.LayoutParams.TYPE_TOAST);</div><div class="line">                record = <span class="keyword">new</span> ToastRecord(callingPid, pkg, callback, duration, token);<span class="comment">//将 Toast 包装为 ToastRecord</span></div><div class="line">                mToastQueue.add(record);<span class="comment">//加入 mToastQueue</span></div><div class="line">                index = mToastQueue.size() - <span class="number">1</span>;</div><div class="line">                keepProcessAliveIfNeededLocked(callingPid);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</div><div class="line">                showNextToastLocked();<span class="comment">//显示下一条 Toast</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(callingId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会将 Toast 请求封装为 ToastRecord 并将其添加进 mToastQueue 队列中。</p>
<ul>
<li>mToastQueue 是一个 ArrayList</li>
<li>注意：每个非系统应用最多只能有 50 个ToastRecord。如果超出了最大值，就会出错。<ul>
<li>这样做主要是为了 防止 DOS（Denial Of Service）</li>
</ul>
</li>
</ul>
<blockquote>
<p>拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
</blockquote>
<p>将 ToastRecord 加入队列之后， <code>enqueueToast</code> 还调用了 <code>showNextToastLocked();</code> 方法, 该方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void showNextToastLocked() &#123;</div><div class="line">    ToastRecord record = mToastQueue.get(0);</div><div class="line">    while (record != null) &#123;</div><div class="line">        if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback);</div><div class="line">        try &#123;</div><div class="line">            record.callback.show(record.token);//调用 record 对象中 callback 的 show 方法</div><div class="line">            scheduleTimeoutLocked(record); //超时提醒，控制显示时间</div><div class="line">            return;</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            //...代码省略</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 callBack 是什么？</p>
<ul>
<li>它是在 ToastRecord 中的，瞅瞅 ToastRecord 的构造方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ToastRecord(<span class="keyword">int</span> pid, String pkg, ITransientNotification callback, <span class="keyword">int</span> duration,</div><div class="line">            Binder token) &#123;</div><div class="line">    <span class="keyword">this</span>.pid = pid;</div><div class="line">    <span class="keyword">this</span>.pkg = pkg;</div><div class="line">    <span class="keyword">this</span>.callback = callback;</div><div class="line">    <span class="keyword">this</span>.duration = duration;</div><div class="line">    <span class="keyword">this</span>.token = token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在 enqueueToast 方法中，将 Toast 包装为 ToastRecord ，创建了 ToastRecord 对象。</p>
<ul>
<li><code>record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord</code> </li>
<li>callBack 是 enqueueToast 中的一个参数，我们的调用如下： <code>service.enqueueToast(pkg, tn, mDuration);</code> </li>
<li><p>没错，callBack 实际上就是前面讲到的 Toast 的内部类 TN。</p>
<ul>
<li>回到前面看看，TN 确实继承了 <code>ITransientNotification.Stub</code>。</li>
</ul>
</li>
<li><p>showNextToastLocked() 方法调用 callBack 的 show() 方法来显示 Toast。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void show(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</div><div class="line">    mHandler.obtainMessage(0, windowToken).sendToTarget();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final Handler mHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        IBinder token = (IBinder) msg.obj;</div><div class="line">        handleShow(token);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其具体实现又是在 handleShow(token);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">        <span class="comment">// 如果有必要的话，将还在显示的 toast 隐藏掉</span></div><div class="line">        handleHide();</div><div class="line">        mView = mNextView;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);<span class="comment">//获取 windowManager</span></div><div class="line">        <span class="comment">//省略代码，给布局参数赋值</span></div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.removeView(mView);</div><div class="line">        &#125;</div><div class="line">        mWM.addView(mView, mParams);</div><div class="line">        trySendAccessibilityEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码核心在于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);`</div><div class="line">`mWM.addView(mView, mParams);`</div></pre></td></tr></table></figure></p>
<p>将 Toast 的视图添加到 Window 中。 这样 View 就能顺利显示出来了。</p>
<p>你可能会问，为什么 TN 调用 show 方法要用到的 Handler ？</p>
<ul>
<li>因为该方法是被是被 NMS 以跨进程方式调用的，因此它们运行在 Binder 线程池中。为了将执行环境切换到 Toast 请求所在的线程，在它们内部使用了 Handler。</li>
</ul>
<p>那么时间到了 Toast 又是怎么样取消的呢？</p>
<ul>
<li><p>在令 Toast 显示方法调用过程中 我们也调用了 <code>scheduleTimeoutLocked(record);</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void scheduleTimeoutLocked(ToastRecord r)&#123;</div><div class="line">    mHandler.removeCallbacksAndMessages(r);</div><div class="line">    Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</div><div class="line">    long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;//设置 延迟时间</div><div class="line">    mHandler.sendMessageDelayed(m, delay);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SHORT_DELAY 为 2s</p>
</li>
<li>LONG_DELAY 为 3.5s</li>
</ul>
<p>scheduleTimeoutLocked 会发出消息给 hanlder,收到相应的信息后 handleMessage 方法会调用<code>handleTimeout((ToastRecord)msg.obj);</code>, 该方法又会调用 <code>cancelToastLocked(index);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelToastLocked</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    ToastRecord record = mToastQueue.get(index);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        record.callback.hide();<span class="comment">//</span></div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到隐藏 Toast 的实现也是在 TN 中的。与 handleShow 对应，有一个 handleHide 方法。<br>该方法会将 Toast 的视图从 Window 中移除。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            mWM.removeViewImmediate(mView);</div><div class="line">        &#125;</div><div class="line">        mView = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建型模式之单例模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/07/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、什么是单例模式？"><a href="#一、什么是单例模式？" class="headerlink" title="一、什么是单例模式？"></a>一、什么是单例模式？</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">wiki</a> 给出的定义如下：单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
<ul>
<li>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</li>
</ul>
<a id="more"></a>
<h2 id="二、为什么要使用单例模式？"><a href="#二、为什么要使用单例模式？" class="headerlink" title="二、为什么要使用单例模式？"></a>二、为什么要使用单例模式？</h2><ul>
<li>有一些对象的内存消耗比较大，创建多次会造成很大的资源开支。</li>
<li>方便配置。<ul>
<li>例如 网络请求经常要用到 cookie，如果使用 OkHttp 可以将其封装为一个单例工具类，内部使用 CookJar 对 cookie  进行管理，这样后续的请求就会方便很多。 </li>
</ul>
</li>
</ul>
<h2 id="三、单例模式的实现方式"><a href="#三、单例模式的实现方式" class="headerlink" title="三、单例模式的实现方式"></a>三、单例模式的实现方式</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明静态对象时就把它初始化。（因为饿，所以迫不及待先把它 new 出来）</p>
<h3 id="2-懒汉模式-26"><a href="#2-懒汉模式-26" class="headerlink" title="2. 懒汉模式 26"></a>2. 懒汉模式 26</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>getInstance</code> 方法中添加了 <code>synchronized</code> 关键字，也就是 </p>
<ul>
<li>一个问题：即使 instance 已经被初始化，之后的每次调用还是会 进行同步，这样会消耗不必要的资源</li>
</ul>
<p>懒汉单例模式的</p>
<ul>
<li>优点：单例只有在使用时才会被实例化，在一定程度上节约了资源。</li>
<li>缺点：第一次加载时需要及时地实例化，反应稍慢，最大的问题是：<strong>每次调用都会进行同步，造成不必要的同步开销</strong>。</li>
</ul>
<h3 id="3-双重校验锁-DCL"><a href="#3-双重校验锁-DCL" class="headerlink" title="3. 双重校验锁 ( DCL )"></a>3. 双重校验锁 ( DCL )</h3><p>DCL 既能够在需要时才初始化实例，又能够保证线程安全，而且单例对象初始化后才调用 getInstance 不进行同步锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class)&#123;</div><div class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="为什么在同步块内还要再进行判空？"><a href="#为什么在同步块内还要再进行判空？" class="headerlink" title="为什么在同步块内还要再进行判空？"></a>为什么在同步块内还要再进行判空？</h4><p>因为<strong>可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了</strong>。</p>
<h4 id="为什么要加-volitale-关键字？"><a href="#为什么要加-volitale-关键字？" class="headerlink" title="为什么要加 volitale 关键字？"></a>为什么要加 volitale 关键字？</h4><p><code>sInstance = new Singleton();</code>这句代码会被编译成多条汇编指令，它大致做了 3 件事情</p>
<ol>
<li>给 Singleton 实例分配内存</li>
<li>调用 Singleton 的构造函数，初始化成员字段</li>
<li>将 sInstance 对象指向分配的内存空间</li>
</ol>
<p>但是由于 Java 编译器允许处理器乱序执行，以及 JDK 1.5 之前 JMM（Java Memory Model， Java 内存模型） 中 cache、寄存器到主内存回写顺序的规定，<br>上面的 2 和 3 的顺序是无法保证的。 如果是 1-3-2，那么当 3 执行完，并且 2 还没有执行的话，被切换到到线程 B，这时 sInstance 已经非空（因为 3 已经被执行了嘛），若 此时线程 B 直接取走 sInstance 使用时就会报错。</p>
<p>解决：JDK 1.5 之后，SUN 官方调整了 JVM，具体化了 volatile 关键字（禁止指令重排序）。 </p>
<ul>
<li>如果是在 JDK 1.5 之后，那么只需要把 sInstance 的声明 改为 <code>private volatile static Singleton sInstance;</code> 即可</li>
</ul>
<h3 id="4-静态内部类单例模式"><a href="#4-静态内部类单例模式" class="headerlink" title="4. 静态内部类单例模式"></a>4. 静态内部类单例模式</h3><p>DCL 在某些情况下会出现失效的问题。这个问题被称为双重检查锁定（DCL）失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123; &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次调用 Singleton 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 SingletonHolder 类，这种方式不仅能够确保线程安全，也能保证单例对象的唯一性。</p>
<p>所以这是推荐使用的单例模式实现方式</p>
<h3 id="5-枚举单例"><a href="#5-枚举单例" class="headerlink" title="5. 枚举单例"></a>5. 枚举单例</h3><p>对枚举不了解可以先看看<a href="https://www.ibm.com/developerworks/cn/java/j-lo-enum/" target="_blank" rel="external">枚举</a>这篇文章</p>
<p>写法简单是枚举单例 最大的优点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    <span class="comment">//枚举内部可以定义成员；</span></div><div class="line">    <span class="keyword">private</span> String mString;</div><div class="line">    <span class="comment">//枚举内部可以定义方法；</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//do sth</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取对象：只需要 Singleton singleton = <code>Singleton.INSTANCE</code>;</p>
<p>枚举在 Java 中与普通的类是一样的，不仅能够有字段，还能定义自己的方法。<br>最重要的是<strong>默认枚举实例的创建是线程安全的</strong>，并且任何情况下它都是一个单例。</p>
<p>上述几种方式中，在一个情况下都会重新创建对象的情况，那就是<strong>反序列化</strong>。</p>
<p>即使构造函数是私有的，反序列化是依然可以通过特殊的途径去创建类的一个新的实例，相当于 调用该类的构造函数。</p>
<p>反序列化操作提供了一耳光很特别的<strong>钩子函数</strong>，类中具有一个私有的、被实例化的方法 <code>readResolve()</code>,这个方法可以让开发人员控制对象的反序列化。</p>
<p>上述几种单例方法中如果要杜绝单例对象在被反序列化时重新生成对象，那必须加入如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">    <span class="keyword">return</span> sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是在 readResolve 方法中将 sInstance 对象返回，而不是默认的重新生成一个新的对象。</p>
<p>而<strong>对于枚举</strong>，并不存在这个问题，因为<strong>即使反序列化也不会重新生成新的实例</strong>。</p>
<h3 id="6-使用容器实现单例模式"><a href="#6-使用容器实现单例模式" class="headerlink" title="6. 使用容器实现单例模式"></a>6. 使用容器实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; sObjectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!sObjectMap.containsKey(key)) &#123;</div><div class="line">            sObjectMap.put(key, instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sObjectMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类型注入到一个统一的管理类中，使用时格根据 key 获取对象对应类型的对象。</p>
<ul>
<li>这种实现方式主要是方便对单例对象进行统一管理。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>不管使用哪一种形式实现单例模式，核心原理都是==将构造函数私有化==，并且==通过静态方法获取唯一的的实例==。</li>
<li>在获取的过程中必须保证线程安全、<strong>防止反序列化导致重新生成实例对象</strong>等问题。</li>
</ul>
<h2 id="使用时的注意点"><a href="#使用时的注意点" class="headerlink" title="使用时的注意点"></a>使用时的注意点</h2><p>避免内存泄漏</p>
<ul>
<li>Android 开发中使用单例模式，如果获取单例对象需要使用 Context，那么尽量使用 ApplicationContext(只要用 <code>contxt.getApplicationContext()</code> 即可获取)。<br>因为如果使用其他 Context（如 Activity)  可能会造成 Activiity 生命周期 执行完成之后，因为其引用被单例所持有，而无法被回收。</li>
<li>多进程环境下，单例模式会失效。</li>
</ul>
<h2 id="Android-源码中的单例模式简述"><a href="#Android-源码中的单例模式简述" class="headerlink" title="Android 源码中的单例模式简述"></a>Android 源码中的单例模式简述</h2><p>我们经常会通过 Context 去获取系统服务，如 LayoutInflater、NetworkStatsManager，这些服务在创建时会以键值对的形式缓存到 HashMap 中，便于管理。</p>
<p>需要时就通过调用  <code>context.getSystemService(String name)</code> 方法获取 。首先会以 name 作为 key，到 hashMap 中查找中相应的服务，如果对应的服务为 null 就创建一个实例，并将该实例缓存到 HashMap 中；如果对应的服务已经存在，则直接返回。</p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">wiki 单例模式</a></li>
<li><a href="">Android 源码设计模式 单例模式</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 消息机制解析]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>提起 Handler，相信大家都不会陌生，日常开发中不可避免地要使用到它。今天要讲的是消息机制。消息机制？咋听起来有点抽象。其实我们在使用 Handler 的时候，就使用了 Android 的消息机制。</p>
<p>从开发的角度来看，Handler 是 Android 消息机制的<strong>上层接口</strong>，这使得开发过程中只需要设计这方面的内容即可。但是作为一名合格的开发者，弄清它的实现原理是很有必要的。</p>
<a id="more"></a>
<p>俗话说得好，一图胜千言，我们先来看下 Android 消息机制简单示意图（参考自<a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">网络</a>）吧。</p>
<p><img src="http://img.blog.csdn.net/20150801014511416" alt=""></p>
<p>我们把 Thread 比作是一个 发动机，MessageQueue 看作是一条流水线，Message 就像是流水线上的工人，Looper 是流水线下的滚筒，Handler 像是一个工人，它负责把 Message 这个产品送到流水线上，最后又负责把它取走。</p>
<p>这幅图中的各个组件的说明如下：</p>
<ul>
<li>Looper ==》 滚轮</li>
<li>MessageQueue ==》 流水线</li>
<li>Message ==&gt; 流水线上的产品</li>
<li>Handler ==》 扮演把『产品』送进流水线，完了以后又把『产品』取走的角色</li>
<li>Thread ==》 动力</li>
</ul>
<p>另外还有一个重要概念 ——ThreadLocal 图中没有标明出来。下面对各个部分进行详细介绍。</p>
<h1 id="Android-的消息机制分析"><a href="#Android-的消息机制分析" class="headerlink" title="Android 的消息机制分析"></a>Android 的消息机制分析</h1><h2 id="从-Handler-出发"><a href="#从-Handler-出发" class="headerlink" title="从 Handler 出发"></a>从 Handler 出发</h2><p>相信很多做 Android 开发的同学都写过与下面相似的代码。在子线程中做一些耗时操作，比如网络请求，操作完成之后，将返回的数据包装为 Message 对象然后调用 sendMessageXxx 方法，最后在 handleMessage 方法中对结果进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            	<span class="comment">//handle </span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//do sth</span></div><div class="line">            Message message = mHandler.obtainMessage();</div><div class="line">            message.what = <span class="number">1</span>;</div><div class="line">            message.obj = result;</div><div class="line">            mHandler.sendMessage(message);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 <code>Handler.sendMessage(message)</code>  到 <code>Handler.handlerMessage</code>方法经历了什么样的过程？</p>
<p>我们先看看 sendMessage 方法内部是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">        delayMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">      msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个调用流程是这样的 <code>sendMessage ==》 sendMessageDelayed ==》 sendMessageAtTime ==》 enqueueMessage ==》  MessageQueue.enqueueMessage</code></p>
<p>我们可能还会调用 <code>Handler.post(Runnable)</code>方法到目标线程中执行 run 方法。post 方法会先调用 <code>getPostMessage</code>方法将 Runable 包装为 一个 Message 对象，（Runnable 就存储在 callback 中）。其他的 <code>postXxx(Runnable)</code>方法内部实现也是这样的流程，首先将 Runnable 包装为一个 Message 对象然后调用相应的 sendXxx 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;<span class="comment">//将 Runnable 包装为一个 Message 对象</span></div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.callback = r;</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述的调用流程可以看出 sendXxx  或者 postXxx 方法最终都会调用 MessageQueue 的 <code>enqueueMessage</code>方法，将 Message 追加到 MessageQueue 中。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>Handler 的消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。<ul>
<li>post 系列方法最终是通过 send 的一系列方法来实现的。</li>
</ul>
</li>
</ul>
<p><strong>Handler 的发送消息的过程仅仅是向消息队列插入了一条消息</strong>。</p>
<h3 id="MessageQueue-对象是从哪里来的？"><a href="#MessageQueue-对象是从哪里来的？" class="headerlink" title="MessageQueue 对象是从哪里来的？"></a>MessageQueue 对象是从哪里来的？</h3><p>mQueue 是 Handler 的一个成员变量，它是在哪里初始化的呢？先看看 Handler 的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    mLooper = Looper.myLooper();<span class="comment">//获取当前线程的 Looper </span></div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="comment">//抛出异常，不能在没有 Looper 的线程创建 Handler </span></div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;<span class="comment">//从本线程的 Looper 中获取 MessageQueue</span></div><div class="line">    mCallback = callback;<span class="comment">//回调</span></div><div class="line">    mAsynchronous = async;<span class="comment">//是否异步</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到 mQueue 是从 Looper 中取出的。在解说 Looper 之前，我们先看看前面提到的 MessageQueue 。</p>
<h2 id="MessageQueue-的工作原理"><a href="#MessageQueue-的工作原理" class="headerlink" title="MessageQueue 的工作原理"></a>MessageQueue 的工作原理</h2><p>MessageQueue 主要包含两个操作：插入和读取（分别对应 enqueueMessage 和 next 方法）。</p>
<ul>
<li>顾名思义，enqueueMessage 的作用是往队列中插入一条信息。</li>
<li>next() 的作用是从队列中取出一条信息并将其从消息队列中移除。</li>
</ul>
<p>虽然 MessageQueue 名为消息队列，但是它的<strong>内部实现并不是用队列</strong>，而是通过一个<strong>单链表的数据结构</strong>来维护消息列表。</p>
<ul>
<li>为什么选择使用单链表结构？ 因为 Message 是可以定时发送的，若使用普通的队列，当插入一个发送时间晚于队首 Message  发送时间的新 Message，那么就需要插队，实现起来不方便，而使用优先队列又显得比较复杂。因此就采用了单链表实现。</li>
</ul>
<p>接下来我们重点看看 enqueueMessage 方法和 next 方法。</p>
<h3 id="enqueueMessage-方法："><a href="#enqueueMessage-方法：" class="headerlink" title="enqueueMessage 方法："></a>enqueueMessage 方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 要进入队列的消息对象的目标 handler 不能为空</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">        <span class="comment">// 要进入队的消息不能处在使用状态</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">            <span class="comment">// 已经调用过 Looper.quit / Looper.quitSafely 方法。 MessageQueue 中不能再追加 Message 对象</span></div><div class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();<span class="comment">//回收消息</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//返回 false 表示入队失败</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 标记消息为使用状态；设置消息发送的时间；是否需要唤醒</span></div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            <span class="comment">//将消息插入到队首</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">          	<span class="comment">//通过该循环找到合适的插入位置（以发送的时间作为排序的标准）</span></div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">//插入队列的指定位置中</span></div><div class="line">            msg.next = p; </div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中不难看出，enqueueMessaege 虽然有点长，但是逻辑还是比较清晰的。它先做了一些状态判断以及一些边界检测，完了以后再进行单链表的插入操作。</p>
<h3 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">      <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>; </div><div class="line">      &#125; </div><div class="line"><span class="comment">//代码省略</span></div><div class="line">      <span class="keyword">for</span> (;;) &#123; </div><div class="line">          <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">              Binder.flushPendingCommands();</div><div class="line">          &#125; </div><div class="line">		<span class="comment">//处理 native 层事件</span></div><div class="line">          nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"> </div><div class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">              <span class="comment">// Try to retrieve the next message.  Return if found. </span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">              Message prevMsg = <span class="keyword">null</span>;</div><div class="line">              Message msg = mMessages;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;<span class="comment">//如果消息的目标 Handler 为空</span></div><div class="line">                  <span class="keyword">do</span> &#123; <span class="comment">// 找出队列中下一个异步 Message 对象</span></div><div class="line">                      prevMsg = msg;</div><div class="line">                      msg = msg.next;</div><div class="line">                  &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">              &#125; </div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                      <span class="comment">// 计算下一条消息的执行时间，设置一个唤醒的延迟</span></div><div class="line">                      nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123; </div><div class="line">                      <span class="comment">// 队首 Message 执行的时机到了，获取一条消息 </span></div><div class="line">                      mBlocked = <span class="keyword">false</span>; </div><div class="line">                      <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                          prevMsg.next = msg.next;</div><div class="line">                      &#125; <span class="keyword">else</span> &#123; </div><div class="line">                          mMessages = msg.next;</div><div class="line">                      &#125; </div><div class="line">                      msg.next = <span class="keyword">null</span>;</div><div class="line">                      <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                      msg.markInUse();<span class="comment">//标记 Message 为正在使用状态</span></div><div class="line">                      <span class="keyword">return</span> msg;<span class="comment">//返回消息</span></div><div class="line">                  &#125; </div><div class="line">              &#125; <span class="keyword">else</span> &#123; </div><div class="line">                  <span class="comment">// 队列中没有消息了</span></div><div class="line">                  nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">              &#125; </div><div class="line"> </div><div class="line">              <span class="comment">// 既然所有待消息都已经处理好了，那就处理退出消息。 </span></div><div class="line">              <span class="keyword">if</span> (mQuitting) &#123; </div><div class="line">                  dispose(); <span class="comment">//处理底层消息队列。实际上移除了 native 层的消息队列</span></div><div class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>; </div><div class="line">              &#125; </div><div class="line"> </div><div class="line"></div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                      &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                  pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">              &#125; </div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// 没有可运行的闲置 handler。跳出本次循环再等待。</span></div><div class="line">                  mBlocked = <span class="keyword">true</span>; </div><div class="line">                  <span class="keyword">continue</span>; </div><div class="line">              &#125; </div><div class="line">		<span class="comment">//代码省略</span></div><div class="line">          &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>next 方法的主要逻辑如下： 从消息队列中依次取出消息，如果这个消息到了执行时间，那么就将该消息返回给 Looper，并且将消息队列链表的指针后移。</p>
<p>next 方法中有一个死循环，其主要逻辑如下:</p>
<ul>
<li>如果消息队列中没有消息，那么 next 会一直阻塞在那里。<ul>
<li>当队首的消息设置了延迟执行时，会造成短时间的阻塞。</li>
</ul>
</li>
<li>当有新消息到来时，next 方法会返回这条信息并将其从单链表中移除。</li>
</ul>
<p>当调用了 quit 方法之后，mQuitting 为 true ，next 方法会移除 native 层的消息队列并返回 null。</p>
<p>我们是不是该说下 Looper 了，下下个就到它了，在此之前需要先看看 ThreadLocal 相关知识。</p>
<h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><p>ThreadLocal  是一个<strong>线程内部的数据存储类</strong>，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>使用场景：</p>
<ol>
<li>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑采用 ThrradLocal。<ul>
<li>在 Android 中，Looper 类就是利用了 ThreadLocal 的特性，保证<strong>每个线程只存在一个 Looper 对象</strong>。</li>
</ul>
</li>
<li>复杂逻辑下的对象传递。<ul>
<li>比如监听器的传递。</li>
</ul>
</li>
</ol>
<p>从 ThreadLocal 的 set 和 get 方法 可以看出，它们所操作的对象都是<strong>当前线程的 localValues 对象的 table 数组</strong>，因此在不同的线程中访问同一个 ThreadLocal 的 get 和 set 方法，他们对 ThreadLocal 所做的读/写操作仅限于各自线程的内部。</p>
<p>关于 ThreadLocal 的具体介绍请见 <a href="https://ivanljt.github.io/blog/2017/08/21/谈谈-ThreadLocal/#more">这篇文章</a></p>
<p>理解 ThreadLocal 对后面理解 Looper 有很大的帮助，建议先细看 ThreadLocal  的内容再看后面的内容。</p>
<h2 id="Looper-的工作原理"><a href="#Looper-的工作原理" class="headerlink" title="Looper 的工作原理"></a>Looper 的工作原理</h2><p>Android 的官方文档中是这么介绍 Looper 的：</p>
<blockquote>
<p>  Looper 是一个用来为单个线程运行消息循环的类。<strong>默认情况下线程是没有一个 Looper 跟他们相关联的</strong>。如果一个线程需要 looper 的话，可以通过先调用 prepare() 方法初始化一个本线程的 Looper 实例。然后调用 loop 方法让它开始处理信息，一直到循环结束。</p>
<p>  我们通常通过 Handler 类与 Looper 的打交道。</p>
</blockquote>
<p>一个 线程最多只能有一个 Looper，一个 Looper 中有一个消息队列（前面 Hanlder 中的 MessageQueue 对象就是从 Looper 中取出的），并且持有它所在线程的引用。Looper 就像一个「死循环」（通过 quit 或者 quitSafely 方法可以退出），它会不断地从 MessageQueue 中查看是否有新消息。如果有，就调用 handler.dispatchMessage 方法进行处理；如果没有，就一直阻塞在那里。</p>
<h3 id="创建-Looper"><a href="#创建-Looper" class="headerlink" title="创建 Looper"></a>创建 Looper</h3><p>我们先看看 Looper 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建一个消息队列</span></div><div class="line">    mThread = Thread.currentThread(); <span class="comment">//把当前线程的对象保存起来</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Looper 构造方法中创建了一个消息队列，并且会保存当前线程对象。</p>
<h4 id="创建普通线程上的-Looper"><a href="#创建普通线程上的-Looper" class="headerlink" title="创建普通线程上的 Looper"></a>创建普通线程上的 Looper</h4><p>Looper 的构造方法是私有的，那么要创建一个 Looper。？<br><strong>调用 <code>Looper.prepare()</code>即可为当前线程创建一个 Looper 对象，接着通过 <code>Looper.loop()</code> 方法开启消息循环</strong>。要注意的是：在子线程中，如果手动为其创建了 Looper，那么在所有的任务完成之后，需要调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待状态。</p>
<p>我们看下 prepare 方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);<span class="comment">//一个线程最多只能有一个 Looper</span></div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));<span class="comment">//为当前线程创建一个 Looper </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;<span class="comment">//获取当前线程的 Looper 对象</span></div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建主线程上的-Looper"><a href="#创建主线程上的-Looper" class="headerlink" title="创建主线程上的 Looper"></a>创建主线程上的 Looper</h4><p>有一个要注意的地方就是 Looper 的另一个创建方法 —— prepareMainLooper。</p>
<p>prepareMainLooper 在应用的入口方法（ActivityThread.main() ）中被调用，用来启动主线程的消息循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">//代码省略</span></div><div class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line"></div><div class="line">    Looper.prepareMainLooper();<span class="comment">//创建主线程的 Looper</span></div><div class="line"></div><div class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">    thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();<span class="comment">//创建主线程的 Handler</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">//代码省略</span></div><div class="line">    Looper.loop();<span class="comment">//开启主线程消息循环</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;<span class="comment">//该方法使得在任何地方都可以获得主线程的消息循环</span></div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">return</span> sMainLooper;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>在应用启动时会开启一个主线程（UI 线程），并且<strong>开启消息循环</strong>，应用不断地从该消息队列中取出、处理消息达到程序运行的结果。</p>
<h3 id="loop-方法"><a href="#loop-方法" class="headerlink" title="loop 方法"></a>loop 方法</h3><p>前面所讲都是 Looper 自身的一些特性，没有提到它是怎么跟其他部分交互的。Looper 与其他 MessageQueue 、Hanlder 的交互主要在 loop 方法中。下面我们来看看 loop 方法的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//获取本线程的 Looper</span></div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);<span class="comment">//调用 loop 方法之前必须先调用 Looper.prepare() 方法创建 Looper</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//获取所在线程的消息队列</span></div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123; </div><div class="line">        Message msg = queue.next(); <span class="comment">// 阻塞方法，如果没有获取到消息，就一直阻塞在这里</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;  <span class="comment">//只有当 msg == null 时才会退出循环</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            msg.target.dispatchMessage(msg);<span class="comment">// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 代码省略</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">        msg.recycleUnchecked();<span class="comment">//调用 Message 的回收方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由源码可见 loop 方法是一个死循环，<strong>唯一跳出循环的方式是 MessageQueue 的 next 方法返回了 null</strong>。</p>
<p>当我们调用 Looper 的 quit 方法时，Looper 会调用 MessageQueue 的 quit 或 quitSafely 方法来通知消息队列退出，否则 loop 方法会一直循环下去。</p>
<p>另外，代码中可以看到，loop 调用了 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 方法会一直阻塞在那里，这也导致了 loop 方法一直阻塞在那里。</p>
<p><code>msg.target.dispatchMessage(msg);</code>// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 <strong>Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理</strong>了。</p>
<p>绕了这么一个大圈意义何在？<br>通常我们都会在子线程中调用 Handler.sendMessageXxx 或者 Handler.postXxx 方法， 而<strong>Handler 的 dispatchMessage 方法是在创建 Handler 的那个线程中执行的，这样就顺利地将代码切换到目标线程中去执行了</strong>。</p>
<h3 id="退出-Looper"><a href="#退出-Looper" class="headerlink" title="退出 Looper"></a>退出 Looper</h3><p>Looper 也是可以退出的（这里的退出 Looper 主要是指跳出 loop 方法中的死循环）。通过调用 Looper 的 quit 方法或者 quitSafely 方法即可。那么这二者有什么区别？</p>
<ul>
<li>调用 Looper 的 quit 方法可以<strong>直接退出</strong>Looper。</li>
<li>调用 Looper 的 quitSafely 方法只是设定了一个<strong>退出标记</strong>，然后把消息队列中<strong>已有的消息处理完才退出</strong> Looper。</li>
</ul>
<p>我们来看看这两个方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Looper.quit</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</div><div class="line">    mQueue.quit(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//Looper.quitSafely</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</div><div class="line">    mQueue.quit(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mQueue 的实际类型为 MessageQueue，Looper 的两个 quit 方法都是通过调用 MessageQueue 的 quit 方法来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);<span class="comment">//主线程的  Looper 无法退出。主线程的 Looper 是通过 prepareMainLooper 方法创建的，创建时调用了 prepare（false），也就是令 mQuitAllowed = false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//是否正在退出</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mQuitting = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (safe) &#123;</div><div class="line">          	<span class="comment">//安全退出,不会取消执行时机早于或等于当前时间的 Message</span></div><div class="line">            removeAllFutureMessagesLocked();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            removeAllMessagesLocked();<span class="comment">//移除 MessageQueue 中所有的消息</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></div><div class="line">        nativeWake(mPtr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MessageQueue.next()</code> 方法片段。当调用了 quit 方法之后会使得 mQuitting 为 true，从而导致  next 方法返回 null，一旦 next 方法返回 null， <code>Looper.loop</code> 就跳出了死循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">    dispose();<span class="comment">//消息 native 层的消息队列。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>MessageQueue.enqueueMessage</code> 方法片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">    IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">            msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">    Log.w(TAG, e.getMessage(), e);</div><div class="line">    msg.recycle();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里实现可以看到，调用了 Looper.quit / quitSafely 方法之后，再通过 Handler 发送的消息无法添加到 MessageQueue 中，此时 Handler 的 send 方法会返回 false。</p>
<h2 id="回到-Handler"><a href="#回到-Handler" class="headerlink" title="回到 Handler"></a>回到 Handler</h2><p> Looper 的 loop 方法中有这样一行代码 <code>msg.target.dispatchMessage(msg);</code>该方法调用的就是 Handler.dispatchMessage 方法。dispatchMessage 方法会根据情况对 Message 进行分发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);<span class="comment">//回调执行 Runnable 的 run 方法</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;<span class="comment">//执行创建 Handler 时指定的 Callback.handleMessage 方法</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);<span class="comment">//执行 handleMessage(msg) 方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;<span class="comment">// Callback 接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;<span class="comment">//空实现，需要由子类覆写</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">    message.callback.run(); <span class="comment">// callback 的实际类型为 Runnable，这行代码的作用就是回调 Runnable 的 run 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler 的工作主要包含<strong>消息的发送</strong>和<strong>接收</strong>过程（还有一个「分发过程」）。  </p>
<ul>
<li>消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。<ul>
<li>post 系列方法最终是通过 send 的一系列方法来实现的。</li>
</ul>
</li>
</ul>
<p>查看源码不难发现，Handler 的发送消息的过程仅仅是向 MessageQueue 插入了一条 Message，MessageQueue 的 next 方法就会返回此 Message 给 Looper， Looper 在 loop 方法中对 Message 进行处理，最终由 Looper 交回给 Handler 处理（调用 Handler 的 dispatchMessage 方法）。</p>
<h2 id="数量关系"><a href="#数量关系" class="headerlink" title="数量关系"></a>数量关系</h2><p>一个线程最多只能有一个 Looper ，一个 MessageQueue，可以有多个 Handler。</p>
<p>MessageQueue 封装在 Looper 中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Looper 对象封装了消息队列，Looper 对象被封装在 ThreadLocal 中，是线程私有的，不同线程之间的 Looper 无法共享。Handler 通过与 Looper 之间的绑定来实现与执行线程之间的绑定，handler 发送消息时会将 Message 对象追加到与线程相关的消息队列中，然后由 Looper 回调它的分发消息方法，根据情况处理消息。</p>
<p>最后我们看一张完整的流程图（图片参考自<a href="http://www.jianshu.com/p/9fe944ee02f7" target="_blank" rel="external">Handler 异步通信机制全面解析</a>），笔者修改了原图中的 Handler dispatchMessage  方法描述。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29739304-0513811c-8a6d-11e7-8a78-510d3c98feb7.png" alt=""></p>
<h2 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h2><ul>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">理解 Java 中的 ThreadLocal </a></li>
<li><a href="https://ivanljt.github.io/blog/2017/08/21/%E8%B0%88%E8%B0%88-ThreadLocal/#more">谈谈 ThreadLocal</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47115879" target="_blank" rel="external">Android 中 Handler 的使用</a></li>
<li><a href="http://www.jianshu.com/p/9fe944ee02f7" target="_blank" rel="external">Handler 异步通信机制全面解析</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">深入源码解析 Android 中的 Handler,Message,MessageQueue,Looper</a></li>
<li>《Android 开发艺术探索》</li>
<li>《Android 源码设计模式解析与实战》</li>
</ul>
<p>如果本文中有不正确的结论、说法或者表述不清晰的地方，恳请大家指出，共同探讨，共同进步，谢谢!</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
