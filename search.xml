<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android源码中的代理模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/18/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h2><p>代理模式也称为委托模式，为其他对象提供一种代理以控制对这个对象的访问。</p>
<h2 id="代理模式的使用场景"><a href="#代理模式的使用场景" class="headerlink" title="代理模式的使用场景"></a>代理模式的使用场景</h2><p>当无法或不想访问某个对象或者访问某个对象存在困难时可以<strong>通过一个代理对象来间接访问</strong>。</p>
<p>为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口（或继承相同的抽象类）</p>
<a id="more"></a>
<h2 id="代理模式的UML类图"><a href="#代理模式的UML类图" class="headerlink" title="代理模式的UML类图"></a>代理模式的UML类图</h2><p><img src="https://user-images.githubusercontent.com/16668676/29449202-6aed8b00-842c-11e7-8e3f-362ead423f2d.png" alt="proxy uml"></p>
<p>角色介绍：</p>
<ul>
<li>Subject 抽象主题类<ul>
<li>主要职责是声明真实主题类与代理的共同接口方法，该类可以是一个抽象类也可以是一个接口</li>
</ul>
</li>
<li>RealSubject 真实主题类<ul>
<li>也称为被委托类或被代理理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。</li>
</ul>
</li>
<li>ProxySubject 代理类<ul>
<li>也称为委托类，持有一个对真实主题类的引用，在其实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。</li>
</ul>
</li>
<li>Client 使用代理类的类</li>
</ul>
<h2 id="代理模式的简单实现"><a href="#代理模式的简单实现" class="headerlink" title="代理模式的简单实现"></a>代理模式的简单实现</h2><p>代理模式大致可分为两大部分，<strong>静态代理和动态代理</strong>。</p>
<p><strong>动态代理</strong>通过反射机制动态地生成代理者的对象，code 阶段不需要知道代理谁，代理的真正对象会在执行阶段确定。</p>
<p>Java 提供一个便捷的动态代理接口 InvocationHandler，实现该接口需要重写其调用方法 invoke。</p>
<p>动态代理通过一个代理类来代理 N 多个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的的耦合关系。</p>
<h3 id="静态代理-vs-动态代理"><a href="#静态代理-vs-动态代理" class="headerlink" title="静态代理 vs 动态代理"></a>静态代理 vs 动态代理</h3><p>相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂。</p>
<ul>
<li>但是静态代理更符合面向对象的原则。</li>
</ul>
<p>实际开发中具体使用哪种方式来实现代理，看自己的偏好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>静态代理和动态代理是从 code 方面来区分代理模式的。</p>
<p>也可以<strong>从其使用范围来区分</strong>不同类型的代理实现：</p>
<ul>
<li><strong>远程代理</strong>（Remote Proxy）为某个对象<strong>在不同的内存地址空间</strong>提供局部代理。</li>
<li><strong>虚拟代理</strong>（Virtual Proxy）使用一个代理对象<strong>表示一个十分耗资源的对象并在真正需要时才创建</strong>。</li>
<li><strong>保护代理</strong>(Protection Proxy)：使用代理<strong>控制对原始对象的访问</strong>。该类型的代理常被<strong>用于原始对象具有不同访问权限</strong>的情况。</li>
<li>智能引用(Smart Reference)：在访问原始对象时执行一些自己的<strong>附加操作并对指向原始对象的引用计数</strong>。</li>
</ul>
<p>静动态代理都可以应用于上述 4 种情形。</p>
<h2 id="Android源码中的代理模式实现"><a href="#Android源码中的代理模式实现" class="headerlink" title="Android源码中的代理模式实现"></a>Android源码中的代理模式实现</h2><p>以 ActivityManager 为例。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29449446-6771e5ce-842d-11e7-935f-d1e5685d43af.png" alt="source code proxy"></p>
<ul>
<li>抽象接口: IActivityManager</li>
<li>代理类 ActivityManagerProxy</li>
<li>被代理类<ul>
<li>ActivityManagerNative(抽象类，并不处理太多的逻辑，大部分逻辑由其子类——ActivityManagerService 承担)</li>
<li>ActivityManagerService(真实部分)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>ActivityManagerService 是系统级的 Service 并且运行于独立的进程空间中，可以通过 ServiceManger 获取到它。</li>
<li>ActivityManagerProxy 运行于自己所处的进程空间中（也就是说，与 ActivityManagerService 运行在不同的进程中）</li>
<li>所以此处源码所实现的代理实质为==远程代理==。</li>
</ul>
<p>ActivityManagerProxy 在实际的逻辑处理并<strong>没有过多地被外部类</strong>使用，Android 中管理与维护 Activity 相关信息的类是另一个叫做 ActivityManager 的类。不过实质上 ActivityManager 大多数逻辑还是由 ActivityManagerProxy 承担。</p>
<p>以 ActivityManager 的 getAppTasks() 方法为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123;</div><div class="line">    ArrayList&lt;AppTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;AppTask&gt;();</div><div class="line">    List&lt;IAppTask&gt; appTasks;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());</div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> numAppTasks = appTasks.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAppTasks; i++) &#123;</div><div class="line">        tasks.add(<span class="keyword">new</span> AppTask(appTasks.get(i)));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ActivityManagerNative.getDefault();</code>方法 返回一个 <code>IActivityManager</code> 类型的对象，通过该对象调用其 getAppTasks 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> gDefault.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gDefault 到底是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);<span class="comment">//获取 AMS</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        IActivityManager am = asInterface(b);<span class="comment">//完成创建一个 AMS 的客户端端代理对象—— ActivityManagerProxy</span></div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        <span class="keyword">return</span> am;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述代码中构造了一个 <code>Singleton&lt;IActivityManager&gt;</code> 类型的 gDefault 对象，其中通过 <code>ServiceManager.getService(&quot;activity&quot;);</code> 获取一个系统级的 Service，而该 Service 实质上就是 AMS，接着调用 asInterface 方法，创建一个 ActivityManagerProxy 对象。</p>
<p>ActivityManagerNative.asInterface 方法的具体实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static public IActivityManager asInterface(IBinder obj) &#123;</div><div class="line">    if (obj == null) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);</div><div class="line">    if (in != null) &#123;</div><div class="line">        return in;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new ActivityManagerProxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ActivityManagerProxy 的 <code>getTasks</code> 方法，将数据打包跨进程传递给 Server 端的 AMS 处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;ActivityManager.RunningTaskInfo&gt; getTasks(<span class="keyword">int</span> maxNum, <span class="keyword">int</span> flags)</div><div class="line">            <span class="keyword">throws</span> RemoteException &#123;</div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel reply = Parcel.obtain();</div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</div><div class="line">        data.writeInt(maxNum);</div><div class="line">        data.writeInt(flags);</div><div class="line">        mRemote.transact(GET_TASKS_TRANSACTION, data, reply, <span class="number">0</span>);</div><div class="line">        reply.readException();</div><div class="line">        ArrayList&lt;ActivityManager.RunningTaskInfo&gt; list = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> N = reply.readInt();</div><div class="line">        <span class="keyword">if</span> (N &gt;= <span class="number">0</span>) &#123;</div><div class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</div><div class="line">                ActivityManager.RunningTaskInfo info =</div><div class="line">                        ActivityManager.RunningTaskInfo.CREATOR</div><div class="line">                                .createFromParcel(reply);</div><div class="line">                list.add(info);</div><div class="line">                N--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        data.recycle();</div><div class="line">        reply.recycle();</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看看 AMS 中的 getTasks 方法的具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;IAppTask&gt; <span class="title">getAppTasks</span><span class="params">(String callingPackage)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> callingUid = Binder.getCallingUid();</div><div class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        ArrayList&lt;IAppTask&gt; list = <span class="keyword">new</span> ArrayList&lt;IAppTask&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"getAppTasks"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mRecentTasks.size();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                TaskRecord tr = mRecentTasks.get(i);</div><div class="line">                <span class="comment">// Skip tasks that do not match the caller.  We don't need to verify</span></div><div class="line">                <span class="comment">// callingPackage, because we are also limiting to callingUid and know</span></div><div class="line">                <span class="comment">// that will limit to the correct security sandbox.</span></div><div class="line">                <span class="keyword">if</span> (tr.effectiveUid != callingUid) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                Intent intent = tr.getBaseIntent();</div><div class="line">                <span class="keyword">if</span> (intent == <span class="keyword">null</span> ||</div><div class="line">                        !callingPackage.equals(intent.getComponent().getPackageName())) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                ActivityManager.RecentTaskInfo taskInfo =</div><div class="line">                        createRecentTaskInfoFromTaskRecord(tr);</div><div class="line">                AppTaskImpl taskImpl = <span class="keyword">new</span> AppTaskImpl(taskInfo.persistentId, callingUid);</div><div class="line">                list.add(taskImpl);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(ident);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Android-中的-Binder-跨进程通信机制与-AIDL"><a href="#Android-中的-Binder-跨进程通信机制与-AIDL" class="headerlink" title="Android 中的 Binder 跨进程通信机制与 AIDL"></a>Android 中的 Binder 跨进程通信机制与 AIDL</h2><p>四个重要类：</p>
<ul>
<li>Binder Client 类比 PC、终端设备</li>
<li>Binder Server 类比 服务器</li>
<li>Binder Driver（实现在内核中） 类比 路由器</li>
<li>Binder Manager 类比 DNS 服务器</li>
</ul>
<p>因为依赖于抽象，加上本地代理类的存在，所以调用远程方法时，还是与调用本地的普通的方法一样。但是代理类内部需要对参数什么的进行打包处理，然后再通过 Binder 机制，跨进程将数据传递给远程方法，远程方法执行完毕再返回数据。</p>
<p><img src="https://user-images.githubusercontent.com/16668676/29453380-021cc0ea-843c-11e7-901d-a7490d12f9ea.jpg" alt="binder 通信大致模型图"></p>
<p>Binder Driver 实现在内核中，主要负责 Binder 通信的建立，以及 Binder数据在进程间的传递和 Binder 引用计数管理/数据包的传输等。</p>
<p>Binder Client 和 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发，</p>
<ul>
<li>对于 Binder Client 而言，它只需要知道自己要使用的 Binder 的名字以及该 <strong>Binder 实体</strong>在 ServerManager 中的 0 号引用即可。<ul>
<li>访问原理：<ul>
<li>通过 0 号引用去访问 ServerManager <strong>获取该 Binder 的引用</strong>，</li>
<li>得到引用后就可以像普通方法调用那样调用 Binder 实体的方法</li>
</ul>
</li>
</ul>
</li>
<li>ServerManager 用来管理 Binder Server（Android 中通常是一个 Service）<ul>
<li>Binder Client 通过它来查询 Binder Server 的引用</li>
<li>ServerManager <strong>是一个标准的 Binder Server</strong>，并且在 Android 中约定其在 Binder 通信过程中的唯一标识（类似于 IP 地址）永远为 0。<ul>
<li>在 IServiceManager 接口中定义有对外开放的接口方法，供客户端访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong>匿名 Binder</strong>。很多时候 Binder Server 会将一个 Binder 实体封装进数据包传递给 Binder Client，而此时 Binder Server 会在该数据包中标注 Binder 实体的位置，Binder Driver 会为该匿名的 Binder 生成实体结点和实体引用，并将该引用传递给 Binder Client。</li>
</ul>
<p>IServiceManager 接口(声明 ServerManger 对外提供的方法、数据 )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IServiceManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">checkService</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line"></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></div><div class="line">                <span class="keyword">throws</span> RemoteException;</div><div class="line">    <span class="keyword">public</span> String[] listServices() <span class="keyword">throws</span> RemoteException;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPermissionController</span><span class="params">(IPermissionController controller)</span></span></div><div class="line">            <span class="keyword">throws</span> RemoteException;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String descriptor = <span class="string">"android.os.IServiceManager"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">4</span>;</div><div class="line">    <span class="keyword">int</span> SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+<span class="number">5</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Andorid 源码设计模式解析与实战》</p>
<p>如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 LayoutInflater]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20LayoutInflater/</url>
      <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="系统服务的注册"><a href="#系统服务的注册" class="headerlink" title="系统服务的注册"></a>系统服务的注册</h2><p>什么时候初始化 ContextImpl？</p>
<p>ContextImpl 中有这样一个成员变量，缓存系统服务。<br><code>final Object[] mServiceCache = SystemServiceRegistry.createServiceCache();</code></p>
<p>在 <code>SystemServiceRegistry</code> 中的静态代码块中注册。注册方法如下所示。在 static 代码块中，会注册所有的系统服务。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Statically registers a system service with the context.</div><div class="line"> * This method must be called during static initialization only.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></div><div class="line">        ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</div><div class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</div><div class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以 <code>LAYOUT_INFLATER_SERVICE</code> 为例子，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">    <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">        &#125;&#125;);</div></pre></td></tr></table></figure></p>
<p><code>CachedServiceFetcher</code> 是一个实现了 <code>ServiceFetcher&lt;T&gt;</code> 接口的抽象类 </p>
<ul>
<li><code>createService</code> 为 <code>CachedServiceFetcher</code> 中的抽象方法，当初始化时会调用该方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Base interface for classes that fetch services.</div><div class="line"> * These objects must only be created during static initialization.</div><div class="line"> */</div><div class="line">static abstract interface ServiceFetcher&lt;T&gt; &#123;</div><div class="line">    T getService(ContextImpl ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;</div><div class="line">    private final int mCacheIndex;</div><div class="line"></div><div class="line">    public CachedServiceFetcher() &#123;</div><div class="line">        mCacheIndex = sServiceCacheSize++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public final T getService(ContextImpl ctx) &#123;</div><div class="line">        final Object[] cache = ctx.mServiceCache;</div><div class="line">        synchronized (cache) &#123;</div><div class="line">            // Fetch or create the service.</div><div class="line">            Object service = cache[mCacheIndex];</div><div class="line">            if (service == null) &#123;//使用了延时加载,第一次调用时才初始化，并将相应服务缓存起来。</div><div class="line">                service = createService(ctx);</div><div class="line">                cache[mCacheIndex] = service;</div><div class="line">            &#125;</div><div class="line">            return (T)service;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract T createService(ContextImpl ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="系统服务的获取"><a href="#系统服务的获取" class="headerlink" title="系统服务的获取"></a>系统服务的获取</h2><p>平时我们都是通过 <code>Context.getSystemService(&quot;服务名字&quot;)</code> 来获取服务。</p>
<p>具体为 ContextImpl 中的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public Object getSystemService(String name) &#123;</div><div class="line">    return SystemServiceRegistry.getSystemService(this, name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 getSystemService 的实际实现是在 <code>SystemServiceRegistry</code> 中的。</p>
<p><code>SystemServiceRegistry</code> 中有一个 <code>HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;</code> ，该 HashMap 以服务名称为 key，以服务相对应的 ServiceFetcher 作为 value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</div><div class="line">        new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</div></pre></td></tr></table></figure>
<p>具体的获取方法为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Gets a system service from a given context.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</div><div class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</div><div class="line">    <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据服务名称去获取相应的 ServiceFetcher，</p>
<ul>
<li>如果 <code>ServiceFetcher</code> 不为空，则调用 <code>ServiceFetcher.getService</code> 方法获取相应服务的引用。<ul>
<li>如果是第一次调用会先创建，然后直接返回</li>
<li>否则直接返回缓存的值</li>
</ul>
</li>
<li>如果 <code>ServiceFetcher</code> 为空，则返回 null。</li>
</ul>
<h2 id="深入理解-LayoutInflater"><a href="#深入理解-LayoutInflater" class="headerlink" title="深入理解 LayoutInflater"></a>深入理解 LayoutInflater</h2><h2 id="LayoutInflater的创建"><a href="#LayoutInflater的创建" class="headerlink" title="LayoutInflater的创建"></a>LayoutInflater的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</div><div class="line">        <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</div><div class="line">    &#125;&#125;);</div></pre></td></tr></table></figure>
<p>可见实际实现为 <code>PhoneLayoutInflater</code>（继承了 LayoutInflater）</p>
<p>onCreateView 是其中最重要的方法。为什么说它重要，后面会提到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Override onCreateView to instantiate names that correspond to the</span></div><div class="line">    widgets known to the Widget factory. If we don't find a match,</div><div class="line">    call through to our super class.</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">//为系统内置的控件添加前缀。比如为 TextView 添加前缀，结果为 android.widget.TextView</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">    <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            View view = createView(name, prefix, attrs);</div><div class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> view;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            <span class="comment">// In this case we want to let the base class take a crack</span></div><div class="line">            <span class="comment">// at it.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="渲染过程解析"><a href="#渲染过程解析" class="headerlink" title="渲染过程解析"></a>渲染过程解析</h2><p>一般我们在渲染 ListView 或者 RecyclerView 中的列表时，都会调用 <code>inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code> 方法（有时也会使用两个参数的方法）。可以看到该方法内部会调用 <code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</div><div class="line">    return inflate(resource, root, root != null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    final Resources res = getContext().getResources();</div><div class="line">    //代码省略</div><div class="line">    //获取 xml 解析器</div><div class="line">    final XmlResourceParser parser = res.getLayout(resource);</div><div class="line">    try &#123;</div><div class="line">        return inflate(parser, root, attachToRoot);</div><div class="line">    &#125; finally &#123;</div><div class="line">        parser.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">    synchronized (mConstructorArgs) &#123;</div><div class="line"></div><div class="line">        final Context inflaterContext = mContext;</div><div class="line">        final AttributeSet attrs = Xml.asAttributeSet(parser);</div><div class="line">        Context lastContext = (Context) mConstructorArgs[0];</div><div class="line">        mConstructorArgs[0] = inflaterContext;</div><div class="line">        //存储父视图</div><div class="line">        View result = root;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 查找根标签</div><div class="line">            int type;</div><div class="line">            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</div><div class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line">                // Empty</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final String name = parser.getName();</div><div class="line">            if (TAG_MERGE.equals(name)) &#123;</div><div class="line">                //1. 解析 merge 标签</div><div class="line">                rInflate(parser, root, inflaterContext, attrs, false);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 2. 不是 merge 元素就直接解析布局中的视图</div><div class="line"> // Temp is the root view that was found in the xml</div><div class="line">                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                    ViewGroup.LayoutParams params = null;</div><div class="line"></div><div class="line">                    if (root != null) &#123;</div><div class="line">                        // 生成布局参数</div><div class="line">                        params = root.generateLayoutParams(attrs);</div><div class="line">                        if (!attachToRoot) &#123;</div><div class="line">                            //如果 attachToRoot 为 false，就给 temp 设置布局参数</div><div class="line">                            temp.setLayoutParams(params);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // 解析 temp 视图下的所有子 View</div><div class="line">                    rInflateChildren(parser, temp, attrs, true);</div><div class="line"></div><div class="line">                    // 如果 root 不为空并且 attachToRoot 为 true，那么将 temp 添加到 父视图中</div><div class="line">                    if (root != null &amp;&amp; attachToRoot) &#123;</div><div class="line">                        root.addView(temp, params);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    //如果 root 为空 或者 attachToRoot 为 false，返回 xml 中的 root，而不是父视图</div><div class="line">                    if (root == null || !attachToRoot) &#123;</div><div class="line">                        result = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上的 inflate 方法主要有以下几步</p>
<ol>
<li>解析 xml 的根标签</li>
<li>如果根标签是 merge，调用 rInflate 进行解析，rInflate 会将 merge 标签下的所有子 View 直接添加到根标签中</li>
<li>如果标签是普通元素，调用 createFromTag </li>
<li>调用 rInflate 解析 temp 根元素下的所有子 View，并且将这些子 View 都添加到 temp 下</li>
<li>返回解析到的根视图。</li>
</ol>
<p>我们先从解析单个元素的 <code>createViewFromTag</code> 方法看起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</div><div class="line">        boolean ignoreThemeAttr) &#123;</div><div class="line">    if (name.equals(&quot;view&quot;)) &#123;</div><div class="line">        name = attrs.getAttributeValue(null, &quot;class&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Apply a theme wrapper, if allowed and one is specified.</div><div class="line">    if (!ignoreThemeAttr) &#123;</div><div class="line">        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</div><div class="line">        final int themeResId = ta.getResourceId(0, 0);</div><div class="line">        if (themeResId != 0) &#123;</div><div class="line">            context = new ContextThemeWrapper(context, themeResId);</div><div class="line">        &#125;</div><div class="line">        ta.recycle();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        View view;</div><div class="line">        //用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段</div><div class="line">        if (mFactory2 != null) &#123;</div><div class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125; else if (mFactory != null) &#123;</div><div class="line">            view = mFactory.onCreateView(name, context, attrs);</div><div class="line">        &#125; else &#123;</div><div class="line">            view = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</div><div class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (view == null) &#123;</div><div class="line">            final Object lastContext = mConstructorArgs[0];</div><div class="line">            mConstructorArgs[0] = context;</div><div class="line">            try &#123;</div><div class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</div><div class="line">                    // 解析内置 View 控件</div><div class="line">                    view = onCreateView(parent, name, attrs);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // 解析自定义控件</div><div class="line">                    view = createView(name, null, attrs);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                mConstructorArgs[0] = lastContext;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line">    //代码省略</div></pre></td></tr></table></figure></p>
<p><strong>onCreateView 方法和 createView 方法有何不同</strong>？<br>前面的介绍中，我们有提到 LayoutInlflater 创建的实际类型为 <code>PhoneLayoutInlflater</code> ，PhoneLayoutInlflater 覆写了 onCreateView 方法，该方法就是在 View 的标签名前添加一个 <code>&quot;android.widget.&quot; 或 &quot;android.webkit.&quot; 或 &quot;android.app.&quot;</code>前缀。然后再传递给 createView 解析。</p>
<ul>
<li>也就是说<strong>内置 View 和自定义 View 最终都调用了 createView 进行解析</strong>。</li>
</ul>
<p><strong>为什么要这么设计呢</strong>？<br>这是为了方便开发者在 xml 文件中更方便使用系统内置的 View（只需要写 View 名称而不需要写完整的路径），如果是自定义控件或者第三方库，写完整路径。</p>
<p>createView 的具体实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">//根据完整路径的类名通过反射机制构造 View 对象</div><div class="line">public final View createView(String name, String prefix, AttributeSet attrs)</div><div class="line">        throws ClassNotFoundException, InflateException &#123;</div><div class="line">    //从缓存中获取构造函数</div><div class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</div><div class="line">    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123;</div><div class="line">        constructor = null;</div><div class="line">        sConstructorMap.remove(name);</div><div class="line">    &#125;</div><div class="line">    Class&lt;? extends View&gt; clazz = null;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</div><div class="line"></div><div class="line">        // 缓存中找不到构造函数</div><div class="line">        if (constructor == null) &#123;</div><div class="line">            //如果前缀（prefix）不为空，构造完整路径，并且加载该类</div><div class="line">            clazz = mContext.getClassLoader().loadClass(</div><div class="line">                    prefix != null ? (prefix + name) : name).asSubclass(View.class);</div><div class="line">            //代码省略</div><div class="line">            //从 class 对象中获取构造函数</div><div class="line">            constructor = clazz.getConstructor(mConstructorSignature);</div><div class="line">            constructor.setAccessible(true);</div><div class="line">            sConstructorMap.put(name, constructor);</div><div class="line">        &#125; else &#123;</div><div class="line">            //代码省略</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Object[] args = mConstructorArgs;</div><div class="line">        args[1] = attrs;</div><div class="line">        //通过反射构造 View</div><div class="line">        final View view = constructor.newInstance(args);</div><div class="line">        if (view instanceof ViewStub) &#123;</div><div class="line">            // Use the same context when inflating ViewStub later.</div><div class="line">            final ViewStub viewStub = (ViewStub) view;</div><div class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));</div><div class="line">        &#125;</div><div class="line">        return view;</div><div class="line"></div><div class="line">    &#125; </div><div class="line">    //省略各种 catch、finally 代码</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>createView 方法中，如果控件名有前缀就先构造 View 的完整路径，并且将该类加载到虚拟机中</p>
<ul>
<li>然后获取该类的构造函数并缓存起来，再通过构造函数来创建该 View 的对象，</li>
<li>最后将 View 对象返回，这就是解析单个 View 的过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">void rInflate(XmlPullParser parser, View parent, Context context,</div><div class="line">        AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</div><div class="line">    //获取树的深度</div><div class="line">    final int depth = parser.getDepth();</div><div class="line">    int type;</div><div class="line">    //逐个元素解析</div><div class="line">    while (((type = parser.next()) != XmlPullParser.END_TAG ||</div><div class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</div><div class="line"></div><div class="line">        if (type != XmlPullParser.START_TAG) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final String name = parser.getName();</div><div class="line">        </div><div class="line">        if (TAG_REQUEST_FOCUS.equals(name)) &#123;</div><div class="line">            parseRequestFocus(parser, parent);</div><div class="line">        &#125; else if (TAG_TAG.equals(name)) &#123;</div><div class="line">            parseViewTag(parser, parent, attrs);</div><div class="line">        &#125; else if (TAG_INCLUDE.equals(name)) &#123;//解析 include 标签</div><div class="line">            if (parser.getDepth() == 0) &#123;</div><div class="line">                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</div><div class="line">            &#125;</div><div class="line">            parseInclude(parser, context, parent, attrs);</div><div class="line">        &#125; else if (TAG_MERGE.equals(name)) &#123;解析 merge 标签</div><div class="line">            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            //根据元素名进行解析</div><div class="line">            final View view = createViewFromTag(parent, name, context, attrs);</div><div class="line">            final ViewGroup viewGroup = (ViewGroup) parent;</div><div class="line">            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</div><div class="line">            //递归调用进行解析，即深度优先遍历</div><div class="line">            rInflateChildren(parser, view, attrs, true);</div><div class="line">            //将解析到的 View 添加到它的父视图中</div><div class="line">            viewGroup.addView(view, params);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (finishInflate) &#123;</div><div class="line">        parent.onFinishInflate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rInflate() 通过深度优先遍历来构造视图树。每解析到一个 View 元素就会递归调用 rInflate，直到这条路径下的最后一个元素，<br>然后在回溯过来将每个 View 元素添加到它们的 parent 中。</p>
<ul>
<li>通过 rInflate 的解析之后，整棵视图树就构建完毕。当调用了 Activity 的 onResume 之后，之前通过 setContentView 设置的内容就会出现在我们的视野中。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>渲染流程大致如下：</p>
<p>inflate 查找根标签</p>
<ul>
<li>如果是 merge，调用 rInflate</li>
<li>否则，调用 <code>createViewFromTag</code><ul>
<li>如果是系统内置控件（通过名称中是否含有「.」来判断），调用 <code>PhoneLayoutInflater.onCreateView()</code> 方法添加前缀，<ul>
<li>处理后将完整路径传给 <code>LayoutInflater.createView()</code> 方法</li>
</ul>
</li>
<li>否则，直接调用 <code>LayoutInflater.createView()</code> 进行解析。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Android 源码设计模式解析与实战》</p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 中子线程真的不能更新UI吗？]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/16/Android%20%E4%B8%AD%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97/</url>
      <content type="html"><![CDATA[<h1 id="Android中子线程真的不能更新UI吗？"><a href="#Android中子线程真的不能更新UI吗？" class="headerlink" title="Android中子线程真的不能更新UI吗？"></a>Android中子线程真的不能更新UI吗？</h1><p>先说结论：Android 中子线程在满足一定的条件下可以更新 UI。</p>
<a id="more"></a>
<h2 id="一个栗子："><a href="#一个栗子：" class="headerlink" title="一个栗子："></a>一个栗子：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.btn1)</div><div class="line">    Button mBtn1;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                mBtn1.setText(<span class="string">"worker thread"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上在 onCreate 方法中新建一个线程对 mBtn1 进行了操作，成功从子线程更新了 ui。</p>
<p>但是如果让线程 sleep 一段时间（比如 300ms），<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        mBtn1.setText(<span class="string">"worker thread"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure></p>
<p>那么就很可能会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</div><div class="line">    at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:4788)</div><div class="line">    at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:865)</div><div class="line">    at android.view.ViewGroup.invalidateChild(ViewGroup.java:4106)</div><div class="line">    at android.view.View.invalidate(View.java:10386)</div><div class="line">    at android.view.View.invalidate(View.java:10341)</div><div class="line">    at android.widget.TextView.checkForRelayout(TextView.java:6657)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3696)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3554)</div><div class="line">    at android.widget.TextView.setText(TextView.java:3529)</div><div class="line">    at com.android.rdc.androidsamples.MainActivity$1.run(MainActivity.java:63)</div></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么会报这个错误呢？<br>从出错的堆栈信息中可以异常看到是 <code>ViewRootImpl.checkThread()</code> 方法中抛出的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void checkThread() &#123;</div><div class="line">    if (mThread != Thread.currentThread()) &#123;</div><div class="line">        throw new CalledFromWrongThreadException(</div><div class="line">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在访问UI的时候，ViewRootImpl会去检查当前是哪个线程访问的UI，如果不是主线程，那就会抛出异常：</p>
<p>分析到了这里，其实异常信息对我们帮助也不大了，它只告诉了我们子线程中访问UI在哪里抛出异常。 </p>
<p>而我们会思考：当访问UI时，ViewRootImpl 会调用 checkThread 方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，这是没问题的。但是为什么一开始在 MainActivity 的 onCreate 方法中创建一个子线程访问UI，程序还是正常能跑起来呢？<br>答案就是执行 onCreate 方法的那个时候 ViewRootImpl 还没创建，无法去检查当前线程。那么，ViewRootImpl 创建之前的，程序对 UI 的更新操作是如何进行的呢？这个问题我暂时还没有找出答案，希望有了解的同学能指导一下。</p>
<p>回过头看，抛异常的方法既然是 ViewRootImpl 中的方法，那首先应该去看看 ViewRootImpl 是在哪里、在什么时候被创建的。<br>在 AS 中对 ViewRootImpl 进行查找，发现唯一一个初始化了它的地方是 <code>WindowManagerGlobal.addView()</code> 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void addView(View view, ViewGroup.LayoutParams params,</div><div class="line">        Display display, Window parentWindow) &#123;</div><div class="line">    //代码省略</div><div class="line">    root = new ViewRootImpl(view.getContext(), display);</div><div class="line"></div><div class="line">    view.setLayoutParams(wparams);</div><div class="line"></div><div class="line">    mViews.add(view);</div><div class="line">    mRoots.add(root);</div><div class="line">    mParams.add(wparams);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，该方法创建了一个 ViewRootImpl 并将它添加到一个列表中。</p>
<p>该方法又是什么被调用的呢？对 Window 和 WindowManager 有所了解的同学应该知道，Window 的添加过程。</p>
<p>先来看看 ActivityThread 中的 handleResumeActivity 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final void handleResumeActivity(IBinder token,</div><div class="line">            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</div><div class="line">    //代码省略</div><div class="line">    r = performResumeActivity(token, clearHide, reason);</div><div class="line">    //代码省略</div><div class="line">    </div><div class="line">    r.activity.mVisibleFromServer = true;</div><div class="line">    mNumVisibleActivities++;</div><div class="line">    if (r.activity.mVisibleFromClient) &#123;</div><div class="line">        r.activity.makeVisible();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法内部调用了 <code>performResumeActivity</code> 方法，看这个方法名可以揣测该方法最终会调用 Activity 的 onResume 方法，大致流程如下。</p>
<ul>
<li><code>ActivityThread.performResumeActivity</code>  ==》  <code>ActivityClientRecord.Activity.performResume();</code>  ==》 <code>Instrumentation.callActivityOnResume(this);</code> ==》 <code>Activity.onResume();</code></li>
</ul>
<p>回归正题。执行完 performResumeActivity 方法后，会执行 <code>r.activity.makeVisible()</code>，即调用 Activity 的 makeVisible() 。该方法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void makeVisible() &#123;</div><div class="line">    if (!mWindowAdded) &#123;</div><div class="line">        ViewManager wm = getWindowManager();</div><div class="line">        wm.addView(mDecor, getWindow().getAttributes());</div><div class="line">        mWindowAdded = true;</div><div class="line">    &#125;</div><div class="line">    mDecor.setVisibility(View.VISIBLE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此处调用了 <code>WindowManager.addView()</code> 方法。而 WindowManger 是一个接口，它的具体实现为 WindowManagerImpl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</div><div class="line">    applyDefaultToken(params);</div><div class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 mGlobal 为 WindowManagerGlobal，也就是说调用了 <code>WindowManagerGlobal.addView()</code> 创建 ViewRootImpl</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>ViewRootImpl 的创建在 onResume 方法回调之后，而我们一开篇是在 onCreate 方法中创建了子线程并访问 UI，在那个时刻，ViewRootImpl 还没有创建，无法检测当前线程是否是 UI 线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了 300 毫秒后，程序就崩了。很明显 300 毫秒后 ViewRootImpl 已经创建了，可以执行 checkThread 方法检查当前线程。</p>
<p>开篇的例子中我们在 onCreate 方法中创建的子线程访问 UI 是一种极端的情况。实际开发中不会这么做。</p>
<p>下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答：</p>
<blockquote>
<p>子线程可以更新UI，但是需要创建子线程的根视图（RootView），并添加到 WindowManager，还要创建子线程的 Looper。以上条件都满足时，它可以修改它自己创建的根视图中的 UI。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/xyh269/article/details/52728861" target="_blank" rel="external">Android中子线程真的不能更新UI吗？</a></li>
<li><a href="http://blog.csdn.net/u010198148/article/details/51779567" target="_blank" rel="external">多线程学习之–真的不能在子线程里更新UI吗？</a></li>
<li><a href="https://www.zybuluo.com/natsumi/note/736165" target="_blank" rel="external">互联网笔记 Android中子线程真的不能更新UI吗？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android源码中的观察者模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/08/09/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="解决、解耦的钥匙——观察者模式"><a href="#解决、解耦的钥匙——观察者模式" class="headerlink" title="解决、解耦的钥匙——观察者模式"></a>解决、解耦的钥匙——观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式定义了对象间一种<strong>一对多</strong>的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>关联行为场景<ul>
<li>需要注意的是，关联行为是可拆分的，而不是“组合”关系</li>
</ul>
</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>
<a id="more"></a>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h2><p>UML 类图如下所示：<br><img src="https://user-images.githubusercontent.com/16668676/29015194-a1c0db10-7b7f-11e7-99a0-437680f88188.png" alt="uml"></p>
<p>四个角色：</p>
<ul>
<li>Subject 抽象主题（抽象的被观察者）。把所有观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，提供接口供添加和删除观察者对象。</li>
<li>ConcreteSubject 具体主题（具体的被观察者）。将有关状态存入具体观察者对象，在具体主题的内部实现发生改变时，给所有注册过的观察者发出通知</li>
<li>Observer 抽象观察者。定义一个更新接口，用来接收主题更改时做出相应的操作（比如更新自身的状态）</li>
<li>ConcreteObserver 具体观察者（实现抽象观察者所定义的更新接口，以便在主题状态更改时更新自身的状态）</li>
</ul>
<h2 id="Android-ListView-的观察者模式"><a href="#Android-ListView-的观察者模式" class="headerlink" title="Android ListView 的观察者模式"></a>Android ListView 的观察者模式</h2><p>ListView 和 RecyclerView 在 Android 中都占据着很重要的地位。</p>
<p>使用这两个组件时，总免不了数据更新的情况：当要更新数据时我们通常都会调用 <code>Adapter.notifyDataSetChanged()</code>，这其中的原理又是怎么样的呢？</p>
<p>下面以 ListView 作为一个栗子，看看其中的具体实现是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void notifyDataSetChanged() &#123;</div><div class="line">    mDataSetObservable.notifyChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void notifyChanged() &#123;</div><div class="line">    synchronized(mObservers) &#123;</div><div class="line">        // since onChanged() is implemented by the app, it could do anything, including</div><div class="line">        // removing itself from &#123;@link mObservers&#125; - and that could cause problems if</div><div class="line">        // an iterator is used on the ArrayList &#123;@link mObservers&#125;.</div><div class="line">        // to avoid such problems, just march thru the list in the reverse order.</div><div class="line">        for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">            mObservers.get(i).onChanged();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>notifyDataSetChanged 方法会调用  <code>DataSetObservable.notifyChanged()</code> 方法,notifyChanged() 内部会遍历调用观察者的 onChanged() 方法。通知数据更新。</li>
<li>但是观察者又是什么时候注册的呢？</li>
</ul>
<p>以下为 setAdapter 的方法的具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setAdapter(ListAdapter adapter) &#123;</div><div class="line">    //如果 已经有 Adapter 存在，先解除注册</div><div class="line">    if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123;</div><div class="line">        mAdapter.unregisterDataSetObserver(mDataSetObserver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resetList();</div><div class="line">    mRecycler.clear();</div><div class="line"></div><div class="line">    if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123;</div><div class="line">        mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter);</div><div class="line">    &#125; else &#123;</div><div class="line">        mAdapter = adapter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mOldSelectedPosition = INVALID_POSITION;</div><div class="line">    mOldSelectedRowId = INVALID_ROW_ID;</div><div class="line"></div><div class="line">    // AbsListView#setAdapter will update choice mode states.</div><div class="line">    super.setAdapter(adapter);</div><div class="line"></div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = mAdapter.getCount();</div><div class="line">        checkFocus();</div><div class="line">        // 构建一个 AdapterDataSetObserver </div><div class="line">        mDataSetObserver = new AdapterDataSetObserver();</div><div class="line">        mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者</div><div class="line"></div><div class="line">        mRecycler.setViewTypeCount(mAdapter.getViewTypeCount());</div><div class="line"></div><div class="line">        int position;</div><div class="line">        if (mStackFromBottom) &#123;</div><div class="line">            position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">        &#125; else &#123;</div><div class="line">            position = lookForSelectablePosition(0, true);</div><div class="line">        &#125;</div><div class="line">        setSelectedPositionInt(position);</div><div class="line">        setNextSelectedPositionInt(position);</div><div class="line"></div><div class="line">        if (mItemCount == 0) &#123;</div><div class="line">            // Nothing selected</div><div class="line">            checkSelectionChanged();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        mAreAllItemsSelectable = true;</div><div class="line">        checkFocus();</div><div class="line">        // Nothing selected</div><div class="line">        checkSelectionChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过源码可以看到，setAdapter 方法内部会构建一个 <code>AdapterDataSetObserver</code> ，然后注册为观察者。我们还可以看到注册的时候是通过 Adapter 来注册的。</p>
<p>Adapter 接口中声明了注册和解注册的方法签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface Adapter &#123;</div><div class="line">    /**</div><div class="line">     * Register an observer that is called when changes happen to the data used by this adapter.</div><div class="line">     *</div><div class="line">     * @param observer the object that gets notified when the data set changes.</div><div class="line">     */</div><div class="line">    void registerDataSetObserver(DataSetObserver observer);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Unregister an observer that has previously been registered with this</div><div class="line">     * adapter via &#123;@link #registerDataSetObserver&#125;.</div><div class="line">     *</div><div class="line">     * @param observer the object to unregister.</div><div class="line">     */</div><div class="line">    void unregisterDataSetObserver(DataSetObserver observer);</div><div class="line">    //代码省略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而 BaseAdapter 实现了 ListAdapter 接口，ListAdapter 接口又继承自 Adapter 接口。<br>BaseAdapter 中注册方法和解除注册方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void registerDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.registerObserver(observer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void unregisterDataSetObserver(DataSetObserver observer) &#123;</div><div class="line">    mDataSetObservable.unregisterObserver(observer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseAdapter 中注册方法和解除注册方法的具体实现都是通过 mDataSetObservable 来完成的。查看一下 DataSetObservable 的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123;</div><div class="line">    public void notifyChanged() &#123;</div><div class="line">        synchronized(mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onChanged();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void notifyInvalidated() &#123;</div><div class="line">        synchronized (mObservers) &#123;</div><div class="line">            for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                mObservers.get(i).onInvalidated();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该类继承了 <code>android.database</code> 包下的 Observable 类，而 Observable 类中存有所有观察者的引用，以及注册和解注册方法。</p>
<p>ListView 中的 onChange 方法具体实现又是什么样的?</p>
<ul>
<li>还记得前面我们说 Observer 是如何注册的吗？注册时，我们构建的是 AdapterDataSetObserver。</li>
<li>该类是 AbsListView 的内部类。<ul>
<li>AbsListView.AdapterDataSetObserver 继承自 AdapterView<listadapter>.AdapterDataSetObserver </listadapter></li>
<li>onChange 方法的主要逻辑都在 AdapterDataSetObserver 中</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class AdapterDataSetObserver extends DataSetObserver &#123;</div><div class="line">    //代码省略 ...</div><div class="line">    @Override</div><div class="line">    public void onChanged() &#123;</div><div class="line">        mDataChanged = true;</div><div class="line">        mOldItemCount = mItemCount;</div><div class="line">        mItemCount = getAdapter().getCount();</div><div class="line"></div><div class="line">        // Detect the case where a cursor that was previously invalidated has</div><div class="line">        // been repopulated with new data.</div><div class="line">        if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null</div><div class="line">                &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123;</div><div class="line">            AdapterView.this.onRestoreInstanceState(mInstanceState);</div><div class="line">            mInstanceState = null;</div><div class="line">        &#125; else &#123;</div><div class="line">            rememberSyncState();</div><div class="line">        &#125;</div><div class="line">        checkFocus();</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div><div class="line">    //代码省略 ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>onChange 方法中，会获取当前 Adapter 中的数据集的新数量，方法的最后调用 ListView 的 requestLayout() 方法重新进行布局。</p>
<p>从上面的分析中，我们可以看到</p>
<ul>
<li>AbsListView 是抽象的观察者</li>
<li>ListView 是具体的观察者</li>
<li>Adapter 接口是抽象的被观察者</li>
<li>BaseAdapter 是具体的被观察者，其内部实际上是通过 <code>android.database</code> 包下的 Observerable 来实现注册和监听的。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>AdapterView 中有一个 AdapterDataSetObserver 内部类，</li>
<li>在 ListView 中设置 Adapter（即调用 ListView 的 setAdapter 方法）时，其内部会构建一个 AdapterDataSetObserver，并注册到 Adapter 中。可见该场景中 ListView 扮演一个观察者角色。</li>
<li>而 Adapter 中有一个数据集可观察者 DataSetObserable。即一个被观察者。</li>
<li>数据集发生变化时，开发者手动调用 Adapter.notifyDataSetChanged 方法，notifyDataSetChanged 会调用 <code>DataSetObserverable.notifyChanged()</code><ul>
<li>notifyChanged() 方法会遍历所有观察者，并调用观察者的 <code>onChanged</code> 方法，</li>
<li>onChanged 会获取 Adapter 中数据集的新数量，同时会调用 View.requestLayout 方法通知 ListView 更新布局，刷新用户界面。</li>
</ul>
</li>
</ul>
<p>虽然 RecyclerView 直接继承自 ViewGroup，而不是 AdapterView ，但是更新列表数据集方法的内部也是通过观察者模式来实现的。只是在其中多提供了单个数据或者指定范围数据更新等回调接口，供开发者使用。感兴趣的同学可以去看看 RecyclerView 中观察者模式的实现。</p>
<p>作者水平有限，疏漏之处，恳请指出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Android 源码设计模式解析与实战》 第十二章 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Toast 原理]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/07/28/Toast%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Toast.makeText(context,”msg”,Toast.Length_SHORT).show();`<br>我们都知道调用了这行代码，便会触发显示 Toast 信息，但是从调用开始到显示出来的具体过程是怎么样的，里面具体实现又是怎么样的呢？</p>
<a id="more"></a>
<p>在 Toast 内部有两类 IPC 过程。</p>
<ul>
<li>第一类： Toast 访问 NotificationManagerService</li>
<li>第二类：NotificationManagerService 回调 Toast 里的 TN 接口。</li>
</ul>
<p>Toast 属于系统 Window，它内部的视图由两种方式指定，一种是系统默认的样式，另一种是自定义一个 view 然后通过 setView 方法将 view 设置进去。<br>不管哪一种方式，它们都对应 Toast 的一个 View 类型的内部成员 mNextView。</p>
<p>Toast 提供 show 和 cancel 方法分别用于显示和隐藏 view，它们的内部都是一个 IPC 过程。</p>
<p>Toast 有定时取消功能，所以系统采用了 Handler（利用其中的 sendMessageDelayed() 方法）</p>
<p>Toast.show() 调用流程大致如下：</p>
<p><img src="https://user-images.githubusercontent.com/16668676/28705462-7393612a-73a2-11e7-92b0-5d0ebfb237f0.jpg" alt="toast show"></p>
<p>先来看看 Toast.makeText 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</div><div class="line">    Toast result = new Toast(context);//创建一个新的 Toast 对象</div><div class="line"></div><div class="line">    LayoutInflater inflate = (LayoutInflater)</div><div class="line">            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取 LayoutInflater</div><div class="line">    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); //渲染出系统默认的布局</div><div class="line">    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</div><div class="line">    tv.setText(text);//将我们的信息设置到 TextView 中去</div><div class="line">    </div><div class="line">    result.mNextView = v;//把 view 赋给 Toast 内部的View</div><div class="line">    result.mDuration = duration;//设置 toast 时长</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再瞧一瞧 Toast.show(); 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void show() &#123;</div><div class="line">    if (mNextView == null) &#123;//判断，如果没有设置 Toast 的 view，就抛出异常</div><div class="line">        throw new RuntimeException(&quot;setView must have been called&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INotificationManager service = getService();//获取 INotificationManager </div><div class="line">    String pkg = mContext.getOpPackageName();// 获取调用者的包名</div><div class="line">    TN tn = mTN;//给 TN 赋值</div><div class="line">    tn.mNextView = mNextView;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        service.enqueueToast(pkg, tn, mDuration);</div><div class="line">    &#125; catch (RemoteException e) &#123;</div><div class="line">        // Empty</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里面有几个地方看起来比较陌生 INotificationManager 是什么，TN 又是什么？</p>
<p>INotificationManager 的值是从 getService() 方法中得来的。我们先查看下 getService() 的内部实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static private INotificationManager getService() &#123;</div><div class="line">    if (sService != null) &#123;</div><div class="line">        return sService;</div><div class="line">    &#125;</div><div class="line">    sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;));</div><div class="line">    return sService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>了解 Binder 的同学应该一看便知道，这里用到了 Binder。</li>
<li>INotificationManager 的具体实现在 NotificationManagerService 中，简便起见，后续内容将 NotificationManagerService 称为 NMS。</li>
</ul>
<p>TN 又是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TN</span> <span class="keyword">extends</span> <span class="title">ITransientNotification</span>.<span class="title">Stub</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable mHide = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            handleHide();</div><div class="line">            <span class="comment">// Don't do this in handleHide() because it is also invoked by handleShow()</span></div><div class="line">            mNextView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManager.LayoutParams mParams = <span class="keyword">new</span> WindowManager.LayoutParams();</div><div class="line">    <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            IBinder token = (IBinder) msg.obj;</div><div class="line">            handleShow(token);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mGravity;</div><div class="line">    <span class="keyword">int</span> mX, mY;</div><div class="line">    <span class="keyword">float</span> mHorizontalMargin;</div><div class="line">    <span class="keyword">float</span> mVerticalMargin;</div><div class="line"></div><div class="line"></div><div class="line">    View mView;</div><div class="line">    View mNextView;</div><div class="line">    <span class="keyword">int</span> mDuration;</div><div class="line"></div><div class="line">    WindowManager mWM;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SHORT_DURATION_TIMEOUT = <span class="number">5000</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LONG_DURATION_TIMEOUT = <span class="number">1000</span>;</div><div class="line"></div><div class="line">    TN() &#123;</div><div class="line">        <span class="comment">// XXX This should be changed to use a Dialog, with a Theme.Toast</span></div><div class="line">        <span class="comment">// defined that sets up the layout params appropriately.</span></div><div class="line">        <span class="keyword">final</span> WindowManager.LayoutParams params = mParams;</div><div class="line">        params.height = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.width = WindowManager.LayoutParams.WRAP_CONTENT;</div><div class="line">        params.format = PixelFormat.TRANSLUCENT;</div><div class="line">        params.windowAnimations = com.android.internal.R.style.Animation_Toast;</div><div class="line">        params.type = WindowManager.LayoutParams.TYPE_TOAST;</div><div class="line">        params.setTitle(<span class="string">"Toast"</span>);</div><div class="line">        params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</div><div class="line">                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleShow into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"SHOW: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.obtainMessage(<span class="number">0</span>, windowToken).sendToTarget();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * schedule handleHide into the right thread</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HIDE: "</span> + <span class="keyword">this</span>);</div><div class="line">        mHandler.post(mHide);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE SHOW: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView</div><div class="line">                + <span class="string">" mNextView="</span> + mNextView);</div><div class="line">        <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">            <span class="comment">// remove the old view if necessary</span></div><div class="line">            handleHide();</div><div class="line">            mView = mNextView;</div><div class="line">            Context context = mView.getContext().getApplicationContext();</div><div class="line">            String packageName = mView.getContext().getOpPackageName();</div><div class="line">            <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</div><div class="line">                context = mView.getContext();</div><div class="line">            &#125;</div><div class="line">            mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</div><div class="line">            <span class="comment">// We can resolve the Gravity here by using the Locale for getting</span></div><div class="line">            <span class="comment">// the layout direction</span></div><div class="line">            <span class="keyword">final</span> Configuration config = mView.getContext().getResources().getConfiguration();</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</div><div class="line">            mParams.gravity = gravity;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;</div><div class="line">                mParams.horizontalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;</div><div class="line">                mParams.verticalWeight = <span class="number">1.0f</span>;</div><div class="line">            &#125;</div><div class="line">            mParams.x = mX;</div><div class="line">            mParams.y = mY;</div><div class="line">            mParams.verticalMargin = mVerticalMargin;</div><div class="line">            mParams.horizontalMargin = mHorizontalMargin;</div><div class="line">            mParams.packageName = packageName;</div><div class="line">            mParams.hideTimeoutMilliseconds = mDuration ==</div><div class="line">                Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;</div><div class="line">            mParams.token = windowToken;</div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeView(mView);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"ADD! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.addView(mView, mParams);</div><div class="line">            trySendAccessibilityEvent();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trySendAccessibilityEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">        AccessibilityManager accessibilityManager =</div><div class="line">                AccessibilityManager.getInstance(mView.getContext());</div><div class="line">        <span class="keyword">if</span> (!accessibilityManager.isEnabled()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// treat toasts as notifications since they are used to</span></div><div class="line">        <span class="comment">// announce a transient piece of information to the user</span></div><div class="line">        AccessibilityEvent event = AccessibilityEvent.obtain(</div><div class="line">                AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);</div><div class="line">        event.setClassName(getClass().getName());</div><div class="line">        event.setPackageName(mView.getContext().getPackageName());</div><div class="line">        mView.dispatchPopulateAccessibilityEvent(event);</div><div class="line">        accessibilityManager.sendAccessibilityEvent(event);</div><div class="line">    &#125;        </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"HANDLE HIDE: "</span> + <span class="keyword">this</span> + <span class="string">" mView="</span> + mView);</div><div class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// note: checking parent() just to make sure the view has</span></div><div class="line">            <span class="comment">// been added...  i have seen cases where we get here when</span></div><div class="line">            <span class="comment">// the view isn't yet added, so let's try not to crash.</span></div><div class="line">            <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">                mWM.removeViewImmediate(mView);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mView = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TN 是 Toast 的一个私有的静态内部类，继承自 ITransientNotification.Stub </p>
<ul>
<li>也是用到了 Binder 机制。</li>
</ul>
<p>在回到 show 方法。该方法最后调用了 <code>service.enqueueToast(pkg, tn, mDuration);</code> 方法。我们到 NMS 看看该方法的主要实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueToast</span><span class="params">(String pkg, ITransientNotification callback, <span class="keyword">int</span> duration)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="comment">//....</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isSystemToast = isCallerSystem() || (<span class="string">"android"</span>.equals(pkg));<span class="comment">//是否是 android 系统的 toast</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPackageSuspended =</div><div class="line">            isPackageSuspendedForUser(pkg, Binder.getCallingUid());</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">synchronized</span> (mToastQueue) &#123;</div><div class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</div><div class="line">        <span class="keyword">long</span> callingId = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ToastRecord record;</div><div class="line">            <span class="keyword">int</span> index = indexOfToastLocked(pkg, callback);<span class="comment">//根据包名和回调来获取的对应包名的 Toast 的在 mToastQueue 中的位置（如果有的话）</span></div><div class="line">            <span class="comment">//如果对应包名的 Toast 已经存在了，则直接在原位更新，不会把它排到队尾</span></div><div class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</div><div class="line">                record = mToastQueue.get(index);</div><div class="line">                record.update(duration);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//限制非系统应用的数量（不能超过 50），防止 DOS 攻击同时也是为了解决内存泄漏问题</span></div><div class="line">                <span class="keyword">if</span> (!isSystemToast) &#123;</div><div class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = mToastQueue.size();</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">                         <span class="keyword">final</span> ToastRecord r = mToastQueue.get(i);</div><div class="line">                         <span class="keyword">if</span> (r.pkg.equals(pkg)) &#123;</div><div class="line">                             count++;</div><div class="line">                             <span class="keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;</div><div class="line">                                 Slog.e(TAG, <span class="string">"Package has already posted "</span> + count</div><div class="line">                                        + <span class="string">" toasts. Not showing more. Package="</span> + pkg);</div><div class="line">                                 <span class="keyword">return</span>;</div><div class="line">                             &#125;</div><div class="line">                         &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Binder token = <span class="keyword">new</span> Binder();</div><div class="line">                mWindowManagerInternal.addWindowToken(token,</div><div class="line">                        WindowManager.LayoutParams.TYPE_TOAST);</div><div class="line">                record = <span class="keyword">new</span> ToastRecord(callingPid, pkg, callback, duration, token);<span class="comment">//将 Toast 包装为 ToastRecord</span></div><div class="line">                mToastQueue.add(record);<span class="comment">//加入 mToastQueue</span></div><div class="line">                index = mToastQueue.size() - <span class="number">1</span>;</div><div class="line">                keepProcessAliveIfNeededLocked(callingPid);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</div><div class="line">                showNextToastLocked();<span class="comment">//显示下一条 Toast</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(callingId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会将 Toast 请求封装为 ToastRecord 并将其添加进 mToastQueue 队列中。</p>
<ul>
<li>mToastQueue 是一个 ArrayList</li>
<li>注意：每个非系统应用最多只能有 50 个ToastRecord。如果超出了最大值，就会出错。<ul>
<li>这样做主要是为了 防止 DOS（Denial Of Service）</li>
</ul>
</li>
</ul>
<blockquote>
<p>拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
</blockquote>
<p>将 ToastRecord 加入队列之后， <code>enqueueToast</code> 还调用了 <code>showNextToastLocked();</code> 方法, 该方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void showNextToastLocked() &#123;</div><div class="line">    ToastRecord record = mToastQueue.get(0);</div><div class="line">    while (record != null) &#123;</div><div class="line">        if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback);</div><div class="line">        try &#123;</div><div class="line">            record.callback.show(record.token);//调用 record 对象中 callback 的 show 方法</div><div class="line">            scheduleTimeoutLocked(record); //超时提醒，控制显示时间</div><div class="line">            return;</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            //...代码省略</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 callBack 是什么？</p>
<ul>
<li>它是在 ToastRecord 中的，瞅瞅 ToastRecord 的构造方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ToastRecord(<span class="keyword">int</span> pid, String pkg, ITransientNotification callback, <span class="keyword">int</span> duration,</div><div class="line">            Binder token) &#123;</div><div class="line">    <span class="keyword">this</span>.pid = pid;</div><div class="line">    <span class="keyword">this</span>.pkg = pkg;</div><div class="line">    <span class="keyword">this</span>.callback = callback;</div><div class="line">    <span class="keyword">this</span>.duration = duration;</div><div class="line">    <span class="keyword">this</span>.token = token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在 enqueueToast 方法中，将 Toast 包装为 ToastRecord ，创建了 ToastRecord 对象。</p>
<ul>
<li><code>record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord</code> </li>
<li>callBack 是 enqueueToast 中的一个参数，我们的调用如下： <code>service.enqueueToast(pkg, tn, mDuration);</code> </li>
<li><p>没错，callBack 实际上就是前面讲到的 Toast 的内部类 TN。</p>
<ul>
<li>回到前面看看，TN 确实继承了 <code>ITransientNotification.Stub</code>。</li>
</ul>
</li>
<li><p>showNextToastLocked() 方法调用 callBack 的 show() 方法来显示 Toast。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void show(IBinder windowToken) &#123;</div><div class="line">    if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</div><div class="line">    mHandler.obtainMessage(0, windowToken).sendToTarget();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final Handler mHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        IBinder token = (IBinder) msg.obj;</div><div class="line">        handleShow(token);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其具体实现又是在 handleShow(token);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShow</span><span class="params">(IBinder windowToken)</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (mView != mNextView) &#123;</div><div class="line">        <span class="comment">// 如果有必要的话，将还在显示的 toast 隐藏掉</span></div><div class="line">        handleHide();</div><div class="line">        mView = mNextView;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">        mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);<span class="comment">//获取 windowManager</span></div><div class="line">        <span class="comment">//省略代码，给布局参数赋值</span></div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">"REMOVE! "</span> + mView + <span class="string">" in "</span> + <span class="keyword">this</span>);</div><div class="line">            mWM.removeView(mView);</div><div class="line">        &#125;</div><div class="line">        mWM.addView(mView, mParams);</div><div class="line">        trySendAccessibilityEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码核心在于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);`</div><div class="line">`mWM.addView(mView, mParams);`</div></pre></td></tr></table></figure></p>
<p>将 Toast 的视图添加到 Window 中。 这样 View 就能顺利显示出来了。</p>
<p>你可能会问，为什么 TN 调用 show 方法要用到的 Handler ？</p>
<ul>
<li>因为该方法是被是被 NMS 以跨进程方式调用的，因此它们运行在 Binder 线程池中。为了将执行环境切换到 Toast 请求所在的线程，在它们内部使用了 Handler。</li>
</ul>
<p>那么时间到了 Toast 又是怎么样取消的呢？</p>
<ul>
<li><p>在令 Toast 显示方法调用过程中 我们也调用了 <code>scheduleTimeoutLocked(record);</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void scheduleTimeoutLocked(ToastRecord r)&#123;</div><div class="line">    mHandler.removeCallbacksAndMessages(r);</div><div class="line">    Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</div><div class="line">    long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;//设置 延迟时间</div><div class="line">    mHandler.sendMessageDelayed(m, delay);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SHORT_DELAY 为 2s</p>
</li>
<li>LONG_DELAY 为 3.5s</li>
</ul>
<p>scheduleTimeoutLocked 会发出消息给 hanlder,收到相应的信息后 handleMessage 方法会调用<code>handleTimeout((ToastRecord)msg.obj);</code>, 该方法又会调用 <code>cancelToastLocked(index);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelToastLocked</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    ToastRecord record = mToastQueue.get(index);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        record.callback.hide();<span class="comment">//</span></div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">    &#125;</div><div class="line">        <span class="comment">//代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到隐藏 Toast 的实现也是在 TN 中的。与 handleShow 对应，有一个 handleHide 方法。<br>该方法会将 Toast 的视图从 Window 中移除。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHide</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</div><div class="line">            mWM.removeViewImmediate(mView);</div><div class="line">        &#125;</div><div class="line">        mView = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建型模式之单例模式]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/07/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、什么是单例模式？"><a href="#一、什么是单例模式？" class="headerlink" title="一、什么是单例模式？"></a>一、什么是单例模式？</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">wiki</a> 给出的定义如下：单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</p>
<ul>
<li>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</li>
</ul>
<a id="more"></a>
<h2 id="二、为什么要使用单例模式？"><a href="#二、为什么要使用单例模式？" class="headerlink" title="二、为什么要使用单例模式？"></a>二、为什么要使用单例模式？</h2><ul>
<li>有一些对象的内存消耗比较大，创建多次会造成很大的资源开支。</li>
<li>方便配置。<ul>
<li>例如 网络请求经常要用到 cookie，如果使用 OkHttp 可以将其封装为一个单例工具类，内部使用 CookJar 对 cookie  进行管理，这样后续的请求就会方便很多。 </li>
</ul>
</li>
</ul>
<h2 id="三、单例模式的实现方式"><a href="#三、单例模式的实现方式" class="headerlink" title="三、单例模式的实现方式"></a>三、单例模式的实现方式</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton sInstance = new Singleton();</div><div class="line">    </div><div class="line">    private Singleton()&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明静态对象时就把它初始化。（因为饿，所以迫不及待先把它 new 出来）</p>
<h3 id="2-懒汉模式-26"><a href="#2-懒汉模式-26" class="headerlink" title="2. 懒汉模式 26"></a>2. 懒汉模式 26</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">    private static Singleton sInstance;</div><div class="line"></div><div class="line">    private Singleton() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static synchronized Singleton getInstance() &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            sInstance = new Singleton();</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>getInstance</code> 方法中添加了 <code>synchronized</code> 关键字，也就是 </p>
<ul>
<li>一个问题：即使 instance已经被初始化，之后的每次调用还是会 进行同步，这样会消耗不必要的资源</li>
</ul>
<p>懒汉单例模式的</p>
<ul>
<li>优点：单例只有在使用时才会被实例化，在一定程度上节约了资源。</li>
<li>缺点：第一次加载时需要及时地实例化，反应稍慢，最大的问题是：每次调用 都会进行同步，造成不必要的同步开销。</li>
</ul>
<h3 id="3-Double-CheckLock-DCL-实现单例"><a href="#3-Double-CheckLock-DCL-实现单例" class="headerlink" title="3. Double CheckLock ( DCL )实现单例"></a>3. Double CheckLock ( DCL )实现单例</h3><p>DCL 既能够在需要时才初始化实例，又能够保证线程安全，而且单例对象初始化后才调用 getInstance 不进行同步锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static Singleton getInstance()&#123;</div><div class="line">    if (sInstance == null)&#123;</div><div class="line">        synchronized (Singleton.class)&#123;</div><div class="line">            if (sInstance == null)&#123;</div><div class="line">                sInstance = new Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="为什么做双重校验呢？"><a href="#为什么做双重校验呢？" class="headerlink" title="为什么做双重校验呢？"></a>为什么做双重校验呢？</h4><p><code>sInstance = new Singleton();</code>这句代码会被编译成多条汇编指令，它大致做了 3 件事情</p>
<ol>
<li>给 Singleton 实例分配内存</li>
<li>调用 Singleton 的构造函数，初始化成员字段</li>
<li>将 sInstance 对象指向分配的内存空间</li>
</ol>
<p>但是由于 Java 编译器允许处理器乱序执行，以及 JDK 1.5 之前 JMM（Java Memory Model， Java 内存模型） 中cache、寄存器到主内存回写顺序的规定，<br>上面的 2 和 3 的顺序是无法保证的。 如果是 1-3-2，那么当 3 执行完，并且 2 还没有执行的话，被切换到到线程 B，这时 sInstance 已经非空（因为 3 已经被执行了嘛），若 此时线程 B 直接取走 sInstance使用时就会报错。</p>
<p>解决：JDK 1.5 之后，SUN 官方调整了 JVM，具体化了 volatile 关键字（禁止指令重排序）。 </p>
<ul>
<li>如果是在 JDK 1.5 之后，那么只需要把 sInstance 的定义 改为 <code>private volatile static Singleton sInstance;</code> 即可</li>
</ul>
<h3 id="4-静态内部类单例模式"><a href="#4-静态内部类单例模式" class="headerlink" title="4. 静态内部类单例模式"></a>4. 静态内部类单例模式</h3><p>DCL 在某些情况下会出现失效的问题。这个问题被称为双重检查锁定（DCL）失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line">    private static volatile Singleton;</div><div class="line">    private Singleton()&#123; &#125;</div><div class="line">    </div><div class="line">    public static Singleton getInstance()&#123;</div><div class="line">        return SingletonHolder.sInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static class SingletonHolder &#123;</div><div class="line">        private static final Singleton sInstance = new Singleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次调用 Singleton 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 SingletonHolder 类，这种方式不仅能够确保线程安全，也能保证单例对象的唯一性。</p>
<p>所以这是推荐使用的单例模式实现方式</p>
<h3 id="5-枚举单例"><a href="#5-枚举单例" class="headerlink" title="5. 枚举单例"></a>5. 枚举单例</h3><p>对枚举不了解可以先看看<a href="https://www.ibm.com/developerworks/cn/java/j-lo-enum/" target="_blank" rel="external">枚举</a>这篇文章</p>
<p>写法简单是枚举单例 最大的优点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public enum Singleton&#123;</div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    //枚举内部可以定义成员；</div><div class="line">    private String mString;</div><div class="line">    //枚举内部可以定义方法；</div><div class="line">    public void doSth() &#123;</div><div class="line">        //do sth</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取对象：只需要 Singleton singleton = <code>Singleton.INSTANCE</code>;</p>
<p>枚举在 Java 中与普通的类是一样的，不仅能够有字段，还能定义自己的方法。<br>最重要的是<strong>默认枚举实例的创建是线程安全的</strong>，并且任何情况下它都是一个单例。</p>
<p>上述几种方式中，在一个情况下都会重新创建对象的情况，那就是<strong>反序列化</strong>。</p>
<p>即使构造函数是私有的，反序列化是依然可以通过特殊的途径去创建类的一个新的实例，相当于 调用该类的构造函数。</p>
<p>反序列化操作提供了一耳光很特别的<strong>钩子函数</strong>，类中具有一个私有的、被实例化的方法 <code>readResolve()</code>,这个方法可以让开发人员控制对象的反序列化。</p>
<p>上述几种单例方法中如果要杜绝单例对象在被反序列化时重新生成对象，那必须加入如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private Object readResolve() throws ObjectStreamException &#123;</div><div class="line">    return sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是在 readResolve 方法中将 sInstance 对象返回，而不是默认的重新生成一个新的对象。</p>
<p>而<strong>对于枚举</strong>，并不存在这个问题，因为<strong>即使反序列化也不会重新生成新的实例</strong>。</p>
<h3 id="6-使用容器实现单例模式"><a href="#6-使用容器实现单例模式" class="headerlink" title="6. 使用容器实现单例模式"></a>6. 使用容器实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; sObjectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!sObjectMap.containsKey(key)) &#123;</div><div class="line">            sObjectMap.put(key, instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sObjectMap.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类型注入到一个统一的管理类中，使用时格根据 key 获取对象对应类型的对象。</p>
<ul>
<li>这种实现方式主要是方便对单例对象进行统一管理。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>不管使用哪一种形式实现单例模式，核心原理都是==将构造函数私有化==，并且==通过静态方法获取唯一的的实例==。</li>
<li>在获取的过程中必须保证线程安全、<strong>防止反序列化导致重新生成实例对象</strong>等问题。</li>
</ul>
<h2 id="使用时的注意点"><a href="#使用时的注意点" class="headerlink" title="使用时的注意点"></a>使用时的注意点</h2><p>避免内存泄漏</p>
<ul>
<li>Android 开发中使用单例模式，如果获取单例对象需要使用 Context，那么尽量使用 ApplicationContext(只要用 <code>contxt.getApplicationContext()</code> 即可获取)。<br>因为如果使用其他 Context（如 Activity)  可能会造成 Activiity 生命周期 执行完成之后，因为其引用被单例所持有，而无法被回收。</li>
</ul>
<h2 id="Android源码中的单例模式"><a href="#Android源码中的单例模式" class="headerlink" title="Android源码中的单例模式"></a>Android源码中的单例模式</h2><p>经常会通过Context后去系统级别的服务，如 WindowManagerService、ActivityManagerService、LayoutInflater，这些服务会在合适的时候以单例的形式注册在系统。</p>
<p>需要时就通过调用  <code>context.getSystemService(String name)</code> 方法获取 </p>
<h1 id="参考资料与学习资源推荐"><a href="#参考资料与学习资源推荐" class="headerlink" title="参考资料与学习资源推荐"></a>参考资料与学习资源推荐</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">wiki 单例模式</a></li>
<li><a href="">Android 源码设计模式 单例模式</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 消息机制解析]]></title>
      <url>https://ivanljt.github.io/blog/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>提起 Handler，相信大家都不会陌生，日常开发中不可避免地要使用到它。今天要讲的是消息机制。消息机制？咋听起来有点抽象。其实我们在使用 Handler 的时候，就使用了 Android 的消息机制。</p>
<p>从开发的角度来看，Handler 是 Android 消息机制的<strong>上层接口</strong>，这使得开发过程中只需要设计这方面的内容即可。但是作为一名合格的开发者，弄清它的实现原理是很有必要的。</p>
<ul>
<li>笔者水平有限，部分内容可能基于学习资源，当然也会有个人的一些见解加入其中。如有疏漏之处，恳请指教。</li>
</ul>
<a id="more"></a>
<h1 id="消息机制概述"><a href="#消息机制概述" class="headerlink" title="消息机制概述"></a>消息机制概述</h1><p>很多人认为 Handler 的作用就是更新 UI, 这种想法也没什么大问题，不过，更新 UI <strong>仅仅是 Handler 的一个特殊的使用场景</strong>。</p>
<p>我们都知道，Android 为了保持与用户交互的流畅性，不允许在主线程执行耗时操作（例如：网络请求），那我们就必须要新开一个线程去执行这些操作。任务执行完了怎么样才能更新 UI 呢？子线程是不允许更新 UI 的，这时就需要将更新的操作切换到主线程中执行。Android 中 Handler 就是这样的一个类。</p>
<p>看看官网的定义：</p>
<blockquote>
<p>A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it – from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.</p>
<p>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.</p>
</blockquote>
<p>大意如下：Handler 允许你在一个线程的消息队列上发送和处理 Message 对象 以及 Runnable 对象。每个 Handler 实例都与一个线程以及这个线程的消息队列相关联。当一个新的 Handler 对象的时候被创建的时候，它会与创建它的那个线程上的消息队列绑定。之后，这个 handler 会把 message 和 runnable 发送到该消息队列上，并且在 message 从消息队列中出列的时处理它们。</p>
<p>Handler 有两个主要用途：</p>
<ol>
<li>指定 message 和 Runnable 在将来的某个时刻执行。</li>
<li>让某一个操作转移到另一个线程执行。</li>
</ol>
<p>看到这么一大串文字这里你可能有点晕了。先看一张图吧。</p>
<p><img src="http://img.blog.csdn.net/20150801014511416" alt=""></p>
<p>Android 消息机制示意图（参考自<a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">网络</a>）</p>
<p>类比：</p>
<ul>
<li>Looper ==》 滚轮</li>
<li>MessageQueue ==》 流水线</li>
<li>Message ==&gt; 流水线上的产品</li>
<li>Handler ==》 扮演把『产品』送进流水线，完了以后又把『产品』取走的角色</li>
<li>Thread ==》 动力</li>
</ul>
<p>另外还有一个重要概念 ——ThreadLocal 图中没有标明出来。</p>
<p>下面对各个部分进行详细介绍。</p>
<h1 id="Android-的消息机制分析"><a href="#Android-的消息机制分析" class="headerlink" title="Android 的消息机制分析"></a>Android 的消息机制分析</h1><h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><p>ThreadLocal  是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>使用场景：</p>
<ol>
<li>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑采用 ThrradLocal。<ul>
<li>在Android中，Looper 类就是利用了 ThreadLocal 的特性，保证每个线程只存在一个 Looper 对象。</li>
</ul>
</li>
<li>复杂逻辑下的对象传递。<ul>
<li>监听器的传递。</li>
</ul>
</li>
</ol>
<p>要想弄清楚 ThreadLocal 首先要明白它的 set() 和 get() 方法</p>
<h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h3><p>ThreadLocal 的 set 方法，大致分为 3 步：</p>
<ul>
<li>首先获取当前线程</li>
<li>利用当前线程作为句柄获取一个ThreadLocalMap的对象</li>
<li>如果上述ThreadLocalMap对象不为空，则设置值，否则创建这个ThreadLocalMap对象并设置值</li>
</ul>
<p>源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><p>当不同线程访问同一个 ThreadLocal 的 get 方法时，ThreadLocal 内部会从各自的线程中取出一个数组，然后在从数组中根据当前 ThreadLocal 的索引去查找对应的 value 值。 不同线程中的数组是不同的。</p>
<p>下面是一个利用Thread对象作为句柄获取 ThreadLocalMap 对象的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码获取的实际上是Thread对象的threadLocals变量，可参考下面代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Thread implements Runnable &#123;</div><div class="line">    /* ThreadLocal values pertaining to this thread. This map is maintained</div><div class="line">     * by the ThreadLocal class. */</div><div class="line"></div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而如果一开始设置，即ThreadLocalMap对象未创建，则新建ThreadLocalMap对象，并设置初始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[==注==]：Android  最新版实现中 ThreadLocal 使用了内部实现的一个 HashMap 以提高优化性能与 Java 中 ThreadLocal 实现有些不同，但是其中的思想并没有太大差异，感兴趣的同学可以看看 Android 中 ThreadLocal 的源码。</p>
<h3 id="ThreadLocal-小结"><a href="#ThreadLocal-小结" class="headerlink" title="ThreadLocal 小结"></a>ThreadLocal 小结</h3><p>从 ThreadLocal 的 set 和 get 方法 可以看出，它们所操作的对象都是<strong>当前线程的 localValues 对象的 table 数组</strong>，因此在不同的线程中访问同一个 ThreadLocal 的 get 和 set 方法，他们对 ThreadLocal 所做的读/写操作仅限于各自线程的内部。</p>
<h2 id="消息队列的工作原理"><a href="#消息队列的工作原理" class="headerlink" title="消息队列的工作原理"></a>消息队列的工作原理</h2><p>MessageQueue 主要包含两个操作：插入和读取（分别对应 enqueueMessage 和 next 方法）。</p>
<ul>
<li>顾名思义，enqueueMessage 的作用是往队列中插入一条信息。</li>
<li>next 的作用是从队列中取出一条信息并将其从消息队列中移除。</li>
</ul>
<p>尽管叫做消息队列，但是它的内部实现并不是用队列，而是通过一个单链表的数据结构来维护消息列表。</p>
<ul>
<li>why？ 学过数据结构的童鞋们都知道，<strong>数组查快改慢，链表查慢改快</strong>，单链表在插入和删除上比较有优势。</li>
</ul>
<p>接下来我们重点看看 enqueueMessage 方法和 next 方法。</p>
<h3 id="enqueueMessage-方法："><a href="#enqueueMessage-方法：" class="headerlink" title="enqueueMessage 方法："></a>enqueueMessage 方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">    if (msg.target == null) &#123;</div><div class="line">        // 要进入队列的消息对象的目标 handler 不能为空</div><div class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">    &#125;</div><div class="line">    if (msg.isInUse()) &#123;</div><div class="line">        // 要进入队的消息不能处在使用状态</div><div class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">        if (mQuitting) &#123;</div><div class="line">            // 要进入队的消息不能发送到一个已经「死亡」的线程上的 Handler</div><div class="line">            IllegalStateException e = new IllegalStateException(</div><div class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        // 标记消息为使用状态；设置消息发送的时间；是否需要唤醒</div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        boolean needWake;</div><div class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">            // New head, wake up the event queue if blocked.</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; else &#123;</div><div class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class="line">            // up the event queue unless there is a barrier at the head of the queue</div><div class="line">            // and the message is the earliest asynchronous message in the queue.</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            for (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                if (p == null || when &lt; p.when) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; // invariant: p == prev.next</div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">        if (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中不难看出，enqueueMessaege 比较简单。它先做了一些状态判断以及一些边界检测，完了以后再进行单链表的插入操作。</p>
<h3 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h3><p><a href="https://gist.github.com/ivanljt/bc298eedb180e6ac67a9613814a4769f" target="_blank" rel="external">next 方法源码</a></p>
<p>部分逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// If first time idle, then get the number of idlers to run.</div><div class="line">// Idle handles only run if the queue is empty or if the first message</div><div class="line">// in the queue (possibly a barrier) is due to be handled in the future.</div><div class="line">if (pendingIdleHandlerCount &lt; 0</div><div class="line">        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</div><div class="line">    pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">&#125;</div><div class="line">if (pendingIdleHandlerCount &lt;= 0) &#123;</div><div class="line">    // No idle handlers to run.  Loop and wait some more.</div><div class="line">    mBlocked = true;</div><div class="line">    continue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由源码可以看出 next 是一个死循环方法</p>
<ul>
<li>如果消息队列中没有消息，那么 next 会一直阻塞在那里。<ul>
<li>当队首的消息设置了延迟执行时，会造成短时间的阻塞。</li>
</ul>
</li>
<li>当有新消息到来时，next 方法会返回这条信息并将其从单链表中移除。</li>
</ul>
<h2 id="Looper-的工作原理"><a href="#Looper-的工作原理" class="headerlink" title="Looper 的工作原理"></a>Looper 的工作原理</h2><p>Looper 可以看作是一个「死循环」。它会不断地从 MessageQueue 中查看是否有新消息</p>
<ul>
<li>如果有，就立刻处理。</li>
<li>如果没有，就一直阻塞在那里。</li>
</ul>
<blockquote>
<p>Looper 是一个用来为单个线程运行消息循环的类。<strong>默认情况下线程是没有一个 Looper 跟他们相关联的</strong>。如果一个线程需要一个 looper 的话，可以通过 调用 prepare() 方法来获取。然后调用 loop 方法让它开始处理信息，一直到循环结束。</p>
<p>我们通常通过 Handler 类与 Looper 的打交道</p>
</blockquote>
<p>Looper的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">    mQueue = new MessageQueue(quitAllowed);//创建一个消息队列</div><div class="line">    mThread = Thread.currentThread(); //把当前线程的对象保存起来</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到构造方法是私有的，那么 Handler 要怎么获取一个 Looper。？<br>通过 <code>Looper.prepare()</code>即可为当前线程创建一个 Looper 对象，接着通过 <code>Looper.loop()</code> 方法开启消息循环。</p>
<p>举个典型的栗子：一个的普通 Thread 如何获得 Looper？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new Thread(&quot;OrdinaryThread&quot;)&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        Looper.prepare();</div><div class="line">        Handler handler = new Handler();</div><div class="line">        Looper.loop();</div><div class="line">    &#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure></p>
<p>除了 <code>Looper.prepare()</code> 还有别的创建方法吗？<br>我们知道主线程（ActivityThread）是比较特殊的，Looper 给它开了小灶，专门为它提供一个 prepareMainLooper() 方法来创建 Looper。</p>
<p>我们更新 UI 的操作都需要在主线程上进行，如果有个方法可以获取主线程的 Looper 就好了。Android 系统很人性化地提供了这么一个方法——<code>Looper.getMainLooper</code>。</p>
<p>只要有了主线程的 Looper，我们就可以利用 Handler 的一个构造方法创建一个依赖于主线程的 Handler，等任务完成之后调用 Handler 的 sendMessage 或者 post 方法来更新 UI 了。</p>
<p>一个应用的小栗子；</p>
<ul>
<li>在封装的一个网络请求类中，保存一个主线程的上 Handler 当请求结果返回时，就可以通过这个 Handler 来对 UI 进行更新。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">public class OkHttpUtil &#123;</div><div class="line"></div><div class="line">    private static final String TAG = &quot;OkHttpUtil&quot;;</div><div class="line">    private volatile static OkHttpUtil sInstance;</div><div class="line">    private OkHttpClient mOkHttpClient;</div><div class="line">    private String mCookie;</div><div class="line">    private Handler mMainHandler;</div><div class="line"></div><div class="line">    public interface OkHttpCallBack &#123;</div><div class="line">        void onSuccess(Bundle data);</div><div class="line">        void onError(Exception e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private OkHttpUtil(Context context) &#123;</div><div class="line">        mMainHandler = new Handler(Looper.getMainLooper());</div><div class="line">        mOkHttpClient = new OkHttpClient.Builder()</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static OkHttpUtil getInstance(Context context) &#123;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (OkHttpUtil.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new OkHttpUtil(context);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void get(String url, final OkHttpCallBack callBack) &#123;</div><div class="line">        final Request request = new Request.Builder()</div><div class="line">                .url(url)</div><div class="line">                .build();</div><div class="line"></div><div class="line">        if (mCookie != null) &#123;</div><div class="line">            request.newBuilder().addHeader(&quot;Cookie&quot;, mCookie);</div><div class="line">        &#125;</div><div class="line">        mOkHttpClient.newCall(request).enqueue(new Callback() &#123;</div><div class="line">            @Override</div><div class="line">            public void onFailure(final Call call, final IOException e) &#123;</div><div class="line">                mMainHandler.post(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        callBack.onError(e);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onResponse(Call call, final Response response) throws IOException &#123;</div><div class="line">                String cookie = response.header(&quot;Set-Cookie&quot;);</div><div class="line">                if (cookie != null) &#123;</div><div class="line">                    setCookie(cookie);</div><div class="line">                &#125;</div><div class="line">                mMainHandler.post(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        Bundle bundle = new Bundle();</div><div class="line">                        bundle.putString(&quot;responseMsg&quot;,&quot;success&quot;);</div><div class="line">                        callBack.onSuccess(bundle);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>刚刚说 Looper 是一个死循环，其实是不严谨的。Looper 也是可以退出的。通过调用 Looper 的 quit 方法或者 quitSafely 方法即可。那么这二者有什么区别？</p>
<ul>
<li>调用 Looper 的 quit 方法可以<strong>直接退出</strong>Looper。</li>
<li>调用 Looper 的 quitSafely 方法只是设定了一个<strong>退出标记</strong>，然后把消息队列中<strong>已有的消息处理完才退出</strong> Looper。</li>
</ul>
<p>从 MessageQueue 的 enqueueMessage 方法可以看到，Looper 退出后，通过 Handler 发送的消息会失败，此时 Handler 的 send 方法会返回 false。</p>
<p><strong>注意！</strong>：在子线程中，如果手动为其创建了 Looper，那么在所有的任务完成之后，需要调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待状态。</p>
<h3 id="loop-方法"><a href="#loop-方法" class="headerlink" title="loop 方法"></a>loop 方法</h3><p><a href="https://gist.github.com/ivanljt/41c14e7c251c9811895b2e292d81cb44" target="_blank" rel="external">loop 方法源码</a></p>
<p>由源码可见 loop 方法是一个死循环，唯一跳出循环的方式是 MessageQueue 的 next 方法返回了 null。</p>
<p>当我们调用 Looper 的 quit 方法时，Looper 会 调用 MessageQueue 的 quit 或 quitSafely 方法来通知消息队列退出，否则 loop 方法会一直循环下去。</p>
<p>另外，代码中可以看到，loop 调用了 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 方法会一直阻塞在那里，这也导致了 loop 方法一直阻塞在那里。</p>
<p><code>msg.target.dispatchMessage(msg);</code>// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 <strong>Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理</strong>了。</p>
<p>绕了这么一个大圈意义何在？<br><strong>Handler 的 dispatchMessage 方法是在创建 Handler 时所使用的 Looper 中执行的，这样就顺利地将代码切换到指定的线程中去执行了</strong>。</p>
<h2 id="Handler-的工作原理"><a href="#Handler-的工作原理" class="headerlink" title="Handler 的工作原理"></a>Handler 的工作原理</h2><p>系统之所以提供 Handler，主要是为了<strong>解决在子线程无法访问 UI 的矛盾</strong>。</p>
<p>那什么系统不允许在子线程访问 UI 呢？因为负责更新 UI 的主线程是线程不安全的（可以简单地理解为没有加同步锁）。</p>
<p>你可能会问那为什么系统不对 UI 控件的访问加上锁机制呢？</p>
<ul>
<li>如果增加了锁机制会有以下的缺点：<ul>
<li>加上锁机制会让 UI 访问的逻辑变得复杂。</li>
<li>锁机制会降低 UI 访问的效率，因为锁机制会阻塞某些线程的执行。</li>
</ul>
</li>
<li>所以，也是一种取舍。整体而言加锁的弊大于利。</li>
</ul>
<p>Handler 的工作主要包含<strong>消息的发送</strong>和<strong>接收</strong>过程。  </p>
<ul>
<li>消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。<ul>
<li>post 系列方法最终是通过 send 的一系列方法来实现的。</li>
</ul>
</li>
</ul>
<p>查看源码不难发现，Handler 的发送消息的过程仅仅是向消息队列插入了一条消息，MessageQueue 的 next 方法就会返回这条消息给 Looper， Looper 收到消息之后就开始处理了，最终由 Looper 交回给 Handler处理（即 handler 的 dispatchMessage 方法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是开头那张图片。把前面的『消息机制概述』重新浏览一遍，说不定有新收获哦。<img src="http://img.blog.csdn.net/20150801014511416" alt=""></p>
<h2 id="学习资源推荐"><a href="#学习资源推荐" class="headerlink" title="学习资源推荐:"></a>学习资源推荐:</h2><ul>
<li><a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/index.html" target="_blank" rel="external">理解 Java 中的 ThreadLocal </a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47115879" target="_blank" rel="external">Android 中 Handler 的使用</a></li>
<li><a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="external">深入源码解析 Android 中的 Handler,Message,MessageQueue,Looper</a></li>
<li>《<a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android 开发艺术探索》 (第十章 Android 的消息机制)</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 原理分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 原理分析 </tag>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
