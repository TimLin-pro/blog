<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RxJava 订阅原理]]></title>
    <url>%2Fblog%2F2018%2F06%2F24%2FRxJava-%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概述RxJava 是什么呢？根据RxJava在GitHub上给出的描述 RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java 大致意思是：一个可以在 JVM上 使用的，是由异步的基于事件编写的通过使用可观察序列构成的一个库。 关键词：异步，基于事件，可观察序列 本文主要讲述 RxJava 的订阅原理。 示例：HelloRxJava一般学一门新的编程语言都是先从打印的「hello word」开始，我们看看如何用 Rxjava 打印出「Hello RxJava」 并以之作为分析的实例。 1234567891011121314151617181920212223242526272829//创建 ObservableObservable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext("Hello RxJava"); emitter.onComplete(); &#125;&#125;);//订阅observable.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; System.out.println("onSubsribe call"); &#125; @Override public void onNext(String s) &#123; System.out.println(s);//打印收到的文字，这里是 Hello RxJava &#125; @Override public void onError(Throwable e) &#123; e.printStackTrace(); &#125; @Override public void onComplete() &#123; System.out.println("onComplete call"); &#125;&#125;); Observerable 是如何创建的？首先 new 了一个 ObservableOnSubscribe 对象，并实现其中的 subscribe 方法。该对象被传递给了 Observable#create 方法以创建 Observable（当然也有其他方法可以创建 Observable ，但是原理大同小异）。 io.reactivex.Observable#create 123456@CheckReturnValue@SchedulerSupport(SchedulerSupport.NONE)public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null");//不可为空 return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; create 方法传递进来的 Observable 又传递给了 Observable 构造方法。 1234final ObservableOnSubscribe&lt;T&gt; source;//保存成员变量public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source;&#125; io.reactivex.plugins.RxJavaPlugins#onAssembly(io.reactivex.Observable) 123456789101112131415/** * Calls the associated hook function. * @param &lt;T&gt; the value type * @param source the hook's input value * @return the value returned by the hook */@SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;)@NonNullpublic static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; io.reactivex.plugins.RxJavaPlugins#onAssembly 方法中只是调用了相关的 hook 函数（如果有的话），然后返回原对象。 创建的结果：ObservableOnSubsribe 外面包装了一层。如下图所示： 订阅过程实例代码中在订阅之前我们先创建了一个 observer 对象。 然后调用 Observable#subscribe 方法，将 observer 作为参数传递给该方法。 点开看看 Observable#subscribe 方法的实现。 12345678910111213141516171819202122@Overridepublic final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null");//非空检查 try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer");//非空检查 subscribeActual(observer);//调用真正的订阅方法。 &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e);// NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 上面 try 块中的第一行代码调用了 RxJavaPlugins#onSubscribe 。点开看看它具体做了啥？ 123456789@SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;)@NonNullpublic static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) &#123; BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe; if (f != null) &#123; return apply(f, source, observer);//调用相应的 hook 函数(如果有的话) &#125; return observer;&#125; 我们订阅的实际对象是 ObserverableCreate，因此点进去看看其中的 subscribeActual 方法实现： ObservableCreate#subscribeActual 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);//以 observer 作为参数构造一个 CreateEmitter observer.onSubscribe(parent);//回调 Observer#onSubsribe 方法 try &#123; source.subscribe(parent);//调用源订阅方法，也就是我们自己实现的在其中发送数据的方法 &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 这里的source#subcribe 也就是： 1234public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext("hello rxJava");//调用 发送数据 emitter.onComplete();&#125; 订阅是从下游传递到上游。传递到源头之后，会触发调用 Emitter#onXxx 方法，将数据从上游发送到下游。 emitter 是如何将数据发射给 observer 的呢？我们先看看 emitter 是什么？ 上面的 emitter 的实际类型是 CreateEmitter 具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable &#123; private static final long serialVersionUID = -3434801548987643227L; final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer; &#125; @Override public void onNext(T t) &#123; if (t == null) &#123;//判空 onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123;//如果当前状态不是 dispose observer.onNext(t);//调用 observer#onNext &#125; &#125; @Override public void onError(Throwable t) &#123; if (!tryOnError(t)) &#123; RxJavaPlugins.onError(t); &#125; &#125; @Override public boolean tryOnError(Throwable t) &#123; if (t == null) &#123; t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources."); &#125; if (!isDisposed()) &#123; try &#123; observer.onError(t); &#125; finally &#123; dispose(); &#125; return true; &#125; return false; &#125; @Override public void onComplete() &#123; if (!isDisposed()) &#123;//不是出于 disposed 状态 try &#123; observer.onComplete();//调用 &#125; finally &#123; dispose();//onComplete 只能调用一次，调用完成之后，状态变为 dispose &#125; &#125; //代码省略&#125; CreateEmitter 是 ObservableCreate的一个内部类，继承自AtomicReference&lt;Disposable&gt;, 实现了两个接口 ObservableEmitter&lt;T&gt; 和 Disposable 。 可以看到 CreateEmitter 对 observer 进行了包装（observer 依赖通过构造函数参数注入）。它在调用 observer 的相应方法的前后对状态进行判断和更新。 CreateEmitter 又是在什么时候创建的呢？在订阅过程中调用到 ObservableCreate#subscribeActual ，该方法会利用 observer 构造一个 CreateEmmiter， 然后把它作为参数去调用 source#subcribe 方法。 source 也就是我们创建的 ObservableOnSubscribe 匿名内部类。CreateEmmiter 就是通过这样的方式作为参数传递给了我们自己实现的 subscribe 方法。 小结订阅是从下游传递到上游。传递到源头之后，会触发调用 Emitter#onXxx 方法，将数据从上游发送到下游。 上游对数据流的控制是通过 CreateEmitter 实现的。 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradle 中 api provided compile implementation 之间的区别]]></title>
    <url>%2Fblog%2F2018%2F06%2F24%2Fgradle-%E4%B8%ADapi-provided-compile-implementation-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[概述api、provided、compile、implementation 都是 gradle 添加依赖时的选项，不同的选项表示不同的依赖关系。 其中 api、implementation 是 Gradle 3.4 引入的新的依赖配置，用来代替 compile 依赖配置。其中 api 和以前的 compile 依赖配置是一样的。使用 api/compile 的依赖方式，会向外界暴露本模块所依赖的库的接口，使用 implementation 则不会。 解决了什么问题？为什么要做这样的修改呢？使用 implementation 依赖配置，可以显著减少构建的时间。 考虑这样的场景，有如下六个模块： D、E、F 三个模块都依赖了 Lib 库。 假设 D、E、F 三个模块都以 implementation 的方式引用 Lib 库，那么上层的 A，B，C 三个模块都无法引用到 Lib 库中的内容。当 Lib 发生变化的时候，只有 D E F 这三个模块需要重新编译，A,B,C 则不需要（因为 DEF 三个模块对外的接口都没有改变）。 假设 D、E、F 三个模块都以 compile/api 的方式引用 Lib 库（对外暴露了自己引用的库的接口），那么无论上层的 A，B，C 三个模块对 D、E、F 模块的依赖是 compile、api 方式还是 implementation 方式，它们（A、B、C）都可以引用到 Lib 库中的内容。这种情况下当 Lib 发生变化的时候，A B C D E F 这三个模块都需要重新编译。 其它变化在该版本中，官方团队也把之前命名的不规范的地方修改了，provided 改成了 compileOnly，apk 改为了 runtimeOnly。改变的只是名称，功能没变。 compileOnly 的使用场景包括但是不限于下面的两种： 编译时所需的依赖性，但在运行时从不需要，例如纯源注释或注释处理器; API 在编译时需要，但其实现由消费库，应用程序或运行时环境提供的依赖项。 runtimeOnly 的使用场景依赖项仅在运行时对模块及其消费者可用。 小结 新配置 已弃用配置 行为 implementation compile 依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。 对于大型多项目构建，使用 implementation 而不是 api/compile 可以显著缩短构建时间，因为它可以减少构建系统需要重新编译的项目量。 大多数应用和测试模块都应使用此配置。 api compile 依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。 此配置的行为类似于 compile（现在已弃用），一般情况下，您应当仅在库模块中使用它。 应用模块应使用 implementation，除非您想要将其 API 公开给单独的测试模块。 compileOnly provided 依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。 此配置的行为类似于 provided（现在已弃用）。 runtimeOnly apk 依赖项仅在运行时对模块及其消费者可用。 此配置的行为类似于 apk（现在已弃用）。 注：compile、provided 和 apk 目前仍然可用。 不过，它们将在下一个主要版本的 Android 插件中消失。 日常开发中一般都是用 implementation，部分情况下会用到 api，其他的依赖方式一般不怎么用到。记住 compile、api 依赖方式是「传递性的」，而 implementation 依赖方式的是「非传递性」的。 参考资料与学习资源推荐 迁移到 Android Plugin for Gradle 3.0.0 Implementation vs API dependency Android Studio3.x 新的依赖方式（implementation、api、compileOnly） 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment Note]]></title>
    <url>%2Fblog%2F2018%2F06%2F02%2FFragment%20Note%2F</url>
    <content type="text"><![CDATA[笔记自用，部分内容待完善。 概述当您将片段作为 Activity 布局的一部分添加时，它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且片段会定义其自己的视图布局。您可以通过在 Activity 的布局文件中声明片段，将其作为 &lt;fragment&gt; 元素插入您的 Activity 布局中，或者通过将其添加到某个现有 ViewGroup，利用应用代码进行插入。不过，片段并非必须成为 Activity 布局的一部分；您还可以将没有自己 UI 的片段用作 Activity 的不可见工作线程。 Fragment 解决了什么问题？不能直接用 View 替代吗？ 相对于 view 而言，它的优势在哪？ Android 3.0（API 级别 11）中引入了片段，主要是为了给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用片段实现此类设计时，您无需管理对视图层次结构的复杂更改。 您应该将每个片段都设计为可重复使用的模块化 Activity 组件。也就是说，由于每个片段都会通过各自的生命周期回调来定义其自己的布局和行为，您可以将一个片段加入多个 Activity，因此，您应该采用可复用式设计，避免直接从某个片段直接操纵另一个片段。 这特别重要，因为模块化片段让您可以通过更改片段的组合方式来适应不同的屏幕尺寸。 在设计可同时支持平板电脑和手机的应用时，您可以在不同的布局配置中重复使用您的片段，以根据可用的屏幕空间优化用户体验。 使用通常至少需要实现以下几个生命周期方法： onCreate（） 在此方法中初始化那些你希望在fragment 处于 paused or stopped, then resumed状态的时候仍然被保留的组件 onCreateView() 这个方法必须返回 这个fragment的布局的根View，也如果此fragment不提供一个UI的话，可以返回空 onPause() 这个方法中你应该提交你的fragment中的那些需要被保存的数据。 参数传递使用 setArgument 的方式，通过这种方式传递参数，如果配置发生更改，通过Fragment.setArguments(Bundle bundle)方法设置的bundle会保留下来。 如果是通过直接赋值的方式，则需要实现 onSaveInstance 和 onRestoreIntanceState 方法（或者 在 onCreate 方法进行配置）才能应对配置更改。 要注意的问题就是 setArgument 方法要在 Fragment 与 Activity 关联之前调用。 可以被继承的Fragment基类 DialogFragment Displays a floating dialog. Using this class to create a dialog is a good alternative to using the dialog helper methods in the Activity class, because you can incorporate(包含) a fragment dialog into the back stack of fragments managed by the activity, allowing the user to return to a dismissed fragment. 相比于 Dialog 的好处： 生命周期便于管理； 比 Dialog 更加地强大。「DialogFragment也允许开发者把Dialog作为内嵌的组件进行重用」 重写 onCreateView 或者 onCreateDialog ListFragment Displays a list of items that are managed by an adapter (such as a SimpleCursorAdapter), similar to ListActivity. It provides several methods for managing a list view, such as the onListItemClick() callback to handle click events. 类似于ListActivity PreferenceFragment Displays a hierarchy of Preference objects as a list, similar to PreferenceActivity. This is useful when creating a “settings” activity for your application. 对于“设置”界面而言很有用 特殊用途调用 setRetainInstance(true);，会在配置发生改变的时候保存当前Fragment 中的所有对象。 1234567891011121314151617181920212223/** * Control whether a fragment instance is retained across Activity * re-creation (such as from a configuration change). This can only * be used with fragments not in the back stack. If set, the fragment * lifecycle will be slightly different when an activity is recreated: * &lt;ul&gt; * &lt;li&gt; &#123;@link #onDestroy()&#125; will not be called (but &#123;@link #onDetach()&#125; still * will be, because the fragment is being detached from its current activity). * &lt;li&gt; &#123;@link #onCreate(Bundle)&#125; will not be called since the fragment * is not being re-created. * &lt;li&gt; &#123;@link #onAttach(Activity)&#125; and &#123;@link #onActivityCreated(Bundle)&#125; &lt;b&gt;will&lt;/b&gt; * still be called. * &lt;/ul&gt; */该方法控制 Fragment 的实例是否在Activity重新创建的时候保留。它只能用于那些不处在回退栈中的Fragment 身上。注意，如果保留实例的话，Fragment 的生命周期将会有一些不同- onDestory 方法不会被调用，但是 onDetach 方法仍然会被调用，因为 Fragment 从当前 Activity 中剥离了。- onCreate 方法也不会被调用，因为 Fragment 并没有重新创建- onAttach 和 onActivityCreated 方法依然会被调用。public void setRetainInstance(boolean retain) &#123; mRetainInstance = retain;&#125; 用于保存数据。 创建/渲染用户界面为了提供一个布局给fragment，你必须实现onCreateView()方法,这个方法会在到这个Fragment 绘出它的布局的时候 被安卓系统调用。此外，这个方法中必须 return a View that is the root of your fragment’s layout Note: If your fragment is a subclass of ListFragment, the default implementation returns a ListView from onCreateView(), so you don’t need to implement it. inflate() 方法带有三个参数： 您想要inflate的布局的资源 ID； 将作为inflate布局父项的 ViewGroup。传递 container 对系统向inflate布局的根视图（由其所属的父视图指定）应用布局参数具有重要意义； 指示是否应该在inflate期间将inflate布局附加至 ViewGroup（第二个参数）的布尔值。（在本例中，其值为 false，因为系统已经将inflate布局插入 container — 传递 true 值会在最终布局中创建一个多余的视图组。） 系统会帮我们 addView，所以 attachToRoot 为 false； android.support.v4.app.FragmentManagerImpl#moveToState(android.support.v4.app.Fragment, int, int, int, boolean) 123if(container != null) &#123; container.addView(f.mView);&#125; 推荐用下边这种方式： 1inflater.inflate(R.layout.item, parent, false); 测量的时候依赖 parent，但是添加需要手动进行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate"); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. int type; final String name = parser.getName(); if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println("Creating params from root: " + root); &#125; // Create layout params that match root, if supplied //创建 根布局的 layout params params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println("-----&gt; start inflating children"); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println("-----&gt; done inflating children"); &#125; //根布局存在 并且 待渲染的布局需要关联到 root，那就调用 addView 方法将它添加进去 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; //确定返回值是 root 还是 xml 文件中的根布局 //root 为 null 或者 不关联到根布局，返回的就是 xml 文件中的根布局 if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; //…… &#125; return result; &#125;&#125; 将 Fragment 添加到 Activity 的两种方式1.在 Activity 的布局文件内声明片段 当系统创建此 Activity 布局时，会实例化在布局中指定的每个片段，并为每个片段调用 onCreateView() 方法，以检索每个片段的布局。系统会直接插入片段返回的 View 来替代 &lt;fragment&gt; 元素。 &lt;fragment&gt; 元素中可以通过 class = “ ” 也可以通过 android:name=&quot;&quot; 来指定 要加入的Fragment。 class 的性能会高一点点。 因为：android.support.v4.app.FragmentManagerImpl#onCreateView(android.view.View, java.lang.String, android.content.Context, android.util.AttributeSet) 123456789101112public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; if (!"fragment".equals(name)) &#123; return null; &#125; //通过 class 获取 Fragment 名字 String fname = attrs.getAttributeValue(null, "class"); TypedArray a = context.obtainStyledAttributes(attrs, FragmentTag.Fragment); if (fname == null) &#123;//用 class 找不到，通过 android:name 去查找 fname = a.getString(FragmentTag.Fragment_name); &#125; //……&#125; 注：每个片段都需要一个唯一的标识符，重启 Activity 时，系统可以使用该标识符来恢复片段（您也可以使用该标识符来捕获片段以执行某些事务，如将其移除）。 可以通过三种方式为片段提供 ID： 为 android:id 属性提供唯一 ID。 为 android:tag 属性提供唯一字符串。 如果您未给以上两个属性提供值，系统会使用容器视图的 ID。 2.通过java 代码将片段添加到某个现有 ViewGroup您可以在 Activity 运行期间随时将片段添加到 Activity 布局中。您只需指定要将片段放入哪个 ViewGroup。 您必须使用 FragmentTransaction 中的 API,才能在 Activity 中执行片段事务（如添加、移除或替换片段）。您可以像下面这样从 Activity 获取一个 FragmentTransaction 实例： 12FragmentManager fragmentManager = getFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 然后，您可以使用 add() 方法添加一个片段，指定要添加的片段以及将其插入哪个视图。例如： 123ExampleFragment fragment = new ExampleFragment();fragmentTransaction.add(R.id.fragment_container, fragment);//将要添加的片段fragmentTransaction.commit(); 传递到 add() 的第一个参数是 ViewGroup，即应该放置片段的位置，由资源 ID 指定，第二个参数是要添加的片段。 一旦您通过 FragmentTransaction 做出了更改，就必须调用 commit() 以使更改生效。 添加没有 UI 的片段可以使用片段为 Activity 提供后台行为，而不显示额外 UI。 要想添加没有 UI 的片段，请使用 add(Fragment, String) 从 Activity 添加片段（为片段提供一个唯一的字符串“标记”，而不是视图 ID）。 这会添加片段，但由于它并不与 Activity 布局中的视图关联，因此不会收到对onCreateView() 的调用。因此，您不需要实现 onCreateView()方法。 如果片段没有 UI，则字符串标记将是标识它的唯一方式。 管理片段要想管理您的 Activity 中的片段，您需要使用 FragmentManager。要想获取它，请从您的 Activity 调用 getFragmentManager()。 您可以使用 FragmentManager 执行的操作包括： 通过 findFragmentById()（对于在 Activity 布局中提供 UI 的片段）或 findFragmentByTag()（对于提供或不提供 UI 的片段）获取 Activity 中存在的片段。 通过 popBackStack()（模拟用户发出的返回命令）将片段从返回栈中弹出。 通过 addOnBackStackChangedListener() 注册一个监听返回栈变化的侦听器。 如需了解有关这些方法以及其他方法的详细信息，请参阅 FragmentManager 类文档。 如上文所示，您也可以使用 FragmentManager 打开一个 FragmentTransaction，通过它来执行某些事务，如添加和移除片段。 执行片段事务在 Activity 中使用片段的一大优点是，可以根据用户行为通过它们执行添加、移除、替换以及其他操作。 您提交给 Activity 的每组更改都称为事务，您可以使用 FragmentTransaction 中的 API 来执行一项事务。您也可以将每个事务保存到由 Activity 管理的返回栈内，从而让用户能够回退片段更改（类似于回退 Activity）。 可以从 FragmentManager 获取一个 FragmentTransaction 实例。 每个事务（从FragmentTransaction# begin 到 commit 之间的一组「添加，删除，隐藏，显示」操作）都是您想要同时执行的一组更改。您可以使用 add()、remove() 和 replace() 等方法为给定事务设置您想要执行的所有更改。然后，要想将事务应用到 Activity，您必须调用 commit()。 不过，在您调用 commit() 之前，您可能想调用 addToBackStack()，以将事务添加到片段事务返回栈。 该返回栈由 Activity 管理，允许用户通过按返回按钮返回上一片段状态。 例如，以下示例说明了如何将一个片段替换成另一个片段，以及如何在返回栈中保留先前状态： 1234567891011// Create new fragment and transactionFragment newFragment = new ExampleFragment();FragmentTransaction transaction = getFragmentManager().beginTransaction();// Replace whatever is in the fragment_container view with this fragment,// and add the transaction to the back stacktransaction.replace(R.id.fragment_container, newFragment);transaction.addToBackStack(null);// Commit the transactiontransaction.commit(); 在上例中，newFragment 会替换目前在 R.id.fragment_container ID 所标识的布局容器中的任何片段（如有）。通过调用 addToBackStack() 可将替换事务保存到返回栈，以便用户能够通过按返回按钮撤消事务并回退到上一片段。 替换事务 指的是什么？ 如果您向事务添加了多个更改（如又一个 add() 或 remove()），并且调用了 addToBackStack()，则在调用 commit() 前应用的所有更改都将作为单一事务添加到返回栈，并且返回按钮会将它们一并撤消。 向 FragmentTransaction 添加更改的顺序无关紧要，不过： 您必须最后调用 commit() 如果您要向同一容器添加多个片段，则您添加片段的顺序将决定它们在视图层次结构中的出现顺序 如果您没有在执行移除片段的事务时调用 addToBackStack()，则事务提交时该片段会被销毁，用户将无法回退到该片段。 不过，如果您在删除片段时调用了 addToBackStack()，则系统会停止该片段，并在用户回退时将其恢复。 提示：对于每个片段事务，您都可以通过在提交前调用 setTransition() 来应用过渡动画。 调用 commit() 不会立即执行事务，而是在 Activity 的 UI 线程（“主”线程）可以执行该操作时再安排其在线程上运行。不过，如有必要，您也可以从 UI 线程调用 executePendingTransactions() 以立即执行 commit() 提交的事务。通常不必这样做，除非其他线程中的作业依赖该事务。 注意：您只能在 Activity 保存其状态（用户离开 Activity）之前使用 commit() 提交事务。如果您试图在该时间点后提交，则会引发异常。 这是因为如需恢复 Activity，则提交后的状态可能会丢失。 对于丢失提交无关紧要的情况，请使用 commitAllowingStateLoss()。 回退栈FragmentTransaction 是在一个链表中存储了一次事务中的所有需要执行的操作。 123456789/** * Add this transaction to the back stack. This means that the transaction * will be remembered after it is committed, and will reverse its operation * when later popped off the stack. * * @param name An optional name for this back stack state, or null. *///添加「事务」注意不是某一个 Fragment到回退栈中。这意味着这个事务会在提交后被「记住」public abstract FragmentTransaction addToBackStack(@Nullable String name); BackStackRecod 本身还是实现了 Runnabled 接口，是一个可以执行的对象。添加完毕之后，会调用 FragmentHostCallback 中提供的 getHandler 方法，获取到 Handler 方法，然后向主线程的 MessageQueue 中发送一个 mExecCommit 可执行对象 处理片段生命周期 Activity 生命周期与片段生命周期之间的最显著差异在于它们在其各自返回栈中的存储方式。 默认情况下，Activity 停止时会被放入由系统管理的 Activity 返回栈（以便用户通过返回按钮回退到 Activity，任务和返回栈对此做了阐述）。不过，仅当在移除片段的事务执行期间通过调用 addToBackStack() 显式请求保存实例时，系统才会将片段放入由宿主 Activity 管理的返回栈。 在其他方面，管理片段生命周期与管理 Activity 生命周期非常相似。 因此，管理 Activity 生命周期的做法同样适用于片段。 注意：如果需要 Context 的话，可以调用 getActivity()。但要注意，请仅在片段附加到 Activity 时调用 getActivity()。如果片段尚未附加，或在其生命周期结束期间分离，则 getActivity() 将返回 null。 不过，片段还有几个额外的生命周期回调，用于处理与 Activity 的唯一交互，以执行构建和销毁片段 UI 等操作。 这些额外的回调方法是： onAttach() 在片段已与 Activity 关联时调用（Activity 传递到此方法内）。 onCreateView() 调用它可创建与片段关联的视图层次结构。 onActivityCreated() 在 Activity 的 onCreate() 方法已返回时调用。 onDestroyView() 在移除与片段关联的视图层次结构时调用。 onDetach() 在取消片段与 Activity 的关联时调用。 一旦 Activity 达到 resume 状态，您就可以随意向 Activity 添加片段和移除其中的片段。 因此，只有当 Activity 处于 resume 状态时，片段的生命周期才能独立变化。 Activity 处于resume 状态下时，创建一个 Fragment ，这个Fragment 前面的生命周期会快速走完，直到 resume 不过，当 Activity 离开 resume 状态时，片段会在 Activity 的推动下再次经历其生命周期。 与 Activity 对比构造方法普通开发者无权使用 Activity 的构造方法，所以，不能通过构造方法从外部注入依赖。 Fragment 的构造方法可以传参进来 Activity 一般是通过 intent。Fragment 会用 setArgument 传一个 Bundle 进来。 设置布局&amp;初始化控件的时机不同Activity#onCreate Fragment#onCreateView 原理 注: FragmentManagerImpl 定义在 FragmentManager的类文件里面，直接搜只能看到 .class,找不到 .java 文件 起始：查找某一个类只看到 .class文件的时候，可以先看看 .class ，它继承/实现了哪些类，然后到父类那里去找，一般都可以找到 我们常看到说 Fragment 的生命周期会与宿主Activity 保持一致，里面究竟是如何实现的呢？ Fragment 的生命周期会在 FragmentActivity 里面的生命周期进行回调 生命周期因为 Fragment 依附于 Activity（生命周期状态由 Activity 控制），所以Fragment 的生命周期方法是在 Activity 的生命周期方法之后才调用的。 android.app.FragmentManagerImpl#onCreateView() 123456789101112131415public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; //…… // If we haven't finished entering the CREATED state ourselves yet, // push the inflated child fragment along. This will ensureInflatedFragmentView // at the right phase of the lifecycle so that we will have mView populated // for compliant fragments below. if (mCurState &lt; Fragment.CREATED &amp;&amp; fragment.mFromLayout) &#123; moveToState(fragment, Fragment.CREATED, 0, 0, false); &#125; else &#123; moveToState(fragment); &#125; //……&#125; 提交事务add hide show replace当然我们注意到 hide 和 show，它们内部实际上不会调用 moveToState, 因为 hideFragment 实际上就做了三件事请， 设置 mHidden 为 true fragment.mView.setVisibility(View.GONE); 隐藏 fragment 的 view fragment.onHiddenChanged(true); 调用 onHiddenChange showFragment 也是类似，只不过行为正好相反。 addFragmentaddFragment 会将 fragment 添加到 mAdded 和 mActive 这两个集合当中，这两个集合维护了当前 activity 中维护的已经添加的 fragment 列表和当前处于活跃状态的 fragment 列表，如果 fragment 位于 mActive 中，那么当 activity 的状态发生变化时，fragment 也会跟随着发生变化。FragmentManger 如何引导 fragment 的状态发生变化呢？ Fragment 状态变迁：moveToStateFragment 状态变迁发生在用户主动发起 transaction，或者 fragment 被 add 到 activity 之后跟随 activity 的生命周期变化一起发生改变。每次状态变迁最终都会走到函数 moveToState，字面意思是将 fragment 迁移到新的状态 fragment 的 state 取值，为前面提到的七种状态，其中最低值是 INITIALIZING 状态，代表 fragment 刚创建，还未被 add， 最高状态值是 RESUMED, 代表 fragment 处于前台。 所以 moveToState 内部分两条线，状态跃升，和状态降低，里面各有一个 switch 判断，注意到 switch 里每个 case 都没有 break，这意味着，状态可以持续变迁，比如从 INITIALIZING，一直跃升到 RESUMED，将每个 case 都走一遍，每次 case 语句内，都会改变 state 的值。 1mManager.moveToState(mManager.mCurState, transition, transitionStyle, true); 就是将 fragment 迁移到 FragmentManager 当前的状态，因为我们不知道用户什么时候 add fragment，因此 fragment 被 add 之后，就将其状态迁移到 FragmentManager 当前的状态，然后跟随 FragmentManager 一起发生状态变迁，除非用户手动 removeFragment 将其从 mActive 列表中移除。 1234getSupportFragmentManager() .beginTransaction() .add(,) .commit(); 12345678910111213141516171819202122FragmentManagerImpl#beginTransaction //创建一个 BackStackRecord; --&gt; BackStackRecord#add(Fragment, String) --&gt; BackStackRecord#doAddOp --&gt; //进行访问控制检查，如果 Fragment 是一个成员类，那么它必须是 public static 的，这样才能正确地从实例状态中重新创建出来 给 mFragmentManager、 mTag 、mContainerId 赋值 创建 Op 对象并添加到 Ops （一个 ArrayList） 中 --&gt; BackStackRecord#commit --&gt; BackStackRecord#commitInternal if mAddToBackStack //添加到回退栈中 mIndex = mManager.allocBackStackIndex(this);//分配回退栈下标 --&gt; 主要对下面两个列表进行操作 ArrayList&lt;BackStackRecord&gt; mBackStackIndices; ArrayList&lt;Integer&gt; mAvailBackStackIndices; else mIndex = -1; --&gt; FragmentManagerImpl#enqueueAction//在等待操作的队列中添加一个操作。 --&gt; mPendingActions.add(action);//添加到「队列中」 （实际上是一个 ArrayList） --&gt; scheduleCommit();//安排 commit --&gt; 内部通过 Handler 来实现 执行的是 mExecCommit （一个 Runnable） --&gt; FragmentManagerImpl#execPendingActions FragmentManagerImpl#execPendingActions //只能从主线程调用 12345678910111213141516171819public boolean execPendingActions() &#123; ensureExecReady(true); boolean didSomething = false; while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123; mExecutingActions = true; try &#123; optimizeAndExecuteOps(mTmpRecords, mTmpIsPop); &#125; finally &#123; cleanupExec(); &#125; didSomething = true; &#125; doPendingDeferredStart(); burpActive(); return didSomething;&#125; 参考资料与学习资源推荐 https://www.jianshu.com/p/180d2cc0feb5 Fragment | Android Developers 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http 头部字段]]></title>
    <url>%2Fblog%2F2018%2F03%2F02%2FHttp-%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[HTTP 报文格式 HTTP 请求报文在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。 HTTP 响应报文在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。 HTTP 首部字段首部和方法配合工作，共同决定了客户端和服务器能做什么事情。 在请求和响应报文中都可以用首部来提供信息，有些首部是某种报文专用的，有些首部则更通用一些。可以将首部分为五个主要的类型。 通用首部字段通用首部字段是指，请求报文和响应报文双方都会使用的首部。 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 Cache-Control通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。 Cache-Control: private, max-age=0, no-cache 指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。 缓存请求指令 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age = [ 秒] 必需 响应的最大Age值 max-stale( = [ 秒]) 可省略 接收已过期的响应 min-fresh = [ 秒] 必需 期望在指定时间内的响应仍有效 no-transform 无 代理不可更改媒体类型 only-if-cached 无 从缓存获取资源 cache-extension - 新指令标记（token） 换言之，无参数值的首部字段可以使用缓存。 从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation更合适。no-store才是真正地不进行缓存， max-age使用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉 only-if-cached 指令Cache-Control: only-if-cached使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。 123This field&apos;s name &quot;only-if-cached&quot; is misleading. It actually means &quot;do not use the network&quot;. It is set by a client who only wants to make a request if it can be fully satisfied by the cache. Cached responses that would require validation (ie. conditional gets) are not permitted if this header is set.该字段名有误导性。实际意义是「不要使用网络」。它由一个只有在缓存能够完全满足需求的情况下才想发出请求的客户端。如果设置了该 header，则不允许使用需要验证的缓存响应（ 比如。条件 get 请求）。 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 vary 首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。 从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。 实体首部字段实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。 有很多首部可以用来描述 HTTP 报文的负荷。 实体首部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体首部可以告知报文的接收者它在对什么进行处理。下表中 列出了实体的信息性首部。 首部字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替代对应资源的URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 扩展首部扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的 HTTP 规范中去。即使不知道这些扩展首部的含义，HTTP 程序也要接受它们并对其进行转发。 参考资料 《图解 HTTP》 《HTTP 权威指南》 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆轮子系列——LeakCanary工作原理]]></title>
    <url>%2Fblog%2F2017%2F12%2F15%2F%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94LeakCanary%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概述LeakCanary 是一个内存泄漏的自动化监测工具。 什么是内存泄漏？内存泄漏指的是应该被释放的内存的没有被释放。原因？长生命周期的对象持有短生命周期对象的引用。 哪些对象应该被回收？首先要找出哪些对象是应该被回收的？Android 中使用最频繁的是 Activity 和 Fragment 了。他们都有 onDestory 方法，当它们的 onDestroy 执行的时候，就可以把它们列为 「应该被回收的对象」，可在 onDestory 方法中建立检测点。 注： Application#dispatchActivityDestroyed 是在 Activity#onDestroy 方法执行后回调的。 如何知道对象是否被回收了？手动 GC +ReferenceQueue + WeakReference WeakReference 创建时，传入一个 ReferenceQueue 对象。当被 WeakReference 引用的对象的生命周期结束，一旦被 GC 检查到，GC 将会把该对象添加到 ReferenceQueue 中，待 ReferenceQueue 处理。当 GC 过后对象一直不被加入 ReferenceQueue，说明它可能存在内存泄漏。 这里其实有一个默认的前提就是，当一个对象存在强引用的时候，这个对象是不会被回收的，所以 GC 前后，可达性并不会发生变化，也就不会被加入到 referenceQueue 中。而如果一个对象只含有弱引用的时候，GC 前后可达性会发生改变？是的。GC 之前弱可达，GC 之后变为弱可达。 什么样的对象会进入引用队列？ 一个对象只含有弱引用的时候，并且发生了 GC。 假设没有发生内存泄漏，那么这个时候，Activity 仅被我们创建的 KeyedWeakReference 弱引用了。我们第一次手动 GC 的时候，它就会进入引用队列。这个时候可以将它从 retainkeys 中移除。 对象一旦只存在弱引用，马上就会被加入 ReferenceQueue 中，这发生在 finalization 或者 gc 之前 LeakCanary 判断是否发生内存的泄漏的标准：对象的引用是否在Set&lt;String&gt; retainedKeys 中。 创建一个跟踪对象，将它的 key 存储在一个 retainedKeys 中。当对象出现在引用队列里面的时候，将它从 set 中移除，如果一个对象的引用不在retainKeys 中，说明没有发生内存泄漏。如果在，则说明没有发生内存泄漏。 未被回收==内存泄漏？没被回收的原因：被持有强引用了吗？未被回收的对象，是否被其他对象引用？找出其最短引用链。VMDebug + HAHA 完成需求。 VMDebug、HAHA。 VM 会有堆内各个对象的引用情况，并能以hprof文件导出。HAHA 是一个由 square 开源的 Android 堆分析库，分析 hprof 文件生成Snapshot对象。Snapshot用以查询对象的最短引用链。 找到最短引用链后，定位问题，排查代码将会事半功倍。 下面是一个总体流程图：（流程图参考自这篇文章） 如果读者还没看过 LeakCanary 的源码，建议照着上面的调用流程图过一遍，这样效果会好很多。why？为什么源码分析味同嚼蜡？浅析技术写作中的思维误区 具体流程前面讲了大体流程，接下来我们看看内部的实现。 通常会在 Applcation#onCreate 中对 LeakCanary 进行初始化,也就是调用下面的 setupLeakCanary 方法。 123456protected RefWatcher setupLeakCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return RefWatcher.DISABLED; &#125; return LeakCanary.install(this);&#125; LeakCanary#install 调用流程12345678910111213141516--&gt; LeakCanary#install --&gt; refWatcher --&gt; AndroidRefWatcherBuilder#listenerServiceClass //监听服务类 --&gt; AndroidExcludedRefs#createAppDefaults//创建默认的忽略列表 --&gt; ExcludedRefs.Builder#build --&gt; RefWatcherBuilder#excludedRefs//排除一些引用 --&gt; AndroidRefWatcherBuilder#buildAndInstall//构造一个 RefWatcher --&gt; RefWatcherBuilder#build --&gt; ActivityRefWatcher#install --&gt; new ActivityRefWatcher --&gt; ActivityRefWatcher#watchActivities --&gt; stopWatchingActivities();//防止装载两次， --&gt; Application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);//解注册 --&gt; Application#registerActivityLifecycleCallbacks(lifecycleCallbacks);//注册生命周期回调 --&gt; mActivityLifecycleCallbacks.add(callback);//添加到监听者列表中 注：监听回调进行仅仅实现了 123@Override public void onActivityDestroyed(Activity activity) &#123; ActivityRefWatcher.this.onActivityDestroyed(activity);&#125; 从上面可以看出在默认情况下只监听 Activity 的 onDestory 方法，也就是说只是检测 Activity 是否存在内存泄漏。 如果要检测 Fragment 的内存泄漏，应该如何实现？因为 Android 中只提供了 Activity 的生命周期方法的回调，而没有提供 Fragment 生命周期回调的监听。 如果要对 Fragment 的内存泄漏进行检测，那么需要自己在 Fragment#onDestroy 方法中手动创建一个 RefWatcher ，然后调用 refWatcher#watch(this)，最好是定义一个 Fragment 基类，在其中的 onDestroy 方法中定义相应的操作。 12345678public abstract class BaseFragment extends Fragment &#123; @Override public void onDestroy() &#123; super.onDestroy(); RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity()); refWatcher.watch(this); &#125;&#125; 当监听事件发生时，切换到后台执行123456789101112131415161718192021--&gt; ActivityLifecycleCallbacks#onActivityDestroyed --&gt; ActivityRefWatcher#onActivityDestroyed --&gt; RefWatcher#watch(Object) --&gt; RefWatcher#watch(Object, String) 内部有一个 ReferenceQueue&lt;Object&gt; queue; --&gt; new KeyedWeakReference(watchedReference, key, referenceName, queue)//创建 KeyedWeakReference //两个 Handler,mainHandler 、backgroundHandler --&gt; RefWatcher#ensureGoneAsync --&gt; WatchExecutor#execute if 当前线程为主线程 ==&gt; AndroidWatchExecutor#waitForIdle// 等待 MainLooper 空闲时发送 --&gt; MessageQueue#addIdleHandler//当 Looper 即将闲置时发送 --&gt; AndroidWatchExecutor#postToBackgroundWithDelay --&gt; backgroundHandler#postDelayed//工作线程 Handler 延迟发送 --&gt; Retryable --&gt; if (result == RETRY) postWaitForIdle(retryable, failedAttempts + 1); else 当前线程是工作线程，需要先切换到主线程，再从主线程切换到 HandlerThread 线程 --&gt; AndroidWatchExecutor#postWaitForIdle --&gt; mainHandler#post//通过主线程 Handler 切换到主线程执行 ==&gt; AndroidWatchExecutor#waitForIdle//等待空闲时发送 可以看到 Retryable#run 在工作线程执行。AndroidWatchExecutor 内创建了一个 HandlerThread ，通过它创建了一个 Handler。如果当前线程是主线程，直接调用主线程的 Message#addIdleHandler 进行处理，给工作线程发送延时任务。否则，需要先调用 mainHandler#post 方法， 切换到主线程，然后再调用 AndroidWatchExecutor#waitForIdle。之所以要切换到主线程，主要是为了使用主线程的 MessageQueue#addIdleHandler 123HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);handlerThread.start();backgroundHandler = new Handler(handlerThread.getLooper()); 前面所谈都是执行线程的切换，下面开始内存分析任务具体是如何进行的。 内存泄漏分析工作机制 在后台线程检查引用是否被清除，如果没有，调用 GC。 如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。 在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。 得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄漏。 HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。 引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。 RefWatcher#ensureGone在前面的线程切换到目标工作线程之后就调用该方法。 12345678910111213141516RefWatcher#ensureGone --&gt; ① RefWatcher#removeWeaklyReachableReferences//移除所有「弱可达引用」 if (debuggerControl.isDebuggerAttached()) --&gt; return RETRY;//调试模式控制 if (gone(reference)) //判断类名是否不在 Set&lt;String&gt; retainedKeys 中，若不在，说明内存分析完毕 return DONE; --&gt; gcTrigger.runGc();//触发 gc，调用的是 Runtime.getRuntime().gc(); --&gt; ② RefWatcher#removeWeaklyReachableReferences//再次移除所有「弱可达引用」 if !gone(reference)//如果该引用对应的键仍然在 retainKeys 中，说明可能存在内存泄漏，进行 dump 然后分析 --&gt; File heapDumpFile = heapDumper.dumpHeap();// dump 堆内存，会触发 stop the world if heapDumpFile == RETRY_LATER //现在无法触发 gc ，先返回。稍候重试 --&gt; return RETRY; --&gt; new HeapDump --&gt; ServiceHeapDumpListener#analyze --&gt; HeapAnalyzerService#runAnalysis --&gt; startService //开启 HeapAnalyzerService 服务，需要 HeapDump 以及接收分析结果的回调类的类名 RefWatcher#removeWeaklyReachableReferences移除在 retainedKeys 中的所有弱可达的对象对应的 key。 123456789private final Set&lt;String&gt; retainedKeys;ReferenceQueue&lt;Object&gt; queue;private void removeWeaklyReachableReferences() &#123; // 对象一旦只存在弱引用，马上就会被加入 ReferenceQueue 中，这发生在 finalization 或者 gc 之前 KeyedWeakReference ref; while ((ref = (KeyedWeakReference) queue.poll()) != null) &#123; retainedKeys.remove(ref.key);//移除弱引用对应的 key &#125;&#125; KeyedWeakReference上面使用到了一个 KeyedWeakReference 类型的对象，KeyedWeakReference 意为「带键的弱引用」。具体实现如下： 1234567891011final class KeyedWeakReference extends WeakReference&lt;Object&gt; &#123; public final String key; public final String name; KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) &#123; super(checkNotNull(referent, "referent"), checkNotNull(referenceQueue, "referenceQueue")); this.key = checkNotNull(key, "key"); this.name = checkNotNull(name, "name"); &#125;&#125; 唯一创建了 KeyedReference 的地方： RefWatcher#watch(Object, String) 1234567891011121314public void watch(Object watchedReference, String referenceName) &#123; if (this == DISABLED) &#123; return; &#125; checkNotNull(watchedReference, "watchedReference"); checkNotNull(referenceName, "referenceName"); final long watchStartNanoTime = System.nanoTime(); String key = UUID.randomUUID().toString();//创建一个独一无二 key retainedKeys.add(key);//添加到 retainedKeys 中 final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue);//创建一个 「带键的弱引用」 ensureGoneAsync(watchStartNanoTime, reference);&#125; retainedKeysretainedKeys 类型为一个 Set&lt;String&gt;，主要用于判断对象是否被回收。 retainedKeys 的添加与删除 添加：一个带键的弱引用（KeyedWeakReference）被创建的时候，其中的键会被加入 retainedKeys 中。 删除：通过 RefWatcher#removeWeaklyReachableReferences 方法 可以删除 retainedKeys 中那些仅含有弱引用的 KeyedWeakReference 对应的 key。 如果不在 retainedKeys 中说明该对象已经被回收了。 HeapAnalyzerServiceHeapAnalyzerService 是一个 IntentService，它会在 onHandleIntent 方法中对堆进行分析。 HeapAnalyzerService#onHandleIntent 12345678910111213@Override protected void onHandleIntent(Intent intent) &#123; if (intent == null) &#123;// intent 为空直接返回 CanaryLog.d("HeapAnalyzerService received a null intent, ignoring."); return; &#125; String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);//获取回调类的类名 HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);//获取 HeapDump HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);//创建 HeapAnalyzer AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);//检查泄漏（通过 HAHA 来完成），并获取结果 AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);//将分析结果发送给监听器&#125; 可以看到，onHandleIntent 方法中，会从 Intent 中获取 HeapDump 以及 listenerClassName（监听器类名），然后将相应的数据交给 HAHA 库中的 HeapAnalyzer 进行分析，最后将结果发回给监听器 注：在创建对分析器的时候 会使用到 heapDump.excludedRefs，excludedRefs 实际类型为 AndroidExcludedRefs ，它是一个枚举类，其中设置了一些由于特定制造商的实现引起内存泄漏的类。如果内存泄漏是由该枚举类含有的类锁引起，那么内存泄漏问题会被忽略。 对于大部分应用开发者而言都应该使用 createAppDefaults 方法，不过也可以自己创建一个 EnumSet ，在其中指定自己要忽略的内存泄漏类，并通过 AndroidExcludedRefs#createBuilder(EnumSet)方法进行设置。 HeapAnalyzer#checkForLeak 检测内存泄漏限于篇幅，仅对 HAHA 进行简单介绍 HAHA 是一个 Java 库，可以自动完成对 Android 堆转储文件的分析。 这个项目实际上是对其他人的工作的重新打包，以使其成为一个小型的 Maven 依赖项。 HAHA 可达性分析算法 1234567891011121314151617181920212223242526public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) &#123; long analysisStartNanoTime = System.nanoTime(); if (!heapDumpFile.exists()) &#123; Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile); return failure(exception, since(analysisStartNanoTime)); &#125; try &#123; HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);//通过堆转储文件构造一个 MemoryMappedFileBuffer HprofParser parser = new HprofParser(buffer);//创建一个 Hprof 文件解析器 Snapshot snapshot = parser.parse();//解析，将结果赋给 Snapshot deduplicateGcRoots(snapshot);//删除重复的 GC Root Instance leakingRef = findLeakingReference(referenceKey, snapshot);//利用 referenceKey 和 snapshot 寻找发生泄漏的引用 // False alarm, weak reference was cleared in between key check and heap dump. if (leakingRef == null) &#123; return noLeak(since(analysisStartNanoTime));//没有发生内存泄漏 &#125; return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);//发现内存泄漏 &#125; catch (Throwable e) &#123; return failure(e, since(analysisStartNanoTime));// &#125;&#125; 得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄漏。 HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。 总结内存泄漏的本质是长生命周期的对象持有短生命周期对象的强引用，导致短生命周期对象使用完了之后无法被回收。也就是应该被回收的对象没有被回收。那么问题就变成了什么对象是应该被回收的对象呢？对于 Activity 而言，执行完 onDestroy 方法之后，就是应该被回收了。因此可以将 Activity#ondestroy 方法作为一个检测点。Application 中提供了各个 Activity 的生命周期回调方法的监听，LeakCanary 就是通过注册 ActivityLifecycleCallbacks ，监听生命周期方法的回调，作为整个内存泄漏分析的入口。 每次 onActivityDestroyed(Activity activity) 方法被回调之后,都会创建一个 KeyedWeakReference 对相应 Activity 的状态进行跟踪，手动调用 gc，后台线程（HandlerThread ）检查引用是否被清除，如果没有就手动调用一次 gc，如果这时还是没有被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。在另一个进程中的 HeapAnalyzerService 中， HeapAnalyzer 会通过 haha 开源库对文件进行分析。 得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄漏。HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄漏。如果是的话，建立导致泄漏的引用链。引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。 进阶使用：了解 LeakCanary 的原理之后，发现其实它就是在对象不可用的时候去判断对象是否被回收了，但 LeakCanary 只检查了 Activity，我们是否可以检查其他对象呢，毕竟 Activity 泄漏只是内存泄漏的一种，答案当然是可以的，我们只要需要进行如下操作: 1LeakCanary.install(app).watch(object) 但我们在调用这个方法的时候需要确定这个 object 已经不需要了，可以被回收了。通过这种方式我们就可以对任何对象都进行检测了。 参考资料与学习资源推荐 LeakCanary 原理浅析 LeakCanary 中文使用说明 话说 ReferenceQueue 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！]]></content>
      <categories>
        <category>源码分析</category>
        <category>框架原理</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>框架原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆轮子系列——LitePal 原理解析]]></title>
    <url>%2Fblog%2F2017%2F12%2F03%2F%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94litepal-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LitePal 解决了什么问题？ LitePal 采取的是对象关系映射(ORM)的模式，那么什么是对象关系映射呢？简单点说，我们使用的编程语言是面向对象语言，而我们使用的数据库则是关系型数据库，那么将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是对象关系映射了。 但是我们为什么要使用对象关系映射模式呢？这主要是因为大多数的程序员都很擅长面向对象编程，但其中只有少部分的人才比较精通关系型数据库。而且数据库的 SQL 语言晦涩难懂，就算你很精通它，恐怕也不喜欢经常在代码中去写它吧？而对象关系映射模式则很好地解决了这个问题，它允许我们使用面向对象的方式来操作数据库，从而可以从晦涩难懂的 SQL 语言中解脱出来。 Android 已经为我们提供了 SQLiteOpenHelper 以帮助我们完成数据库的创建、表的创建、以及数据的 CRUD 操作。但是使用起来还是不够方便。建立数据库需要继承 SQLiteOpenHelper 重写相应的方法，同时为了方便后续的操作，我们每创建一张表，都要一个相应的 DAO 类，完成相应表的 CRUD 操作。加在一起工作量真的不小。 如果使用 LitePal，只需要建立一个 xml 配置文件，在其中指定数据库名称、版本号，以及需要进行映射的类名，然后让 App 的 Application 类继承 LitePalApplication 进行初始化，就可以完成数据库、表的创建工作。同时，数据的 CRUD 操作只需要通过 DataSupport 的相应方法就能完成。这样工作量是不是少了很多。 初始化文档中建议通过将在 Manifest 文件中指定 application 为 LitePalApplication 或者通过继承 LitePalApplication 来实现初始化。初始化的目的为了方便获取 Context 对象 12345678public class LitePalApplication extends Application &#123; static Context sContext; public LitePalApplication() &#123;//默认的构造方法，初始化 Context 静态变量 sContext = this; &#125;&#125; 数据库的创建查看文档说明，我们发现 table 的创建和修改都是自动实现的。对外公开的主要是对数据的操作，所以我们就顺着对数据的操作来分析。而进行操作的前提是表中有数据，我们就从插入操作（对应 save 方法）看起。 DataSupport#save() 12345public synchronized boolean save() &#123; //代码省略 saveThrows(); //代码省略&#125; save 会调用 saveThrows 方法， DataSupport#saveThrows 1234public synchronized void saveThrows() &#123; SQLiteDatabase db = Connector.getDatabase();//获取数据库//代码省略&#125; saveThrows 方法中首先调用了 Connector.getDatabase() 获取数据库。 Connector#getDatabase()Connector#getDatabase主要调用流程如下 123456789101112Connector#getDatabase --&gt; getWritableDatabase --&gt; buildConnection //获取 LitePalOpenHelper （实际上是一个 SQLiteOpenHelper） --&gt; LitePalAttr.getInstance();//获取单例对象 --&gt; LitePalAttr = new LitePalAttr();//创建 LitePalAttr --&gt; loadLitePalXMLConfiguration();//加载 liepal.xml 配置文件中的数据 --&gt; LitePalParser.parseLitePalConfiguration() //首先进行解析 --&gt; //将解析到的数据（ 数据库名、数据库版本号、需要映射为表的类名、是否大小写敏感、存储路径 ）赋值给 LitePalAttr 中的字段 --&gt; LitePalAttr.checkSelfValid();//参数合法性检查 --&gt; //构造存储路径 --&gt; //创建 LitePalOpenHelper --&gt; SQLiteOpenHelper#getWritableDatabase 虽然 LitePal 号称零配置，但是基础的准备工作还是需要做的。按照官方教程，在使用 LitePal 之前，需要在 res 目录下面创建一个 xml 目录，然后在该目录中创建一个名为 LitePal 的 xml 文件。举个栗子： 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LitePal&gt; &lt;!--数据库名--&gt; &lt;dbname value="library"/&gt; &lt;!--版本号--&gt; &lt;version value="1"/&gt; &lt;!--映射表--&gt; &lt;list&gt; &lt;mapping class="com.android.rdc.librarysystem.bean.Book"/&gt; &lt;mapping class="com.android.rdc.librarysystem.bean.BookType"/&gt; &lt;mapping class="com.android.rdc.librarysystem.bean.Borrow"/&gt; &lt;/list&gt;&lt;/LitePal&gt; 其中的 dbname 标签就是用于指定数据库名的。 Connector#buildConnection 123456789101112private static LitePalOpenHelper buildConnection() &#123; LitePalAttr LitePalAttr = LitePalAttr.getInstance(); //获取单例对象——LitePalAttr LitePalAttr.checkSelfValid();//参数合法性检查 if (mLitePalHelper == null) &#123; String dbName = LitePalAttr.getDbName();// //……省略路径处理代码 dbName = dbPath + "/" + dbName; mLitePalHelper = new LitePalOpenHelper(dbName, LitePalAttr.getVersion());// &#125; return mLitePalHelper;&#125; 首次连接数据库时，LitePal 会通过 LitePalParser#parseLitePalConfiguration();方法对 xml 配置文件进行解析。大体流程就是使用 XmlPullParser 对 xml 文件的解析，解析完成之后，就将结果保存在 LitePalConfig类中。 LitePalConfig 类字段如下所示： 12345678public class LitePalConfig &#123; private int version;//数据库版本号 private String dbName;//数据库名 private String cases;//数据库大小写敏感性 private String storage;//数据库文件的存储路径，可选择内部存储或者外部存储 private List&lt;String&gt; classNames;//需要进行映射的模型类，每一个类名都需要给全名（包括包名） //代码省略&#125; 注：大小写敏感SQLite 是大小写敏感的，具体： 创建表、列的时候，SQL 语句里是什么大小写，表名、列名就是什么大小写； SQL 语句执行的时候：==表名、列名大小写不敏感，都能识别==； SQL 语句里面，“=”还是 LIKE 都是大小写敏感； buildConnectionbuildConnection 方法首先会去获取 LitePalAttr 单例对象（首次调用会触发解析 LitePal.xml 文件），然后检查参数合法性，并根据解析得到的 LitePalAttr 中的字段创建一个 LitePalOpenHelper。 到这里，数据库已经创建完成了。那么数据库中的表是什么时候创建的呢？回到前面的 saveThrows 方法，该方法在获取数据库之后就开始做保存工作了（表创建工作不应该放在 保存工作过程中，因为这样不合理）。因此，表很可能就是在数据库创建过程中顺便创建的。实际上也确实如此。 LitePalOpenHelper#onCreate 调用链主要流程如下： 1234567891011LitePalOpenHelper#onCreate//数据库 onCreate 回调方法 --&gt; Generator#create() --&gt; create(db, true); --&gt; new Creator(); --&gt; creator.createOrUpgradeTable(db, force); --&gt; 迭代调用 createOrUpgradeTable(tableModel, db, force); --&gt; getCreateTableSQLs(tableModel, db, force) //拼接建表 sql 语句，存储在 ArrayList 中 --&gt; execute(); --&gt; 迭代调用 db.execSQL() 执行 SQL 语句 --&gt; AssociationCreator#giveTableSchemaACopy --&gt; addAssociation(db, true); 上述过程中，我们看下 getCreateTableSQLs 方法，该方法会先生成删除表的语句 sql，然后再生成创建表的语句，并将它们按序存在 ArrayList 中。也就是说，每次建表之前先尝试删除同名的表（如果有的话）。 1234567891011121314protected List&lt;String&gt; getCreateTableSQLs(TableModel tableModel, SQLiteDatabase db, boolean force) &#123; List&lt;String&gt; sqls = new ArrayList&lt;String&gt;(); if (force) &#123; sqls.add(generateDropTableSQL(tableModel)); sqls.add(generateCreateTableSQL(tableModel)); &#125; else &#123; if (DBUtility.isTableExists(tableModel.getTableName(), db)) &#123; return null; &#125; else &#123; sqls.add(generateCreateTableSQL(tableModel)); &#125; &#125; return sqls;&#125; 至此数据库和表创建完毕。 dataSupport#save() 的背后先看下整体的调用流程 1234567891011121314151617datasupport#save --&gt; saveThrows --&gt; 创建 SaveHanlder --&gt; 调用 SaveHanlder#onSave --&gt; getSupportedFields//获取支持域 --&gt; getSupportedGenericFields//获取支持的泛型域 --&gt; getAssociationInfo//获取关联关系 --&gt; if(baseObjId &gt; 0) doUpdateAction//执行更新操作 --&gt; else doSaveAction --&gt; values.clear();//清空 ContentValue --&gt; beforeSave();//存放值（对象本身的值与外键） --&gt; long id = saving(); --&gt; SQLiteDatabase#insert()// 将记录插入数据库 --&gt; SQLiteDatabase#insertWithOnConflict()//拼接 sql 语句 --&gt; afterSave() --&gt; clearAssociatedData();//清除所有的关联数据 --&gt; SQLiteDatabase#setTransactionSuccessful();//设置事务成功 123456789public synchronized boolean save() &#123; try &#123; saveThrows(); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125;&#125; LitePal 文档中对 save 方法的说明如下: 如果是一条新记录，则插入一个新的行。如果保存过程中出错，整个操作取消，相应的修改会回滚。如果数据类中含有名为 id 或者 _id 并且类型为 int / long 的字段，那么在该对象被保存之后它们会被赋予相应的 id 值。（与 DataSupport 类中的 baseObjId 相同） 从 synchronized 可以看出 save 是一个同步方法，保证线程安全。它在内部调用了 saveThrows 方法。如果捕获到异常就 return false；否则 return true 表示保存成功。 saveThrowsDataSupport#saveThrows 1234567891011121314public synchronized void saveThrows() &#123; SQLiteDatabase db = Connector.getDatabase();//获取数据库 db.beginTransaction();//开始事务 try &#123; SaveHandler saveHandler = new SaveHandler(db);//创建 SaveHandler，构造方法会创建一个 ContentValues saveHandler.onSave(this);//保存 clearAssociatedData();//清除关联数据 db.setTransactionSuccessful();//事务成功 &#125; catch (Exception e) &#123; throw new DataSupportException(e.getMessage(), e); &#125; finally &#123; db.endTransaction();//结束事务 &#125;&#125; saveThrows 方法中使用了事务保证了数据的原子性。不过它没有做具体的保存工作，而是创建一个 SaveHandler 然后将自身的引用传递给 onSave 方法。 SaveHandler继承结构如下： DataHandler 是 CRUD 组件的基类。里面定义了一些 CRUD 操作所需要通用方法。DataHandler 中又继承自LitePalBase。LitePalBase 是所有 的 LitePal 组件的基类。主要是给有如下需求的组件提供解决方案：①需要与其他组件进行交互的组件②有通用的逻辑代码的组件。 SaveHandler 继承自 DataHandler。从继承关系图中可以看到所有的 CRUD 操作都有相应的 Handler 。而且他们都继承自 DataHandler。是 DataSupport 下面的一个组件。SaveHandler 处理保存的工作。所有的实现基于所有的实现都基于 java 反射 API 和 Android SQLiteDatabase API。它如果关联模型已经存储了，它会自动在当前模型与关联模型之间建立关系。 SaveHandler#onSave 123456789101112131415161718192021void onSave(DataSupport baseObj) throws SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; String className = baseObj.getClassName();//获取要保存对象的类名 List&lt;Field&gt; supportedFields = getSupportedFields(className);//获取支持的字段 List&lt;Field&gt; supportedGenericFields = getSupportedGenericFields(className);//获取支持的泛型信息 Collection&lt;AssociationsInfo&gt; associationInfos = getAssociationInfo(className);//获取关联信息 if (!baseObj.isSaved()) &#123; if (!ignoreAssociations) &#123; analyzeAssociatedModels(baseObj, associationInfos); &#125; doSaveAction(baseObj, supportedFields, supportedGenericFields);//对 id 值&lt;=0 对象执行保存操作 if (!ignoreAssociations) &#123; analyzeAssociatedModels(baseObj, associationInfos); &#125; &#125; else &#123; if (!ignoreAssociations) &#123; analyzeAssociatedModels(baseObj, associationInfos); &#125; doUpdateAction(baseObj, supportedFields, supportedGenericFields);//对象本身存在数据库中，执行更新操作 &#125;&#125; onSave 方法会先去收集 LitePal 支持的类型和基础类型的 Filed 并将它们分别存在两个 List 中，同时也会获取关联信息。然后通过判断对象的 baseObjid &gt; 0 是否成立，不成立，说明对象是一个未保存的对象，执行 doSaveAction 方法；否则调用 doUpdateAction 方法。 LitePalBase#getSupportedFields 12345678910111213141516protected List&lt;Field&gt; getSupportedFields(String className) &#123; List&lt;Field&gt; fieldList = classFieldsMap.get(className);//尝试从缓存中获取 if (fieldList == null) &#123;// List&lt;Field&gt; supportedFields = new ArrayList&lt;Field&gt;(); Class&lt;?&gt; clazz; try &#123; clazz = Class.forName(className);//获取类名 &#125; catch (ClassNotFoundException e) &#123; throw new DatabaseGenerateException(DatabaseGenerateException.CLASS_NOT_FOUND + className); &#125; recursiveSupportedFields(clazz, supportedFields);//递归类型 classFieldsMap.put(className, supportedFields);//缓存到 hashMap 中 return supportedFields;//返回 &#125; return fieldList;//缓存命中&#125; 1234567891011121314151617181920212223private void recursiveSupportedFields(Class&lt;?&gt; clazz, List&lt;Field&gt; supportedFields) &#123; if (clazz == DataSupport.class || clazz == Object.class) &#123; return; &#125; Field[] fields = clazz.getDeclaredFields(); if (fields != null &amp;&amp; fields.length &gt; 0) &#123; for (Field field : fields) &#123; Column annotation = field.getAnnotation(Column.class); if (annotation != null &amp;&amp; annotation.ignore()) &#123;//有注解，但是注解设置为忽略 continue; &#125; int modifiers = field.getModifiers();//获取修饰符 if (!Modifier.isStatic(modifiers)) &#123;//不是静态的 Class&lt;?&gt; fieldTypeClass = field.getType();//获取字段域类型 String fieldType = fieldTypeClass.getName();//字段类型的名称 if (BaseUtility.isFieldTypeSupported(fieldType)) &#123; supportedFields.add(field);//非静态、并且受支持的字段添加到 List&lt;Filed&gt; 中 &#125; &#125; &#125; &#125; recursiveSupportedFields(clazz.getSuperclass(), supportedFields);&#125; 递归调用，直到是 DataSupport 或者 Object 为止，通过反射取得所有的 fields，当不需要忽略时，不是静态，一些基本支持的数据类型时会直接加入到这个 fieldList 里边。 getSupportedGenericFields() 方法与上面的类似，只不过处理的是泛型。 LitePalBase#getAssociationInfo12345678910private Collection&lt;AssociationsInfo&gt; mAssociationInfos;protected Collection&lt;AssociationsInfo&gt; getAssociationInfo(String className) &#123; if (mAssociationInfos == null) &#123; mAssociationInfos = new HashSet&lt;AssociationsInfo&gt;(); &#125; mAssociationInfos.clear();//清理关系集 analyzeClassFields(className, GET_ASSOCIATION_INFO_ACTION);//分析类的字段域 return mAssociationInfos;&#125; 分析类字段以找出关联关系 123456789101112131415161718private void analyzeClassFields(String className, int action) &#123; try &#123; Class&lt;?&gt; dynamicClass = Class.forName(className);//加载类 Field[] fields = dynamicClass.getDeclaredFields();// for (Field field : fields) &#123; if (isNonPrimitive(field)) &#123;//不是原生类型 Column annotation = field.getAnnotation(Column.class);//获取注解 if (annotation != null &amp;&amp; annotation.ignore()) &#123; continue; &#125; oneToAnyConditions(className, field, action);//一对？关系 manyToAnyConditions(className, field, action);//多对？关系 &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; //代码省略 &#125;&#125; LitePalBase#oneToAnyConditions首先我们要明确，oneToAnyConditions 是在遍历处理类的所有字段的过程中调用的。并且只有当字段类型是非原生类型时才会进入该方法。 设有 A 和 B 两个类。现在对 A 中存在类型为 B 的字段。首先判断 B 是否在配置文件里边配置的。如果是，就找到这个类的所有字段。找到一个和 A 相同的字段，这代表 A 里边有一个 B，B 里边有一个 A，是一对一关系；如果 B 找到的和 A 相同的字段是一个集合，代表 A 里边有一个 B，B 里边有多个 A，是多对一关系。 最后统一把关系加入到一个集合里边来管理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void oneToAnyConditions(String className, Field field, int action) throws ClassNotFoundException &#123; Class&lt;?&gt; fieldTypeClass = field.getType();//获取字段的类型 //字段的类型包含在 LitePal 配置文件映射的列表中 if (LitePalAttr.getInstance().getClassNames().contains(fieldTypeClass.getName())) &#123; Class&lt;?&gt; reverseDynamicClass = Class.forName(fieldTypeClass.getName());//通过类名加载字段的类（简称为 B） Field[] reverseFields = reverseDynamicClass.getDeclaredFields(); boolean reverseAssociations = false; // 开始检查类 B 中的属性 for (int i = 0; i &lt; reverseFields.length; i++) &#123; Field reverseField = reverseFields[i];// if (!Modifier.isStatic(reverseField.getModifiers())) &#123; Class&lt;?&gt; reverseFieldTypeClass = reverseField.getType(); // B 中也有 A 的引用。因此是一对一的双向关系 if (className.equals(reverseFieldTypeClass.getName())) &#123; if (action == GET_ASSOCIATIONS_ACTION) &#123; addIntoAssociationModelCollection(className, fieldTypeClass.getName(), fieldTypeClass.getName(), Const.Model.ONE_TO_ONE); &#125; else if (action == GET_ASSOCIATION_INFO_ACTION) &#123; addIntoAssociationInfoCollection(className, fieldTypeClass.getName(), fieldTypeClass.getName(), field, reverseField, Const.Model.ONE_TO_ONE); &#125; reverseAssociations = true; &#125; // B 类中有字段： List&lt;A&gt; 说明是多对一关系 else if (isCollection(reverseFieldTypeClass)) &#123; String genericTypeName = getGenericTypeName(reverseField); if (className.equals(genericTypeName)) &#123; if (action == GET_ASSOCIATIONS_ACTION) &#123; addIntoAssociationModelCollection(className, fieldTypeClass.getName(), className, Const.Model.MANY_TO_ONE); &#125; else if (action == GET_ASSOCIATION_INFO_ACTION) &#123; addIntoAssociationInfoCollection(className, fieldTypeClass.getName(), className, field, reverseField, Const.Model.MANY_TO_ONE); &#125; reverseAssociations = true; &#125; &#125; &#125; &#125; // B 中没有 A 的引用，AB 是单向的一对一关系 if (!reverseAssociations) &#123; if (action == GET_ASSOCIATIONS_ACTION) &#123; addIntoAssociationModelCollection(className, fieldTypeClass.getName(), fieldTypeClass.getName(), Const.Model.ONE_TO_ONE); &#125; else if (action == GET_ASSOCIATION_INFO_ACTION) &#123; addIntoAssociationInfoCollection(className, fieldTypeClass.getName(), fieldTypeClass.getName(), field, null, Const.Model.ONE_TO_ONE); &#125; &#125; &#125;&#125; manyToAnyConditions 也是通过类似的逻辑进行分析处理。 回到 saveThrows 方法，可以看到后续会调用 doSaveAction。 doSaveAction12345678private void doSaveAction(DataSupport baseObj, List&lt;Field&gt; supportedFields, List&lt;Field&gt; supportedGenericFields) throws SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; values.clear();//先清除 contentValue 中的值 beforeSave(baseObj, supportedFields, values); long id = saving(baseObj, values);//保存 afterSave(baseObj, supportedFields, supportedGenericFields, id);&#125; doSaveAction 方法中依次调用了 beforeSave saving afterSave 三个方法。 beforeSave 方法会将相应的字段列与值以键值对的形式存放到 values 中， values 将作为后面 saving 方法的参数。 saving 方法内部会调用 调用 SQLiteDatabase#insert 方法对数据进行保存。 afterSave 所做的工作是获取刚刚保存的那条记录的 id ，然后以反射的形式将它赋给对象的 baseObjId 字段，同时还会更新关联表的数据 123456private long saving(DataSupport baseObj, ContentValues values) &#123; if (values.size() == 0) &#123;//如果 contentValue 中的大小为 0，那就存储一个仅有 id 的空行 values.putNull("id"); &#125; return mDatabase.insert(baseObj.getTableName(), null, values);//终于看到了 SqlLite 的保存操作&#125; SQLiteDatabase#insertinsert 方法内部会调用 SQLiteDatabase#insertWithOnConflict 方法。 可以看到该方法的实现是将相应的数据结构拼接为一个 SQL 插入语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static final String[] CONFLICT_VALUES = new String[] &#123;"", " OR ROLLBACK ", " OR ABORT ", " OR FAIL ", " OR IGNORE ", " OR REPLACE "&#125;;public long insertWithOnConflict(String table, String nullColumnHack, ContentValues initialValues, int conflictAlgorithm) &#123; acquireReference(); try &#123; StringBuilder sql = new StringBuilder(); sql.append("INSERT"); sql.append(CONFLICT_VALUES[conflictAlgorithm]); sql.append(" INTO "); sql.append(table);//表名 sql.append('('); Object[] bindArgs = null; int size = (initialValues != null &amp;&amp; !initialValues.isEmpty()) ? initialValues.size() : 0; if (size &gt; 0) &#123; bindArgs = new Object[size]; int i = 0; for (String colName : initialValues.keySet()) &#123; sql.append((i &gt; 0) ? "," : ""); sql.append(colName);//添加名称 bindArgs[i++] = initialValues.get(colName);//列名对应的值，将其存在数组中 &#125; sql.append(')'); sql.append(" VALUES ("); for (i = 0; i &lt; size; i++) &#123; sql.append((i &gt; 0) ? ",?" : "?"); &#125; &#125; else &#123; sql.append(nullColumnHack + ") VALUES (NULL");//空行 &#125; sql.append(')'); SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);// 利用表名，以及需要更新的列名，还有相应的列参数「bindArgs」 创建一个 SQLiteStatement try &#123; return statement.executeInsert();//执行插入操作 &#125; finally &#123; statement.close(); &#125; &#125; finally &#123; releaseReference();//释放引用 &#125;&#125; 至此，save 过程分析完成。 find 过程浅析DataSupport#find 大体流程： 123456789101112find() --&gt; find(modelClass, id, false); --&gt; 创建 QueryHandler --&gt; queryHandler#onFind --&gt; query //获取符合条件的 list --&gt; DataHandler#query --&gt; getSupportedFields //获取支持的字段 --&gt; //调用相关方法。做一些铺垫工作 --&gt; SQLiteDatabase#query //调用 SQLiteDataBase#query （该方法最终会调用 buildQueryString 拼接出字符串）。然后通过 cursor 逐行取出数据 --&gt; //省略一些转发方法 --&gt; SQLiteDatabase#queryWithFactory --&gt; SQLiteQueryBuilder#buildQueryString//拼接 sql 语句 SQLiteQueryBuilder#buildQueryString1234567891011121314151617181920212223242526272829303132public static String buildQueryString( boolean distinct, String tables, String[] columns, String where, String groupBy, String having, String orderBy, String limit) &#123; if (TextUtils.isEmpty(groupBy) &amp;&amp; !TextUtils.isEmpty(having)) &#123; throw new IllegalArgumentException( "HAVING clauses are only permitted when using a groupBy clause"); &#125; if (!TextUtils.isEmpty(limit) &amp;&amp; !sLimitPattern.matcher(limit).matches()) &#123; throw new IllegalArgumentException("invalid LIMIT clauses:" + limit); &#125; StringBuilder query = new StringBuilder(120); query.append("SELECT "); if (distinct) &#123; query.append("DISTINCT "); &#125; if (columns != null &amp;&amp; columns.length != 0) &#123; appendColumns(query, columns); &#125; else &#123; query.append("* "); &#125; query.append("FROM "); query.append(tables); appendClause(query, " WHERE ", where); appendClause(query, " GROUP BY ", groupBy); appendClause(query, " HAVING ", having); appendClause(query, " ORDER BY ", orderBy); appendClause(query, " LIMIT ", limit); return query.toString();&#125; 小结：find 就是通过相应的查询条件拼接为 SQL 查询语句，然后将查询结果返回。 问题：同步/异步对于每一个 CRUD 操作，LitePal 都有同步以及相对应的异步方法。 以异步 save 为例异步更新只是新开一条线程来执行 save 方法，并在主线程进行结果回调 123456789101112131415161718192021public SaveExecutor saveAsync() &#123; final SaveExecutor executor = new SaveExecutor();//参加一个 SaveExecutor Runnable runnable = new Runnable() &#123;//创建一个 Runnable 匿名内部子类， @Override public void run() &#123; synchronized (DataSupport.class) &#123; final boolean success = save();//调用保存方法 if (executor.getListener() != null) &#123; LitePal.getHandler().post(new Runnable() &#123;//切换到主线程中回调 @Override public void run() &#123; executor.getListener().onFinish(success);//回调 &#125; &#125;); &#125; &#125; &#125; &#125;; executor.submit(runnable); return executor;&#125; 1234567891011121314151617public class SaveExecutor extends AsyncExecutor &#123; private SaveCallback cb;//回调接口 /** * 注册回调接口之后，马上执行异步任务 */ public void listen(SaveCallback callback) &#123;//注册回调 cb = callback; execute();//执行异步任务 &#125; public SaveCallback getListener() &#123; return cb; &#125;&#125; SaveExecutor 继承自 AsyncExecutor。特别之处在于它是通过 listen 方法来触发异步任务执行的。 123456789101112131415161718192021public abstract class AsyncExecutor &#123; private Runnable pendingTask;//延时任务 /** * 提交任务 */ public void submit(Runnable task) &#123; pendingTask = task; &#125; /** * 后台执行延时任务 */ void execute() &#123; if (pendingTask != null) &#123; new Thread(pendingTask).start();//新建线程执行任务 &#125; &#125;&#125; AsyncExecutor 一个简单的异步执行器，在后台线程中运行任务。它是所有的异步操作执行器的基类。 总结LitePal 需要在 Application 中进行初始化。首次获取数据库的时会触发数据库以及表的创建。后续的 CRUD 操作都是通过反射机制和 Android SQLite API 来实现的。它会自动分析表与表之间的关联关系，并帮助创建表、自动管理表。 优点：配置简单，操作方便，业务对象清晰，LitePal 很「轻」，jar 包只有 100k 不到。 缺点 反射影响性能。 无法直接进行关联查询。 与同类框架（GreenDAO）对比：GreetDao 一开始就人工生成业务需要的 Model 和 DAO 文件，业务中可以直接调用相应的 DAO 文件进行数据库的增删改查操作，从而避免了因反射带来的性能损耗和效率低。因此大批量的插入、更新、查询等操作，greenDAO 用时短，执行快更适合。但是 greenDAO 使用不方便，学习成本较高。 如果应用对性能要求不是特别苛刻并且数据量也不大的情况下，轻量级的 LitePal，基本能满足我们的需求了。 参考资料与学习资源推荐 数据库 ORM 之 LitePal Android 数据库高手秘籍 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源，谢谢！]]></content>
      <categories>
        <category>源码分析</category>
        <category>框架原理</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>框架原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆轮子系列——EventBus 源码解析]]></title>
    <url>%2Fblog%2F2017%2F10%2F14%2F%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[项目地址：EventBus，本文分析版本: 3.1.1 一、概述EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。 事件(Event)：又可称为消息，本文中统一用事件表示。其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。事件类型(EventType)指事件所属的 Class。 事件分为一般事件和 Sticky 事件，相对于一般事件，Sticky 事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个 Sticky 事件（所谓「最近一个」指的就是该类型事件「最后一次发出」）。 订阅者(Subscriber)：订阅某种事件类型的对象。当有发布者发布这类事件后，EventBus 会执行订阅者的 onEvent 函数，这个函数叫事件响应函数。订阅者通过 register 接口订阅某个事件类型，unregister 接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为 0。 发布者(Publisher)：发布某事件的对象，通过 post 接口发布事件。 二、如何使用2.1 添加依赖方式一，运行期处理注解在app 的 build.gradle 文件中添加依赖 123dependencies &#123; implementation 'org.greenrobot:eventbus:3.1.1'&#125; 方式二，编译期预处理注解Android Studio 3.0 及以上 在 app 的 build.gradle 文件中添加 12345678910111213141516android &#123; //…… defaultConfig &#123; //…… javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [eventBusIndex: 'org.greenrobot.eventbusperf.MyEventBusIndex'] &#125; &#125; &#125;&#125;dependencies &#123; implementation 'org.greenrobot:eventbus:3.1.1' annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.0.1'&#125; build 之后，会生成一个 MyEventBusIndex.java类。 然后在使用 EventBus 实例之前，又有两种方式可以将配置MyEventBusIndex.java配置到类中是哟经。 方式一 在构造 EventBus 时传入我们自定义的 EventBusIndex，1EventBus mEventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build(); 方式二 将索引应用到默认的单例中使用 EventBus 之前，先调用下面的代码初始化 EventBus。 1EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus(); 2.2 定义事件类1234567891011121314public class CustomEvent &#123; private String mEventName; public CustomEvent() &#123; &#125; public String getEventName() &#123; return mEventName; &#125; public void setEventName(String eventName) &#123; mEventName = eventName; &#125;&#125; 2.3 注册为监听者在合适的地方（比如 Activity#onCreate、Fragment#onCreateView）通过下方代码进行注册 EventBus.getDefault().register(this); 2.4 编写响应事件的订阅方法1234@Subscribe(threadMode = ThreadMode.BACKGROUND, sticky = true, priority = 100)public void onMessage(CustomEvent event) &#123; Log.d(TAG, "onMessage: " + event.getEventName());&#125; 使用编译期注解处理的情况下，订阅方法的访问控制权限必须是 非 private 并且非 static 的 使用运行期反射处理的情况下，订阅方法的访问控制权限必须是 public 的 通过 ThreadMode 可以指定订阅方法在哪个线程执行，有四种选择 ThreadMode.MAIN 事件订阅方法会在 UI 线程中执行 使用此模式的事件订阅方法必须快速返回以避免阻塞主线程。 ThreadMode.POSTING （默认的模式）表示事件在哪个线程中发布出来的，事件订阅方法就会在这个线程中运行； 该模式避免了线程切换，适用于那些在很短的时间内完成的简单任务，无需主线程。使用这种模式的事件订阅方法必须快速返回以避免阻塞发布线程（发布线程可能是主线程）。 ThreadMode.MAIN_ORDERED 在 Android 上，订阅方法将在 Android 的主线程中被调用。事件将会排队等待交付，这确保了 post 调用是非阻塞的。 ThreadMode.BACKGROUND 子线程执行，如果本来就在子线程，直接在该子线程执行 EventBus 使用一个后台线程，将按顺序发送所有事件。使用这种模式的订阅方法应该尽快返回以避免阻塞后台线程。 注意：「一个后台线程」所指的并不是 Executors.newSingleThreadPool()，而是使用 EventBus 在实例化时创建的 cacheThreadPool 中的某一个线程。 ThreadMode.ASYNC 新建子线程执行。适用于耗时操作 发布事件永远不会等待使用此模式的订阅方法。适用于比较耗时的订阅方法，比如用于网络请求。使用时应该避免同时触发大量长时间运行的异步订阅方法来限制并发线程的数量。 EventBus 使用线程池有效地重用已完成的异步用户通知中的线程。 通过 sticky 指定是否接收粘性事件，默认为 false 通过 priority 设置接收订阅方法的优先级，相同的事件，优先级越高的订阅方法 越早收到事件 2.5 发送事件通过EventBus的post()方法来发送事件, 发送之后就会执行注册过这个事件的对应类的方法. 或者通过postSticky()来发送一个粘性事件。 2.6 解除注册在合适的地方（比如 Activity#onDestroy）使用下面的代码进行解除注册 EventBus.getDefault().unregister(this); 2.7 小结要实现订阅，需要进行注册，以及解注册，订阅方法以「目标事件」作为方法的参数， 使用 Subscribe 注解，可以指定订阅方法执行的线程、是否接收 sticky 事件、订阅方法的优先级。 至于发送方，只需要创建相应的 事件实例，然后调用 post 或者 postSticky 将事件发送出去即可。 三、实现3.1 初始化 EventBus开发者通常是调用 EventBus#getDefault 方法获取 EventBus 实例。 12345678910public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; getDefault 通过双重校验锁的方式来实现单例 构造方法12345private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();public EventBus() &#123; this(DEFAULT_BUILDER);&#125; 通过 getDefault 获取的 EventBus 对象是通过默认的 EventBusBuilder 构造而成的。 1234567891011121314151617181920212223private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();//默认为 CachedThreadPool，不限制线程数boolean logSubscriberExceptions = true;boolean logNoSubscriberMessages = true;boolean sendSubscriberExceptionEvent = true;boolean sendNoSubscriberEvent = true;boolean throwSubscriberException;boolean strictMethodVerification;//ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;//默认的线程池List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;MainThreadSupport mainThreadSupport;EventBus(EventBusBuilder builder) &#123; //…… subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); //…… eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125; 主要看以下几个单例的实现。 12345678910boolean eventInheritance = true;//是否允许事件继承boolean ignoreGeneratedIndex;//是否忽略 生成的 index，默认为 false，也就是会先尝试寻找编译期注解生成的订阅方法信息，找不到再使用反射去获取。private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;private final HandlerPoster mainThreadPoster;private final BackgroundPoster backgroundPoster;private final AsyncPoster asyncPoster; subscriptionsByEventType ，key 是事件类型，value 为 订阅了该事件的方法列表 typesBySubscriber，key 为订阅者，value 某个订阅者订阅的事件列表 stickyEvents，key 为事件类型，value 为具体的事件实例 mainThreadPoster 主线程分发 backgroundPoster 后台线程分发 asyncPoster 异步线程分发 3.2 注册订阅org.greenrobot.eventbus.EventBus#register 12345678910public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass();//获取订阅者的 class 对象 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);//查找订阅者中所有的订阅方法 synchronized (this) &#123; //迭代遍历订阅者中所有的订阅方法 for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; EventBus#findSubscriberMethods 找出给定 class 中所有的订阅方法 12345678910111213141516171819202122private static final Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap();//以 class 为 key，方法列表为 value 的，Map 作为缓存List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; List subscriberMethods = (List)METHOD_CACHE.get(subscriberClass);//缓存中获取 if(subscriberMethods != null) &#123; return subscriberMethods;//缓存命中，直接返回 &#125; else &#123; if(this.ignoreGeneratedIndex) &#123;//忽略编译期生成的 订阅方法信息 subscriberMethods = this.findUsingReflection(subscriberClass);//通过反射获取订阅方法信息 &#125; else &#123; //获取编译期生成的 订阅方法信息 subscriberMethods = this.findUsingInfo(subscriberClass);// &#125; if(subscriberMethods.isEmpty()) &#123; throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods);//添加到缓存中 return subscriberMethods;//返回 &#125; &#125;&#125; EventBus#subscribe() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//必须从同步块中调用private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType;//事件类型 Subscription newSubscription = new Subscription(subscriber, subscriberMethod);//新建一个 Subscription，存储订阅的对象以及 响应的方法 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);//Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; 从 map 中获取相应订阅类型的 列表 if (subscriptions == null) &#123;//如果没有则新建一个 subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event " + eventType);//没有则抛出异常。 &#125; &#125; int size = subscriptions.size(); //遍历监听列表，将新的 subscription 插入到正确位置。列表按照优先级递减的顺序排序 for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //如果触发的方法 要接收「粘性事件」，获取相应类型的 Event 并触发相应的方法 if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 该方法会将相应的事件插入对应事件的列表中。如果在方法注解中声明了 sticky，还会马上调用该方法。 检测 stick 事件，如果相应的事件定义有子类的话，会遍历事件的事件子类逐一通知该方法。 3.2.1 通过反射处理注解SubscriberMethodFinder#findUsingReflection 123456789private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; SubscriberMethodFinder#findUsingReflectionInSingleClass 12345678910111213141516171819202122232425262728293031323334353637private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods();//获取的是类的所有公有方法，这就包括自身 和从基类继承的、从接口实现的所有 public 方法。 //getDeclareMethods 返回的是该类中定义的「所有方法」，但是不包括从父类继承而来的方法 &#125; catch (Throwable th) &#123; methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123;//遍历方法 int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123;//参数列表长度为 0 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); //将订阅方法信息添加到 findState 中 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException("@Subscribe method " + methodName + "must have exactly 1 parameter but has " + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException(methodName + " is a illegal @Subscribe method: must be public, non-static, and non-abstract"); &#125; &#125; &#125; ignoreGeneratedIndex 是什么?由于反射成本高,而且 EventBus 3.0 引入了 EventBusAnnotationProcessor,故默认 ignoreGeneratedIndex 为 false,需要注意的是,如果设置 ignoreGeneratedIndex 为 true,则前面使用的 MyEventBusIndex 无效,还是会走反射解析的分支。 3.2.2 使用编译期生成的订阅方法信息网上有很多介绍 EventBus 的文章,但是几乎没有提到 EventBusAnnotationProcessor 的。在 3.0 版本开始，EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析,处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.我们可以参考EventBus项目里的EventBusPerformance这个例子,编译后我们可以在build文件夹里找到这个类,MyEventBusIndex 类,当然类名是可以自定义的.我们大致看一下生成的MyEventBusIndex类是什么样的: 订阅者中的 订阅方法 1234567891011121314public class ReceiveEventFragment extends Fragment &#123; //…… @Subscribe(threadMode = ThreadMode.MAIN, priority = 0) public void onReceive(MsgEvent event) &#123; Log.d(TAG, "onReceive: " + event); mTvMsg.setText(String.format("msgId:%d\nmsg:%s", event.msgId, event.msg)); &#125; @Subscribe(threadMode = ThreadMode.MAIN, priority = 10000) public void ShowToast(MsgEvent event) &#123; Toast.makeText(getActivity(), String.format("msgId:%d\nmsg:%s", event.msgId, event.msg), Toast.LENGTH_SHORT).show(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132/** This class is generated by EventBus, do not edit. */public class MyEventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();//以订阅者为 key，以订阅者中的 订阅方法列表为 value 的 map //将 ReceiveEventFragment 的订阅信息存储到 map 中 putIndex(new SimpleSubscriberInfo(com.test.commentdemo.eventbusdemo.ReceiveEventFragment.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo("onReceive", com.test.commentdemo.eventbusdemo.MsgEvent.class, ThreadMode.MAIN), new SubscriberMethodInfo("ShowToast", com.test.commentdemo.eventbusdemo.MsgEvent.class, ThreadMode.MAIN, 10000, false), &#125;));//订阅者中所有的订阅方法 //……代码省略（存储其他订阅者的订阅信息到 map 中） &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);//根据类型从 Map 获取订阅者的订阅信息 if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; 继续前面 ignoreGeneratedIndex 为 false 时，会执行以下分支。 12345678910111213141516171819private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();//获取订阅的方法信息 for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; findUsingReflectionInSingleClass(findState);//如果找不到相应的订阅方法信息（可能使用 EventBus 实例之前，没有将MyEventBusIndex ），需要通过反射获取订阅方法信息 &#125; findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; findUsingInfo()方法,其无非就是通过查找我们前面所说的MyEventBusIndex类中的信息,来转换成List&lt;SubscriberMethod&gt;从而获得订阅类的相关订阅函数的各种信息 SubscriberMethodFinder#getSubscriberInfo 123456789101112131415161718192021private SubscriberInfo getSubscriberInfo(SubscriberMethodFinder.FindState findState) &#123; if(findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();//获取父类的订阅方法信息 if(findState.clazz == superclassInfo.getSubscriberClass()) &#123;// return superclassInfo; &#125; &#125; if(this.subscriberInfoIndexes != null) &#123; Iterator superclassInfo1 = this.subscriberInfoIndexes.iterator(); //遍历，从 index 中获取 订阅信息 while(superclassInfo1.hasNext()) &#123; SubscriberInfoIndex index = (SubscriberInfoIndex)superclassInfo1.next(); SubscriberInfo info = index.getSubscriberInfo(findState.clazz);//从自动生成的 MyEventBusIndex 类中的 SUBSCRIBER_INDEX 里面获取订阅方法信息 if(info != null) &#123; return info; &#125; &#125; &#125; return null;&#125; 3.3 解注册123456789101112/** Unregisters the given subscriber from all event classes. */public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);//获取订阅者订阅的事件列表 if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123;//遍历订阅者所订阅的事件 //从事件对应的订阅列表中 订阅者的订阅信息 unsubscribeByEventType(subscriber, eventType); typesBySubscriber.remove(subscriber);//移除订阅者 &#125; else &#123; logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass()); &#125;&#125; 1234567891011121314151617/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); //从事件对应的订阅列表中 订阅者的订阅信息 if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125;&#125; 3.4 发送事件EventBus#post 1. 获取订阅列表1234567891011121314151617181920212223242526272829303132333435363738public class EventBus &#123; private final ThreadLocal&lt;EventBus.PostingThreadState&gt; currentPostingThreadState;//线程私有变量——当前发布线程状态 public void post(Object event) &#123; EventBus.PostingThreadState postingState = (EventBus.PostingThreadState)this.currentPostingThreadState.get();//记录发布线程的状态（比如是否是主线程） List eventQueue = postingState.eventQueue;//从发布状态中获取事件队列 eventQueue.add(event);//添加进事件队列的队尾 if(!postingState.isPosting) &#123;//当前不是处于分发状态 postingState.isMainThread = this.isMainThread();//是否在主线程 postingState.isPosting = true;//将状态改为发布中 if(postingState.canceled) &#123;//取消发布 throw new EventBusException("Internal error. Abort state was not reset &#125; try &#123; while(!eventQueue.isEmpty()) &#123;//只要事件队列非空，就一直往外取出事件并发布 this.postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125; static final class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList();//事件队列 boolean isPosting; boolean isMainThread; Subscription subscription; Object event; boolean canceled; PostingThreadState() &#123; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;();//事件队列 boolean isPosting;//是否正在分发中 boolean isMainThread;//是否在主线程 Subscription subscription; Object event;//事件 boolean canceled;//取消&#125;private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;;//currentPostingThreadState 是一个线程局部变量/** Posts the given event to the event bus. */public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get();//获取当前线程事件分发状态 List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event);//添加到事务队列中 if (!postingState.isPosting) &#123;//如果当前不是在分发状态,则进入分发状态 postingState.isMainThread = isMainThread(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; //编译事件队列，逐一进行分发 while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; EventBus#postSingleEvent 1234567891011121314151617181920212223private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123;//如果事件支持子类型，查找该事件的所有子类型 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; logger.log(Level.FINE, "No subscribers registered for event " + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; EventBus#postSingleEventForEventType， 123456789101112131415161718192021222324252627 //查找 事件所对应的订阅者列表，然后迭代列表，切换到目标线程执行private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass);//查找 事件所对应的订阅者列表 &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123;//事件取消了 break; &#125; &#125; return true; &#125; return false;&#125; 2.切换到指定线程12345678910111213141516171819202122232425262728293031323334private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING:// invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: if (mainThreadPoster != null) &#123; mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); &#125; break; case BACKGROUND://后台线程 if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC://新建一个子线程处理 asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125;&#125; BACKGROUND123456789101112131415161718192021222324252627282930313233343536373839public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);//包装为一个 PendingPost synchronized (this) &#123;//加锁，进入同步块 queue.enqueue(pendingPost);//添加到队列中 if (!executorRunning) &#123;//如果现在没有在执行 后台任务，则获取一个新线程执行任务 executorRunning = true; eventBus.getExecutorService().execute(this); &#125; &#125;&#125;@Overridepublic void run() &#123; try &#123; try &#123; while (true) &#123;//循环，直到队列为空 PendingPost pendingPost = queue.poll(1000);//获取 PendingPost，最多等到 1 秒 if (pendingPost == null) &#123; //前面取不到 PendingPost，下面进行双重校验检查 synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll();// if (pendingPost == null) &#123; //队列确实为空，停止运行 executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost);//通过反射调用相应的方法 &#125; &#125; catch (InterruptedException e) &#123; eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + " was interruppted", e); &#125; &#125; finally &#123; executorRunning = false; &#125;&#125; MAIN1mainThreadPoster.enqueue(subscription, event); HandlerPoster#enqueue 123456789101112public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123;//加锁 queue.enqueue(pendingPost);//加入 pendingQueue 中。该队列会在 handleMessage 方法中调用 if (!handlerActive) &#123;//如果当前 handler 不是处于活跃状态，则退出 handlerActive = true; if (!sendMessage(obtainMessage())) &#123;//发送信息，提示 throw new EventBusException("Could not send handler message"); &#125; &#125; &#125;&#125; org.greenrobot.eventbus.HandlerPoster#handleMessage 12345678910111213141516171819202122232425262728293031@Overridepublic void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException("Could not send handler message"); &#125; rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125;&#125; 在 handleMessage 方法内部停留时间不能大于 10 毫秒，从 MAIN_ORDERED新增加的模式，但是当前版本的实现还不完善。 ASYN将事件添加 cachedThreadPool 中执行(如果当前有空闲线程，则复用空闲线程，如果没有就创建新线程) 1234567891011121314public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); queue.enqueue(pendingPost); eventBus.getExecutorService().execute(this);//放到默认的 cachedThreaPool 中执行&#125;@Overridepublic void run() &#123; PendingPost pendingPost = queue.poll(); if(pendingPost == null) &#123; throw new IllegalStateException("No pending post available"); &#125; eventBus.invokeSubscriber(pendingPost);&#125; 3.反射调用订阅方法org.greenrobot.eventbus.EventBus#invokeSubscriber(org.greenrobot.eventbus.PendingPost) 12345678void invokeSubscriber(PendingPost pendingPost) &#123; Object event = pendingPost.event; Subscription subscription = pendingPost.subscription; PendingPost.releasePendingPost(pendingPost); if (subscription.active) &#123; invokeSubscriber(subscription, event); &#125;&#125; 123456789void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException("Unexpected exception", e); &#125;&#125; 切换到指定线程之后，通过反射的方法，调用订阅方法。 四、总结EventBus 的实现原理可以归结为以下三点 注册—&gt;扫描订阅方法，添加到订阅方法列表中 发送事件—&gt;根据事件的类型，遍历方法列表，反射调用订阅方法 解注册—&gt;从订阅方法列表中移除相应的订阅方法 EventBus 虽然不是标准的观察者模式的实现, 但是它的整体就是一个发布 / 订阅框架, 也拥有观察者模式的优点, 比如: 发布者和订阅者的解耦。 五、参考资料与学习资源推荐 EventBus 源码解析 EventBus 高效使用及源码解析-知乎专栏 EventBus 3.0 源码分析 EventBus 3.0 源码分析（二）注解处理器的使用 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我。谢谢！]]></content>
      <categories>
        <category>源码分析</category>
        <category>框架原理</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>框架原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆轮子系列——ButterKnife工作原理]]></title>
    <url>%2Fblog%2F2017%2F10%2F07%2F%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ButterKnife%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概要本篇博客主要包括以下三个部分 日常使用 ButterKnife 的方式以及 ButterKnife 的 bind 方法 Xxx_ViewBinding 类是如何生成的？ 注解处理器是怎么注册的？ 其中的代码基于 ButterKnife 8.6.0 本文假设你已经对注解有所了解。不了解注解的同学可以先看看这篇文章 ，我们主要关注编译期注解。 运行期 ButterKnife#bind我们通常都是通过以下方式使用 ButterKnife 的。将要绑定的控件加上 @BindView 注解，在 onCreate 方法 完成 setContentView(R.layout.activity_main); 之后。调用 ButterKnife.bind(this); 对相应的 View 进行初始化。 123456789101112131415public class MainActivity extends AppCompatActivity &#123; private static final String TAG = "MainActivity"; @BindView(R.id.btn) Button mBtn; @BindView(R.id.radar_view) RadarView mRadarView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this);//ButterKnife 的入口 &#125;&#125; public static Unbinder bind(@NonNull Activity target) ，在 Activity 中以该方法作为入口，首先获取 与 Activity 相关联的 window，然后再通过 window 获取 DecorView。最后通过 createBinding 方法创建相关绑定。 1234public static Unbinder bind(@NonNull Activity target) &#123; View sourceView = target.getWindow().getDecorView(); return createBinding(target, sourceView);&#125; 1234567891011121314private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123; Class&lt;?&gt; targetClass = target.getClass(); if (debug) Log.d(TAG, "Looking up binding for " + targetClass.getName()); Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);//查找目标类的构造器 if (constructor == null) &#123; return Unbinder.EMPTY; &#125; try &#123; return constructor.newInstance(target, source);//利用反射创建一个实例，这里实际上调用了 Xxx_ViewBinding 的构造方法（由此可以看到，Butterknife 也是有用到一点反射的） &#125; //代码省略&#125; 12345678910111213141516171819202122232425static final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();//LinkedHashMap 作为缓存容器@Nullable @CheckResult @UiThreadprivate static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123; Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);//先从缓存中查找 if (bindingCtor != null) &#123; return bindingCtor;//缓存命中直接返回 &#125; String clsName = cls.getName();//获取类型 //如果是 Framework 层的类，则直接返回 null if (clsName.startsWith("android.") || clsName.startsWith("java.")) &#123; return null; &#125; try &#123; Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + "_ViewBinding");//加载类 //noinspection unchecked bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);//获取构造器 &#125; catch (ClassNotFoundException e) &#123; bindingCtor = findBindingConstructorForClass(cls.getSuperclass());//递归查找父类的构造器 &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException("Unable to find binding constructor for " + clsName, e); &#125; BINDINGS.put(cls, bindingCtor);//加入到缓存中 return bindingCtor;//返回构造器&#125; 以下为编译器生成的 MainActivity_ViewBinding 类，该类在构造方法中对那些在 MainActivity 中打了注解（例如：@BindView）的 View 进行了初始化。 12345678910111213141516171819202122232425262728293031public class MainActivity_ViewBinding implements Unbinder &#123; private MainActivity target;//目标类 private View view2131427444; private View view2131427442; private View view2131427443; @UiThread public MainActivity_ViewBinding(MainActivity target) &#123; this(target, target.getWindow().getDecorView()); &#125; @UiThread public MainActivity_ViewBinding(final MainActivity target, View source) &#123; this.target = target; View view; view = Utils.findRequiredView(source, R.id.btn, "field 'mBtn' and method 'onViewClicked'");//findViewbyId target.mBtn = Utils.castView(view, R.id.btn, "field 'mBtn'", Button.class);//强制类型转换 view2131427444 = view; view.setOnClickListener(new DebouncingOnClickListener() &#123;//注册监听器 @Override public void doClick(View p0) &#123; target.onViewClicked(p0); &#125; &#125;); target.mRadarView = Utils.findRequiredViewAsType(source, R.id.radar_view, "field 'mRadarView'", RadarView.class);//findViewbyId &#125; 这里插一个小话题：通常我们都会把不需要被外部使用到的成员变量声明为 private 的，但是回头看看我们使用 @BindView的 View 访问权限均为 defalut 。为什么呢？从 MainActivity_ViewBinding 的构造方法中可以看到对 View 进行赋值时直接使用了 target.mBtn、 target.mRadarView，如果声明为 private ，那就需要通过反射才能访问到对应的 View，这样会有性能上的损失。 小结在运行时以 ButterKnife#bind 方法作为入口，首先以目标 class 为 key 到缓存（一个 LinkedHashMap）中查找相应的 binding class，如果命中直接返回。如果没有缓存，则通过类加载器加载对应的 Xxx_ViewBinding 类，并将其加入到缓存中，然后返回。最后调用 Xxx_ViewBinding 类的构造器（通过反射）创建一个实例。Xxx_ViewBinding 类的构造器中完成了对 View 的绑定。比如 findViewById，setOnClickListener 编译期生成代码Q：前面提到的 MainActivity_ViewBinding 类是如何生成的呢？ Answer: 在编译时对类中的 Annotation 进行解析，通过 JavaPoet 生成相应的代码。 编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，由编译器自动解析。开发人员需要做的a. 自定义类继承自 AbstractProcessorb. 重写其中的 process 函数c. 注册注解处理器。注册完成后，编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理 自定义 Annotation 用于存储元数据以 BindView 注解为例 12345@Retention(CLASS) @Target(FIELD)public @interface BindView &#123; /** View ID to which the field will be bound. */ @IdRes int value();&#125; @Retention(CLASS) ：表示保留到编译期 @Target(FIELD)：表示作用域为成员变量 注解处理器 ButterKnifeProcessorButterKnifeProcessor 继承自 AbstractProcessor ，AbstractProcessor 的主要源码如下，我们主要关注四个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class AbstractProcessor implements Processor &#123; protected ProcessingEnvironment processingEnv; private boolean initialized = false; protected AbstractProcessor() &#123;//默认构造器 &#125; //获取支持的注解类型 public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; SupportedAnnotationTypes var1 = (SupportedAnnotationTypes)this.getClass().getAnnotation(SupportedAnnotationTypes.class);//获取支持的注解类型 if(var1 == null) &#123; if(this.isInitialized()) &#123;//如果已经初始化了，打印提醒 this.processingEnv.getMessager().printMessage(Kind.WARNING, "No SupportedAnnotationTypes annotation found on " + this.getClass().getName() + ", returning an empty set."); &#125; return Collections.emptySet();//返回空集 &#125; else &#123; return arrayToSet(var1.value());//返回支持的注解集合 &#125; &#125; public SourceVersion getSupportedSourceVersion() &#123;//获取支持的源码版本 SupportedSourceVersion var1 = (SupportedSourceVersion)this.getClass().getAnnotation(SupportedSourceVersion.class);//支持的源码版本 SourceVersion var2 = null; if(var1 == null) &#123; var2 = SourceVersion.RELEASE_6; if(this.isInitialized()) &#123; this.processingEnv.getMessager().printMessage(Kind.WARNING, "No SupportedSourceVersion annotation found on " + this.getClass().getName() + ", returning " + var2 + "."); &#125; &#125; else &#123; var2 = var1.value(); &#125; return var2; &#125; public synchronized void init(ProcessingEnvironment var1) &#123; if(this.initialized) &#123; throw new IllegalStateException("Cannot call init more than once."); &#125; else &#123; Objects.requireNonNull(var1, "Tool provided null ProcessingEnvironment"); this.processingEnv = var1; this.initialized = true; &#125; &#125; public abstract boolean process(Set&lt;? extends TypeElement&gt; var1, RoundEnvironment var2);&#125; init(ProcessingEnvironment env)：每个注解处理器都必须有个空的构造方法。不过，有一个特殊的 init 方法，它会被注解处理器工具传入一个 ProcessingEnvironment 作为参数来调用。ProcessingEnvironment 提供了一些有用的工具类，如 Elements，Types 和 Filter。我们后面会用到它们。 process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)：这个方法可以看做每个处理器的 main 方法。你要在这里写下你的扫描，判断和处理注解的代码，并生成 java 文件。通过传入的 RoundEnvironment 参数，你可以查询使用了某个特定注解的所有元素，我们稍后会看到。 getSupportedAnnotationTypes( )：这里你需要说明这个处理器需要针对哪些注解来注册。注意返回类型是一个字符串的 Set，包含了你要用这个处理器处理的注解类型的全名 getSupportedSourceVersion( )：用于指定你使用的 java 版本。通常会选择返回SourceVersion.latestSupported( )。当然，你也可以指定具体 java 版本：比如return SourceVersion.RELEASE_7; ButterKnife 的解析工作就是通过 ButterKnife#process 方法实现的。 123456789101112131415161718192021private Filer filer;//成员变量@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);//扫描并解析目标类，获取 存储绑定信息的 bindingMap。 //遍历获取到的注解 for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk);//使用 javaPoet 生成 java 文件 try &#123; javaFile.writeTo(filer);//调用 javaPoet 的方法，将内容写入文件 &#125; catch (IOException e) &#123; error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage()); &#125; &#125; return false; &#125;&#125; process 方法首先调用 findAndParseTargets 方法获取解析的目标类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); scanForRClasses(env); // 处理 @BindArray 元素. for (Element element : env.getElementsAnnotatedWith(BindArray.class)) &#123; if (!SuperficialValidation.validateElement(element)) continue; try &#123; parseResourceArray(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindArray.class, e); &#125; &#125;//代码省略 // 遍历处理每一个打了 @BindView 注解的元素 for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123; // 解析 BindView 注解 try &#123; parseBindView(element, builderMap, erasedTargetNames); &#125; catch (Exception e) &#123; logParsingError(element, BindView.class, e); &#125; &#125; // 处理每一个关联有监听器的注解 for (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123; findAndParseListener(env, listener, builderMap, erasedTargetNames); &#125; // Associate superclass binders with their subclass binders. This is a queue-based tree walk // which starts at the roots (superclasses) and walks to the leafs (subclasses). Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries = new ArrayDeque&lt;&gt;(builderMap.entrySet()); Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;(); while (!entries.isEmpty()) &#123; Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst(); TypeElement type = entry.getKey(); BindingSet.Builder builder = entry.getValue(); TypeElement parentType = findParentType(type, erasedTargetNames); if (parentType == null) &#123; bindingMap.put(type, builder.build()); &#125; else &#123; BindingSet parentBinding = bindingMap.get(parentType); if (parentBinding != null) &#123; builder.setParent(parentBinding); bindingMap.put(type, builder.build()); &#125; else &#123; // Has a superclass binding but we haven't built it yet. Re-enqueue for later. entries.addLast(entry); &#125; &#125; &#125; return bindingMap;//返回 bindingMap，用于后续 javapoet 生成代码 &#125; 上面的方法是以注解为单位，处理各个使用了注解的属性，然后将它们存放到一个 Map 中。（该 Map 以属性所在类为 key，以属性集 BindingSet.Builder 为 value）。那么具体是如何解析的呢？ 对于 ButterKnife 我们最常用的是 @BindView，针对 BindView 我们主要看 parseBindView 方法，该方法将使用了@BindView 的属性的绑定信息，存放到以该属性所在类为 key ，值为 BindingSet.Builder 的Map 中，供后续 javaPoet 生成代码使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames) &#123; TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();//获取该元素所在的类对应的元素。 // 检查常见的代码生成限制 boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element) || isBindingInWrongPackage(BindView.class, element); // 检查目标类型是否继承自 View TypeMirror elementType = element.asType(); if (elementType.getKind() == TypeKind.TYPEVAR) &#123; TypeVariable typeVariable = (TypeVariable) elementType; elementType = typeVariable.getUpperBound(); &#125; Name qualifiedName = enclosingElement.getQualifiedName();//获取全称 Name simpleName = element.getSimpleName();//获取简单名//代码省略……//如果不是接口而且不是 View 的子类，则打印错误信息，将 hasError 置为true if (hasError) &#123; return; &#125; // 下面开始拼接要绑定的属性的信息 int id = element.getAnnotation(BindView.class).value();//获取 R.id.xx BindingSet.Builder builder = builderMap.get(enclosingElement);//获取该属性所在的类的 builder QualifiedId qualifiedId = elementToQualifiedId(element, id);//从绑定记录中获取，如果相应的 id 已经被绑定过了，则报错，并打印相应的错误信息 if (builder != null) &#123; String existingBindingName = builder.findExistingBindingName(getId(qualifiedId)); if (existingBindingName != null) &#123; error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)", BindView.class.getSimpleName(), id, existingBindingName, enclosingElement.getQualifiedName(), element.getSimpleName()); return; &#125; &#125; else &#123; //创建一个 BindingBuilder builder = getOrCreateBindingBuilder(builderMap, enclosingElement); &#125; String name = simpleName.toString();//简单类名 TypeName type = TypeName.get(elementType);//获取该属性所在类的类名 boolean required = isFieldRequired(element); builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));//创建 Field 并添加到 BindingSet.Builder 的 field 中 // Add the type-erased version to the valid binding targets set. erasedTargetNames.add(enclosingElement); &#125; 假设我们在某一个类中重复绑定了相同的 id，比如下面这个例子对 R.id.app_bar_layout 进行了两次绑定： 1234@BindView(R.id.app_bar_layout)AppBarLayout mAppBarLayout;@BindView(R.id.app_bar_layout)//绑定了相同的 id，会报错AppBarLayout mAppBarLayout2; 在编译期会报如下错误： Error:(36, 18) 错误: Attempt to use @BindView for an already bound ID 2131230757 on &#39;mAppBarLayout&#39;. (com.android.rdc.librarysystem.MainActivity.mAppBarLayout2) 小结ButterKnife 是以这样的方式来处理注解的：ButterKnife 支持多种注解（比如 @BindView 、@BindColor），这些注解被按照一定的顺序处理。获取使用了某个注解的所有 Element，对该 Element 的进行处理，生成相应的 FieldXxxBinding 然后将它添加到该 Element 所在类的 BindingSet.Builder 中。 也就是说，ButterKnife 是以注解为单位进行解析，处理完了，就把它放到相应属性所在类对应的 Set 里面（而不是一次扫描一个类，然后对该类中属性使用到的注解进行处理，一次性生成某个类的所对应的 BindingSet.Builder ）。 通过 JavaPoet 生成 java 文件正如其名，poet 指诗人，也就是作诗的人。java poet 指的是能够自动写 java 源代码的库。 javapoet 里面常用的几个类： TypeName Java 系统的所有类型，加上 void 类型 MethodSpec 代表一个构造函数或方法声明。 TypeSpec 代表一个类，接口，或者枚举声明。 FieldSpec 代表一个成员变量，一个字段声明。 JavaFile包含一个顶级类的 Java 文件。 回到前面的 process 方法，可以看到 JavaFile javaFile = binding.brewJava(sdk); javaFile.writeTo(filer); BindingSet#brewJava 。该方法通过 Javapoet 生成一个 java 文件 12345JavaFile brewJava(int sdk) &#123; return JavaFile.builder(bindingClassName.packageName(), createType(sdk)) .addFileComment("Generated code from Butter Knife. Do not modify!")//添加文件注释 .build();&#125; 关于 javapoet 的介绍详见这篇文章 注解处理器的注册方法 1：使用 google 提供的注册处理器库最简单的方式是使用 google 提供的一个注册处理器的库。 compile &#39;com.google.auto.service:auto-service:1.0-rc2&#39; 然后@AutoService(Processor.class):向 javac 注册我们这个自定义的注解处理器，这样，在 javac 编译时，才会调用到我们这个自定义的注解处理器方法。 AutoService 这里主要是用来生成META-INF/services/javax.annotation.processing.Processor文件的。 方法 2：手动注册如果不使用上述处理库，那么，你需要自己进行手动配置进行注册，具体手动注册方法如下：1.创建一个META-INF/services/javax.annotation.processing.Processor 文件，其内容是一系列的自定义注解处理器完整有效类名集合，以换行切割： 123com.example.MyProcessorcom.foo.OtherProcessornet.blabla.SpecialProcessor 2.将自定义注解处理器和META-INF/services/javax.annotation.processing.Processor 打包成一个.jar 文件。所以其目录结构大概如下所示： 12345678MyProcessor.jar - com - example - MyProcessor.class - META-INF - services - javax.annotation.processing.Processor ButterKnife 使用的是第一种方式。 1234@AutoService(Processor.class)public final class ButterKnifeProcessor extends AbstractProcessor &#123; //...&#125; 总结ButterKnife 在编译的时候帮我们自动生成了绑定的代码，然后在运行的时候调用就行了。 首先我们在需要绑定 View 的 地方使用 @BindView 或者 ButterKnife 提供的其他注解，比如 @BindColor 在编译期 ButterKnifeProcessor 的 process 函数会被调用，在其中获取使用了相应注解的相关方法/成员变量信息，通过 javapoet 生成 Xx_ViewBinder 和 Xx_ViewBinding 类。 运行时，onCreate 方法中通常需要 ButterKnife.Bind()方法，从此处进入，通过 反射调用 Xx_ViewBinding 的构造方法对 View 进行初始化。 参考资料与学习资源推荐 公共技术点之 Java 注解 Annotation ButterKnife 源码分析 深入理解 ButterKnife，让你的程序学会写代码 javapoet——让你从重复无聊的代码中解放出来 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！]]></content>
      <categories>
        <category>源码分析</category>
        <category>框架原理</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>框架原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String StringBuilder与StringBuffer的区别]]></title>
    <url>%2Fblog%2F2017%2F09%2F21%2FString-StringBuilder%E4%B8%8EStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[概述 CharSequence 就是字符序列，String, StringBuilder 和 StringBuffer 本质上都是通过字符数组实现的。 String 字符串常量（不可变） StringBuffer 字符串变量（线程安全） StringBuilder 字符串变量（非线程安全） String 类型和 StringBuilder 类型的主要性能区别 String 是不可变的对象,因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，会进一步消耗性能。 StringBuilder 是可变的， 可以对 StringBuilder 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuilder ，特别是字符串对象经常改变的情况下。 通常 String 对象的字符串拼接其实是被 JVM 解释成了 StringBuilder 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuilder 对象慢。 特别是以下的字符串对象生成中，String 效率是远要比 StringBuffer 高的： 12String S1 = “This is only a” + “ simple” + “ test”;//直接拼接现有字符串StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”); 这其实涉及到了编译器的优化。在编译期，编译器会把字符串常量相加的情况直接变为拼接为目标字符串。也就是说编译之后就获得了目标字符串。 123String S1 = “This is only a” + “ simple” + “test”; //其实就是：String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。要注意的是，如果你的字符串是来自另外的 String 对象的话（比如下面所列举的这个例子），直接将 String 相加，性能上不会有什么提升。 1234String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 + S3 + S4; 这时候 JVM 会规规矩矩的按照原来的方式去做——先创建一个 StringBuilder 对象，然后再进行调用它的 append 方法对 字符串进行拼接。 StringBufferStringBuffer 是线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 主要操作:append 和 insert 方法，可重载这些方法，以接受任意类型的数据。 append 方法始终将这些字符添加到缓冲区的末端。 insert 方法则在指定的点添加字符。 例如:z 引用一个当前内容是“start”的字符串缓冲区对象，用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。 StringBuilderStringBuilder 是 Java5 新增的一个非线程安全的可变的字符序列。可以把它理解为 StringBuffer 的非线程安全版本，因为实际应用中很少有需要对字符串进行同步的情况，所以采用 StringBuilder 的性能更加。在不需要同步，优先采用 StringBuilder。 初始长度分为三种情况: 如果是调用的是无参构造函数，则默认容量为 16 如果指定了一个大于 0 的 capacity，则初始容量为 指定的 capacity 如果使用了参数类型为 CharSequence/String 的构造函数，则初始容量为CharSequence的长度 + 16。 扩容每次 append 的时候都会调用 ensureCapacityInternal ，当前长度 + append 内容总长度作为 minimumCapacity，如果 minimumCapacity 超过了 value 数组的长度，就将value 数组复制到长度为 newCapacity 的新数组， 一般情况下 newCapacity 大于 minimumCapacity 1234567891011121314/** * For positive values of &#123;@code minimumCapacity&#125;, this method * behaves like &#123;@code ensureCapacity&#125;, however it is never * synchronized. * If &#123;@code minimumCapacity&#125; is non positive due to numeric * overflow, this method throws &#123;@code OutOfMemoryError&#125;. */private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839/** * The maximum size of array to allocate (unless necessary). * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * Returns a capacity at least as large as the given minimum capacity. * Returns the current capacity increased by the same amount + 2 if * that suffices. * Will not return a capacity greater than &#123;@code MAX_ARRAY_SIZE&#125; * unless the given minimum capacity is greater than that. * * @param minCapacity the desired minimum capacity * @throws OutOfMemoryError if minCapacity is less than zero or * greater than Integer.MAX_VALUE * 返回一个至少跟 minCapacity 一样大的值。如果空间足够的话，当前的容量会增长一倍 +2 。 * 除非给定的值超过MAX_ARRAY_SIZE。否则返回的容量不会超过 MAX_ARRAY_SIZE。 */private int newCapacity(int minCapacity) &#123; // overflow-conscious code。防止溢出 int newCapacity = (value.length &lt;&lt; 1) + 2;//当前数组长度 * 2 + 2 if (newCapacity - minCapacity &lt; 0) &#123;//如果新长度 &lt; minCapacity，将新长度赋值为 minCapacity newCapacity = minCapacity; &#125; return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE - newCapacity &lt; 0) ? hugeCapacity(minCapacity)//检查溢出。如果溢出了，抛出错误。否则置为 MAX_ARRAY_SIZE : newCapacity;//长度在正常范围内，直接使用该长度&#125;private int hugeCapacity(int minCapacity) &#123; if (Integer.MAX_VALUE - minCapacity &lt; 0) &#123; // overflow throw new OutOfMemoryError(); &#125; return (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE;&#125; 参考资料与学习资源推荐 Class StringBuilder 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！]]></content>
      <categories>
        <category>java 基础</category>
      </categories>
      <tags>
        <tag>java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机类加载机制]]></title>
    <url>%2Fblog%2F2017%2F09%2F19%2FJVM%20%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[概述虚拟机的类加载机制：虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。 与那些在编译时需要进行连接工作的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的， 缺点：这种策略会令类加载时稍微增加一些性能开销 优点：为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类； 约定： 第一，在实际情况中，后文中直接对「类」的描述都包括了类和接口的可能性，而对于类和接口需要分开描述的场景会特别指明； 第二，「Class 文件」并非特指某个存在于具体磁盘中的文件，这里所说的「Class 文件」应当是一串二进制的字节流，无论以何种形式存在都可以。 类加载的时机七个阶段：如下所示 上图中，加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而==解析阶段则不一定==：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。注意，这里说的是按部就班地「开始」，这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。也就是说可能有些阶段未完成，下一个阶段就开始了。 什么情况下需要会开始加载一个类？Java 虚拟机规范中并没有进行强制约束。但是对于初始化阶段，虚拟机规范严格规定了有且只有 5 种情况必须立即对类进行「初始化」（而加载、验证、准备自然需要在此之前开始）： 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这 4 条指令的最常见的 Java 代码场景是： 使用 new 关键字实例化对象的时候、 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候， 以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 主动引用：以上 5 种场景中的行为称为对一个类进行主动引用。 被动引用：除了以上 5 种场景中的行为以外的对一个进行引用的行为。 对于静态字段，只有直接定义这个字段的类才会被初始化，所以通过一个类的子类来引用父类中定义的静态变量，只会触发父类的初始化，而不会触发子类的初始化。 通过数组定义来引用类，不会触发此类的初始化。 常量定义在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 在编译阶段通过常量传播优化实现 接口的加载过程与类加载过程稍有一些不同，接口也有初始化过程，这点与类是一致的，虽然接口中不能使用 static{}语句块，但编译器仍然会为接口生成 &lt;clinit&gt;()类构造器，用于初始化接口中所定义的成员变量。 接口与类真正有所区别的是前面讲述的 5 种「有且仅有」需要开始初始化场景中的第 3 种： 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。 类加载的过程加载「加载」是「类加载」（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下 3 件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。 虚拟机规范的这 3 点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。 一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的 loadClass()方法）。 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是==由 Java 虚拟机直接创建==的。 一个数组类（下面简称为 C）创建过程就遵循以下规则： 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（一个类必须与类加载器一起确定唯一性）。 如果数组的组件类型不是引用类型（例如 int[] 数组），Java 虚拟机将会把数组 C 标记为与引导类加载器关联。数组类的可见性与它的组件类型的可见性一致， 如果组件类型不是引用类型，那数组类的可见性将默认为 public。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个 java.lang.Class 类的对象（并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。 加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证为什么需要验证？ 虽然在编译时，编译器也会对 java 源码会对代码进行检查。但是 .class 文件并一定不要求用 java 源码编译来的，它可以使用任何途径生成，甚至可以用十六进制编辑器直接编写 class 文件。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃。所以验证是虚拟机对自身保护的一项重要工作。 验证什么？ 文件格式验证 元数据验证 字节码验证 符号引用验证 文件格式验证 是否以魔数 0xCAFEBABE 开头。 主、次版本号是否在当前虚拟机处理范围之内。 常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 …… 该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的 3 个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。 元数据验证第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求 这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。 这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。即，非抽象类是否实现了所有应该实现的方法？ 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 继承关系，方法覆盖 字节码验证第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的； 但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。 离散数学中一个很著名的问题「Halting Problem」（停机问题） ：通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。 符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。 符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： 符号引用中通过字符串描述的全限定名是否能找到对应的类。 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的*方法和字段。 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 准备准备阶段是正式为类变量分配内存并设置==类变量==初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。 其次，这里所说的初始值「通常情况」下是数据类型的零值 这时候尚未开始执行任何 Java 方法。 「==特殊情况==」：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值。 假设上面类变量 value 的定义变为：public static final int value=123； 那么在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，在 Class 文件中 符号引用 以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果有了直接引用，那引用的目标必定已经在内存中存在。 虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。 invokedynamic 指令的目的本来就是用于动态语言支持（目前仅使用 Java 语言不会生成这条字节码指令），它所对应的引用称为「动态调用点限定符」（Dynamic Call Site Specifier），这里「动态」的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。 相对的，其余可触发解析的指令都是「静态」的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。 1. 类或接口的解析假设当前代码所处的类为 D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，那虚拟机完成整个解析的过程需要以下 3 个步骤： 如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。 如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的描述符会是类似「[Ljava/lang/Integer」的形式，那将会按照第 1 点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式，需要加载的元素类型就是「java.lang.Integer」，接着由虚拟机生成一个代表此数组维度和元素的数组对象。 如果上面的步骤没有出现任何异常，那么 C 在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，检查访问权限。如果发现不具备访问权限，将抛出 java.lang.IllegalAccessError 异常。 字段解析类方法解析接口方法解析接口的方法、常量都是 public 的，所以不需要进行权限验证 初始化类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。 在准备阶段，变量已经赋过一次系统要求的初始值 在初始化阶段，根据项目需要对类变量进行相应的初始化，或者可以从另外一个角度来表达：初始化阶段是执行类构造器 () 方法的过程。 ()方法是由编译器自动收集类中的所有类变量的==赋值动作==和静态语句块（static{}块）中的语句合并产生的， 编译器收集的顺序是由语句在源文件中出现的顺序所决定的， 静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。 如果没有静态语句块也没有变量初始化赋值，就不会产生 方法 ()方法不需要显式地调用父类构造器，虚拟机会保证在子类的 ()方法执行之前，父类的()方法已经执行完毕。因此在虚拟机中第一个被执行的 ()方法的类肯定是 java.lang.Object。 接口与类一样都会生成 ()方法。但接口与类不同的是， 执行接口的 ()方法不需要先执行父接口的 ()方法。只有当父接口中定义的变量使用时，父接口才会初始化。 另外，接口的实现类在初始化时也一样不会执行接口的 ()方法。 虚拟机会保证一个类的 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的 ()方法中有耗时很长的操作，就可能造成多个进程阻塞。在实际应用中这种阻塞往往是很隐蔽的 类加载器类与类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器都拥有一个独立的命名空间。 双亲委派模型从 Java 虚拟机的角度来讲，只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现 ，是虚拟机自身的一部分； 另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度来看，绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器。 启动类加载器（Bootstrap ClassLoader）：这个类将器负责将存放在＜JAVA_HOME＞\lib 目录中的，或者被-Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 无法直接被用户使用，只能通过子类返回 null 来间接调用。 扩展类加载器：Extension ClassLoader，负责加载＜JAVA_HOME＞\lib\ext (扩展库)目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器：因为可以通过 ClassLoader.getSystemClassLoader() 获取，因此一般也称为系统类加载器，负责加载用户路径上所指定类库，可以直接被开发者使用。 上图中展示的层次关系，称为类加载器的双亲委派模型。 该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。 此处的父子关系通常不会通过继承关系来实现，而是选择组合关系来复用父加载器的代码 工作过程：当一个类加载器收到了类加载的请求时，它不是自己加载，而是将这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成该请求时，子加载器才会尝试自己去加载。 好处： Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。 保证 java 核心库的安全性（例如：如果用户自己写了一个 java.lang.String 类就会因为双亲委派机制不能被加载，不会破坏原生的 String 类的加载） 栗子： Object 类，无论哪一个类要加载该类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。 实现：在 ClassLoader 的 loadClass 方法中。 对比：代理模式： 与双亲委派机制相反，代理模式是先自己尝试加载，如果无法加载则向上传递。tomcat 就是代理模式。 「破坏」双亲委派模型双亲委派模型并不是一个强制性的约束模型。 双亲委派模型的第一次「被破坏」其实发生在双亲委派模型出现之前——即 JDK 1.2 发布之前。 双亲委派模型的第二次「被破坏」是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载） 基础类之所以称为「基础」，是因为它们总是作为被用户代码调用的 API，但是基础类调用回用户的代码不容易（用回调不行？？） 一个典型的例子便是 JNDI 服务 双亲委派模型的第三次「被破坏」是由于用户对程序动态性的追求而导致的，这里所说的「动态性」指的是当前一些非常「热门」的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U 盘，不用重启机器就能立即使用。热插拔？ 在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索： 将以 java.*开头的类委派给父类加载器加载。 否则，将委派列表名单内的类委派给父类加载器加载。 否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载。 否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。 否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。 否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。 否则，类查找失败。 一个问题写出下面代码中的输出结果 12345678910111213141516171819202122class SingleTon &#123; private static SingleTon singleTon = new SingleTon(); public static int count1; public static int count2 = 0; private SingleTon() &#123; count1++; count2++; &#125; public static SingleTon getInstance() &#123; return singleTon; &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; SingleTon singleTon = SingleTon.getInstance(); System.out.println("count1=" + singleTon.count1); System.out.println("count2=" + singleTon.count2); &#125;&#125; 分析: 从 main 函数看起，SingleTon singleTon = SingleTon.getInstance();调用了SingleTon类的静态方法，触发类的初始化。 类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值singleton=null count1=0,count2=0 类初始化，为类的静态变量赋值和执行静态代码块。singleton赋值为new SingleTon()。调用类的构造方法 调用类的构造方法后 count=1;count2=1 继续为count1与count2赋值,此时count1没有赋值操作,所有count1为1,但是count2执行赋值操作就变为0 小结加载加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 验证这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： 1public static int v = 8080; 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的putstatic指令是程序被编译后，存放于类构造器&lt;client&gt;方法之中，这里我们后面会解释。 但是注意如果声明为： 1public static final int v = 8080; 在编译阶段会为 v 生成ConstantValue属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。 解析解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的： CONSTANT_Class_info CONSTANT_Field_info CONSTANT_Method_info 等类型的常量。 下面我们解释一下符号引用和直接引用的概念： 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 初始化初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 初始化阶段是执行类构造器&lt;clint&gt;方法的过程。&lt;clint&gt;方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证&lt;clint&gt;方法执行之前，父类的&lt;clint&gt;方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成&lt;clint&gt;()方法。 注意以下几种情况不会执行类初始化： 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 Xxx[] ary = new Xxx[]; 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 参考资料与学习资源推荐 《深入理解 Java 虚拟机》 JVM 类加载机制详解 本文内容主要参考自《深入理解 Java 虚拟机》，当然也有一些个人理解，若有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合框架之 LinkedHashMap 工作原理]]></title>
    <url>%2Fblog%2F2017%2F09%2F17%2FJava-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8B-LinkedHashMap-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、不同类型 Map 的适用场景 如果需要使用的Map中的key无序，选择HashMap； 如果要求key有序，则选择TreeMap。 但是选择TreeMap就会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的， LinkedHashMap的出现就是为了平衡这些因素，使得 能够以O(1)时间复杂度增加查找元素，又能够保证key的有序性 此外，LinkedHashMap提供了两种key的顺序： 按照访问顺序排序（access order）。可以使用这种顺序实现LRU（Least Recently Used）缓存 因为每次访问后的元素会被移到链表尾部，实现 LRU 只需要移除 链首元素 即可 「一次访问」的定义是什么？ put，putIfAbsent，get，getOrDefault，compute，computeIfAbsent，computeIfPresent或merge方法会导致访问相应的条目（假设它在调用完成后存在）。如果值被替换，替换方法只会导致条目的访问 按照插入顺序排序（insertion orde）。注：同一key的多次插入，并不会影响其顺序。 注：WeakHashMap 也可以用于实现缓存，二者的使用场景不同。WeakHashMap无法像 LinkedHashMap 那样自定义淘汰规则，它的元素会在 gc 的发生的时候被清除。 特别地，对 collection-view 的操作不会影响后台映射的迭代顺序。 collection-view 是否类似于数据库的视图？ 二、性能LinkedHashMap 提供了所有可选的Map操作，并允许使用null元素。与HashMap一样，假设散列函数能够正确地在桶之间分散元素，它为基本操作（添加，包含和删除）提供了恒定的性能。性能可能略低于HashMap的性能，这是因为维护链接列表的成本增加了，但有一个例外：对LinkedHashMap的collection-view的迭代需要时间与 map 的size 成比，而不关其capacity。迭代HashMap可能会更加昂贵，需要的时间与其capacity成正比。 LinkedHashMap 有两个影响其性能的参数：初始容量和负载因子。它们的定义与HashMap完全相同。但请注意，对于此类，初始容量选择过高值对性能的影响不会像HashMap那么严重，因为此类的迭代时间不受容量影响，迭代只受到 size 的影响。 三、并发问题（fail-fast）并发方式：推荐使用 Map m = Collections.synchronizedMap(new LinkedHashMap(...));进行包装。内部是使用一个内置锁，各个方法的实现只是加锁然后 调用原来的类。这最好在创建时就完成「包装操作」，以防止意外的不同步访问Map。 结构性修改（A structural modification ） 是指 添加或删除一个或多个映射的操作， 在访问有序的LinkedHashMap的情况下会影响迭代顺序。 在插入有序的LinkedHashMap 中，仅更改与已包含在映射中的键相关的值不是结构修改。 在 access-ordered 模式下的 LinkedHashMap中，仅通过get查询map就是一种结构修改。 迭代遍历过程中如果发现结构性修改问题（使用 iterater#remove 方法产生的结构性修改问题除外 ），马上抛出ConcurrentModificationException，以免造成更大的损失。 「快速失败」具体实现是怎么样的呢？每趟遍历完成之后都会调用 checkForComodification 方法进行检查 java.util.ArrayList.Itr#checkForComodification 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 四、实现节点数据结构主要基于HashMap的节点数据结构实现。 1234567static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; //每个节点包含两个指针，指向前继节点与后继节点 Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 双向链表实现的LinkedHshMap，所以每个节点须在HashMap的基础上添加指向前继节点与后继节点指针：before，after。 核心方法HashMap 中定义了三个回调方法供 LinkedHashMap 重写。 1234// Callbacks to allow LinkedHashMap post-actionsvoid afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125;void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; LinkedHashMap继承于HashMap，重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。 1.afterNodeRemoval双向链表删除节点可以参考这样思路。 假设 before —&gt; p —&gt; after 要删除 p 1.先处理 after 方向if p 为第一个节点 before == null head = after else before.after = after 2.再处理 before 方向if p 为最后一个节点 after == null tail = beforeelse after.before = before; 12345678910111213void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; 2.afterNodeInsertion evict参数有什么用？ if false, the table is in creation mode. Creation mode 是什么？刚刚创建时的模式？ HashMap#的 put 方法，调用 putVal 方法时，传入的 evit 为 true。 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 调用处传递 evict 全部为 true。 1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; 3.afterNodeAccess与模式相关 final boolean accessOrder 只能在构造函数中指定，默认为 false， true 表示按访问顺序排序 false 表示按插入顺序排序 把节点移到链表末尾。 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123;//如果是按照访问顺序，并且 不是最后一个元素 LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 4.putput put函数在LinkedHashMap中未重新实现，只是实现了afterNodeAccess和afterNodeInsertion两个回调函数。 5.get12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; get函数重新实现并加入了afterNodeAccess来保证访问顺序 五、小结 怎样保证插入顺序？ 使用前驱和后继指针，使得原来的HashMap有序，在LinkedHashMap中覆盖HashMap中newNode 方法，使得每次put数据时，新建的节点都是LinkedHashMap.Entry&lt;K,v&gt; 类型的，比普通的HsahMap.Entry 多一个前驱结点和一个后继节点，使用前驱和后继保证插入有序。 怎么样保证访问顺序？ 覆盖父类HashMap的afterNodeAccess 方法，使得每次访问后，都改变链表顺序。使得原链表按访问排序。将最新一次访问的节点放到链表的最后。 六、参考资料与学习资源推荐 重识java-LinkedHashMap 官方文档 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 内存模型与线程浅析]]></title>
    <url>%2Fblog%2F2017%2F09%2F14%2FJava-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[硬件的效率与一致性多级缓存的作用：由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以为了提高处理器的利用率，现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 缓存虽然解决了速度差，但是也引入了新问题——缓存与主内存的数据一致性(Cache Coherence) 本文中「内存模型」一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化（即 指令重排序），处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致。 Java 语言规范要求 JVM 在线程中维护一种类似串行的语义：只要程序的最终结果与在严格串行环境中执行的结果相同，那么上述操作（指令重排序、增加高速缓存）都是允许的。 Java 内存模型主内存与工作内存以下所谈的变量(Variables)与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。 ~注~：如果局部变量是一个 reference 类型，它引用的对象在 Java 堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中，它是线程私有的。 Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中(此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分)。 每条线程还有自己的工作内存(Working Memory，可与前面讲的处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝 [4] 线程对变量的所有操作(读取、赋值等)都必须在==工作==内存中进行，而不能直接读写主内存中的变量。 干活要在操作线程中干。 这个对象的引用、对象中某个在线程访问到的字段是有可能存在拷贝的，但不会有虚拟机实现成把整个对象拷贝 A 一次。 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 内存间交互操作Java 内存模型中定义了以下 8 种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外。 lock、unlock read 从主存读取 load 加载 use 使用 assign 分配 store 存储 write 写回主存 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作， 如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。 注意，Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是==连续==执行。 Java 内存模型还规定了在执行上述 8 种基本操作时必须满足如下规则： 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 read 和 load、store 和 write 。工作内存与主内存之间有求必应。 不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 改了一定要让主内存知道。 不允许一个线程无原因地(没有发生过任何 assign 操作)把数据从线程的工作内存同步回主内存中。 没改就别瞎折腾。 一个新的变量只能在主内存中「诞生」，不允许在工作内存中直接使用一个未被初始化(load 或 assign)的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。 ​ 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。 锁了多少次，开多少次。 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。 没有锁不要乱开锁 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)。 做好手尾，再开锁。 这 8 种内存访问操作以及上述规则限定，再加上稍后介绍的对 volatile 的一些特殊规定，就已经完全确定了 Java 程序中哪些内存访问操作在并发下是安全的。 对于 volatile 型变量的特殊规则当一个变量定义为 volatile 之后，它将具备两种特性， 第一是保证此变量对所有线程的可见性，这里的「可见性」是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。 第二个语义是禁止指令重排序。 可见性 != 线程安全 volatile 变量在各个线程的工作内存中不存在一致性问题(在各个线程的工作内存中，volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)，但是 Java 里面的==运算并非原子操作==，导致 volatile 变量的运算在并发下一样是不安全的， 非原子操作会导致读取数据后，多个线程并行所进行操作的都是旧值。那么加载到主内存的值也就不是最新的了。 非原子操作 执行过程中是可以暂停的，暂停的那一段时间里其他线程可能修改了这个变量的值。 由于 volatile 变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用 synchronized 或 java.util.concurrent 中的原子类)来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束 volatile 性能某些情况下，volatile 的同步机制的性能确实要优于锁(使用 synchronized 关键字或 java.util.concurrent 包里面的锁)，但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为 volatile 就会比 synchronized 快多少。 volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求。 内存屏障内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。Java 编译器也会根据内存屏障的规则禁止重排序。内存屏障可以被分为以下 4 种类型 LoadLoad 屏障：对于这样的语句 Load1; LoadLoad 屏障; Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。 StoreStore 屏障：对于这样的语句 Store1; StoreStore 屏障; Store2，在 Store2 及后续写入操作执行前，保证 Store1 的写入操作对其它处理器可见。 LoadStore 屏障：对于这样的语句 Load1; LoadStore 屏障; Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。 StoreLoad 屏障：对于这样的语句 Store1; StoreLoad 屏障; Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。 有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java 编译器会在这种情况下不放置内存屏障。为了实现 JSR-133 的规定，Java 编译器会这样使用内存屏障： 对于 long 和 double 型变量的特殊规则允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定(Nonatomic Treatment ofdouble and long Variables)。 Java 内存模型「强烈建议」虚拟机把这些操作实现为具有原子性的操作。目前各种商用虚拟机也都是将它们实现为原子操作，因此我们在编写代码时==一般不需要==把用到的 long 和 double 变量专门声明为 volatile。 原子性、可见性与有序性原子性原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。 由 Java 内存模型直接保证的原子性变量操作包括 read、load、assign、use、store 和 write，我们大致可以认为基本数据类型的访问读写是具备原子性的(例外就是 long 和 double 的非原子性协定)。 尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter 和 monitorexit 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性。 可见性可见性(Visibility)：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 除了 volatile 以外，Java 还有两个关键字能实现可见性，即 synchronized 和 final。 同步块的可见性是由「对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store、write 操作)」这条规则获得的， final 关键字的可见性是指：保证一个对象的构建方法结束前，所有 final 成员变量都必须完成初始化（前提是没有 this 引用溢出）。在构造器中一旦初始化完成，并且构造器没有把「this」的引用传递出去，那在其他线程中就能看见 final 字段的值。 this 引用逃逸 是指在构造函数返回之前其他线程就持有该对象的引用。调用尚未构造完全的对象的方法可能引发令人疑惑的错误, 因此应该避免 this 逃逸的发生。 例子：在构造函数中启动线程 / 注册监听器/ 创建匿名内部类。 有序性如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指「线程内表现为串行的语义」(Within-Thread As-If-Serial Semantics)，后半句是指「指令重排序」现象和「工作内存与主内存同步延迟」现象。 先行发生原则先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据。 先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。所谓偏序关系可以这样理解：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。 123456//以下操作在线程 A 中执行i=1；//以下操作在线程 B 中执行j=i；//以下操作在线程 C 中执行i=2； 假设 A B C 之间满足 Happens-Before 条件，且 A Happens-Before B Happens-Before C，那么执行结果就是 j = 1; i = 2; 这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。 程序次序规则(Program Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。 管程锁定规则(Monitor Lock Rule)：一个 unlock 操作先行发生于后面对同一个锁的 lock操作。这里必须强调的是同一个锁，而「后面」是指时间上的先后顺序。 volatile 变量规则(Volatile Variable Rule)：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的「后面」同样是指时间上的先后顺序。 线程启动规则(Thread Start Rule)：Thread 对象的 start()方法先行发生于此线程的每一个动作。 线程终止规则(Thread Termination Rule)：线程中的所有操作必须在其他线程检测到该线程已经结束之前完成，我们可以通过 Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则(Thread Interruption Rule)：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted()方法检测到是否有中断发生。 对象终结规则(Finalizer Rule)：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()方法的开始。 传递性(Transitivity)：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。 Java 无需任何同步手段就能成立的先行发生规则就以上 8 点。看上去有些抽象，想要进一步了解的同学可以参考下这篇文章 从Java多线程可见性谈Happens-Before原则 ==时间先后顺序与先行发生原则之间基本没有太大的关系==，所以我们衡量并发安全问题的时候==不要受到时间顺序的干扰，一切必须以先行发生原则为准==。 这句话应该如何理解呢？ 考虑这样一个场景： 123456789private int value = 0;//线程 A 先（时间上）调用了 getValue 方法public int getValue() &#123; return value;&#125;//之后（时间上）线程 B 调用了 setValue(2) 方法public void setValue(int value) &#123; this.value = value;&#125; 但是线程 A 的 getValue 获取的结果是什么呢？可能是 0 ，也可能是 2。也就是说，没有进行同步处理的情况下，不同线程对在时间上先后对调用对某个共享变量的操作，并不能保证它们的结果是根据它们在时间上调用顺序确定的。换句话说，在不同线程之间，「时间上的先调用」并不代表「先行发生」。要解决这个问题，可以给 getValue 和 setValue 方法都定义为 synchronized 的，因为这样就可以套用「管程锁定原则」了。或者将 value 定义了 volatile 变量，因为 setValue 方法对 value 的修改不依赖 value 的原值，满足 volatile 关键字使用场景，这样就可以套用 volatile 变量规则来实现先行发生规则了。 通过上面的讨论，我们可以得出结论：一个操作「时间上的先发生」不代表这个操作会会是「先行发生」。那么一个操作「先行发生」是否能推导出这个操作必定是「时间上先发生」呢？这个推论也是不成立的，一个典型的栗子就是「指令重排序」 12int i = 2;int j = 1; 按照程序次序规则，int i = 2; 的操作先行发生与 int j = 1;,但是 int j = 1; 完全可能先执行，这并不影响先行发生原则的正确性，因为在同一条线程中无法感知到这点。 先行发生原则的真正意义该段内容参考自从Java多线程可见性谈Happens-Before原则 从上面的分析中我们可以看出，Happens-Before原则致力于解决变量间可见性问题。但是它是如何解决的呢？ 导致多线程间变量间可见性问题的根源在于 CPU 缓存以及指令重排序。那么，要解决这个可见性问题，一个最简单粗暴的方法就是禁止所有的重排序和 CPU 缓存。即关闭所有的编译器、操作系统和处理器的优化，这样所有的指令顺序全部按照程序代码书写的顺序执行。去掉 CPU 高速缓存，让 CPU 每次读写操作都直接与主存交互。 但是，如此粗暴的解决方案是不可取的，因为这会极大影响处理器的计算性能，并且对于那些非多线程共享的 变量是极不公平的。我们可以采用一种折中的方案来解决 CPU 高速缓存与指令重排带来的数据一致性问题。使用分割线把整个程序划分为几个程序块，在每个程序块内部的指令是可重排序的，但是分割线上的指令与程序块其他指令之间是不可以重排序的。在一个程序块内部，CPU 不用每次都与主内存进行交互，只需要在 CPU 缓存中执行读写操作即可，但是当程序执行到分割线出，CPU 必须将执行结果同步到主内存或者从主内存读取最新的变量值，那么 Happen-before 规则就是定义了这些程序块的分割线。 如图所示，这里的unlock M和lock M就是划分程序的分割线。在这里，红色区域和绿色区域的代码内部是可以进行重排序的，但是 unlock 和 lock 操作是不能与它们进行重排序的。即第一个图中的红色部分必须要在unlock M指令之前全部执行完，第二个图中的绿色部分必须全部在lock M指令之后执行。并且在第一个图中的unlock M指令处，红色部分的执行结果要全部刷新到主存中，在第二个图中的lock M指令处，绿色部分用到的变量都要从主存中重新读取。 在程序中加入分割线将其划分成多个程序块，虽然在程序块内部代码仍然可能被重排序，但是保证了程序代码在宏观上是有序的。并且可以确保在分割线处，CPU一定会和主内存进行交互。Happens-Before原则就是定义了程序中什么样的代码可以作为分割线。并且无论是哪条Happens-Before原则，它们所产生分割线的作用都是相同的。 Java 与线程线程的实现(广义)实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。 Thread 类与大部分的 Java API 有显著的差别，它的所有关键方法都是声明为 Native 的。在 Java API 中，一个 Native 方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现(当然也可能是为了执行效率而使用 Native 方法，不过，通常最高效率的手段也就是平台相关的手段)。 1.内核线程实现内核线程(Kernel-Level Thread,KLT)就是直接由操作系统内核(Kernel，下称内核)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。 程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程(Light Weight Process,LWP)，轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。 系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间)，因此一个系统支持轻量级进程的数量是有限的。 1:1 2.使用用户线程实现从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程(User Thread,UT)，因此，从这个定义上来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知用户线程存在的实现。 现在使用用户线程的程序越来越少了，Java、Ruby 等语言都曾经使用过用户线程，最终又都放弃使用它。 3.使用用户线程加轻量级进程混合实现线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为 N：M 的关系 线程调度主要调度方式有两种，分别是协同式线程调度(Cooperative Threads-Scheduling)和抢占式线程调度(Preemptive Threads-Scheduling)。 如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。 优点：实现简单，不用考虑同步问题。 缺点：不稳定，前面一个线程执行出现问题，那么后面的线程都会受到影响。 如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。 优点：相对于协同式调度而言，较为稳定。 缺点：可控性不是很高，因为线程的优先级不是很靠谱；虽然 Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法。 目前 Java 使用的线程调度方式就是抢占式调度。JDK 后续版本中有可能会提供协程(Coroutines)方式来进行多任务处理 为什么说线程优先级并不是太靠谱？因为 Java 的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与 Java 线程的优先级一一对应。 线程的状态转换图片参考自这篇文章 创建 (New) 运行，两种子状态 Running 正在执行 Ready 等待着 CPU 给它分配执行时间。 等待 (Waiting) 无限期等待 没有设置 Timeout 参数的 Object.wait()方法。 没有设置 Timeout 参数的 Thread.join()方法。 LockSupport.park()方法。 有限期等待 (Timed Waiting) Thread.sleep()方法。 设置了 Timeout 参数的 Object.wait()方法。 设置了 Timeout 参数的 Thread.join()方法。 LockSupport.parkNanos()方法。 LockSupport.parkUntil()方法。 阻塞 (Blocked) 「阻塞状态」与「等待状态」的区别是：「阻塞状态」在等待着获取到一个互斥锁(排它锁)，这个事件将在另外一个线程放弃这个锁的时候发生；而「等待状态」则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 结束 (Terminated) 相关方法介绍调用 sleep、join 时，不会释放所占用的资源，会进入阻塞状态；调用 wait 时，会释放所占用的资源，会进入等待队列。 sleep 方法线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态 。sleep() 中指定的时间是线程不会运行的最短时间。因此，sleep() 方法不能保证该线程睡眠到期后就开始执行。 sleep()是静态方法，只能控制当前正在运行的线程。 wait 方法因为 wait() 方法会释放锁，所以必须要在 synchronized 块中调用（也就是要先拿到锁，不然就没有锁可以是释放了）。 join 方法join() 导致线程栈发生了变化，当然这些变化都是瞬时的。 join() 方法有带超时限制的重载版本。 例如 t.join(5000);则让线程等待 5000 毫秒，如果超过这个时间，则停止等待，变为可运行状态。 yield 方法yield() 方法会停止当前线程（使之进入可运行状态），让同等优先权的线程运行。如果没有同等优先权的线程，那么 yield() 方法将不会起作用。 实际中无法保证 yield() 达到让步目的，因为让步的线程(回到可执行状态)还有可能被线程调度程序再次选中。 简记：硬件效率与一致性因为处理器需要读取和返回数据，所以需要存储器。而存储器的速度与处理器的运算速度相差几个数量级。所以引入了缓存，引入缓存的同时也引入了主存与缓存中的数据一致性问题。 为了充分利用处理器的运算能力，除了引入缓存以外，处理器可能还会对输入的代码进行来乱序执行(不影响结果)。JVM 的即时编译器中也有类似于指令重排的优化。 工作内存与主内存每条线程有自己的工作内存，工作内存是线程私有的，如果要交换必须通过主内存。若要把二者与 Java 中的内存区域对应起来，则工作内存像对应虚拟机栈中的部分区域，主内存对应于堆中的对象实例数据部分。 虚拟机可能会让工作内存优先存储在寄存器或者高速缓存中，因为程序运行时主要访问读写的是工作内存 。 内存间的交互操作(lock)read load use assign store write(unlock) 一个变量在同一时刻只能被某一个线程 lock。但是该线程可以对这个变量 lock 多次。 某些操作必须成对出现，比如 read 与 load 、store 与 write。 对某个变量执行了 assign 操作，必须把它同步回主内存。 volatile 关键字保证可见性、禁止指令重排。 无法保证一致性。以多线程修改变量自增为例，当线程 A 读取了该变量(此时变量的值是正确的)但是还未进行 +1 操作，此变量的值被线程 B 执行了 +1 操作(更新后会通知所有线程，但是由于 线程 A 已经读取过该值了但是由还没有进行赋值操作，所以不会得到最新的值)，但是之后线程 A 会对旧值进行自增操作，导致结果错误。 注：i++ 由 4 条字节码指令构成。从字节码层面解释：当 getStatic 指令把 race 的值(进行自增操作的变量)读取到操作栈顶时，volatile 保证 race 的值在此时是正确的，但是在执行 iconst_1、add 这些指令时，其他线程可能已经把 race 的值加大了，而在操作栈顶的值就变成了过期的数据，所以 putStatic 指令执行后就可能把较小的 race 值同步回主内存中。 在不符合以下两条规则的运算场景中，仍然要通过加锁来保证原子性。 运算结果不依赖变量当前的值 or 只要单一的线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束。 普通变量只保证「结果正确」，volitale 变量还保证「程序正确」 「程序正确」指的是按照顺序执行 参考资料与学习资源推荐 《深入理解 Java 虚拟机》 Java 内存访问重排序的研究 线程状态的转换 从Java多线程可见性谈Happens-Before原则 若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>jvm</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程安全与锁优化]]></title>
    <url>%2Fblog%2F2017%2F09%2F11%2FJava%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.线程安全当我们谈线程安全的时候，我们谈些什么？ 先看看「线程安全」的定义： 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。 1.1 Java 语言中的线程安全可将 Java 语言中的各种操作共享的数据分为以下 5 类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 1. 不可变只要一个不可变对象被正确地构建出来（没有 this 引用逃逸的情况），那么其外部的可见状态永远也不会改变。 final + 基本数据类型，则该变量为不可变变量final + 对象，无法保证对象是不可变的 如何保证对象的行为不会对其状态产生任何影响？最简单的就是将对象中带有状态的变量都声明为 final。 Java API 中属于不可变的类有以下几种： String 基础数据类型包装类 BigInteger BigDecimal 注意：同为 Number 的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。因为它们都有 set 方法，可以改变对象的状态。 2. 绝对线程安全绝对线程安全的定义是很严格的。Java API 中标注自己的是线程安全的类，大多数都不是绝对的线程安全。 栗子：Vector 123456789101112131415161718192021222324252627282930313233package jvm.ch13;import java.util.Vector;public class VectorTest &#123; private static Vector&lt;Integer&gt; sIntegerVector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; sIntegerVector.add(i); &#125; Thread removeThread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; sIntegerVector.size(); i++) &#123; sIntegerVector.remove(i); &#125; &#125;); Thread printThread = new Thread(() -&gt; &#123; for (int i = 0; i &lt; sIntegerVector.size(); i++) &#123; System.out.println(sIntegerVector.get(i)); &#125; &#125;); removeThread.start(); printThread.start(); while (Thread.activeCount() &gt; 20) &#123; &#125; &#125; &#125;&#125; 以上代码可能会报 ArrayIndexOutOfBoundException 因为可能出现一个线程恰好在一个错误的时间删除了一个元素，导致 i 元素已经不再可用，另一个线程访问了 i 元素。（比如：get(i) 进入等待锁期间，remove(i) 刚好执行完了）。 解决：操作时加上锁，使得复合操作变为原子操作。 原子操作与复合操作简介： 原子操作：不可分割的操作，要么成功要么失败。 复合操作：可分割的操作，可能出现数据失效的问题。 1234567891011121314Thread removeThread = new Thread(() -&gt; &#123; synchronized (sIntegerVector) &#123;//加上锁使之成为原子操作 for (int i = 0; i &lt; sIntegerVector.size(); i++) &#123; sIntegerVector.remove(i); &#125; &#125;&#125;);Thread printThread = new Thread(() -&gt; &#123; synchronized (sIntegerVector) &#123; for (int i = 0; i &lt; sIntegerVector.size(); i++) &#123; System.out.println(sIntegerVector.get(i)); &#125; &#125;&#125;); 为什么是使用 Vector 对象作为锁？因为 Vector 内部是使用自带的锁来实现的。 3. 相对线程安全即通常意义上所讲的线程安全。它需要保证对这个对象单独操作是线程安全的，调用时就不需要做额外的保障措施。 对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 Java API 中大部分线程安全的类都属于这种类型： Vector，HashTable，Collections.sychronizedCollection() 4. 线程兼容也就是平常所说的线程不安全类。对象本身并不安全，但是可以通过在调用端正确地使用同步手段来保证对象子啊并发环境中可以安全地使用。 比如：ArrayList、HashKMap 5. 线程对立在调用端是否使用同步手段都无法再多线程环境下使用。 这种排斥多线程代码很少出现。 线程安全的实现方法线程安全的实现方法主要有以下几种：互斥同步、非阻塞同步、无同步方案。 1. 互斥同步「互斥同步」的意思是通过互斥来实现同步。同步是指在多个线程并发访问共享数据的时候，保证共享数据在同一时刻只能有一个（或者一些，使用信号量的时候）线程使用。临界区、互斥量、信号量都是主要的互斥实现方式。 最基本的互斥同步实现方法就是使用 synchronized 关键字。synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter、monitorexit 两条指令。根据虚拟机规范的要求， 在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1， 在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。 上述描述中有两点是需要特别注意的。 首先，synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。 其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。 Java 的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。 除了 synchronized 之外，我们还可以使用 java.util.concurrent（简称 J.U.C）包中的重入锁（ReentrantLock）来实现同步，在基本用法上，ReentrantLock 与 synchronized 很相似，他们都具备一样的线程重入特性，不同点表现在代码写法上 一个表现为 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成）， 另一个表现为原生语法层面的互斥锁。 相比 synchronized,ReentrantLock 增加了一些高级功能，主要有以下 3 项： 等待可中断,如果持有锁的线程长时间不释放锁，正在等待的线程可以选择放弃等待，改为处理其他事情。 公平锁 多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁; 非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。 synchronized 中的锁是非公平的， ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 锁可以绑定多个条件 一个 ReentrantLock 对象可以同时绑定多个 Condition 对象 而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁。 ReentrantLock 还是 synchronized？关于性能：Java 1.6 发布之后，synchronized 与 ReentrantLock 的性能基本上是完全持平了。因此，Java 1.6 或以上，性能因素就不再是选择 ReentrantLock 的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized。 因此在不需要用到 ReentrantLock 三个特性的情况下，优先考虑使用 synchronized 来进行同步。 2. 非阻塞同步互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题。 基于冲突检测的乐观并发策略，通俗地说，就是先进行操作， 如果没有其他线程争用共享数据，那操作就成功了； 如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。 为什么说使用乐观并发策略需要 “硬件指令集的发展” 才能进行呢？ 因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。 这类指令常用的有： 测试并设置（Test-and-Set）。 获取并增加（Fetch-and-Increment）。 交换（Swap）。 ==比较并交换（Compare-and-Swap，下文称 CAS==）。 加载链接/条件存储（Load-Linked/Store-Conditional，下文称 LL/SC）。 Java 1.5 之后，Java 程序中才可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 compareAndSwapInt()和 compareAndSwapLong() 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令。 CAS 指令需要有 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。 Unsafe 类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的 Class 才能访问它），因此，如果不采用反射手段，我们只能通过其他的 Java API 来间接使用它。 如 J.U.C（java.util.concurrent） 包里面的整数原子类，其中的 compareAndSet()和 getAndIncrement()等方法都使用了 Unsafe 类的 CAS 操作。 12345678public final int incrementAndGet()&#123; for（;;）&#123; int current = get()； int next = current+1； if（compareAndSet（current,next）） return next； &#125;&#125; CAS 存在的问题： 无法涵盖互斥同步的所有使用场景 存在==ABA 问题==，值改了但是自己却不知道。 怎么解决？ 加入引用计数。 加入修改记录 可重入代码（Reentrant Code）：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码的一些共同的特征： 不依赖存储在堆上的数据和公用的系统资源、 用到的状态量都由参数中传入、 不调用非可重入的方法等。 判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，也就是说只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。 3. 无同步方案一个数据的可见范围局限在同一个线程之内， 不会存在多线程竞争问题，也就不需要进行同步了。 如果一个变量要被某个线程独享，Java 中可以通过 java.lang.ThreadLocal 类来实现线程本地存储的功能。每一个线程的 Thread 对象中都有一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值，使用这个值就可以在线程 K-V 值对中找回对应的本地线程变量。 2. Java 中锁的分类与优化可重入锁又称为「递归锁」，指的是当同一个线程的外层方法获取锁时，进入内层方法会自动获取锁。 可重入锁的一个好处就是可以在一定程度上避免死锁。 123456synchronized void setA() throws Exception &#123; Thread.sleep(1000); synchronized(this) &#123; Thread.sleep(1000); &#125;&#125; 独享(占)锁/共享锁根据能够同时被多少线程持有来区分。 独享锁就是指该锁一次仅能被一个线程所持有。 共享锁可以同时被多个线程持有。 互斥锁/读写锁上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。 互斥锁：在 Java 中的具体就是 ReentrantLock 读写锁：在 Java 中的具体实现就是 ReadWriteLock。其读锁是共享锁，其写锁是独享锁。 读锁的共享可保证高效并发。 读写、写读、写写的过程是互斥的 独享锁与共享锁也是使用 AQS 来实现的。通过实现不同的方法来实现独享或者共享。 乐观锁/悲观锁并不是指具体类型的锁，而是指看待并发同步的态度。 悲观锁采用一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁不能解决脏读的问题。 二者之间如何选择选择？首先要弄清楚，事实是悲观的还是乐观的？ 假如你的资源竞争很激烈，并且无法共享的话，乐观锁不过是让大量请求的希望落空罢了。——如果事实是悲观的，但是采用了乐观锁，那就只会导致大量请求落空罢了。 假如你的资源没什么竞争（这个和并发高低没必然的关联，业务的影响更大），那悲观锁意味着不必要地加锁。如果原本是可共享的资源（比如资源支持多个只读方），那么悲观锁意味着失去原本的可以使用的时间。——如果事实是乐观的，但是使用了悲观锁，那么就损失一些本来可以使用的时间。 再详细点可以从以下几个方面来判断： 响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。 冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。 重试代价：如果重试代价大，建议采用悲观锁。 以上内容参考自高并发下悲观锁与乐观锁的选择问题 分段锁分段锁其实是一种锁的设计，并不是具体的一种锁。 我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为 Segment，它即类似于 HashMap（Java7 与 Java8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表；同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock)。当需要 put 元素的时候，并不是对整个 hashmap 进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。 但是，在统计 size 的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 偏向锁/轻量级锁/重量级锁这三种锁是指锁的状态，并且是针对Synchronized 的。在 Java1.5 通过引入锁升级的机制来实现高效的Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。 偏向锁：当一段同步代码总是被一个线程访问的时候， 那么该线程就会自动获取锁，降低获取锁的代价。如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。偏向锁的“偏”，意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。 轻量级锁：当锁是偏向锁时（因为经常被一个线程访问），当另外一个线程需要访问相应的同步代码段时，偏向锁会升级为轻量级锁，其他线程会通过自旋的方式尝试去获取锁，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 重量级锁：自旋达到一定次数之后，就会膨胀为重量级锁。重量级锁会使其他申请线程进入阻塞状态。 错误观点：锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。具体可以参考下这篇文章 锁的升级： 偏向锁的实现假设当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中， 如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如 Locking、Unlocking 及对 Mark Word 的 Update 等）。 当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。 根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态， 后续的同步操作就如上面介绍的轻量级锁那样执行。 图片参考自聊聊并发（二）——Java SE1.6中的Synchronized 轻量级锁轻量级锁的加锁过程在代码进入同步块的时候， 如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），这时候线程堆栈与对象头的状态如图 13-3 所示。 然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后 2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如下图所示。 如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧， 如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行， 否则说明这个锁对象已经被其他线程抢占了。 如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 图片参考自聊聊并发（二）——Java SE1.6中的Synchronized 轻量级锁的解锁过程解锁过程也是通过 CAS 操作来进行的 如果对象的 Mark Word 仍然指向着线程的锁记录，那就用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来， 如果替换成功，整个同步过程就完成了。 如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。（如何唤醒？ notify() ） 轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。 如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销， 如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在==有竞争的情况下，轻量级锁会比传统的重量级锁更慢==。 锁的优缺点对比 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 适用于只有一个线程访问同步块场景 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度 如果始终得不到锁竞争的线程使用自旋会消耗 CPU 追求响应时间,锁占用时间很短 重量级锁 线程竞争不使用自旋，不会消耗 CPU 线程阻塞，响应时间缓慢 追求吞吐量,锁占用时间较长 自旋锁在 Java 中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。典型的自旋锁实现的例子，可以参考自旋锁的实现 如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。这样可以避免线程挂起和恢复(挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力)，从而降低性能开销。 自旋次数的默认值是 10 次，用户可以使用参数-XX：PreBlockSpin 来更改。 在 Java 1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 锁消除锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 锁消除的主要判定依据来源于逃逸分析的数据支持（第 11 章已经讲解过逃逸分析技术），如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。 举个栗子： 1234567public String concatString（String s1，String s2，String s3）&#123; StringBuffer sb = new StringBuffer()； sb.append（s1）; sb.append（s2）; sb.append（s3）; return sb.toString()；&#125; 每个 StringBuffer.append()方法中都有一个同步块，锁就是 sb 对象。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString()方法内部。sb 的所有引用永远不会“逃逸”到 concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。 锁粗化原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为使得需要同步的操作数量尽可能变小。 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。 1234567public String concatString（String s1，String s2，String s3）&#123; StringBuffer sb=new StringBuffer()； sb.append（s1）； sb.append（s2）； sb.append（s3）； return sb.toString()；&#125; 上面连续的 append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以上述代码为例，就是扩展到第一个 append()操作之前直至最后一个 append()操作之后，这样只需要加锁一次就可以了。 参考资料与学习资源推荐 乐观锁的一种实现方式——CAS Java 中的锁分类 Java多线程（七）之同步器基础：AQS框架深入分析 高并发下悲观锁与乐观锁的选择问题 聊聊并发（二）——Java SE1.6中的Synchronized 《深入理解 Java 虚拟机》 如果本文中存在不正确的说法，请提出，共同讨论，共同进步，谢谢！]]></content>
      <categories>
        <category>并发</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合框架之 HashMap 工作原理]]></title>
    <url>%2Fblog%2F2017%2F09%2F10%2FJava%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8B%20HashMap%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[概要概括的说，HashMap 是一个关联数组、哈希表，它是线程不安全的，允许key 为 null,value 为 null。遍历时无序。其底层数据结构是数组称之为哈希桶，每个桶里面放的是链表，链表中的每个节点，就是哈希表中的每个元素。在 JDK8 中，当链表长度达到 8，会转化成红黑树，以提升它的查询、插入效率，它实现了Map&lt;K,V&gt;, Cloneable, Serializable接口。 因其底层哈希桶的数据结构是数组，所以也会涉及到扩容的问题。 当HashMap的容量达到threshold域值时，就会触发扩容。扩容前后，哈希桶的长度一定会是 2 的次方。这样在根据 key 的 hash 值寻找对应的哈希桶时，可以用位运算替代取余操作，更加高效。 而 key 的 hash 值，并不仅仅只是 key 对象的hashCode()方法的返回值，还会经过扰动函数的扰动，以使 hash 值更加均衡。因为hashCode()是int类型，取值范围是 40 多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。 但就算原本的hashCode()取得很好，每个 key 的hashCode()不同，但是由于HashMap的哈希桶的长度远比 hash 取值范围小，默认是 16，所以当对 hash 值以桶的长度取余，以找到存放该 key 的桶的下标时，由于取余是通过与操作完成的，会忽略 hash 值的高位。因此只有hashCode()的低位参加运算，发生不同的 hash 值，但是得到的 index 相同的情况的几率会大大增加，这种情况称之为hash 碰撞。 即，碰撞率会增大。 扰动函数就是为了解决 hash 碰撞的。它会综合 hash 值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少 hash 碰撞的概率。（在 JDK8 之前，扰动函数会扰动四次，JDK8 简化了这个操作） 执行扩容操作时，会 new 一个新的Node数组作为哈希桶，然后将原哈希表中的所有数据(Node节点)移动到新的哈希桶中，相当于对原哈希表中所有的数据重新做了一个 put 操作。所以性能消耗很大，可想而知，在哈希表的容量越大时，性能消耗越明显。 扩容时，如果发生过哈希碰撞，节点数小于 8 个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位= low 位+原哈希桶容量如果追加节点后，链表数量》=8，则转化为红黑树 由迭代器的实现可以看出，遍历 HashMap 时，顺序是按照哈希桶从低到高，链表从前往后，依次遍历的。属于无序集合。 实现两个重要的参数 An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets. capacity：容量。也就是哈希桶数组的长度。默认初始化容量为 16。 loadFactor：加载因子。 扩容的阈值 threshold = capacity * loadFactor 加载因子默认为 0.75，这是时间和空间上的折衷点。大于 0.75，能提高空间利用率，但是会导致查找效率降低。 当 hashMap 中元素的总数大于 capacity * loadFactor 时，就会发生扩容（将 buckets 的数目调整为当前的两倍）。 capacity 被控制为 2 的 n 次方（一定是合数），这有点不合常规。常规的做法是将桶数组的长度设置为素数，因为相对而言使用素数发生冲突的概率要比使用合数要小一些。HashTable 默认初始化容量就为 11（素数，Hashtable 扩容后不能保证还是素数）。之所以这样设计是取模和扩容时进行优化（使用位运算提高效率），同时也是为了减少冲突，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。 put 函数的实现1.8 对 HashMap 的底层实现进行了修改（当相同 hash 值的元素大于 8 个时，会将链表转换为 红黑树，以提高查找效率），所以 put 函数看起来相对复杂了点，通过以下流程图能帮助理解。 图片出自这篇文章。 注意：对于 resize 方法的是否需要执行有两次判断： 第一次判断桶数组是否为空，如果为空，则通过 resize 方法执行初始化操作。第二次判断是在插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。 put 方法具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 将指定的值与该映射中指定的键关联起来。 * 如果该 key 对应的 value 存在，则替换旧值 * */public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; java.util.HashMap.Node&lt;K,V&gt;[] tab; java.util.HashMap.Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)//桶数组为空或者长度为 0（说明还未初始化） n = (tab = resize()).length;//调用扩容方法进行初始化，并获取初始化后桶数组的长度 if ((p = tab[i = (n - 1) &amp; hash]) == null)//根据 hash 值与 n-1 进行「模运算」获取插入数组的索引的 i。 tab[i] = newNode(hash, key, value, null);//创建新结点 else &#123; //发生碰撞 java.util.HashMap.Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; //key 值相同，替换旧值 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof java.util.HashMap.TreeNode)//该链为树 e = ((java.util.HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//该链为链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash);//转换为红黑树 break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果本身存在相同的 key，则将旧值返回 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount;//结构化修改次数加 1 if (++size &gt; threshold)//如果当前数量超过阈值，则进行扩容 resize(); afterNodeInsertion(evict);//默认为空实现 return null;//原先 key 不存在，也就是说没有旧值，直接返回 null&#125; get 函数的实现12345678910111213141516171819202122232425262728/** * 获取给定 key 的 hash 值，获取相应位置 value * */public V get(Object key) &#123; java.util.HashMap.Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final java.util.HashMap.Node&lt;K,V&gt; getNode(int hash, Object key) &#123; java.util.HashMap.Node&lt;K,V&gt;[] tab; java.util.HashMap.Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))//先检查对应位置的「头结点」，如果匹配直接返回对应的值 return first; if ((e = first.next) != null) &#123; if (first instanceof java.util.HashMap.TreeNode)//该链是红黑树，根据 hash 和 key 到 树中查找相应的 value,直接返回 return ((java.util.HashMap.TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //该链是链表，到链表中遍历查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 可以看到 get 方法的大致逻辑是这样的： 先计算出当前 key 的 hash 值，然后通过 getNode 方法去获取当前对应的结点 如果对应的节点为 null，直接返回 null， 否则返回节点中的 value。 getNode 方法的实现思路是这样的： 通过 hash 跟 当前容量进行 与运算 得到数组下标 使用指定下标去获取对应的节点（从头结点开始） 如果首个元素就命中，直接返回结点。 存在冲突：如果该 hash 值对应的是一棵红黑树，则到红黑树中去获取相应的结点。如果该 hash 值对应的是一个链表，则遍历该链表，直到取得相应的结点或者到达链尾。 hash 函数的实现在 HashMap 中，哈希桶数组 table 的长度 length 大小必须为 2 的 n 次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考这篇文章，Hashtable 初始化桶大小为 11，就是桶大小设计为素数的应用（Hashtable 扩容后不能保证还是素数）。HashMap 采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。 通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。当 length 总是 2 的 n 次方时，h&amp; (length-1) 运算等价于对 length 取模，也就是 h%length，但是&amp;比%具有更高的效率。 h &amp; (length - 1) 《==》 h % length 在 JDK1.8 的实现中，优化了高位运算的算法，通过 hashCode()的高 16 位（其实是完整的） 异或 低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。 hash 是 int 类型的（32 位），原 hashcode 异或 右移 16 位后的 hashcode，高低位兼顾 右移 16 位，那么高 16 位均为 0，所以高十六位的取值由 key 的 hashCode 的高十六位确定， 低 16 位的值由 hashcode 的低十六位与高十六位 在 get 和 put 的过程中，计算下标时，先对 hashCode 进行 hash 操作，然后再通过 hash 值进一步计算下标，如下图所示： 在对 hashCode()计算 hash 时具体实现是这样的： 123456static final int hash(Object key) &#123; int h; //因为 h &gt;&gt;&gt; 16 右移了 16 位(高 16 位都为 0)，因此结果的高 16 位仍然是 key.hashCode() 的高 16 位 //而低 16 位取决于 key.hashCode() 的高十六位和低十六位进行异或的结果 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 可以看到这个函数大概的作用就是：高 16bit 不变，低 16bit 和高 16bit 做了一个异或。这样做的目的就在于你求余的时候包含了高 16 位和第 16 位的特性 也就是说你所计算出来的 hash 值包含从而使得你的 hash 值更加「随机」以降低碰撞的概率 计算下标存储结点时，计算得到的 hash 值可能远大于哈希桶数组的长度，为了避免数组越界，我们需要进行取模运算。计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)： 1(n - 1) &amp; hash 上面的计算实际上等价于hash % n，但是前者的效率比较高。前面我们提到过，HashMap 的数组长度一定是 2 的 ？次方。也就是说 (n - 1) 可以化为 0…0011…1，这样跟 hash 进行与运算，就相当于取模运算。 Java 8 所做的优化hash 函数设计得再好，也无法避免冲突的。如何解决冲突也是一门学问。 在 Java 8 之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行 get 时，两步的时间复杂度是 O(1)+O(n)。因此，当碰撞很厉害的时候 n 很大，O(n)的速度显然是影响速度的。 因此在 Java 8 中，当链表长度大于 8 时，就利用红黑树替换链表，这样复杂度就变成了 O(1)+O(logn)了，这样在 n 很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap 的性能提升一文中有性能测试的结果。 resize （扩容）实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 初始化或者扩容一倍 * */final java.util.HashMap.Node&lt;K,V&gt;[] resize() &#123; java.util.HashMap.Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;//旧长度 int oldThr = threshold;//旧阈值 int newCap, newThr = 0; //这一段代码用于确定新容量,并根据新容量重新确定阈值 if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//旧容量大于最大允许容量，将阈值赋值为最大允许容量 threshold = Integer.MAX_VALUE; return oldTab;//直接返回旧表 &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//扩容后小于允许的最大容量，且大于默认初始容量（16），则修改 threshold newThr = oldThr &lt;&lt; 1; // threshold 增大一倍 &#125; else if (oldThr &gt; 0) // 原有阈值大于 0，但是原容量小于 0 newCap = oldThr;//将新容量赋值为就旧阈值 else &#123; // 原阈值、原容量均为 0 ，使用默认的初始化参数来创建 map newCap = DEFAULT_INITIAL_CAPACITY;//默认的初始化容量 （16） newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//新的阈值 &#125; if (newThr == 0) &#123;//如果新阈值为 0 float ft = (float)newCap * loadFactor;//重新计算 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); //如果阈值大于最大容量，修改阈值为 int 的最大值(2^31-1)，这样以后就不会扩容了 &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) java.util.HashMap.Node&lt;K,V&gt;[] newTab = (java.util.HashMap.Node&lt;K,V&gt;[])new java.util.HashMap.Node[newCap];//按照新容量 创建数组 table = newTab; if (oldTab != null) &#123;//原有的 map 上的元素不为空，将原有 map 上面的数据复制到新的 map 上面 //遍历旧元素 for (int j = 0; j &lt; oldCap; ++j) &#123; java.util.HashMap.Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null;//释放，防止内存泄漏 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e;//该桶中只有一个元素，获取的 hash 值并与（新容量 -1）进行 与运算 else if (e instanceof java.util.HashMap.TreeNode)//如果该元素是一个树节点（说明该桶对应有一棵红黑树），将树存储到新数组上 ((java.util.HashMap.TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 保持顺序 //因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位 = low 位+原哈希桶容量 //低位链表的头结点、尾节点 java.util.HashMap.Node&lt;K,V&gt; loHead = null, loTail = null; //高位链表的头结点、尾节点 java.util.HashMap.Node&lt;K,V&gt; hiHead = null, hiTail = null; //临时结点 java.util.HashMap.Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123;//根据 hash 值与 oldCap 的运算结果，将链表中集结的元素分开，可认为结果是随机的 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //在原索引处存放 「低位链表」 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //在原索引加上原容量处，存放「高位链表」 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。 元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化： 因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap，可以看看下图为 16 扩充为 32 的 resize 示意图： 这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。 树化与链表化当冲突链表长度达到 8 的时候，会调用 treeifyBin 尝试将链表转换为树。 如果当前数组的长度小于 64 的话，只会触发扩容，而不会将链表转换为红黑树。 1234567891011121314151617181920final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)//在「树化」之前先判断，当前的容量 resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125; 当移除元素或者是扩容的时候，如果树的大小&lt;=6，会调用 HashMap.TreeNode#untreeify 方法将红黑树转换为链表。 为什么要进行「树化」呢？一方面是为了保证性能，如果同一个桶上面的冲突都通过链表连接，链表的查询是线性的，同一个桶上冲突较多的时候，会严重影响存取的性能。 另一个原因其实也是由性能问题引发的哈希碰撞拒绝服务攻击，因为构造哈希冲突的数据并不是困难的事情，恶意代码可以构造这样的数据大量与服务端交互，导致服务端CPU 大量占用。 常见问题此部分内容参考自HashMap 的工作原理 1. 什么时候会使用 HashMap？他有什么特点？是基于 Map 接口的实现，存储键值对时，它可以接收 null 的键值，是非同步的，HashMap 存储着 Entry(hash, key, value, next)对象。 2. 你知道 HashMap 的工作原理吗？通过 hash 的方法，通过 put 和 get 存储和获取对象。存储对象时，我们将 K/V 传给 put 方法时，它调用 hashCode 计算 hash 从而得到 bucket 位置，进一步存储，HashMap 会根据当前 bucket 的占用情况自动调整容量(超过 Load Facotr 则 resize 为原来的 2 倍)。获取对象时，我们将 K 传给 get，它调用 hashCode 计算 hash 从而得到 bucket 位置，并进一步调用 equals()方法确定键值对。如果发生碰撞的时候，Hashmap 通过链表将产生碰撞冲突的元素组织起来，在 Java 8 中，如果一个 bucket 中碰撞冲突的元素超过某个限制(默认是 8)，则使用红黑树来替换链表，从而提高速度。 3. 你知道 get 和 put 的原理吗？equals()和 hashCode()的都有什么作用？通过对 key 的 hashCode()进行 hashing，并计算下标( n-1 &amp; hash)，从而获得 buckets 的位置。如果产生碰撞，则利用 key.equals()方法去链表或树中去查找对应的节点 4. 你知道 hash 的实现吗？为什么要这样实现？在 Java 1.8 的实现中，是通过 hashCode()的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在 bucket 的 n 比较小的时候，也能保证考虑到高低 bit 都参与到 hash 的计算中，同时不会有太大的开销。 5. 如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认 0.75)，则会重新 resize 一个原来长度两倍的 HashMap，并且重新调用 hash 方法。 参考资料与学习资源推荐 面试必备：HashMap 源码解析（JDK8） HashMap 的 hash 函数原理 重新认识 HashMap HashMap 的工作原理 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，谢谢！]]></content>
      <categories>
        <category>java集合框架</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>java集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 垃圾收集器与内存分配策略]]></title>
    <url>%2Fblog%2F2017%2F09%2F08%2FJVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[确定回收的对象「死去」的对象即不可能再被任何途径使用的对象。 几乎所有对象的实例都存在堆中。（部分 String 对象存在于字符串常量池中，JDK1.7 以前，字符串常量池存放在方法区中）。 进行回收的第一步就是确定哪些对象还活着，哪些已经死亡。 引用计数算法给对象中添加一个引用计数器， 每当有一个地方引用它时，计数器值就加 1； 当引用失效时，计数器值就减 1； 任何时刻计数器为 0 的对象就是不可能再被使用的。 缺点：很难解决对象之间相互循环引用的问题。因此 Java 虚拟机中没有采用引用计数算法来管理内存。 可达性分析算法主流的商用程序语言的主流实现中，都是通过可达性分析来判断对象是否存活的。 算法的基本思路： 通过一系列的称为 GC Root 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为『引用链』（Reference Chain） 当一个对象到 GC Root 没有任何引用链相连时，则证明此对象是不可用的。 GC Root 对象的定义是什么？ Help - Eclipse Platform 上给的定义是这样的： A garbage collection root is an object that is accessible from outside the heap 也就是说 GC Roots 是可以从堆外访问的对象。由 Java 运行时数据区可以知道，堆外的空间有虚拟机栈、本地方法栈以及方法区。而java 1.8 将整个方法区被移到一个叫元空间的地方（使用本地内存存储） 所以GC Roots 对象包含以下几种： 虚拟机栈(栈帧中的本地变量表)中引用的对象，也就是局部变量引用的对象。 本地方法栈中 JNI 引用的对象，包括 本地方法栈中的局部变量或者参数 JNI全局引用 方法区中类静态属性引用的对象。由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。它们可以通过静态属性的方式持有对象的引用。注意，一般情况下由自定义的类加载器加载的类不能成为GC Roots 方法区中常量引用的对象 引用分类JDK 1.2 之后对，Java 对引用的概念进行了扩充（不再是仅有被引用或者没有被引用两种）： 共有四种： 强引用 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用 SoftReference 内存不够时被回收 在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。 弱引用 WeakReference 只要一执行 GC 就会被回收 虚引用，也称为幽灵引用、幻影引用 PhantomReference 『形同虚设』。一个对象被持有虚引用对其生命周期毫无影响 虚引用的作用仅仅是在该对象被回收时，收到一个系统通知而已 生存还是死亡一个对象的 finalize 方法最多只会被系统调用一次。 即使在可达性分析算法中不可达的对象，也并非是「非死不可」的，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与 GCRoots 相连接的引用链，那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，虚拟机将这两种情况都视为「没有必要执行」。 如果这个对象被判定为有必要执行 finalize 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。 这里所谓的「执行」是指虚拟机 会触发这个方法，但并不承诺会等待它运行结束，为什么要这么做？ 因为如果承诺得到 finalize 方法执行结束，那么当一个对象在 finalize 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致 F-Queue 队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。 finalize 方法是对象逃脱死亡命运的==最后一次机会==，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记， 如果对象要在 finalize 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出「即将回收」的集合； 如果对象这时候还没有逃脱，那基本上它就真的被回收了。 任何一个对象的 finalize 方法只会被系统调用一次。 回收方法区永久代的垃圾回收主要回收两部分的内容： 废弃常量 无用的类 回收废弃常量回收废弃常量与回收 Java 堆中对象很相似。以常量池中字面量的回收为例，假如一个字符串「abc」已经进入了常量池中，它没有被引用，如果这时发生内存回收，而且必要的话，这个「abc」常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 回收无用类类需要同时满足下面 3 个条件才能算是「无用的类」： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。 而且因为由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。所以正常情况下回收无用类收效甚微。 垃圾收集算法标记-清除算法标记-清除 (Mark-Sweep) 算法是最基础的收集算法，分为标记和清除两个阶段： 首先标记出所有需要回收的对象， 在标记完成后统一回收所有被标记的对象 之所以说它基础，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。 主要不足有两个： 效率问题：标记和清除两个过程的效率都不高； 空间问题（确切而言是空间碎片问题）：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 仅有 CMS 收集器使用了标记-清除算法。 复制算法复制算法主要是为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。 当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 商业虚拟机都采用复制收集算法来回收新生代，但并不是按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和==两块==较小的 ==Survivor== 空间，每次使用 Eden 和其中一块 Survivor，当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到==另外一块==Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。 HotSpot 虚拟机默认 Eden 和两块 Survivor 的大小比例是 8:1:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10%的内存会被「浪费」。当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。 缺点： 使用空间换取时间，这种算法将内存缩小为了原来的一半。 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种复制算法。 标记-==整理==算法「标记-整理」算法的标记过程仍然与「标记-清除」算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。(先移动到『安全位置』再清除掉安全区域边界外的无用位置) 分代收集算法目前商业虚拟机的垃圾收集都采用「分代收集」（Generational Collection）算法， 只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。可以通过 -XX:NewRatio调整新生代与老年代的内存空间比例（指定老年代所占的「份数」）。默认情况下 NewRatio = 2，即： 新生代约占整个堆空间的 1/3 ,老年代约占 2/3 。 在新生代中，因为对象存活率比较低，只需要付出少量存活对象的复制成本就可以完成收集。选用复制算法。 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用「标记-清理」或者「标记-整理」算法来进行回收。 HotSpot 的算法实现如何发起内存回收？首先要知道回收的哪些对象。 枚举根节点可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。 分析期间引用不可变导致 GC 停顿可达性分析对执行时间的敏感还体现在 GC 停顿 上，因为这项分析工作必须在一个能确保一致性的快照中进行。 「一致性」的意思是指在整个分析期间，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程（Sun 将这件事情称为「Stop The World」）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。 由于目前的主流 Java 虚拟机使用的都是准确式 GC，也就是说，虚拟机可以准确的知道内存中某个位置的数据类型是什么。所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机只要直接扫描存放对象引用的区域。 在 HotSpot 的实现中，使用一组称为 OopMap 的数据结构来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC 在扫描时就可以直接得知这些信息了。 使用空间换时间。 安全点从线程角度看，safepoint 可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，（就好像高速公路上的服务区，可以安全地停下来休息） 如果有需要，可以在这个位置暂停，比如发生 GC 时，需要暂停暂停所以活动线程， 但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待 GC 结束。（还在马路上，就不能休息，要到下一个服务区才能休息） 安全的选取安全点是怎么选的？基本上是以程序「是否具有让程序长时间执行的特征」为标准进行选定的。 「长时间执行」的最明显特征就是指令序列复用，例如：方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint。 GC 时让线程停止的方式如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都「跑」到最近的安全点上再停顿下来？ 这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）， 抢先式中断在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它「跑」到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。 主动式中断主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域安全区域是一个安全点连续的代码段。 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。 在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region， 那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。 （那些没标记为安全区域的怎么处理？） 在线程要离开 Safe Region 时，它要检查系统是否已经完成了==根节点枚举==（或者是整个 GC 过程）[因为其他步骤可能不需要 stop the world ] 如果完成了，那线程就继续执行， 否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。 垃圾收集器内存回收如何进行是由虚拟机所采用的 GC 收集器决定的，而通常虚拟机中往往不止有一种 GC 收集器。 如果说收集算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现。 虚拟机规范中对于垃圾回收器应该如何实现并没有任何规定。 图 3-5 展示了 7 种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。 我们选择的只是对具体应用最合适的收集器。 以下分析的关注点： 收集器的特点： 工作线程数? 工作过程中需不需要 stop the word？ 需要的话具体是哪个过程需要？ 能与哪个收集器搭配使用? Serial 收集器一个单线程的收集器。单线程指的是它用单条线程去完成垃圾收集工作 重点：在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。 实际上到现在为止，它依然是虚拟机运行在 Client 模式下的默认新生代收集器。 优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器专心做垃圾收集自然可以获得最高的单线程收集效率。 Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择因为在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。 ParNew 收集器ParNew 收集器其实就是 Serial 收集器的多线程版本 是许多运行在 Server 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。 两个名词：并发和并行。 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。 二者关系：并行是并发的一个子集 ParallelScavenge 收集器Parallel Scavenge 收集器是一个新生代收集器， 与 ParNew 很相似。但它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个==可控制==的吞吐量（Throughput）。实际上二者概念存在重叠的地方。因为 GC 过程中用户线程停顿时间缩短，那么吞吐量也就上去了，只不过要考虑用户代码执行时间与停顿时间的比例。 吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即 吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间），假设虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。注意：GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，这也直接导致垃圾收集发生得更频繁一些。停顿时间的确在下降，但吞吐量也降下来了。 GCTimeRatio 参数的值是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1/（1+19）），默认值为 99，就是允许最大 1 %（即 1/（1+99））的垃圾收集时间。 由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为「吞吐量优先」收集器。 Parallel Scavenge 收集器还有一个开关参数 -XX：+UseAdaptiveSizePolicy当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 ==GC 自适应的调节策略==（GC Ergonomics）。自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别。 SerialOld 收集器Serial Old 是 Serial 收集器的老年代版本，使用「标记-整理」算法。 这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。 如果在 Server 模式下，那么它主要还有两大用途： 一种用途是在 JDK 1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用 另一种用途就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集，并非直接使用了 Serial Old 收集器，但是这个 PS MarkSweep 收集器与 Serial Old 的实现非常接近。 ParallelOld 收集器Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和「标记-整理」算法。 这个收集器是在 JDK 1.6 中才开始提供的，此前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。因为 JDK1.6 以前只能选择 serial old 作为老年代收集器。（唯一能选择的队友不行） 直到 Parallel Old 收集器出现后，「吞吐量优先」收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 CMS 收集器CMS 收集器（Concurrent Mark Sweep）在 JDK1.5 时期被推出，这款收集器是 HotSpot 虚拟机中第一款真正意义上的==并发==收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作。 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。适合于交互型的应用。希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。从名字（包含「Mark Sweep」）上就可以看出，CMS 收集器是基于「标记—==清除==」算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤，包括： 初始标记（CMS initial mark） ,需要「Stop The World」仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快 并发标记（CMS concurrent mark）进行 GC RootsTracing 重新标记（CMS remark）,需要「Stop The World」为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 并发清除（CMS concurrent sweep） 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。通过图 3-10 可以比较清楚地看到 CMS 收集器的运作步骤中并发和需要停顿的时间。 缺点 对 CPU 资源非常敏感其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。 CMS 默认启动的回收线程数是（CPU 数量 + 3）/ 4， 也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25%的 CPU 资源，并且随着 CPU 数量的增加而下降。 但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大. 用户程序在 GC 过程中执行 缓慢的问题，推出了增量式 CMS（i-CMS），在并发标记、清除时让 GC 线程与用户线程交替执行，尽量减少 GC 线程独占资源的时间，虽然这样会导致整个垃圾回收过程变长。但是效果不明显，目前版本中已经不再推荐使用。 无法处理浮动垃圾（Floating Garbage）可能出现「Concurrent Mode Failure」失败而导致另一次 Full GC 的产生。 由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为「浮动垃圾」。 收集结束时会产生大量空间碎片。（因为使用了「标记-清除」算法）空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Full GC 。 为了解决这个问题，CMS 收集器提供了一个-XX：+UseCMSCompactAtFullCollection 开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 FullGC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。 另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的 Full GC 后，跟着来一次带压缩的（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。 G1 收集器G1（Garbage-First）是一款面向服务端应用的垃圾收集器。它有以下几个优点： 并行与并发：G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短Stop-The-World停顿的时间 分代收集：不需要其他收集器配合就能独立管理整个 GC 堆，能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合：无内存碎片。与 CMS 的「标记—清理」算法不同，G1 从整体来看是基于「标记—整理」算法实现的收集器 从局部（两个 Region 之间）上来看是基于「复制」算法实现的 这两种算法都意味着G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。 可预测的停顿：降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别（其他收集器都是对整一个老年代或者新生代进行操作），它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。 之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。 Region 不可能是孤立的。一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。那在做可达性判定确定对象是否存活的时候，岂不是还得扫描整个 Java 堆才能保证准确性？在 G1 收集器中，Region 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 ==Remembered Set== 来避免全堆扫描的。 G1 中每个 Region 都有一个与之对应的 Remembered Set，虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。 当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 哪一块回收的收益大就选哪一块。 G1 的前几个步骤的运作过程和 CMS 有很多相似之处。 初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记阶段是从 GC Root 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。 筛选回收阶段对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。 组合策略在进行 JVM 调优的过程中，并非任何一种新生代 GC 策略都可以和另一种年老代 GC 策略进行配合工作，所以，我们应该知道，哪些种组合可以有效地进行 GC，而且应该在什么样的应用场景下选择哪一种组合，如下表所示： 新生代 GC 策略 年老代 GC 策略 说明 组合 1 Serial Serial Old Serial 和 Serial Old 都是单线程进行 GC，特点就是 GC 时暂停所有应用线程。 组合 2 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发 GC，实现 GC 线程和应用线程并发工作，不需要暂停所有应用线程。另外，当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC。 组合 3 ParNew CMS 使用-XX:+UseParNewGC 选项来开启。ParNew 是 Serial 的并行版本，可以指定 GC 线程数，默认 GC 线程数为 CPU 的数量。可以使用-XX:ParallelGCThreads 选项指定 GC 的线程数。如果指定了选项-XX:+UseConcMarkSweepGC 选项，则新生代默认使用 ParNew GC 策略。 组合 4 ParNew Serial Old 使用-XX:+UseParNewGC 选项来开启。新生代使用 ParNew GC 策略，年老代默认使用 Serial Old GC 策略。 组合 5 Parallel Scavenge Serial Old Parallel Scavenge 策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC 时间)，可见这会使得 CPU 的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 组合 6 Parallel Scavenge Parallel Old Parallel Old 是 Parallel Scavenge 收集器的老年代版本。适用于注重吞吐量以及 CPU 资源敏感的场合 7 G1 G1 是 Garbage First 垃圾收集器。 理解 GC 日志GC 日志开头的 「[GC」和「[Full GC」说明了这次垃圾收集的==停顿类型==，而不是用来区分新生代 GC 还是老年代 GC 的。 如果有「Full」，说明这次 GC 是发生了 Stop-The-World 的，这段新生代收集器 ParNew 的日志也会出现「[Full GC」（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW）。 如果是调用 System.gc（）方法所触发的收集，那么在这里将显示「[Full GC（System）」。 接下来的「[DefNew」、「[Tenured」、「[Perm」表示 GC 发生的区域，这里显示的区域名称与使用的 GC 收集器是密切相关的， Serial 收集器中的新生代名为 「Default New Generation」，所以显示的是「[DefNew」。 如果是 ParNew 收集器，新生代名称就会变为「[ParNew」，意为 「Parallel New Generation」。 如果采用 Parallel Scavenge 收集器，那它配套的新生代称为「PSYoungGen」 内存分配与回收策略对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过 JIT 编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配*。少数情况下也可能会直接分配在老年代中， 注: TLAB 全称为 Thread Local Allocation Buffered 分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。以下为几条最普遍的内存分配规则。 对象优先在 Eden 分配、 大对象直接进入老年代、 长期存活的对象将进入老年代 、 动态对象年龄判定 、 空间分配担保 对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 Minor GC 和 Full GC 有什么不一样吗？ 新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。 老年代 GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。 虚拟机提供了一个-XX：PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制（复习一下：新生代采用复制算法收集内存）。 长期存活的对象将进入老年代为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。 对象在 Survivor 区中每「熬过」一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。 对象晋升老年代的年龄阈值，可以通过参数 -XX：MaxTenuringThreshold 设置。 动态对象年龄判定虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold中要求的年龄。 也就是说，同龄的小伙伴的内存大于总内存的一半。那么 &gt;= 该年龄的就算老了。 空间分配担保在发生 Minor GC 之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立，那么 Minor GC 可以确保是安全的。 如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象容量的==平均大小==， 如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的； 如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 如果不允许，改为进行一次 Full GC 「冒险」是冒了什么风险？ 一句话就是：老年代的最大可用连续空间可能小于新生代所有存活对象总空间，就会导致 Full GC，本来是应该直接执行 Full GC 的，但是没有直接执行，导致浪费了时间。 具体而言：新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行 Full GC 来让老年代腾出更多空间。 取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了 HandlePromotionFailure 失败，那就只好在失败后重新发起一次 Full GC。 虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将 HandlePromotionFailure 开关打开，避免 Full GC 过于频繁。 常见问题你能不能谈谈，GC 是在什么时候，对什么东西，做了什么事情？此问题摘自《深入理解 Java 虚拟机》作者的一篇博文，详见 一个面试官对面试问题的分析 java的gc为什么要分代？答案可参考 R 大的这个回答 总结没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。 学习虚拟机内存知识，如果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。 参考资料与学习资源推荐 《深入理解 Java 虚拟机》 本文大部分内容都出自《深入理解 Java 虚拟机》 第三章，若文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 运行时数据区域与对象创建布局]]></title>
    <url>%2Fblog%2F2017%2F09%2F07%2FJVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[java 运行时数据区域根据《Java 虚拟机规范》规定，Java 虚拟机锁管理的内存包含以下以下几个运行时数据区域，如下图所示： 程序计数器程序计数器是线程私有的，各线程独立存储，以便线程切换后能恢复到正确的执行位置。可以看作是当前线程所执行的字节码的行号指示器。 如果正在执行的是一个 Java 方法，该计数器记录的是正在执行的虚拟机字节码指令的地址。 如果正在执行的是一个 Native 方法，则该计数器值为空。 ==此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域== Java 虚拟机栈Java 虚拟机栈是==线程私有的==。生命周期与线程相同。 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）。每一个方法从调用到执行都对应着一个栈帧在虚拟机栈中入栈和出栈的过程。 注：栈帧（Stack Frame ）是方法运行时基础数据结构，其中存储了局部变量表、操作数栈、动态链接、方法出口等信息。 平时所讲的栈内存，就是现在讲的 Java 虚拟机栈，或者说是虚拟机栈中局部变量表部分。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 SOF（Stack Over Flow） 异常 如果扩展时，无法申请到足够的内存，就会抛 OOMError 异常 本地方法栈发挥的作用与虚拟机栈相似。只不过一个是针对 Java 方法，一个是针对本地方法。 Java 堆对于大多数应用而言，Java 堆是 Java 虚拟机所管理的内存中最大的一块。同时它也是==所有线程共享==的一块内存区域。Java 虚拟机规定，Java 堆可以是物理上不连续的内存空间，只要逻辑上连续即可。 按照虚拟机规范中的描述，所有对象实例以及数组都要在堆上分配。不过随着 JIT 编译器的发展和逃逸分析技术的逐渐成熟，未来或许会有所改变。 从内存分配角度来看，线程共享的 Java 堆中可能会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不管怎么划分，其中存储的都是对象，进行划分的目的只是为了更好地回收/分配内存。 方法区方法区有一个别名：non-heap，与 Java 堆区分开来。它是==所有线程共享==的，用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。 Hotspot 虚拟机设计团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区。因为这样就不用专门为方法区编写内存管理的代码的工作。对于其他虚拟机而言是不存在永久代这个概念的。 使用永久代来实现方法区的好处在于可以直接像管理 Java 堆那样管理这部分内存，而不需要再专门为方法区编写内存管理代码。坏处在于这样更容易导致 OOM，因为永久代有 -XX：MaxPermSize 的上限。在 JDK 1.8 HotSpot 虚拟机的实现中已经将整个永久代移除，取而代之的是一个叫元空间（Metaspace）的区域。 当方法区无法满足内存分配需求时，将抛出 java.lang.OutOfMemoryError: PermGen space 。 运行时常量池Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。JDK 1.8 前运行时常量池是方法区的一部分。 虚拟机规范中对 Class 文件中的每一个部分的格式都有严格规定。但是对于运行时常量池，并没有做任何细节的要求。一般而言，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于 Class 文件常量池的的另一特征在于具备动态性。java 运行期间也可以把新的常量放入池中。比如使用 String.intern() 将堆中的字符串加入常量池中。 JDK1.7 中把原本放在永久代的字符串常量池移到 Java 堆中。常量池位置的不同影响到了 String 的 intern()方法的表现。不同版本的 JDK 使用「==」去比较 String 字符串的结果会有不同。具体情况可参考这篇文章——Java 技术——你真的了解 String 类的 intern()方法吗 Metaspace（元空间）介绍元空间之前先说点题外话。其实，移除永久代的工作从 JDK1.7 就开始了。JDK1.7 中，存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。譬如符号引用(Symbols)转移到了 native heap、字面量(interned strings)转移到了 java heap、类的静态变量(class statics)转移到了 java heap。但 JDK1.7 并没有完全移除将永久代完全移除。直到 JDK1.8 才将永久代完整地移除。 元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小： -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时 GC 会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 MaxMetaspaceSize 时，适当提高该值。 -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 如果本地空间的内存用尽了会收到java.lang.OutOfMemoryError: Metadata space 的错误信息。JDK1.8 中持久代相关的 JVM 参数 -XX:PermSize 及 -XX:MaxPermSize 将会被忽略掉。 为什么移除持久代？ 它的大小只能在启动时指定，运行时无法修改——很难进行调优。-XX:MaxPermSize，设置成多少好呢？ HotSpot 的内部类型也是 Java 对象：它可能会在 Full GC 中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。 简化 Full GC：每一个回收器有专门的元数据迭代器。 可以在 GC 不进行暂停的情况下并发地释放类数据。 使得原来受限于持久代的一些改进未来有可能实现 元空间的内存分配模型 绝大多数的类元数据的空间都从本地内存中分配 用来描述类元数据的类（klasses)也被删除了 分元数据分配了多个虚拟内存空间 给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些 归还内存块，释放内存块列表 一旦元空间的数据被清空了，虚拟内存的空间会被回收掉 减少碎片的策略 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。 JDK 1.4 新添加的 NIO（New Input/Output） 可以使用 Native 函数库直接分配堆外存，然后通过一个存储在 Java 堆中的 DireByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场合能够显著提高性能。 本机直接内存不受 Java 堆大小的限制，但是受到本机总内存的大小以及处理器寻址空间的限制。 HotSpot 虚拟机中对象创建、初始化与布局对象的创建类加载检查、判断遇到一条 new 指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载。 分配内存类加载检查通过后，将为新生对象分配内存。也就是划分出一块内存区域。 如果 java 堆中的内存是绝对规整的，那么会使用指针碰撞的分配方式 如果 java 堆中的内存不规整的，虚拟机必须维护一个列表，记录哪些内存块可用，在分配时从列表中，找到一块足够大的空间划分给对象。即，使用空闲列表的分配方式。 选择哪种分配方式由 java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞 而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。 线程安全问题：另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案： 一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性； 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。 哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。 虚拟机是否使用 TLAB，可以通过-XX：+/-UseTLAB 参数来设定。 对象的初始化此处的初始化指的是将分配到的内存空间初始化为零值。（不包括对象头）。如果使用 TLAB，该过程也可以提前至 TLAB 分配时进行。初始化为零值的操作保证了对象的实例字段在 Java 代码中可不赋初值就使用。 对象头的设置： 对象是哪个类的实例 如何才能找到类的元数据信息 对象的哈希码 对象的 GC 分代年龄等信息。 … 从虚拟机的视角来看，一个新的对象已经创建完毕。 但从 Java 程序视角来看，对象的创建才刚刚开始—— 方法还没有执行、所有字段都还为零. 一般来说（由字节码中是否跟随 invokespecial 指令所决定），执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局HotSpot 中，对象在内存中存储的布局可以分为 3 块区域： 对象头 Header 实例数据 Instance Data 对齐填充 Padding (并不是必然存在) 1. 对象头对象头包括两部分信息：第一部分为存储对象自身得运行时数据，第二部分为类型指针。 存储对象自身的运行时数据。如： 哈希码（HashCode） GC 分代年龄、 锁状态标志、 线程持有的锁、 偏向线程 ID、 偏向时间戳等，这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit，官方称它为「Mark Word」。 对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 类型指针，即对象指向它的类元数据的指针，虚拟机通过该指针来确定这个对象是哪个类的实例。 如果对象是一个数组，那么对象头中还需要有一块用于记录数据长度的数据 因为从数据的元数据无法确定数组的大小 注意：并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身 比如：通过句柄访问对象 2. 实例数据接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。 无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。 HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers）， 可以看出，相同宽度的字段总是被分配到一起。 在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。 如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 3. 对齐填充对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。 由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说，就是对象的大小必须是 8 字节的整数倍。 对象的访问定位由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。 主流的访问方式有两种：1. 使用句柄，2. 使用直接指针 使用句柄访问： Java 堆中将会划分出来一块内存作为句柄池，reference 中就是存储了对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。 直接指针访问： 采用这种方式，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，而对象中包含了对象类型数据的地址信息。 对比 使用句柄访问优点：是 reference 中存储的是稳定的句柄地址，在对象被移动时，只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。 使用直接指针的最大好处就是速度更快，节省了一次指针定位需要的时间开销，由于 Java 对象访问十分频繁，这类开销积小成多后也是一项非常可观的执行成本。 Sun HotSpot 虚拟机使用的就是这种访问方式。 OutOfMemoryError 异常简析Java 堆溢出不断创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象。在对象总内存达到 -XmX:heapSize指定的值之后就会 OOM。 一般出现这种情况都是通过 MAT 工具来分析。确定是出现了内存泄漏，还是的最大堆空间的设置不合理。 如果是内存泄漏，可进一步通过工具来查看对象到 GC Roots 的引用链，找出内存泄漏的原因 如果不存在内存泄漏，即对象确实必须存活着，那就要检查虚拟机的堆参数（-Xmx 与 -Xms）与机器物理内存比较看是否还可以调大；同时也可以通过检查代码中是否存在一些对象的生命周期过长、持有状态时间过长的情况，尝试·减少程序运行期的内存消耗。 虚拟机栈和本地方法栈溢出在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈。栈容量只由 -Xss 参数设定。 关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常： 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 导致 SOF 的常见原因有递归、定义大量的局部变量等。 方法区和运行时常量池溢出可以通过在运行时产生大量的类去填满方法区。 由于 JDK1.7 把字符串常量池从方法区移到堆中，在不同的版本的 JDK中String.intern()方法的表现不一。 JDK1.6 中调用 String.intern() 方法时，会把首次遇到的字符串复制到永久代中。 JDK1.7 中调用 String.intern()方法时，不会再复制实例，只是在常量池中记录首次出现的实例引用 本机直接内存溢出可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，默认与 Java 堆最大值（-Xmx指定）一样 参考资料与学习资源推荐 Java8 内存模型—永久代(PermGen)和元空间(Metaspace) Java 8 的元空间 Java 8 的元空间英文原文 JAVA 8 ：从永久区（PermGen）到元空间（Metaspace） Java虚拟机（一）结构原理与运行时数据区域 《深入理解 Java 虚拟机(第 2 版)》 若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合框架之 ArrayList]]></title>
    <url>%2Fblog%2F2017%2F09%2F06%2FJava-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BArrayList%2F</url>
    <content type="text"><![CDATA[概要ArrayList 是一个动态数组，它是线程不安全的，允许元素为 null。它的底层数据结构是数组，ArrayList 实现了 List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 接口，其中 RandomAccess 代表了其拥有随机快速访问的能力，ArrayList 可以以 O(1) 的时间复杂度去根据下标访问元素。 时间、空间效率因为数组内存的连续，可以根据下标以 O1 的时间改查元素，因此时间效率很高 同样也因为数组要占据一块连续的内存空间，所以它也有数组的缺点——空间效率不高。 性能当集合中的元素超出容量时，会进行扩容操作，扩容操作是一个性能消耗较大的地方，所以如果能预知数据的规模，最好在初始化时通过 public ArrayList(int initialCapacity) 构造方法指定 ArrayList 的大小，来构造 ArrayList 实例，以减少扩容次数，提高效率。 在添加大量元素前，应用程序也可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量，这可以减少递增式再分配的数量。 不过该方法是 ArrayList 中添加的，List 中没有该方法。所以如果声明的类型为 List 的话，需要进行强转。((ArrayList)list).ensureCapacity(number); 当每次修改结构时(添加或者删除元素)，都会修改 modCount。 成员变量123456789101112131415private static final int DEFAULT_CAPACITY = 10;//默认初始容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//空对象数据，用于空对象，如果指定初始容量为 0 就给元素附一个空对象/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//共享的空数组对象，使用该对象用以区分 EMPTY_ELEMENTDATA，从而知道第一次添加元素时，应该初始化的数组长度。transient Object[] elementData; // 之所以不声明为 private 是为了简化内部类访问，// 所有原本为默认容量的空数组，在第一次添加元素的时候都会被初始化为长度为默认容量的数组private int size;//包含元素的数量 构造方法ArrayList 提供了三种方式的构造器，可以构造一个默认初始容量为 10 的空列表、构造一个指定初始容量的空列表以及构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。 123456789101112131415161718192021222324252627public ArrayList(int initialCapacity) &#123;//按照指定的初始容量初始化 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity];//创建数组 &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA;//如果指定初始容量为 0 就给元素附一个空对象 &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity); &#125;&#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//初始化一个初始容量为 10 的 ArrayList&#125;//构造一个包含指定 collection 的元素的列表，这些元素按照该 collection 的迭代器返回它们的顺序排列的。public ArrayList(Collection&lt;? extends E&gt; c) &#123;//从给定的容器中构建一个 ArrayList elementData = c.toArray();//将容器对象中的元素转换为数组 if ((size = elementData.length) != 0) &#123;//长度不为 0，进行判断操作 // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);//如果返回的数组不是 Object[].class 类型的，则进行将数组元素复制到类型为 Object 数组上 &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA;//长度为 0，则将空数组对象赋值给元素数组 &#125;&#125; 这里要注意的是第三个构造方法中对数组元素类型的判断 12345if (elementData.getClass() != Object[].class)&#123; elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; else&#123; //...&#125; 虽然表面上看起来，c.toArray() 会返回一个 Object[] 对象数组，但是它指向的实际类型并不一定是 Object[]，这样当我们调用 objList[i] = new Object(); 就会报错 。 比如说如果我们有 1 个 List stringList 对象，当我们调用Object[] objectArray = stringList.toArray()的时候， objectArray 只能存放 String 类型的数据而不能存储其他类型的对象。 增 ArrayList 提供了 add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。 1234567891011121314151617181920212223/** * 添加元素到列表尾部。 * 先确认 ArrayList 的容量 * 每次 add 之前，都会判断 add 后的容量，是否需要扩容。 * */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! 确保容量足以容纳原有元素加上新增的元素 elementData[size++] = e; return true;&#125;/** * 添加元素到列表指定位置。需要将该位置右端的所有元素都往右移动一个单位 * 先确认 ArrayList 的容量 * */public void add(int index, E element) &#123; rangeCheckForAdd(index);//上下界判断 ensureCapacityInternal(size + 1); // Increments modCount!! 判断 add 之后的容量，根据情况进行扩容 System.arraycopy(elementData, index, elementData, index + 1,// 将 index ~ size-1 范围内的元素复制到 index+1 ~ size 范围中。也就是将 index 及其以后的元素后移一个位置 size - index); elementData[index] = element;//将给定元素添加到指定元素中 size++;//元素数量 + 1&#125; 12345678910111213141516171819202122232425262728293031/** * 添加给定集合中的所有元素到 ArrayList 中 * */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray();//先转换为数组 int numNew = a.length;//要添加的元素数量 ensureCapacityInternal(size + numNew); // Increments modCount，确保容量足够容纳新添加的所有元素 System.arraycopy(a, 0, elementData, size, numNew);//将元素添加到列表尾部 size += numNew; return numNew != 0;&#125;/** * 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。 * */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index);//检查上下界 Object[] a = c.toArray();//转换为数组 int numNew = a.length;//增加的数量 ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index;//要移动的元素数 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved);//移动数组中需要移动的元素 System.arraycopy(a, 0, elementData, index, numNew);//插入元素 size += numNew; return numNew != 0;&#125; 删ArrayList 提供了根据下标或者指定对象两种方式的删除功能。 1234567891011121314151617/** * 移除指定位置的元素 * */public E remove(int index) &#123; rangeCheck(index);//上界判断 modCount++;//结构修改次数 + 1 E oldValue = elementData(index); int numMoved = size - index - 1;//移动的元素总数 if (numMoved &gt; 0) System.arraycopy(elementData, index + 1, elementData, index,// numMoved);//将要删除的元素的后面的所有元素往前移一个单位 elementData[--size] = null; // clear to let GC do its work 将末元素置为 null，以免内存泄漏 return oldValue;//返回删除掉的值&#125; 123456789101112131415161718192021/** * 移除此列表中首次出现的指定元素（如果存在的话）。 * 先找到指定元素在数组中的位置，然后再调用 fastRemove 删除 * */public boolean remove(Object o) &#123; // 由于 ArrayList 中允许存放 null，因此下面通过两种情况来分别处理。 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 12345678910111213141516/** * 删除 [fromIndex，toIndex) 范围中的所有元素 * */protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex - fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125; 1234567/** * 移除 ArrayList 中给定指定集合中的所有元素。 * */public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125; 123456789101112131415161718192021222324252627282930313233343536/** * 批量删除 * complement 为 false 时，删除指定集合 c 中所有的元素。 * complement 为 true 时，删除指定集合 c 中以外的所有的元素。 * */private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;// complement 为 true 时为补集 final Object[] elementData = this.elementData;//将数组引用赋给 elementdata,节省空间 int r = 0, w = 0; boolean modified = false; try &#123; //遍历，把要保存的元素存在前面 for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement)//存储要保留的元素。集合 c 中是否包括该元素 == 删除补集？ elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123;// 此段代码作用为：当 c.contains 抛出异常时（此时 r &lt; size ），保持与 AbstractCollection 的行为兼容性 System.arraycopy(elementData, r, elementData, w, size - r);//将后面的元素移动到 w 后面 w += size - r;//加上移动的元素数，获取「最后的元素」的下标 &#125; if (w != size) &#123;//清除引用，防止内存泄漏 // clear to let GC do its work for (int i = w; i &lt; size; i++)//将 w 之后的元素都置为 null elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 性能注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。 查/获取 获取此列表中指定位置上的元素。 12345public E get(int index) &#123; rangeCheck(index); checkForComodification(); return java.util.ArrayList.this.elementData(offset + index);&#125; 小结、对比改1234567public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = java.util.ArrayList.this.elementData(offset + index); java.util.ArrayList.this.elementData[offset + index] = e; return oldValue;&#125; 对比调整数组容量扩容123456789101112131415161718192021222324252627282930313233343536public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;/** * 内部保证容量，如果 ArrayList 是通过无参构造函数创建的， * 那么第一次 add 元素的时候就会调用该方法扩容 * */private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;/** * 确保分配指定的容量 * */private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code //如果指明的最小容量超过数组的长度，就增大容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 每次数组容量的增长大约是其原容量的 1.5 倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造 ArrayList 实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用 ensureCapacity 方法来手动增加 ArrayList 实例的容量。 「压缩」 ArrayList 还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过 trimToSize 方法来实现。代码如下： 12345678910//将 ArrayList 的容量压缩到当前元素数量，这样可以最大限度节省空间public void trimToSize() &#123; modCount++;//定义与父类 AbstractList 中，记录发生结构化修改的次数。如果不打算提供「快速失败的迭代器」，可忽略此域 if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; Fail-Fast 机制ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。具体介绍请参考我之前的文章深入 Java 集合学习系列：HashMap 的实现原理 中的 Fail-Fast 机制。 快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 java.util 包下的都是快速失败。 安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。 在 java.util.concurrent 包下的全是安全失败的。 即 抛异常是快速失败（util 包下都是快速失败），不抛异常是安全失败。 Java 版本越往后越「安全」，concurrent 包下面全部为安全失败 总结可以看到核心操作在于增加和删除元素。 增删改查中， 增导致扩容，则会修改 modCount，删一定会修改。 改和查一定不会修改 modCount。 扩容操作会导致数组复制，批量删除会导致找出两个集合的交集，以及数组复制操作，因此，增、删都相对低效。 而 改、查都是很高效的操作。 因此，结合特点，在使用中，以 Android 中最常用的展示列表为例，列表滑动时需要展示每一个 Item（element）的数组，所以 查 操作是最高频的。相对来说，增操作只有在列表加载更多时才会用到 ，而且是在列表尾部插入，所以也不需要移动数据的操作。而删操作则更低频。 故选用 ArrayList 作为保存数据的结构。 和Vector的区别，Vector内部也是数组实现的，区别在于Vector在 API 上都加了synchronized所以它是线程安全的，以及Vector扩容时，是翻倍 size，而ArrayList`是扩容 50%。 参考资料与学习资源推荐 面试必备：ArrayList 源码解析（JDK8） 深入 Java 集合学习系列：ArrayList 的实现原理 Java ArrayList 工作原理及实现 若本文中有不正确的结论、说法，请大家提出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>java集合框架</category>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>java集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码中的装饰者模式]]></title>
    <url>%2Fblog%2F2017%2F09%2F05%2FAndroid-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰者模式的定义装饰模式（Decorator Pattern） 也称包装模式（Wrapper Pattern），是结构型设计模式之一，使用一种对客户端透明的方式来动态地拓展对象的功能，同时它也是继承关系的一种替代方案之一。 通过装饰者模式可以动态地给一个对象添加一些额外的职责。就增加功能而言，装饰模式相比生成子类更灵活。因为它装饰者持有一个被装饰者的引用，因此可以方便地调用具体被装饰者对象中的方法，因此可以在不破坏原类层次结构的情况下为类增加一些功能，我们只需要在被装饰者对象的相应方法前后增加相应的功能逻辑即可。 使用场景需要透明且动态地拓展类的功能时。 UML 类图 Component 抽象组件 可以是接口或者抽象类，充当一个被装饰的原始对象。（在该模式中位于继承结构的顶部，大家都直接/间接地继承它） ConcreteComponent 组件具体实现类 该类是 Component 类的具体实现，也是我们装饰的具体对象。 Decorator 抽象装饰者 继承自 Component 并且必须持有一个指向 Component 的引用 通常会在其方法中调用 ConcreteComponent 的方法。 如果装饰逻辑单一，可以直接省略该类，直接写一个具体的装饰者对象即可。 ConcreteDecoratorA,B,C 继承自 Decoration， 在父类对 Component 的方法调用基础上上，增加自己的一些功能。（通常都是在基础方法执行前或者后调用自己新增的方法） 使用时经常会把 ComponentImpl 或者说 ConcreteComponent 传入给具体的 Decorator。 123Compoent component = new ConponentImpl();DecoratorImpl decoratorImpl = new DecoratorImpl(component);decoratorImpl.xxOperation(); Android 源码中的模式实现 角色简介： Context ：抽象组件 ComtextImpl ：Context 的具体实现类 ContextWrapper ：装饰者的父类（其中的所有方法都只是调用了 ContextImpl 中对应的方法） ContextThemeWrapper ：继承自 ContextWrapper 的装饰者 Activity ：继承自 ContextThemeWrapper 的装饰者 我们以常用的方法为例，看看装饰者模式在其中的具体实现方式 123456789101112131415161718192021222324252627public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; //启动 Activity @Override public void startActivity(Intent intent, Bundle options) &#123; mBase.startActivity(intent, options); &#125; //发送广播 @SystemApi @Override public void sendBroadcast(Intent intent, String receiverPermission, Bundle options) &#123; mBase.sendBroadcast(intent, receiverPermission, options); &#125; //注册监听器 @Override public Intent registerReceiver( BroadcastReceiver receiver, IntentFilter filter) &#123; return mBase.registerReceiver(receiver, filter); &#125;&#125; 从以上的代码中可以看出，ContextWrapper 作为装饰者的父类，持有 Context 的引用 mBase（mBase 的实际类型为 ContextImpl），其中的所有方法都只是调用了 ContextImpl 中对应的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class ContextImpl extends Context &#123; //启动 Activity 的逻辑实现 @Override public void startActivity(Intent intent) &#123; warnIfCallingFromSystemProcess(); startActivity(intent, null); &#125; @Override public void startActivity(Intent intent, Bundle options) &#123; warnIfCallingFromSystemProcess(); // 代码省略 //调用 Instrumentation.execStartActivity() 方法 mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, (Activity) null, intent, -1, options); &#125; @Override public void sendBroadcast(Intent intent, String receiverPermission) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); String[] receiverPermissions = receiverPermission == null ? null : new String[] &#123;receiverPermission&#125;; try &#123; intent.prepareToLeaveProcess(this); //调用 AMS 的 broadcastIntent 方法 ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, receiverPermissions, AppOpsManager.OP_NONE, null, false, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; //注册广播的方法 public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; return registerReceiver(receiver, filter, null, null); &#125; //注册广播 @Override public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) &#123; return registerReceiverInternal(receiver, getUserId(), filter, broadcastPermission, scheduler, getOuterContext()); &#125; //注册广播的具体实现 private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; //调用 AMS 的 registerReceiver 方法 final Intent intent = ActivityManagerNative.getDefault().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125; 可以看到，ContextImpl 中提供了具体的方法实现。 ContextWrapper 的子类，例如 Activity 会根据需要对具体方法的实现进行装饰或者修改。 比如 startActivity() 方法，Activity 没有使用被装饰者的实现，而是自己实现了一套逻辑。 123456789101112131415161718192021222324252627282930313233public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, WindowControllerCallback &#123; @Override public void startActivity(Intent intent) &#123; this.startActivity(intent, null); &#125; @Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125; public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) &#123; if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); //调用 Instrumentation.execStartActivity() 方法 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); //代码省略 &#125;&#125; ContextImpl 的创建从上面解析中我们知道 Context 的实现中使用了装饰者模式也知道了 ContextImpl 是 Context 具体实现类，但是 ContextImpl 是在上面地方被初始化的呢？ 我们猜想 Activity 启动之后我们便可以调用 Context 中的方法了，我们猜想 ContextImpl 是在 Activity 创建过程中初始化的。 对 Android FrameWork 层有所了解同学应该知道 Activity 是由 AMS 管理的，AMS 会通过调用 ApplicationThread 与间接地控制 Activity。 ApplicationThread 的 scheduleXxx 方法中会调用 sendMessage 方法将相应的 Message 发送给 H，H 根据不同的 Message 调用 ActivityThread 中相应的 handleXxx 方法。 ActivityThread#H 12345678910111213141516private class H extends Handler &#123; //代码省略 public void handleMessage(Message msg) &#123; //代码省略 switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); //调用 handleLaunchActivity handleLaunchActivity(r, null, "LAUNCH_ACTIVITY"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; //代码省略&#125; 当需要启动新的 Activity 时，ApplicationThread 的 scheduleLaunchActivity 方法会先被调用，该方法会通过 H 调用 handleLaunchActivity 方法，而 handleLaunchActivity 方法又会调用 performLaunchActivity 方法。 ActivityThread#performLaunchActivity 1234567891011121314151617181920212223242526private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //代码省略 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //创建 Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; //获取 Context Context appContext = createBaseContextForActivity(r, activity); //将前面准备的值关联到 Activity 中 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); //代码省略 &#125; return activity;&#125; ActivityThread#createBaseContextForActivity 12345678private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; ContextImpl appContext = ContextImpl.createActivityContext(//调用 ContextImpl 的静态方法创建 Activity Context this, r.packageInfo, r.token, displayId, r.overrideConfig); appContext.setOuterContext(activity);//外部的 context（此处为 Activity）设置给 ContextImpl Context baseContext = appContext; //代码省略 return baseContext;&#125; ContextImpl#createActivityContext() 1234567static ContextImpl createActivityContext(ActivityThread mainThread, LoadedApk packageInfo, IBinder activityToken, int displayId, Configuration overrideConfiguration) &#123; if (packageInfo == null) throw new IllegalArgumentException("packageInfo"); return new ContextImpl(null, mainThread, packageInfo, activityToken, null, 0, null, overrideConfiguration, displayId);&#125; 经过上面的分析，我们可以得出结论，Activity 的 Context 是在 performLaunchActivity 方法中通过调用 createBaseContextForActivity 初始化的。在 createBaseContextForActivity 方法中，通过调用 ContextImpl 的静态方法 createActivityContext 创建 获取一个 ContextImpl 的实例对象，并通过 setOuterContext 方法将两者建立关联。 总结学过代理模式的同学可能觉得装饰模式与代理模式有点像（因为同样持有引用）。但是既然是它们是两个不同的设计模式，先看看它们的格子的定义。 装饰模式：以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；代理模式：给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用； 光看定义可能还是比较模糊。二者区别在哪里呢？ 装饰模式应该为所装饰的对象增强功能 代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。 可以简单地理解为：你在一个地方写装饰，大家就知道这是在增加功能，你写代理，大家就知道是在限制。 参考资料与学习资源推荐 《Android 源码设计模式解析与实战》]]></content>
      <categories>
        <category>原理分析</category>
        <category>Android 进阶</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码中的享元模式——Message 复用原理]]></title>
    <url>%2Fblog%2F2017%2F08%2F26%2FAndroid-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Message%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[介绍享元模式是对象池的一种实现，它的英文名为 Flyweight，代表轻量级的意思。 享元模式用来尽可能==减少内存使用量==，它适合用于可能存在大量对象的场景，来==缓存可共享的对象==（例如 Message、Java 中的字符串常量池）,从而实现对象共享、避免创建过多对象的效果，这样一来就可以提升性能，避免内存移除等。 享元模式中的部分状态是可以共享的， 可以共享的状态称为内部状态。内部状态不会随着环境变化 不可共享的状态则称之为外部状态，他们会随着环境的改变而改变。 享元模式会建立一个对象容器，在经典的享元模式中，该容器为一个 Map，它的键是享元对象的内部状态，它的值就是享元对象本身。 享元模式的定义享元模式是一种结构型设计模式，以共享的方式高效地支持大量的细粒度对象。 使用场景 系统中存在大量的相似对象 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。 需要缓冲池的场景。 UML 类图 Flyweight ：享元对象抽象基类或者接口。 ConcreteFlyweight：具体享元对象。 FlyweightFactory ：享元工厂，负责创建享元对象和管理享元对象池。 Android 源码中的享元模式在使用 Handler 发送消息之前，我们一般都会使用如下代码调用 mHandler.obtainMessage() 方法获取一个 Message 对象。这其中究竟是怎么实现的呢？ 1234567891011121314Handler mHandler = new Handler();public void do() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //do sth Message message = mHandler.obtainMessage(); message.what = 1; message.obj = result; mHandler.sendMessage(message); &#125; &#125;);&#125; 1234//Handler.otainMessage()方法public final Message obtainMessage()&#123; return Message.obtain(this);&#125; 可以看到 Handler.obtainMessage() 实际上调用的是 Message 的 obtain 方法，我们顺着源码看下去。 先看看 Message 类部分源码 1234567891011121314151617181920212223242526272829// sometimes we store linked lists of these thingsMessage next;private static final Object sPoolSync = new Object();//作为锁对象private static Message sPool;//虽然名称为 sPool 但是实际上是一个指向消息队列队首的指针private static int sPoolSize = 0;//private static final int MAX_POOL_SIZE = 50;//「对象池」中的最大数量public static Message obtain(Handler h) &#123; Message m = obtain();//调用 obtain 方法获取 message 对象 m.target = h;//指定 message 的目标对象 return m;&#125;//从消息对象池中取出一个 Message 对象，如果没有就创建一个public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // 清空 in-use flag sPoolSize--; return m; &#125; &#125; return new Message();//消息池中没有可复用的 Message 就创建一个新的 Message&#125; 至此，从对象池中获取对象的大致流程。无论是 Handler.obtainMessage(参数列表) 方法，还是 Message 的 obtain(参数列表) 方法，最终都会调用 Message.obtain() 方法。在 Message.obtain() 方法的实现中，会先从对象池中获取 Message 对象，如果获取不到，则创建一个新的 Message 对象，然后返回。该对象在后续的执行过程中会被回收到对象池，以便复用。 但是 Message 对象是如何被回收到「对象池」中的呢？ 从 Message 类的部分代码中我们看到 sPool 的实际类型是一个 Message 对象，而不是一个容器。另外从 obtain 方法中我们不难看到链表的踪影。难道消息池是使用链表实现的吗？ 在 AS 中打开 Message 类的结构图，可以看到其中有一个 recycle 方法，我们看看里面是怎么实现的。 123456789101112131415161718192021222324252627282930313233343536public void recycle() &#123; if (isInUse()) &#123;//判断消息是否还在使用 if (gCheckRecycle) &#123;//如果消息处在使用状态时被 gc 回收，就抛出异常 throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); &#125; return;//直接返回，取消回收操作 &#125; recycleUnchecked();//调用回收方法&#125;/** * 回收一个可能还在使用的对象 */void recycleUnchecked() &#123; // 只要该对象还在回收对象池中，就标记该对象为正在使用状态。 // 清空其他状态 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; //回收消息到消息池中 synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; recycle 方法首先会判断 Message 对象是否处在使用状态。如果处在使用状态会直接返回（如果此时 GC 回收该对象会抛出异常），否则调用 recycleUnchecked 方法，具体的回收逻辑是在 recycleUnchecked 方法中实现的。首先会标记 Message 处于使用状态，然后清空对象中的其他状态。将消息存入回收池，主要是链表的操作。大致如下图所示。 小结Message 通过在内部构建一个链表来维护一个被会受到 Message 对象的对象池，当用户调用 obtain 方法时，会优先从池中获取。如果池中没有可以复用的对象就创建一个新的对象，该对象使用完之后，会被缓存到对象池中，当下次调用 obtain 方法时，他们就会被复用。 此处 Message 扮演了三个角色。既是 FlyWeight 抽象，又是 ConcreteFlyWeight 对象，同时还担任 FlyWeightFactory 角色，承担着管理对象池的职责。 想进一步了解 Android 消息机制的同学可参考Android 消息机制解析。 总结享元模式的优点： 大幅度降低了内存中对象的数量。从而降低了内存的占用，提高了程序的性能。 缺点： 使得系统更加复杂。为了使应用能够共享，需要将一些状态外部化，这使得程序的逻辑复杂化。 享元模式将状态外部化，而读取外部状态使得运行时间稍微变长 参考资料与学习资源推荐 《JAVA 与模式》之享元模式 《Android 源码设计模式解析与实战》 Android 消息机制解析 若本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>原理分析</category>
        <category>Android 进阶</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 源码中的模板方法模式——AsyncTask解析]]></title>
    <url>%2Fblog%2F2017%2F08%2F24%2FAndroid-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94AsyncTask%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言假设我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的。就好像执行程序的流程： 检查代码的正确性 链接相关代码 编译相关代码 执行程序 对于不同的语言，上述 4 个步骤都是不一样的，但是它们的执行流程是固定的，这类问题的解决方案就是我们介绍的模板方法模式。 模板方法模式的定义定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式的使用场景 多个子类有公有的方法，并且逻辑基本相同时。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，把相同的代码抽取到父类中，然后通过钩子方法约束其行为。 注：何谓钩子方法？基本方法又可以分为三种：抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。 这是《java与模式》书里的一种说法，三种方法也是在书中的模板方法模式中提及到的。 先说这个三个方法的基本定义： 抽象方法：由抽象类声明，由具体子类实现。在java语言里一个抽象方法以abstract关键字标示出来。 具体方法：由抽象类声明并实现，而子类并不实现或覆盖。其实就是一般的方法，但是不需要子类来实现。 钩子方法：由抽象类声明并实现，而子类也会加以扩展。通常抽象类给出的是一个空的钩子方法，也就是方法体为空的方法（也可以根据需要实现部分逻辑）。其实它和具体方法在代码上没有区别，不过是意识上的一种区别。 详见抽象方法 具体方法 钩子方法 模板方法模式的 UML 类图 AbsTemplate：抽象类，定义一套算法框架 ConcreteImplA：具体实现类 A ConcreteImplB：具体实现类 B 模板方法模式的简单示例实际上是封装一个固定流程，就像是一套执行模板一样，第一步该做什么，第二步该做什么都已经在抽象类中定义好。而子类可以有不同的算法实现，在框架不被修改的情况下实现某些步骤的算法替换。 Android 源码中的模板方法模式AsyncTask使用过 AsyncTask 的同学都知道，我们调用 execute 之后，（如果没有调用 cancel 方法的话）以下三个方法会依次执行： onPreExecute doInBackground onPostExecute 为什么能让它们依次执行呢？其内部是怎么实现的？我们看看源码，一探究竟。 首先看看异步任务的入口方法 execute。123456789101112131415161718192021222324252627282930 @MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 以上两个构造方法中主要做了如下几件事： 状态判断 判断之后执行 onPreExecute(); 使用线程池执行 mFuture 什么样的线程池？ 默认为 SerialExecutor 即单线程的线程池 123456789101112131415161718192021222324252627282930313233343536public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);//设置进程优先级 //noinspection unchecked result = doInBackground(mParams);//调用 doInBackground 方法 Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result);//调用 postResult 方法 &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get());//任务完成 &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occurred while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 12private final WorkerRunnable&lt;Params, Result&gt; mWorker;private final FutureTask&lt;Result&gt; mFuture; mWorker 类型为 WorkerRunnable&lt;Params, Result&gt; ， WorkerRunnable 实现了 Callable mFuture 类型为 FutureTask&lt;Result&gt; 简而言之，这个 mFuture 包装了这个 mWorker 对象，而 mFuture 是在线程池中执行的，会调用 mFuture 的 run 方法，该 run 方法中调用了 mWorker 的 call 方法，mWorker 的 call 方法又调用了 doInBackground 方法，所以 doInBackground 是在工作线程执行的。 123456private void postResultIfNotInvoked(Result result) &#123; final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) &#123; postResult(result); &#125;&#125; doInBackground 执行完成后会通过 postResult(result) 方法将结果传递给主线程。 postResult(result) 可能通过 call 方法的 finally 块直接调用或者通过 FutureTask 中的 done 方法里面的 postResultIfNotInvoked(get()); 来间接调用。 接下来我们看看 postResult(result) 方法1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // 调用 AsyncTask 的 finish 方法 result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; postResult(result) 方法就是通过发送一条消息（msg.what == MESSAGE_POST_RESULT）给 sHandler，sHandler 为 InternalHanlder。当 InternalHanlder 接收到 MESSAGE_POST_RESULT 时，就会调用 result.mTask.finish(result.mData[0]) 方法，result 的类型为 AsyncTaskResult 123456789private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 从 AsyncTaskResult 的具体实现中吗，我们知道 mTask 就是 AsyncTask，finish 方法中又调用了 onPostExecute ，此时整个执行流程就完成了。 小结execute 方法内部封装了 onPreExecute、doInBackGround、onPostExecute 这个逻辑流程。通过这种方式，用户可以根据自己的需求再覆写这几个方法，使得用户可以很方便地使用异步任务来完成耗时的操作及更新 UI。实际上就是通过线程池来执行耗时的任务，得到结果之后，通过 Handler 将结果传递给 UI 线程执行。 Activity 的生命周期函数除了 AsyncTask 以外，Android 源码中还有不少地方有模板方法的身影，比如说 Activity 的生命周期方法—— onCreate 、onStart、onResume 等，都是按照顺序调用的，我们会在对应的方法中执行合适的操作。 其内部实现涉及到进程间通信，限于篇幅，本文不作深入介绍。有兴趣的同学可以看看 ActivityThread 的 main 方法，以之作为入口，对生命周期方法的调用时机做进一步研究。 模板方法总结简单概括模板方法模式就是流程封装。把某一个固定的流程封装到一个固定的 final 方法中。并且让子类能够定制这个过程中的某些甚至所有步骤，这就要求父类提取共用的代码，提升代码的复用率，同时也带来了更高的可扩展性。 优点： 封装不变的部分，扩展可变的部分 提取公共部分代码，便于维护。 缺点： 提高了代码阅读的难度，会让用户觉得难以理解 参考资料与学习资源推荐 《Android 源码设计模式解析与实战》 抽象方法 具体方法 钩子方法 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问请在下面评论区告诉我，谢谢！]]></content>
      <categories>
        <category>原理分析</category>
        <category>Android 进阶</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型设计模式之备忘录模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[备忘录模式的定义备忘录模式是一种行为型设计模式，该模式用于保存对象当前的状态，并且在之后可以再次恢复到此状态。 实现效果为：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便后续将对象恢复到原来的状态。 备忘录模式的使用场景 需要保存一个对象在某一个时刻的状态或部分状态 一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。（如果使用接口来让其他对象获取对象的状态，会破坏封装性） 备忘录模式的UML类图 三个角色： Originator：需要保存状态的对象。负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。 Memento（类似于 pojo 类）备忘录角色。用于存储 Originator 内部状态，并且可以防止 Originator 以外的对象访问 Memento Caretaker：负责存储备忘录，不能对备忘录的内容进行操作和访问，只能将备忘录传递给其他对象。 Android源码中的备忘录模式日常开发中如果需要保存什么数据以防止 Activity 意外销毁，第一时间会想到 Activity 中的这两个方法——onSaveInstanceState、onRestoreInstanceState。其内部具体是如何实现数据保存的呢？ 先透漏一下，这里面使用到了备忘录模式。 123456789101112protected void onSaveInstanceState(Bundle outState) &#123; //1. 存储窗口的视图树的状态 outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); //2. 存储 Fragment 中的状态 Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; //3. 若用户设置了 Activity 的 ActivityLifeCycleCallbacks， //则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。 getApplication().dispatchActivitySaveInstanceState(this, outState);&#125; Activity.onSaveInstanceState 方法中主要做了三件事 存储窗口的视图树的状态 存储 Fragment 中的状态 若用户设置了 Activity 的 ActivityLifeCycleCallbacks，则调用 ActivityLifeCycleCallbacks 的 onSaveInstanceState 进行存储状态。 首先看看步骤 1，该步骤将 Window 对象中的视图树中的各个 View 状态存储到 Bundle 中。 Window 的具体实现在 PhoneWindow 中.以下为 PhoneWindow.saveHierarchyState 的具体实现。 12345678910111213141516171819202122232425262728293031public Bundle saveHierarchyState() &#123; Bundle outState = new Bundle(); if (mContentParent == null) &#123; return outState; &#125; // SparseArray 相当于一个 key 为 整型的 map SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;(); //此处的 mContentParent 就是我们 setContentView 时设置的 View mContentParent.saveHierarchyState(states); outState.putSparseParcelableArray(VIEWS_TAG, states); // 持有焦点的 View 必须设置 id，否则重新进入该界面时不会恢复它的焦点状态 final View focusedView = mContentParent.findFocus(); if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) &#123; outState.putInt(FOCUSED_ID_TAG, focusedView.getId()); &#125; // 存储整个面板的状态 SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;(); savePanelState(panelStates); if (panelStates.size() &gt; 0) &#123; outState.putSparseParcelableArray(PANELS_TAG, panelStates); &#125; // 保存 actionbar 的状态 if (mDecorContentParent != null) &#123; SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;(); mDecorContentParent.saveToolbarHierarchyState(actionBarStates); outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates); &#125; return outState;&#125; 看看步骤 2 中的 mContentParent.saveHierarchyState 方法，mContentParent 是一个 ViewGroup 但是 saveHierarchyState 方法并不是定义在 ViewGroup 中，而是定义在它的父类——View 中，查看下该方法在 View 中的实现。123public void saveHierarchyState(SparseArray&lt;Parcelable&gt; container) &#123; dispatchSaveInstanceState(container);&#125; 12345678910111213141516protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; //1. 只有含有 id 的 View，状态才会被存储 if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123; mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED; //2. 调用 onSaveInstanceState 方法获取自身状态 Parcelable state = onSaveInstanceState(); if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123; throw new IllegalStateException( "Derived class did not call super.onSaveInstanceState()"); &#125; //3. 将自身状态存放到 container 中 if (state != null) &#123; container.put(mID, state); &#125; &#125;&#125; View.onSaveInstanceState 方法默认存储的状态为空状态。但是它的子类通常都有定义自身的覆盖方法。12345678910@CallSuperprotected Parcelable onSaveInstanceState() &#123; mPrivateFlags |= PFLAG_SAVE_STATE_CALLED; if (mStartActivityRequestWho != null) &#123; BaseSavedState state = new BaseSavedState(AbsSavedState.EMPTY_STATE); state.mStartActivityRequestWhoSaved = mStartActivityRequestWho; return state; &#125; return BaseSavedState.EMPTY_STATE;&#125; 步骤 2 中的 View 的调用大致如下：saveHierarchyState ==》 dispatchSaveInstanceState ==》 onSaveInstanceState 其中要注意的是 只有含有 id 的 View，状态才会被存储，如果没有给 view 赋一个 id，那么系统是不会帮忙保存该 view 的状态的。 View 类中的 saveHierarchyState 方法调用了dispatchSaveInstanceState 方法用来存储自身状态。 ViewGroup 覆写了 dispatchSaveInstanceState 来存储自身以及子视图的状态。 ViewGroup.dispatchSaveInstanceState具体实现如下：123456789101112@Overrideprotected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; super.dispatchSaveInstanceState(container); final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) &#123;//遍历调用子 View 的 dispatchSaveInstanceState 方法 View c = children[i]; if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123; c.dispatchSaveInstanceState(container); &#125; &#125;&#125; 可以看到 ViewGroup 的 dispatchSaveInstanceState 方法会先调用 super.dispatchSaveInstanceState(container); 存储自身的状态。然后遍历调用所有子视图的 dispatchSaveInstanceState(container) 方法来保存它们的状态，如果子 View 也是一个 ViewGroup，则会再次执行这个过程。 我们以 TextView 的 saveInstanceState 方法为例，看看具体的控件是如何保存自身状态的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Overridepublic Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); // Save state if we are forced to final boolean freezesText = getFreezesText(); boolean hasSelection = false; int start = -1; int end = -1; //存储 TextView 的 start、end if (mText != null) &#123; start = getSelectionStart(); end = getSelectionEnd(); if (start &gt;= 0 || end &gt;= 0) &#123; // 是否存存在选项 hasSelection = true; &#125; &#125; if (freezesText || hasSelection) &#123; SavedState ss = new SavedState(superState); //保存 TextView 的文本内容 if (freezesText) &#123; if (mText instanceof Spanned) &#123; final Spannable sp = new SpannableStringBuilder(mText); if (mEditor != null) &#123; removeMisspelledSpans(sp); sp.removeSpan(mEditor.mSuggestionRangeSpan); &#125; ss.text = sp; &#125; else &#123; ss.text = mText.toString(); &#125; &#125; //存储 TextView 的 start、end if (hasSelection) &#123; // XXX Should also save the current scroll position! ss.selStart = start; ss.selEnd = end; &#125; if (isFocused() &amp;&amp; start &gt;= 0 &amp;&amp; end &gt;= 0) &#123; ss.frozenWithFocus = true; &#125; ss.error = getError(); if (mEditor != null) &#123; ss.editorState = mEditor.saveInstanceState(); &#125; //返回状态对象 return ss; &#125; return superState;&#125; 调用 View 的 onSaveInstance 函数之后就得到了 View 要存储的数据，此时执行到 View 的 dispatchSaveInstanceState 方法中的注释 3。这里以 View 的 id 为 key，以状态为 value，存储到 container（ SparseArray 类型）中。1234//3. 将自身状态存放到 container 中if (state != null) &#123; container.put(mID, state);&#125; 存储完 Window 的视图状态信息之后，便会执行存储 Fragment 中的状态信息、回退栈等。Fragment 也是通过调用自身的 onSaveInstaceState 方法来存储自身的 View 视图树状态的。 最后就是调用用户设置的 ActivityLifecycleCallbacks 的 onSaveInstaceState 方法，让用户做一些额外的处理 前面我们所提及到的只是备忘录模式中的 Originator 角色，即需要保存备忘录的对象。不过也有涉及到 CareTaker 角色——Activity。下面我们再看看另外两个角色——Memoto 和 CareTaker。 存了状态信息的 Bundle 数据存储在哪？ onSaveInstance 方法是在 onStop 方法之前调用的。Activity.onStop 方法是通过 Activity 的 performStopActivity 间接调用。123456 final void performStopActivity(IBinder token, boolean saveState, String reason) &#123; //获取 ActivityClientRecord ActivityClientRecord r = mActivities.get(token); // saveState 表示是否保存状态 performStopActivityInner(r, null, false, saveState, reason);&#125; 1234567891011121314151617181920212223242526272829303132333435private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState, String reason) &#123; if (r != null) &#123; if (!keepShown &amp;&amp; r.stopped) &#123; if (r.activity.mFinished) &#123; // 如果正在执行销毁过程，是用户主动销毁。 activity 不打算恢复，我们也没必要调用 onStop 方法 return; &#125; //代码省略 &#125; // 在调用 onStop 之前必须先调用 onPause performPauseActivityIfNeeded(r, reason); //代码省略 // 接下来让 activity 保存它目前的状态和它所管理的 dialogs if (!r.activity.mFinished &amp;&amp; saveState) &#123; if (r.state == null) &#123; // 间接调用 Activity.onSaveInstance() callCallActivityOnSaveInstanceState(r); &#125; &#125; if (!keepShown) &#123; try &#123; // 执行 onStop 方法 r.activity.performStop(false /*preserveWindow*/); &#125; catch (Exception e) &#123; // ... &#125; //将 stop 字段置为 true 表示已经调用了 stop 方法。 r.stopped = true; &#125; &#125;&#125; 123456789101112private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123; r.state = new Bundle();//内容就存储在该 Bundle 中 r.state.setAllowFds(false); if (r.isPersistable()) &#123; r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); &#125; else &#123; //该方法实际调用了 Activity.onSaveInstanceState 方法 mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); &#125;&#125; 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) &#123; activity.performSaveInstanceState(outState, outPersistentState);&#125; 上面的 performStopActivity 与 performStopActivityInner 方法中，首先通过 token 从 mActivities 中获取一个 ActivityClientRecord 对象，状态信息就是存储在这里面的。获取该对象之后，调用了 performStopActivityInner 方法，对于保存状态而言，该方法大概有如下三步 判断 Activity 是否需要保存状态 如果需要，则调用 onSaveInstance 方法，该方法会将状态信息存储到 ActivityClientRecord 中 调用 Activity.onStop() 方法 执行 onStop 方法之前，系统会根据情况来选择是否存储 Activity 的状态，并且将这些状态（简介地）存储到 mActivities 中。 mActivities 是一个 ArrayMap&lt;IBinder, ActivityClientRecord&gt; ，它维护了一个 Activity 的信息表，当 Activity 重新启动时，会从 mActivities 中查询对应的 ActivityClientRecord，如果这个记录对象中含有状态信息就调用 Activity 的 onRestoreInstanceState 方法。开发人员可以从这个方法中做一些状态恢复操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //代码省略 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //1. 构建 Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent); //代码省略 &#125; catch (Exception e) &#123; //代码省略 &#125; try &#123; //2. 创建一个 Application 对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); //代码省略 if (activity != null) &#123; //创建 appContext，类型为 ContextImpl Context appContext = createBaseContextForActivity(r, activity); //代码省略 //3. 关联 appContext、Application 等对象到 Activity 中 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); //代码省略 activity.mCalled = false; //4. 调用 Activity.onCreate 方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; //代码省略 r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; //调用 onStart 方法 activity.performStart(); r.stopped = false; &#125; //5. 如果有保存状态的话，调用 Activity.onRestoreInstanceState 方法恢复状态 if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; //代码省略 &#125; r.paused = true; //6. 将 Activity 的信息记录对象——ActivityClientRecord 存储到 mActivities 中。 mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; return activity;&#125; 在上面的注释 5 处，系统会判断 Activity 是否调用过了 Activity.finish() 方法、是否是「永久的」以及 ActivityClientRecord 对象中的 state 是否为空， 如果满足条件，就会获取存储的状态信息传递给 Activity.onRestoreInstanceState 方法，也会将这些数据传递给 onCreate 方法的 bundle 参数 。 不过 Google 官方推荐调用 onRestoreInstanceState 方法来恢复状态，因为只有在存储有状态信息的时候才会调用该方法，而在 onCreate 方法中还需要先进行判空处理。 小结上述过程中备忘录模式的三种关键角色分别由什么类扮演？ CareTaker：Activity 负责存储、恢复 UI 的态信息。 Originator：Activity、Fragment、View、ViewGroup ，是需要存储状态的对象 Memoto：由 Bundle 类扮演 Activity 会在停止之前根据 Activity 的退出情景来选择是否需要存储状态 在重新启动该 Activity 时会判断 ActivityClientRecord 对象中是否存储了 Activity 的状态 如果含有状态，调用 Activity.onRestoreInstanceState() 方法恢复状态。从而使得 Activity 的 UI 可以恢复至异常退出前的状态。 你可能会问的问题onSaveInstanceState 何时被调用onSaveInstanceState() 方法会在什么时候被执行？有这么几种情况： 当用户按下 HOME 键时。 这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 长按HOME键，选择运行其他的程序时。 按下电源按键（关闭屏幕显示）时。 从 Activity A 中启动一个新的 Activity 时。 屏幕方向切换时，例如从竖屏切换到横屏时。 onSaveInstanceState 的调用在 onStop 方法之前，但是与 onPause 方法之间没有既定关系。 总而言之，当系统存在「==未经用户许可==」时销毁了我们的 Activity，则 onSaveInstanceState() 会被系统调用，这是系统的责任，因此它必须提供一个机会让用户保存数据。 「经用户许可」的情况不多，通常只有用户按下回退键这一种。这种情况下是用户主动退出某个 Activity，系统不会调用 onSaveInstanceState() 方法。 各个 「Originator 」 的 onSaveInstanceState() 方法的默认实现是怎么样的？在前面的分析中我们知道即使没有覆写 onSaveInstanceState()方法, ViewGroup、View、Fragment、Activity 内部都有自己的默认实现，它们的默认实现也会保存某些状态数据。 比如 activity 中各种 UI 控件的状态。android 应用框架中定义的几乎所有 UI 控件都恰当的实现了 onSaveInstanceState() 方法,因此当 Activity 被销毁和重建时, 这些 UI 控件会自动保存和恢复状态数据. EditText 控件会自动保存和恢复输入的数据 CheckBox 控件会自动保存和恢复选中状态 … 开发者只需要为这些控件指定一个唯一的 id(通过设置 android:id 属性即可), 剩余的事情就可以自动完成了 注意：如果没有为控件指定ID, 则这个控件就不会进行自动的数据保存和恢复操作。 由上所述, 如果我们需要覆写 onSaveInstanceState() 方法, 一般会在第一行代码中调用该方法的默认实现:super.onSaveInstanceState(outState)。 有默认实现，还需要重写 onSaveInstanceState() 方法吗？既然该方法的默认实现可以自动的保存UI控件的状态数据, 那什么时候需要覆写该方法呢? 如果需要保存额外的数据时, 就需要覆写 onSaveInstanceState() 方法。大家需要注意的是：onSaveInstanceState()方法只适合保存瞬态数据, 比如 UI 控件的状态，成员变量的值等，而不应该用来保存持久化数据，持久化数据应该当用户离开当前的 activity时，在 onPause() 中保存（比如将数据保存到数据库或文件中）。说到这里，还要说一点的就是在onPause()中不适合用来保存比较费时的数据，所以这点要理解。 另外由于 onSaveInstanceState() 方法方法不一定会被调用, 因此不适合在该方法中保存持久化数据, 例如向数据库中插入记录等。 保存持久化数据的操作应该放在 onPause() 中。若是永久性值，则在 onPause() 中保存；若有大量要保存的数据，则另开线程，以免阻塞 UI 线程。 参考资料与学习资源推荐 《Android 源码设计模式解析与实战》 Android 开发之 instanceState详解]]></content>
      <categories>
        <category>设计模式</category>
        <category>Android 原理分析</category>
        <category>Android 进阶</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>设计模式</tag>
        <tag>Android 原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 ThreadLocal]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2F%E7%90%86%E8%A7%A3%20ThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal 是什么？ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。 为什么要使用 ThreadLocal？从定义我们知道 ThreadLocal 是一个用于存储本线程内部数据的类。假设没有 ThreadLocal 的话，每个 Thread 中可以输入自己的一个本地变量，但是在整个 Thread 的生命周期中，如果要穿梭很多 class 的很多 method 来使用这个本地变量的话，就要一直一直向下传送这个变量，显然很麻烦。那么怎么才能在这个 Thread 的生命中，在任何地方都能够方便的访问到这个变量呢，这时候 ThreadLocal 就诞生了。 ThreadLocal 就是这么个作用，除此之外和通常使用的本地变量没有任何区别。也就是说，没有 ThreadLocal 也是可以解决问题的，但是会比较麻烦，ThreadLocal 的作用便是简化线程内部数据的使用流程。 ThreadLocal 的内部实现既然是线程的本地变量，那自然与线程有着密切的联系。 打开 Thread 的源码可以看到，源码中有一个类型为 ThreadLocal.ThreadLocalMap 的变量1ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal#get 流程我们以 ThreadLocal#get 方法作为分析的源头。这些方法的逻辑都比较简单，因此直接在注释中说明。可参考小结部分的调用流程图。 12345678910public T get() &#123; Thread t = Thread.currentThread();//获取当前线程 ThreadLocalMap map = getMap(t);//获取当前线程的 ThreadLocalMap 对象 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this);//获取存储该 ThreadLocal 的 Entry if (e != null) return (T)e.value;//获取目标值并返回 &#125; return setInitialValue();//设置初始值&#125; ThreadLocal#getMap，该方法返回当前线程的 ThreadLocalMap 对象。 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; Entry 类继承自弱引用，防止内存泄漏。其中存储了 ThreadLocal 以及对应的值 12345678static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125;&#125; ThreadLocal#setInitialValue 12345678910private T setInitialValue() &#123; T value = initialValue();//获取默认的初始值 Thread t = Thread.currentThread();//获取当前线程 ThreadLocalMap map = getMap(t);//获取当前线程的 ThreadLocalMap 对象 if (map != null) map.set(this, value);//当前线程的 ThreadLocalMap 对象不为空，直接设置给目标对象。 else createMap(t, value);//为当前线程创建 ThreadLocalMap 对象。 return value;&#125; ThreadLocal#initialValue 123456//该方法的调用时机：//1. 通常该方法只会被调用一次，也就是在第一次初始化时//2. 调用了 ThreadLocal#remove 方法之后（使得 Entry 被回收），再调用 ThreadLocal#get 方法protected T initialValue() &#123; return null;//；默认实现为返回 null&#125; ThreadLocal#createMap 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);//调用构造方法初始化&#125; ThreadLocal#set 流程12345678public void set(T value) &#123; Thread t = Thread.currentThread();//获取当前线程 ThreadLocalMap map = getMap(t);//获取当前线程的 ThreadLocalMap 对象 if (map != null) map.set(this, value);//当前线程的 ThreadLocalMap 对象 已经存在直接设置值 else createMap(t, value);//为当前线程创建 ThreadLocalMap &#125; 可以看到 ThreadLocal#set 方法的逻辑与 ThreadLocal#setInitialValue 方法中的逻辑如出一辙，这里不再赘述。 ThreadLocalMapThreadLocalMap 是 ThreadLocal 的一个静态内部类。其中以键值对的形式存储数据。可以将它简单理解为一个 HashMap。ThreadLocal#createMap 方法通过调用 ThreadLocalMap 的构造方法为当前线程创建一个 ThreadLocalMap 对象。 ThreadLocalMap 的构造方法1234567ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY];//创建一个长度为 16 的 Entry 数组 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);//计算 key 的哈希值 table[i] = new Entry(firstKey, firstValue);//将 Entry 存到指定位置。 size = 1; setThreshold(INITIAL_CAPACITY);&#125; ThreadLocalMap 的构造方法主要做了下面几件事： 首先创建了一个 Entry 数组， Entry 是 ThreadLocalMap 中的一个静态内部类,它以 ThreadLocal 为 key，以要存储的值为 value。 然后根据 key 计算 Hash 值 接着创建一个 Entry 对象存储在数组中 最后设置大小和阈值。 ThreadLocalMap.Entry123456789static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125;&#125; Entry 作为 ThreadLocalMap 的元素，表示的是一个键值对：ThreadLocal 的弱引用为键，将要用 ThreadLocal 存储的对象为值。 解决冲突的方式线性探测法。 123456789101112131415161718 /*ThreadLocals 依赖于附加到每个线程（Thread.threadLocals和inheritableThreadLocals）的线性探测 HashMap。 ThreadLocal对象作为键，通过threadLocalHashCode进行搜索。这是一个自定义的 hash code（仅在ThreadLocalMaps中有用），可以消除常见情况下的冲突，而在不常见的情况下也能表现良好。*/private final int threadLocalHashCode = nextHashCode();private static AtomicInteger nextHashCode = new AtomicInteger();/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647;//（1640531527）十进制/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; java.lang.ThreadLocal.ThreadLocalMap#getEntryAfterMiss 12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; java.lang.ThreadLocal.ThreadLocalMap#nextIndex 123private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125; ThreadLocal 会造成内存泄漏？因为作为 key 的 ThreadLocal 是弱引用，所以一发生 GC ，ThreadLocal 就会被回收，这个时候 Map 中存在一个 Key 为 null 的键值对，但是 value 仍然被线程强引用着，那么如果用完ThreadLocal后不主动移除（调用 ThreadLocal#remove 方法），就会造成短期的内存泄漏。但事实上，ThreadLocal 用完后主动调 remove 就能规避这个问题。 注：上面说 value 被线程强引用是因为存在这样一条引用链：栈帧中持有一个当前线程的引用，ThreadLocalMap 被当前线程引用着，ThreadLocalMap 中有指向 Entry 的强引用，Entry 有持有 value 的强引用。具体可参考下图。 当前 Thread 结束以后, Current Thread 就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收。 前面提到不调用 remove 方法 ThreadLocal 会造成短期的内存泄漏，下面就来证明下这个说法是否正确。 为什么说是「短期的内存泄漏」呢？以 ThreadLocal#get 为例 12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this);//调用 ThreadLcoalMap#getEntry 方法 if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; 12345678private Entry getEntry(ThreadLocal key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key)//命中 return e; else return getEntryAfterMiss(key, i, e);//不在数组的相应位置上（可能是冲突）&#125; ThreadLocal.ThreadLocalMap#getEntryAfterMiss 12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i);//移除「过期的」Entry，也就是移除 key 为 null 的 Entry else i = nextIndex(i, len);//加 1 「取模」，获得下一个地址 e = tab[i]; &#125; return null;&#125; ThreadLocal.ThreadLocalMap#expungeStaleEntry 123456789101112131415161718192021222324252627282930313233//移除指定下标对应的的「过期的」Entry，private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // 删除过期的 slot 上的 entry tab[staleSlot].value = null; tab[staleSlot] = null; size--; // 不断尝试，直到遇到 e 为 null为止。 Entry e; int i; for (i = nextIndex(staleSlot, len);//（staleSlot +1）% len (e = tab[i]) != null; i = nextIndex(i, len)) &#123;//(i+1)%len ThreadLocal k = e.get();//待清除的 entry if (k == null) &#123;//key 为 null，说明该 entry 已经过期，需要被移除 e.value = null;//将 value 置为 null，方便 GC tab[i] = null;//解除对 entry 的应用 size--; &#125; else &#123;//key 不为 null 的情况。这一步的操作主要是方便查找，提高命中率 int h = k.threadLocalHashCode &amp; (len - 1);//通过 hash 值计算下标 if (h != i) &#123;//下标不相等，说明之前setValue 时发生冲突，往后面存储了。 tab[i] = null;//将 //与Knuth 6.4算法R 不同，我们必须扫描直到null，因为可能有多个entry已经过期。 while (tab[h] != null)//从「本应该对应的下标」开始往后探测，直到有空位 h = nextIndex(h, len); tab[h] = e;//将 e 存储在当前情况下，最接近自己计算得出位置的那个下标。 &#125; &#125; return i;&#125; 从 ThreadLocal#get 方法（set 方法也有类似的实现）的调用链中可以看到：在没有主动调用 ThreadLocal#remove 的情况下，ThreadLocalMap后续的get/set中也会探测到那些key为 null的entry，然后将其 value 设置为 null 以帮助GC，因此 value 在 key 被 GC 后可能还会存活一段时间（也就是说会造成短期的内存泄漏），但最终也会被回收。这个过程和 java.util.WeakHashMap 的实现几乎是一样的。不过为了避免潜在的内存泄漏还是要养成一个习惯，使用完 ThreadLocal 中的value 之后要调用 ThreadLocal#remove 。 小结get 方法调用的主要流程 get 方法中会尝试获取当前线程的 ThreadLocalMap 如果 ThreadLocalMap 非空，并且以当前 ThreadLocal 对象为 key 去获取到的 Entry 不为空，就返回该 ThreadLocal 对应的值； 否则，先获取默认的初始值（默认实现为空，可以自己重写 initialValue 方法来设置需要的值） 然后判断 ThreadLocalMap 是否为空 如果为空创建一个 ThreadLocalMap 同时将初始值设置进去。 如果不为空，直接把初始值存储在其中。 set 方法的调用流程 你可能存在的疑问每个 ThreadLocal 只能放一个对象吗？每个 ThreadLocal 只能放一个对象。要是需要放其他的对象，就再 new 一个新的 ThreadLocal 出来，这个新的 ThreadLocal 将作为 key,需要放的对象作为value，放在 ThreadLocalMap 中。也就是说一个线程可以含有多个 ThreadLocal 类。 当然也可以根据需要在 ThreadLocal 存放一些容器对象，比如 List、Set、Map，一个 ThreadLocal 存放一个容器对象，借助该容器对象也可以实现存储多个对象。 为什么 ThreadLocal 只存储一个对象却要用一个 ThreadLocalMap 来存储值？实际上每个线程中都有一个 ThreadLocal.ThreadLocalMap，真正存储数据的类是 ThreadLocalMap ，可以将它看作是一个 HashMap，而 ThreadLocal 是一个维护类。我们知道，存储的时候，都是以 ThreadLocal 实例作为 key，然后和 value 一起作为键值对存储到 ThreadLocalMap 中。当我们调用不同 ThreadLocal 的 set 方法时，如果 ThreadLocalMap 不为空，那么直接在里面存储键值对就可以了，不需要再创建新的值。也就是说，同一个线程上的不同 ThreadLocal 对象，存储的值是在同一个 ThreadLocalMap 上。 没有 ThreadLocal 能不能解决问题？能。 可以自己定义一个静态的 map，将当前 thread 作为 key，将目标值作为 value，put 到 map 中，这也是一般人的想法。 ThreadLocal 的实现刚好相反，它是在每个线程中有一个 map，而将 ThreadLocal 实例作为 key，这样每个 map 中的项数很少，而且当线程销毁时相应的东西也一起销毁了。因为各线程访问的 map 是各自不同的 map，所以不需要同步，速度会快些；而如果把所有线程要用的对象都放到一个静态 map中的话 多线程并发访问需要进行同步。 所以说 ThreadLocal 只是实现线程私有变量的一种方式。但是综合来看这种方式相比其他实现方式要更好。 典型应用我们通常会用下面的方式为普通线程创建一个 Looper。 123456789101112class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare();//为当前线程创建一个 Looper mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop();//开启消息循环 &#125; &#125; Android 中每个线程中最多只能有一个 Looper，这种限制就是通过 ThreadLocal 来实现的。 12345public final class Looper &#123; //创建一个 ThreadLocal 对象，其泛型类型为 Looper，在调用 prepare 之前 sThreadLocal.get() 都返回空。 static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); //...&#125; 创建 Looper 时会同时创建一个泛型类型为 Looper 的 ThreadLocal 对象。 Looper#prepare()，通过 prepare 方法可以为当前线程创建一个 Looper。 12345678910public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123;//如果线程已经存在 Looper 了 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));//为当前线程创建一个 Looper 对象，并将它存储在当前线程的 ThreadLocalMap 中&#125; Looper#myLooper() ，通过该方法可以获取当前线程的 Looper 对象 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 注意如果一个对象的引用被多个线程持有，那么即使该对象存在 ThreadLocalMap 中也不是线程的本地变量。 首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过 ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。各个线程中访问的是不同的对象。 也就是说，其他线程能否访问，还要看你的 set 进去的对象引用是否被其他线程持有。 如果两个线程都存入同一个对象引用，那就会有线程共享问题。 总结我们总结 ThreadLocal 具体是怎么一步一步去为每一个线程创建一个~线程私有变量~的： 首先，在每个线程 Thread 内部有一个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals，这个 threadLocals 就是用来存储~线程私有变量的~，键值（key）为当前 ThreadLocal 变量，值 value 为~线程的私有变量~（即 T 类型的变量）。 初始时，在 Thread 里面，threadLocals 为空，当通过 ThreadLocal 变量调用 get() 方法或者 set() 方法，就会对 Thread 类中的 threadLocals 进行初始化，并且以当前 ThreadLocal 变量为 key，以 ThreadLocal 要保存的~线程私有变量~为 value，存到 threadLocals 中。 注意，如果是 先调用 get() 方法而不是 set() 方法的话，会返回 null 然后在当前线程里面，如果要使用~该线程私有变量~，就可以通过 get 方法在 threadLocals 里面查找。 参考资料与学习资源推荐 正确理解 ThreadLocal ThreadLocal and synchronized 补充 ThreadLocal Java并发编程：深入剖析ThreadLocal Android关于ThreadLocal的思考和总结 深入理解ThreadLocal 如果本文中有不正确的结论、说法，请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明白原理,轻松解决内存泄漏]]></title>
    <url>%2Fblog%2F2017%2F08%2F19%2F%E6%98%8E%E7%99%BD%E5%8E%9F%E7%90%86-%E8%BD%BB%E6%9D%BE%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[相信「内存泄漏」 问题，是一个挺让开发者头疼的事情，笔者在回顾以为代码时，惊讶发现：初学 Android 时，许多不修边幅的代码习惯，导致了许多内存泄漏问题，借此分析其原因，把自己挖过的坑补一下，也希望奔跑在 Android 开发道路上的你能够优雅避免。 什么是内存泄漏 对于 C++ 来说，内存泄漏就是 new 出来的对象没有 delete，俗称野指针； 而对于 java 而言，就是存放在堆上的 Object 无法被 GC 正常回收； 分析之前我们先来看看三个基础知识点。 基础知识java 的内存分配简述运行时数据区域内存模型图 方法区（non-heap）：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量； 栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存； 堆区（heap）：通常用来存放 new 出来的对象。由 GC 负责回收。 四种不同类型的引用GC 过程与对象的引用类型有着很大的联系，下面我们就看看 Java 中（Android 中存在差异）的四种引用： 强引用（Strong Reference）:JVM 宁愿抛出 OOM，也不会让 GC 回收存在强引用的对象。 软引用（Soft Reference） ：只有内存不足时，才会被 GC 回收。 弱引用（weak Reference）：在 GC 时，如果一个对象只存在弱引用，将会被回收 虚引用（Phantom Reference）：任何时候都可以被 GC 回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为 GC 回收 Object 的标志。 与 Android 中的差异：在 2.3 以后版本中，即使内存够用，Android 系统会优先将 SoftReference 的对象提前回收掉, 其他和 Java 中是一样的。因此谷歌官方建议用 LruCache(least recentlly use 最少最近使用算法)。会将内存控制在一定的大小内, 超出最大值时会自动回收, 这个最大值开发者自己定。 可达性分析算法内存泄漏是因为内存无法被正常回收引起。为什么无法被回收？我们前面是这么说的——「因为它的强/软引用被长生命周期的对象持有」。可为什么引用被长生命周期的对象持有就不能进行释放呢？这就涉及到了垃圾回收机制。 进行垃圾回收的第一个问题是如何确定哪些对象是可以被回收的垃圾。通常有两种判断方法，一种是引用计数方法，另一种是可达性分析算法。主流的商用程序语言的主流实现中，都是通过可达性分析来判断对象是否存活的。 可达性分析算法的基本思路是这样的： 通过一系列的称为 GC Root 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为『引用链』（Reference Chain） 当一个对象到 GC Root 没有任何引用链相连时，则证明此对象是不可用的。 问题来了，到底什么是 GC Root 呢？ R 大在知乎中这样答道：所谓“GC roots”，或者说tracing GC的“根集合”，一组必须活跃的==引用== 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。 VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。 JNI handles，包括global handles和local handles （看情况）所有当前被加载的Java类 （看情况）Java类的运行时常量池里的引用类型常量（String或Class类型） （看情况）String常量池（StringTable）里的引用 关于 GC 回收机制，可以参考下这篇文章 内存泄漏的危害 运行性能的问题: Android在运行的时候，如果内存泄漏将导致其他组件可用的内存变少，一方面会使得GC的频率加剧，在发生GC的时候，所有进程都必须进行等待，GC的频率越多，从而用户越容易感知到卡顿。另一方面，内存变少，将可能使得系统会额外分配给你一些内存，而影响整个系统的运行状况。 运行崩溃问题: 内存泄露是内存溢出(OOM)的重要原因之一，会导致 Crash。如果应用程序在消耗光了所有的可用堆空间，那么再试图在堆上分配新对象时就会引起 OOM(Out Of Memory Error) 异常，此时应用程序就会崩溃退出。 内存泄漏的典型案例要想避免内存泄漏，首先要知道导致内存泄漏的原因。内存泄漏本质原因:==长生命周期的对象持有短生命周期对象的强/软引用。导致本应该被回收的短生命周期的对象无法被正常回收==。 这么讲可能比较抽象。举个常见的栗子：单例模式中，我们常常在获取单例对象时需要传一个 Context 。单例对象是一个长生命周期的对象（应用程序结束时才终结），而如果我们传递的是某一个 Activity 作为 context,那么这个 Activity 就会因为引用被持有而无法销毁，从而导致内存泄漏。 下面我们来看看导致内存泄漏的常见例子。 永远的 Singleton单例的使用在我们的程序中随处可见，因为使用它可以解决我们在程序中重复创建对象的问题。但是由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏。 解决 应该把传入的 Context 改为同应用生命周期一样长的 Application 中的 Context。 也可以通过重写 Application，提供 getContext 方法,那样就不需要在获取单例时传入 context。 123456789101112public class BaseApplication extends Application&#123; private static ApplicationContext sContext; @Override public void onCreate()&#123; super.onCreate(); sContext = getApplicationContext(); &#125; public static Context getApplicationContext()&#123; return sContext; &#125;&#125; Handler 引发的内存泄漏由于 Handler 属于 TLS（Thread Local Storage）变量，导致它的生命周期和 Activity 不一致。因此通过 Handler 来更新 UI 一般很难保证跟 View 或者 Activity 的生命周期一致，故很容易导致无法正确释放。12345678910111213141516171819202122public class HandlerBadActivity extends AppCompatActivity &#123; private final Handler handler = new Handler()&#123;//非静态内部类，持有外部类的强引用 @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler_bad); // 延迟 5min 发送一个消息 handler.postDelayed(new Runnable() &#123;//内部会将该 Runable 封装为一个 Message 对象，同时将 Message.target 赋值为 handler @Override public void run() &#123; //do something &#125; &#125;, 1000 * 60 * 5); this.finish(); &#125;&#125; 上面的代码中发送了了一个延时 5 分钟执行的 Message，当该 Activity 退出的时候，延时任务（Message）还在主线程的 MessageQueue 中等待，此时的 Message 持有 Handler 的强引用（创建时通过 Message.target 进行指定），并且由于 Handler 是 HandlerBadActivity 的非静态内部类，所以 Handler 会持有一个指向 HandlerBadActivity 的强引用，所以虽然此时 HandlerBadActivity 调用了 finish 也无法进行内存回收，造成内存泄漏。 解决将 Handler 声明为静态内部类，但是要注意如果用到 Context 等外部类的 非static 对象，还是应该使用 ApplicationContext 或者通过弱引用来持有这些外部对象。123456789101112131415161718192021public class HandlerGoodActivity extends AppCompatActivity &#123; private static final class MyHandler extends Handler&#123;//声明为静态内部类（避免持有外部类的强引用） private final WeakReference&lt;HandlerGoodActivity&gt; mActivity; public MyHandler(HandlerGoodActivity activity)&#123; this.mActivity = new WeakReference&lt;HandlerGoodActivity&gt;(activity);//使用弱引用 &#125; @Override public void handleMessage(Message msg) &#123; HandlerGoodActivity activity = mActivity.get(); if (activity == null || activity.isFinishing() || activity.isDestroyed()) &#123;//判断 activity 是否为空，以及是否正在被销毁、或者已经被销毁 removeCallbacksAndMessages(null); return; &#125; // do something &#125; &#125; private final MyHandler myHandler = new MyHandler(this);&#125; 慎用 static 成员变量从前面的介绍我们知道，static 修饰的变量位于内存的方法区，其生命周期与 App 的生命周期一致。这必然会导致一系列问题，如果你的 app 进程设计上是长驻内存的，那即使 app 切到后台，这部分内存也不会被释放。 解决不要在类初始时初始化静态成员，也就是可以考虑懒加载。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。 当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下： 说明： NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要==创建一个新的 task 任务队列==。 对于 Dialog 而言，只有在 Activity 中才能创建 下面举一个隐蔽的栗子 使用系统服务引发的内存泄漏为了方便我们使用一些常见的系统服务，Activity 做了一些封装。比如说，可以通过 getPackageManager 在 Activtiy 中获取 PackageManagerService，但是，里面实际上调用了 Activity 对应的 ContextImpl 中的 getPackageManager 方法 ContextWrapper#getPackageManager 1234@Overridepublic PackageManager getPackageManager() &#123; return mBase.getPackageManager();&#125; ContextImpl#getPackageManager 1234567891011121314@Overridepublic PackageManager getPackageManager() &#123; if (mPackageManager != null) &#123; return mPackageManager; &#125; IPackageManager pm = ActivityThread.getPackageManager(); if (pm != null) &#123; // Doesn't matter if we make more than one instance. return (mPackageManager = new ApplicationPackageManager(this, pm));//创建 ApplicationPackageManager &#125; return null;&#125; ApplicationPackageManager#ApplicationPackageManager 12345ApplicationPackageManager(ContextImpl context, IPackageManager pm) &#123; mContext = context;//保存 ContextImpl 的强引用 mPM = pm;&#125; 123456private UserManagerService(Context context, PackageManagerService pm, Object packagesLock, File dataDir) &#123; mContext = context;//持有外部 Context 引用 mPm = pm; //代码省略&#125; PackageManagerService#PackageManagerService 1234567public class PackageManagerService extends IPackageManager.Stub &#123; static UserManagerService sUserManager;//持有 UMS 静态引用 public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) &#123; sUserManager = new UserManagerService(context, this, mPackages);//初始化 UMS &#125;&#125; 笔者遇到的内存泄漏问题是因为在 Activity 中调用了 getPackageManger 方法获取 PMS ，该方法调用的是 ContextImpl，此时如果ContextImpl 中 PackageManager 为 null，就会创建一个 PackageManger（ContextImpl 会将自己传递进去，而 ContextImpl 的 mOuterContext 为 Activity），创建 PackageManager 实际上会创建 PackageManagerService（简称 PMS），而 PMS 的构造方法中会创建一个 UserManger（UserManger 初始化之后会持有 ContextImpl 的强引用）。 只要 PMS 的 class 未被销毁，那么就会一直引用着 UserManger ，进而导致其关联到的资源无法正常释放。 小结本例的引用链大致如下： 方法区中（1.8 后移到了 元空间）含有已经加载的 PMS class，PMS 静态引用 –&gt; UserManger（mContext） –&gt; ContextImpl（mOuterContext） –&gt; Activity (资源无法被正常回收) 通常这种内存泄漏总是比较隐蔽，不使用检测工具，根本就想不到，原来那一行代码竟然会引发内存泄漏。 解决将getPackageManager() 改为 getApplication()#getPackageManager() 。这样引用的就是 Application Context，而非 Activity 了。 远离非静态内部类和匿名类，有需要时请使用静态内部类为什么要怎么做呢?因为使用非静态内部类和匿名类都会默认持有外部类的引用，如果生命周期不一致，就会导致内存泄漏。 看一个例子。 1234567891011121314151617public class NestedClassLeakActivity extends AppCompatActivity &#123; class InnerClass &#123;//非静态内部类 &#125; private static InnerClass sInner;//指向非静态内部类的静态引用 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_nested_class); if (sInner == null) &#123; sInner = new InnerClass();//创建非静态内部类的实例 &#125; &#125;&#125; 本例中，因为非静态内部类默认会持有外部类的引用，而外部类中又有一个该非静态内部类的静态实例，该静态实例的生命周期和应用的一样长，而静态实例又持有 Activity 的引用，因此导致 Activity 的内存资源不能正常回收。 解决 将该内部类设为静态内部类 也可以将该内部类抽取出来封装成一个单例 集合引发的内存泄漏我们通常会把一些对象的引用加入到集合容器（比如ArrayList）中，当我们不再需要该对象时（通常会调用 remove 方法），并没有把它的引用从集合中清理掉（其中的一种情况就是 remove 方法没有将不再需要的引用赋值为 null），下面以 ArrayList 的 remove 方法为例 12345678910111213141516public E remove( int index) &#123; // 数组越界检查 RangeCheck(index); modCount++; // 取出要删除位置的元素，供返回使用 E oldValue = (E) elementData[index]; // 计算数组要复制的数量 int numMoved = size - index - 1; // 数组复制，就是将index之后的元素往前移动一个位置 if (numMoved &gt; 0) System. arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一个元素置空（因为删除了一个元素，然后index后面的元素都向前移动了，所以最后一个就没用了），好让gc尽快回收 elementData[--size ] = null; // Let gc do its work return oldValue;&#125; elementData[--size ] = null; // Let gc do its work 如果替换为 --size，就会导致已经「移除」的对象因为强引用被集合持有，而无法正常被 gc 回收。 WebView 引发的内存泄漏WebView 解析网页时会申请Native堆内存用于保存页面元素，当页面较复杂时会有很大的内存占用。如果页面包含图片，内存占用会更严重。并且打开新页面时，为了能快速回退，之前页面占用的内存也不会释放。有时浏览十几个网页，都会占用几百兆的内存。这样加载网页较多时，会导致系统不堪重负，最终强制关闭应用，也就是出现应用闪退或重启。 由于占用的都是 Native 堆内存，所以实际占用的内存大小不会显示在常用的 DDMS Heap 工具中（ DMS Heap 工具看到的只是Java虚拟机分配的内存，即使Native堆内存已经占用了几百兆，这里显示的还只是几兆或十几兆）。只有使用 adb shell 中的一些命令比如 dumpsys meminfo 包名，或者在程序中使用 Debug.getNativeHeapSize() 才能看到 Native 堆内存信息。 据说由于 WebView 的一个 BUG，即使它所在的 Activity(或者Service) 结束也就是 onDestroy() 之后，或者直接调用 WebView.destroy()之后，它所占用这些内存也不会被释放。 解决把使用了 WebView 的 Activity (或者 Service) 放在单独的进程里。 系统在检测到应用占用内存过大有可能被系统干掉 也可以在它所在的 Activity(或者 Service) 结束后，调用 System.exit(0)，主动Kill掉进程。由于系统的内存分配是以进程为准的，进程关闭后，系统会自动回收所有内存。 使用 WebView 的页面（Activity），在生命周期结束页面退出（onDestory）的时候，主动调用WebView.onPause()==以及==WebView.destory()以便让系统释放 WebView 相关资源。 其他常见的引起内存泄漏原因 Android 3.0 以下，Bitmap 在不使用的时候没有使用 recycle() 释放内存。 非静态内部类的静态实例容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。 警惕线程未终止造成的内存泄露；譬如在 Activity 中关联了一个生命周期超过 Activity 的 Thread，在退出 Activity 时切记结束线程。 一个典型的例子就是 HandlerThread 的 run 方法。该方法在这里是一个死循环，它不会自己结束，线程的生命周期超过了 Activity 生命周期，我们必须手动在 Activity 的销毁方法中中调用 thread.getLooper().quit() 才不会泄露。 对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。 创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。 避免代码设计模式的错误造成内存泄露；譬如循环引用，A 持有 B，B 持有 C，C 持有 A，这样的设计谁都得不到释放。 内存泄漏的检测工具 LeakCanary 是 Apache 开源的一个自动检测内存泄漏的框架。具体用法可以参考 LeakCanary——如何检测 Activity 是否泄漏 使用 AS Monitor + MAT 自己分析内存泄漏原因。虽然MAT不会准确告诉你你的代码哪泄漏了，但是它会给你发现哪泄露的数据和线索。 AS 3.0 中提供了 Profiler 工具，这里简述一下使用流程：手动点击 GC 按钮（图标是一个垃圾桶）—&gt; 选择 Dump 内存（等待20秒左右）—&gt; 下方会弹出分析结果窗口—&gt; 下拉选择 app heap ，下拉选择 Arrange by package—&gt;到包下寻找自己认为可能发生内存泄漏的类，单击选中类 —&gt; 右边弹出 Instance View 窗口，显示该类的所有实例 —&gt; 选中某一个实例 –&gt; 下方会弹出 Reference 窗口（显示该实例的所有引用），然后分析一下到底是谁强引用了该实例，导致内存无法释放。 参考资料与学习资源推荐 Android 性能优化 详解内存优化的来龙去脉 内存泄漏全解析，从此拒绝ANR，让OOM远离你的身边，跟内存泄漏say byebye 明白原理，轻松应对Android内存泄漏 如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！]]></content>
      <categories>
        <category>原理分析</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码中的代理模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F18%2FAndroid%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式的定义代理模式也称为委托模式，为其他对象提供一种代理以控制对这个对象的访问。 代理模式的使用场景当无法或不想访问某个对象或者访问某个对象存在困难时可以通过一个代理对象来间接访问。 为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口（或继承相同的抽象类） 代理模式的UML类图 角色介绍： Subject 抽象主题类 主要职责是声明真实主题类与代理的共同接口方法，该类可以是一个抽象类也可以是一个接口 RealSubject 真实主题类 也称为被委托类或被代理理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题类中定义的方法。 ProxySubject 代理类 也称为委托类，持有一个对真实主题类的引用，在其实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。 Client 使用代理类的类 代理模式的简单实现代理模式大致可分为两大部分，静态代理和动态代理。 动态代理通过反射机制动态地生成代理者的对象，code 阶段不需要知道代理谁，代理的真正对象会在执行阶段确定。 Java 提供一个便捷的动态代理接口 InvocationHandler，实现该接口需要重写其调用方法 invoke。 动态代理通过一个代理类来代理 N 多个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的的耦合关系。 代理可以看作是 对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是代理完成。（观点：大部分动态代理的场景可以看作是 装饰器模式的应用。） 静态代理 vs 动态代理相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂。 但是静态代理更符合面向对象的原则。 实际开发中具体使用哪种方式来实现代理，看自己的偏好。 分类静态代理和动态代理是从 code 方面来区分代理模式的。 也可以从其使用范围来区分不同类型的代理实现： 远程代理（Remote Proxy）为某个对象在不同的内存地址空间提供局部代理。使系统可以将 Server 部分的实现隐藏，以便 Client 可以不考虑 Server 的存在。 虚拟代理（Virtual Proxy）使用一个代理对象表示一个十分耗资源的对象并在真正需要时才创建。 保护代理(Protection Proxy)：使用代理控制对原始对象的访问。该类型的代理常被用于原始对象具有不同访问权限的情况。 智能引用(Smart Reference)：在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数。 静动态代理都可以应用于上述 4 种情形。 Android源码中的代理模式实现以 ActivityManager 为例。 抽象接口: IActivityManager 代理类 ActivityManagerProxy 被代理类 ActivityManagerNative(抽象类，并不处理太多的逻辑，大部分逻辑由其子类——ActivityManagerService 承担) ActivityManagerService(真实部分) ActivityManagerService 是系统级的 Service 并且运行于独立的进程空间中，可以通过 ServiceManger 获取到它。 ActivityManagerProxy 运行于自己所处的进程空间中（也就是说，与 ActivityManagerService 运行在不同的进程中） 所以此处源码所实现的代理实质为==远程代理==。 ActivityManagerProxy 在实际的逻辑处理并没有过多地被外部类使用，Android 中管理与维护 Activity 相关信息的类是另一个叫做 ActivityManager 的类。不过实质上 ActivityManager 大多数逻辑还是由 ActivityManagerProxy 承担。（注意：ActivityManager 并没有实现 IActivityManager 接口，它直接继承自 Object） 以 ActivityManager 的 getAppTasks() 方法为例1234567891011121314public List&lt;ActivityManager.AppTask&gt; getAppTasks() &#123; ArrayList&lt;AppTask&gt; tasks = new ArrayList&lt;AppTask&gt;(); List&lt;IAppTask&gt; appTasks; try &#123; appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; int numAppTasks = appTasks.size(); for (int i = 0; i &lt; numAppTasks; i++) &#123; tasks.add(new AppTask(appTasks.get(i))); &#125; return tasks;&#125; ActivityManagerNative.getDefault();方法 返回一个 IActivityManager 类型的对象，通过该对象调用其 getAppTasks 方法123static public IActivityManager getDefault() &#123; return gDefault.get();&#125; gDefault 到底是什么？123456789private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService("activity");//获取 AMS //代码省略 IActivityManager am = asInterface(b);//完成创建一个 AMS 的客户端端代理对象—— ActivityManagerProxy //代码省略 return am; &#125;&#125;; 上述代码中构造了一个 Singleton&lt;IActivityManager&gt; 类型的 gDefault 对象，其中通过 ServiceManager.getService(&quot;activity&quot;); 获取一个系统级的 Service，而该 Service 实质上就是 AMS，接着调用 asInterface 方法，创建一个 ActivityManagerProxy 对象。 ActivityManagerNative.asInterface 方法的具体实现1234567891011static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; ActivityManagerProxy 的 getTasks 方法，将数据打包跨进程传递给 Server 端的 AMS 处理12345678910111213141516171819202122232425public List&lt;ActivityManager.RunningTaskInfo&gt; getTasks(int maxNum, int flags) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeInt(maxNum); data.writeInt(flags); mRemote.transact(GET_TASKS_TRANSACTION, data, reply, 0); reply.readException(); ArrayList&lt;ActivityManager.RunningTaskInfo&gt; list = null; int N = reply.readInt(); if (N &gt;= 0) &#123; list = new ArrayList&lt;&gt;(); while (N &gt; 0) &#123; ActivityManager.RunningTaskInfo info = ActivityManager.RunningTaskInfo.CREATOR .createFromParcel(reply); list.add(info); N--; &#125; &#125; data.recycle(); reply.recycle(); return list; &#125; 看看 AMS 中的 getTasks 方法的具体实现。1234567891011121314151617181920212223242526272829303132333435@Overridepublic List&lt;IAppTask&gt; getAppTasks(String callingPackage) &#123; int callingUid = Binder.getCallingUid(); long ident = Binder.clearCallingIdentity(); synchronized(this) &#123; ArrayList&lt;IAppTask&gt; list = new ArrayList&lt;IAppTask&gt;(); try &#123; if (DEBUG_ALL) Slog.v(TAG, "getAppTasks"); final int N = mRecentTasks.size(); for (int i = 0; i &lt; N; i++) &#123; TaskRecord tr = mRecentTasks.get(i); // Skip tasks that do not match the caller. We don't need to verify // callingPackage, because we are also limiting to callingUid and know // that will limit to the correct security sandbox. if (tr.effectiveUid != callingUid) &#123; continue; &#125; Intent intent = tr.getBaseIntent(); if (intent == null || !callingPackage.equals(intent.getComponent().getPackageName())) &#123; continue; &#125; ActivityManager.RecentTaskInfo taskInfo = createRecentTaskInfoFromTaskRecord(tr); AppTaskImpl taskImpl = new AppTaskImpl(taskInfo.persistentId, callingUid); list.add(taskImpl); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; return list; &#125;&#125; Android 中的 Binder 跨进程通信机制与 AIDL四个重要类： Binder Client 类比 PC、终端设备 Binder Server 类比 服务器 Binder Driver（实现在内核中） 类比 路由器 Binder Manager 类比 DNS 服务器 因为依赖于抽象，加上本地代理类的存在，所以调用远程方法时，还是与调用本地的普通的方法一样。但是代理类内部需要对参数什么的进行打包处理，然后再通过 Binder 机制，跨进程将数据传递给远程方法，远程方法执行完毕再返回数据。 Binder Driver 实现在内核中，主要负责 Binder 通信的建立，以及 Binder数据在进程间的传递和 Binder 引用计数管理/数据包的传输等。 Binder Client 和 Binder Server 之间的跨进程通信统一通过 Binder Driver 处理转发， 对于 Binder Client 而言，它只需要知道自己要使用的 Binder 的名字以及该 Binder 实体在 ServerManager 中的 0 号引用即可。 访问原理： 通过 0 号引用去访问 ServerManager 获取该 Binder 的引用， 得到引用后就可以像普通方法调用那样调用 Binder 实体的方法 ServerManager 用来管理 Binder Server（Android 中通常是一个 Service） Binder Client 通过它来查询 Binder Server 的引用 ServerManager 是一个标准的 Binder Server，并且在 Android 中约定其在 Binder 通信过程中的唯一标识（类似于 IP 地址）永远为 0。 在 IServiceManager 接口中定义有对外开放的接口方法，供客户端访问。 匿名 Binder。很多时候 Binder Server 会将一个 Binder 实体封装进数据包传递给 Binder Client，而此时 Binder Server 会在该数据包中标注 Binder 实体的位置，Binder Driver 会为该匿名的 Binder 生成实体结点和实体引用，并将该引用传递给 Binder Client。 IServiceManager 接口(声明 ServerManger 对外提供的方法、数据 )1234567891011121314151617181920212223public interface IServiceManager extends IInterface &#123; public IBinder getService(String name) throws RemoteException; public IBinder checkService(String name) throws RemoteException; */ public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException; public String[] listServices() throws RemoteException; public void setPermissionController(IPermissionController controller) throws RemoteException; static final String descriptor = "android.os.IServiceManager"; int GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION; int CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+1; int ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+2; int LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+3; int CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+4; int SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+5;&#125; 参考《Andorid 源码设计模式解析与实战》 如果本文中有不正确的结论、说法，请大家提出和我讨论，共同进步，谢谢！]]></content>
      <categories>
        <category>原理分析</category>
        <category>Android 进阶</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 LayoutInflater]]></title>
    <url>%2Fblog%2F2017%2F08%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20LayoutInflater%2F</url>
    <content type="text"><![CDATA[基础系统服务的注册什么时候初始化 ContextImpl？ ContextImpl 中有这样一个成员变量，缓存系统服务。final Object[] mServiceCache = SystemServiceRegistry.createServiceCache(); 在 SystemServiceRegistry 中的静态代码块中注册。注册方法如下所示。在 static 代码块中，会注册所有的系统服务。 123456789/** * Statically registers a system service with the context. * This method must be called during static initialization only. */private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass, ServiceFetcher&lt;T&gt; serviceFetcher) &#123; SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);&#125; 以 LAYOUT_INFLATER_SERVICE 为例子，123456registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); CachedServiceFetcher 是一个实现了 ServiceFetcher&lt;T&gt; 接口的抽象类 createService 为 CachedServiceFetcher 中的抽象方法，当初始化时会调用该方法。1234567/** * Base interface for classes that fetch services. * These objects must only be created during static initialization. */static abstract interface ServiceFetcher&lt;T&gt; &#123; T getService(ContextImpl ctx);&#125; 123456789101112131415161718192021222324static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123; private final int mCacheIndex; public CachedServiceFetcher() &#123; mCacheIndex = sServiceCacheSize++; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public final T getService(ContextImpl ctx) &#123; final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; // Fetch or create the service. Object service = cache[mCacheIndex]; if (service == null) &#123;//使用了延时加载,第一次调用时才初始化，并将相应服务缓存起来。 service = createService(ctx); cache[mCacheIndex] = service; &#125; return (T)service; &#125; &#125; public abstract T createService(ContextImpl ctx);&#125; 系统服务的获取平时我们都是通过 Context.getSystemService(&quot;服务名字&quot;) 来获取服务。 具体为 ContextImpl 中的。1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; 而 getSystemService 的实际实现是在 SystemServiceRegistry 中的。 SystemServiceRegistry 中有一个 HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; ，该 HashMap 以服务名称为 key，以服务相对应的 ServiceFetcher 作为 value。 12private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); 具体的获取方法为1234567/** * Gets a system service from a given context. */public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; 根据服务名称去获取相应的 ServiceFetcher， 如果 ServiceFetcher 不为空，则调用 ServiceFetcher.getService 方法获取相应服务的引用。 如果是第一次调用会先创建，然后直接返回 否则直接返回缓存的值 如果 ServiceFetcher 为空，则返回 null。 深入理解 LayoutInflaterLayoutInflater的创建123456registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); 可见实际实现为 PhoneLayoutInflater（继承了 LayoutInflater） onCreateView 是其中最重要的方法。为什么说它重要，后面会提到。123456789101112131415161718192021/** Override onCreateView to instantiate names that correspond to the widgets known to the Widget factory. If we don't find a match, call through to our super class.*///为系统内置的控件添加前缀。比如为 TextView 添加前缀，结果为 android.widget.TextView@Override protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123; for (String prefix : sClassPrefixList) &#123; try &#123; View view = createView(name, prefix, attrs); if (view != null) &#123; return view; &#125; &#125; catch (ClassNotFoundException e) &#123; // In this case we want to let the base class take a crack // at it. &#125; &#125; return super.onCreateView(name, attrs);&#125; 渲染过程解析一般我们在渲染 ListView 或者 RecyclerView 中的列表时，都会调用 inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) 方法（有时也会使用两个参数的方法）。可以看到该方法内部会调用 inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)。123public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; return inflate(resource, root, root != null);&#125; 1234567891011public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); //代码省略 //获取 xml 解析器 final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; //存储父视图 View result = root; try &#123; // 查找根标签 int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; final String name = parser.getName(); if (TAG_MERGE.equals(name)) &#123; //1. 解析 merge 标签 rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // 2. 不是 merge 元素就直接解析布局中的视图 // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; // 生成布局参数 params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; //如果 attachToRoot 为 false，就给 temp 设置布局参数 temp.setLayoutParams(params); &#125; &#125; // 解析 temp 视图下的所有子 View rInflateChildren(parser, temp, attrs, true); // 如果 root 不为空并且 attachToRoot 为 true，那么将 temp 添加到 父视图中 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; //如果 root 为空 或者 attachToRoot 为 false，返回 xml 中的 root，而不是父视图 if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; return result; &#125;&#125; 以上的 inflate 方法主要有以下几步 解析 xml 的根标签 如果根标签是 merge，调用 rInflate 进行解析，rInflate 会将 merge 标签下的所有子 View 直接添加到根标签中 如果标签是普通元素，调用 createFromTag 调用 rInflate 解析 temp 根元素下的所有子 View，并且将这些子 View 都添加到 temp 下 返回解析到的根视图。 我们先从解析单个元素的 createViewFromTag 方法看起。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals(&quot;view&quot;)) &#123; name = attrs.getAttributeValue(null, &quot;class&quot;); &#125; // Apply a theme wrapper, if allowed and one is specified. if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; try &#123; View view; //用户可以通过设置 LayoutInlflater 的 factory 来自行解析 View，默认这些 Factory 都为空，可忽略这段 if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf(&apos;.&apos;)) &#123; // 解析内置 View 控件 view = onCreateView(parent, name, attrs); &#125; else &#123; // 解析自定义控件 view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; //代码省略 onCreateView 方法和 createView 方法有何不同？前面的介绍中，我们有提到 LayoutInlflater 创建的实际类型为 PhoneLayoutInlflater ，PhoneLayoutInlflater 覆写了 onCreateView 方法，该方法就是在 View 的标签名前添加一个 &quot;android.widget.&quot; 或 &quot;android.webkit.&quot; 或 &quot;android.app.&quot;前缀。然后再传递给 createView 解析。 也就是说内置 View 和自定义 View 最终都调用了 createView 进行解析。 为什么要这么设计呢？这是为了方便开发者在 xml 文件中更方便使用系统内置的 View（只需要写 View 名称而不需要写完整的路径），如果是自定义控件或者第三方库，写完整路径。 createView 的具体实现如下12345678910111213141516171819202122232425262728293031323334353637383940414243//根据完整路径的类名通过反射机制构造 View 对象public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; //从缓存中获取构造函数 Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); // 缓存中找不到构造函数 if (constructor == null) &#123; //如果前缀（prefix）不为空，构造完整路径，并且加载该类 clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); //代码省略 //从 class 对象中获取构造函数 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); &#125; else &#123; //代码省略 &#125; &#125; Object[] args = mConstructorArgs; args[1] = attrs; //通过反射构造 View final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123; // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; return view; &#125; //省略各种 catch、finally 代码&#125; createView 方法中，如果控件名有前缀就先构造 View 的完整路径，并且将该类加载到虚拟机中 然后获取该类的构造函数并缓存起来，再通过构造函数来创建该 View 的对象， 最后将 View 对象返回，这就是解析单个 View 的过程 123456789101112131415161718192021222324252627282930313233343536373839404142void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; //获取树的深度 final int depth = parser.getDepth(); int type; //逐个元素解析 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123;//解析 include 标签 if (parser.getDepth() == 0) &#123; throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123;解析 merge 标签 throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;); &#125; else &#123; //根据元素名进行解析 final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); //递归调用进行解析，即深度优先遍历 rInflateChildren(parser, view, attrs, true); //将解析到的 View 添加到它的父视图中 viewGroup.addView(view, params); &#125; &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125; rInflate() 通过深度优先遍历来构造视图树。每解析到一个 View 元素就会递归调用 rInflate，直到这条路径下的最后一个元素，然后在回溯过来将每个 View 元素添加到它们的 parent 中。 通过 rInflate 的解析之后，整棵视图树就构建完毕。当调用了 Activity 的 onResume 之后，之前通过 setContentView 设置的内容就会出现在我们的视野中。 总结渲染流程大致如下： inflate 查找根标签 如果是 merge，调用 rInflate 否则，调用 createViewFromTag 如果是系统内置控件（通过名称中是否含有「.」来判断），调用 PhoneLayoutInflater.onCreateView() 方法添加前缀， 处理后将完整路径传给 LayoutInflater.createView() 方法 否则，直接调用 LayoutInflater.createView() 进行解析。 参考《Android 源码设计模式解析与实战》]]></content>
      <categories>
        <category>原理分析</category>
        <category>Android 进阶</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中子线程真的不能更新 UI 吗？]]></title>
    <url>%2Fblog%2F2017%2F08%2F16%2FAndroid%20%E4%B8%AD%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%9C%9F%E7%9A%84%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97%2F</url>
    <content type="text"><![CDATA[Android 中子线程真的不能更新 UI 吗？先说结论：Android 中子线程在满足一定的条件下可以更新 UI。 一个栗子：12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private ImageView mImageView; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImageView = (ImageView)findViewById(R.id.iv); new Thread(new Runnable() &#123; @Override public void run() &#123; mImageView.setImageResource(R.drawable.ic_book);//更新 ui &#125; &#125;).start(); &#125;&#125; 如上在 onCreate 方法中新建一个线程对 mImageView 进行了操作，成功从子线程更新了 ui。 但是如果让线程 sleep 一段时间（比如 300ms）， 1234567891011new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(300);//睡眠 300 ms &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; mImageView.setImageResource(R.drawable.ic_book);//更新 ui &#125;&#125;).start(); 那么就很可能会报如下错误：(如果 300ms 不报错，可将其改为 1000ms) 12345678910111213android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:7194) at android.view.ViewRootImpl.invalidateChildInParent(ViewRootImpl.java:1111) at android.view.ViewGroup.invalidateChild(ViewGroup.java:4833) at android.view.View.invalidateInternal(View.java:12102) at android.view.View.invalidate(View.java:12062) at android.view.View.invalidate(View.java:12046) at android.widget.ImageView.setImageDrawable(ImageView.java:456) at android.support.v7.widget.AppCompatImageView.setImageDrawable(AppCompatImageView.java:100) at android.support.v7.widget.AppCompatImageHelper.setImageResource(AppCompatImageHelper.java:89) at android.support.v7.widget.AppCompatImageView.setImageResource(AppCompatImageView.java:94) at com.android.rdc.librarysystem.MainActivity$1.run(MainActivity.java:52) at java.lang.Thread.run(Thread.java:818) 分析该异常是从哪里抛出的？ 从出错的堆栈信息中可以异常看到是 ViewRootImpl#checkThread() 方法中抛出的。 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; 当访问 UI 时，ViewRootImpl 会调用 checkThread 方法去检查当前访问 UI 的线程是否为创建 UI 的那个线程，如果不是。则会抛出异常。但是为什么一开始在 MainActivity 的 onCreate 方法中创建一个子线程访问 UI，程序还是正常能跑起来呢？ 上述例子中的 Thread 执行时，ViewRootImpl 还没创建，ViewRootImpl 无法对 view tree 的根节点 DecorView 执行 performTraversals，view tree 里的所有 View 都没有被赋值 mAttachInfo（注：AttachInfo 中存储了一组信息。当 View 被连接到它的父节点时，会给这个 View 的 AttachInfo 赋值）。 在 onCreate 完成时，Activity 并没有完成初始化 view tree。view tree 的初始化是从 ViewRootImpl 执行 performTraversals 开始，这个过程会对 view tree 进行从根节点 DecorView 开始的遍历，对所有视图完成初始化，初始化包括视图的大小布局，以及 AttachInfo，ViewParent 等属性域的初始化。 ImageView#setImageResource触发的调用流程 123456789101112131415161718192021ImageView#setImageResource --&gt; View#invalidate --&gt; View#invalidate(boolean) --&gt; View#invalidateInternal //如果 if mAttachInfo 以及 mParent 都不为空 --&gt; ViewGroup#invalidateChild //这里会不断循环去取上一个结点的 mParent,一直到 mParent == null 也就是到达顶部 View 为止 --&gt; ViewRootImpl#invalidateChildInParent // 注意 DecorView 的 mParent 是 ViewRootImpl --&gt; ViewRootImpl#checkThread //在这里执行 checkThread，如果当前线程不是创建 UI 的线程则抛出异常 else ----------------------------------------------------------------------//View#invalidateInternal final AttachInfo ai = mAttachInfo;final ViewParent p = mParent;//只有当 mAttachInfo 以及 mParent 都不为空时，才会触发重绘if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; //.... p.invalidateChild(this, damage);&#125; 从上述流程可以看出，只有在 mAttachInfo 以及 mParent 都不为空时， ViewGroup#invalidateChild 才会被调用，该方法最终会触发 checkThread，而向上面所提到的， onCreate 方法调用时 ViewRootImpl 还未创建， mAttachInfo 以及 mParent 均为 null，所以在子线程修改 UI 不会报错。 但是这个时候对 View 的修改是有效果的。那么，ViewRootImpl 创建之前的，程序对 UI 的更新操作是如何进行的呢？在最初的ImageView#setImageResource 方法中已经将要图片资源 id 赋给了ImageView 的一个属性 mResource ，等到 ViewRootImpl 创建完毕之后就可以得到更新了。 ViewRootImpl 何时被创建？回过头看，抛异常的方法既然是 ViewRootImpl 中的方法，那首先应该去看看 ViewRootImpl 是在哪里、在什么时候被创建的。 如果你对 Activity 的启动流程有所了解，应该知道，Activity 的启动与生命周期都是由 ActivityThread 相应的方法触发的。我们知道每一个 Activity 都有一个顶级 View ——DecorView，当 Activity 中的视图显示出来的时候 DecorView 肯定已经创建完毕了。而 ViewRootImpl 作为 DecorView 与 WindowManager 之间的「桥梁」，应该也是在视图变得可见之前被创建出来的。说到视图可见与否，一般都会想起 onResume（实际上 onResume 调用时，Activity 的视图也不一定可见）。 从ActivityThread#handleLaunchActivity 方法出发，查看其调用流程 1234567891011ActivityThread#handleLaunchActivity --&gt; performLaunchActivity //创建 Activity *--&gt; handleResumeActivity --&gt; performResumeActivity//回调 onResume --&gt; Activity#performResume(); --&gt; Instrumentation#callActivityOnResume --&gt; Activity#onResume();//回调 onResume **--&gt; Activity#makeVisible(); --&gt; WindowManagerGlobal#addView() --&gt; root = new ViewRootImpl(view.getContext(), display);//创建 ViewRootImpl --&gt; ViewRootImpl#setView 从上述流程可以看出，ViewRootImpl 是在 WindowManagerGlobal#addView() 方法中被创建出来的。并且是在 Activity#onResume 方法调用之后才被创建。因此我们如果在 onResume 方法中创建一个子线程去修改 UI，大多数情况下也是可以成功的。 一个在子线程更新 UI 的栗子：下面代码仅用于演示，不适合直接用在实际项目中。 创建一个 handlerThread并调用它的 start 方法，获取handlerThread 中的 looper 构造一个 Handler。在该 Handler的 handleMessage方法（运行在子线程） 中将 view 添加到 WindowManger里面，并支持进行更新操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.rdc.timlin.appiumdemo;import android.graphics.Color;import android.graphics.PixelFormat;import android.graphics.drawable.ColorDrawable;import android.os.Bundle;import android.os.Handler;import android.os.HandlerThread;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.view.Gravity;import android.view.View;import android.view.WindowManager;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; public static final int CREATE_VIEW = 1; public static final int UPDATE_VIEW = 2; private Handler mHandler; private TextView mTextView; private WindowManager mWindowManager; private Button mBtnCreateView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWindowManager = getWindowManager(); HandlerThread handlerThread = new HandlerThread("my handler thread"); handlerThread.start(); mTextView = new TextView(MainActivity.this); mHandler = new Handler(handlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(); layoutParams.format = PixelFormat.TRANSPARENT;//设置为 透明，默认效果是 黑色的 layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;//设置window透传，也就是当前view所在的window不阻碍底层的window获得触摸事件。 switch (msg.what) &#123; case CREATE_VIEW: mTextView.setText("created at non-ui-thread"); mTextView.setBackground(new ColorDrawable(Color.WHITE)); layoutParams.width = WindowManager.LayoutParams.WRAP_CONTENT; layoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT; layoutParams.gravity = Gravity.CENTER; mWindowManager.addView(mTextView, layoutParams); mBtnCreateView.setClickable(false);//添加 TextView 不能 add 两次。add 完之后就屏蔽点击事件 break; case UPDATE_VIEW: mTextView.setBackground(new ColorDrawable(Color.WHITE)); mTextView.setText("updated at non-ui-thread"); layoutParams.width = WindowManager.LayoutParams.WRAP_CONTENT; layoutParams.height = WindowManager.LayoutParams.WRAP_CONTENT; layoutParams.gravity = Gravity.LEFT; mWindowManager.updateViewLayout(mTextView, layoutParams); break; &#125; &#125; &#125;; initView(); &#125; private void initView() &#123; mBtnCreateView = findViewById(R.id.btn_create_view); Button btnUpdateView = findViewById(R.id.btn_update_view); mBtnCreateView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mHandler.sendEmptyMessage(CREATE_VIEW); &#125; &#125;); btnUpdateView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mHandler.sendEmptyMessage(UPDATE_VIEW); &#125; &#125;); &#125;&#125; 布局文件。activity_main.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/btn_create_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Create View in subThread"/&gt; &lt;Button android:id="@+id/btn_update_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="update View in subThread"/&gt;&lt;/LinearLayout&gt; 总结：ViewRootImpl 的创建在 onResume 方法回调之后，而我们一开篇是在 onCreate 方法中创建了子线程并访问 UI，在那个时刻，ViewRootImpl 还没有创建，无法检测当前线程是否是创建的 UI 那个线程，所以程序没有崩溃一样能跑起来，而之后修改了程序，让线程休眠了 300 毫秒后，程序就崩了。很明显 300 毫秒后 ViewRootImpl 已经创建了，可以执行 checkThread 方法检查当前线程。 开篇的例子中我们在 onCreate 方法中创建的子线程访问 UI 是一种极端的情况。实际开发中不会这么做。 下次如果有人问你 Android 中子线程真的不能更新 UI 吗？ 你可以这么回答： 子线程可以更新 UI，但是需要创建子线程的根视图（ViewRoot），并添加到 WindowManager，还要创建子线程的 Looper。以上条件都满足时，它可以修改它自己创建的根视图中的 UI。 参考资料与学习资源推荐 Android 中子线程真的不能更新 UI 吗？ 多线程学习之–真的不能在子线程里更新 UI 吗？ 互联网笔记 Android 中子线程真的不能更新 UI 吗？ Android 只在 UI 主线程修改 UI，是个谎言吗？ 为什么这段代码能完美运行？ 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！]]></content>
      <categories>
        <category>原理分析</category>
        <category>探究</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
        <tag>探究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码中的观察者模式]]></title>
    <url>%2Fblog%2F2017%2F08%2F09%2FAndroid%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[解决、解耦的钥匙——观察者模式定义观察者模式定义了对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 使用场景 关联行为场景 需要注意的是，关联行为是可拆分的，而不是“组合”关系 事件多级触发场景 跨系统的消息交换场景，如消息队列、事件总线的处理机制。 UML 类图UML 类图如下所示： 四个角色： Subject 抽象主题（抽象的被观察者）。把所有观察者对象的引用保存在一个集合里，每个主题可以有任意数量的观察者，提供接口供添加和删除观察者对象。 ConcreteSubject 具体主题（具体的被观察者）。将有关状态存入具体观察者对象，在具体主题的内部实现发生改变时，给所有注册过的观察者发出通知 Observer 抽象观察者。定义一个更新接口，用来接收主题更改时做出相应的操作（比如更新自身的状态） ConcreteObserver 具体观察者（实现抽象观察者所定义的更新接口，以便在主题状态更改时更新自身的状态） Android ListView 的观察者模式ListView 和 RecyclerView 在 Android 中都占据着很重要的地位。 使用这两个组件时，总免不了数据更新的情况：当要更新数据时我们通常都会调用 Adapter.notifyDataSetChanged()，这其中的原理又是怎么样的呢？ 下面以 ListView 作为一个栗子，看看其中的具体实现是怎么样的。 123public void notifyDataSetChanged() &#123; mDataSetObservable.notifyChanged();&#125; 1234567891011public void notifyChanged() &#123; synchronized(mObservers) &#123; // since onChanged() is implemented by the app, it could do anything, including // removing itself from &#123;@link mObservers&#125; - and that could cause problems if // an iterator is used on the ArrayList &#123;@link mObservers&#125;. // to avoid such problems, just march thru the list in the reverse order. for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125;&#125; notifyDataSetChanged 方法会调用 DataSetObservable.notifyChanged() 方法,notifyChanged() 内部会遍历调用观察者的 onChanged() 方法。通知数据更新。 但是观察者又是什么时候注册的呢？ 以下为 setAdapter 的方法的具体实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Overridepublic void setAdapter(ListAdapter adapter) &#123; //如果 已经有 Adapter 存在，先解除注册 if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mAdapter.unregisterDataSetObserver(mDataSetObserver); &#125; resetList(); mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; mAdapter = adapter; &#125; mOldSelectedPosition = INVALID_POSITION; mOldSelectedRowId = INVALID_ROW_ID; // AbsListView#setAdapter will update choice mode states. super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; mItemCount = mAdapter.getCount(); checkFocus(); // 构建一个 AdapterDataSetObserver mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver);//注册观察者 mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; if (mStackFromBottom) &#123; position = lookForSelectablePosition(mItemCount - 1, false); &#125; else &#123; position = lookForSelectablePosition(0, true); &#125; setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) &#123; // Nothing selected checkSelectionChanged(); &#125; &#125; else &#123; mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); &#125; requestLayout();&#125; 通过源码可以看到，setAdapter 方法内部会构建一个 AdapterDataSetObserver ，然后注册为观察者。我们还可以看到注册的时候是通过 Adapter 来注册的。 Adapter 接口中声明了注册和解注册的方法签名。1234567891011121314151617public interface Adapter &#123; /** * Register an observer that is called when changes happen to the data used by this adapter. * * @param observer the object that gets notified when the data set changes. */ void registerDataSetObserver(DataSetObserver observer); /** * Unregister an observer that has previously been registered with this * adapter via &#123;@link #registerDataSetObserver&#125;. * * @param observer the object to unregister. */ void unregisterDataSetObserver(DataSetObserver observer); //代码省略&#125; 而 BaseAdapter 实现了 ListAdapter 接口，ListAdapter 接口又继承自 Adapter 接口。BaseAdapter 中注册方法和解除注册方法的具体实现： 1234567public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer);&#125;public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer);&#125; BaseAdapter 中注册方法和解除注册方法的具体实现都是通过 mDataSetObservable 来完成的。查看一下 DataSetObservable 的具体实现。1234567891011121314151617public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123; public void notifyChanged() &#123; synchronized(mObservers) &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125; &#125; public void notifyInvalidated() &#123; synchronized (mObservers) &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onInvalidated(); &#125; &#125; &#125;&#125; 该类继承了 android.database 包下的 Observable 类，而 Observable 类中存有所有观察者的引用，以及注册和解注册方法。 ListView 中的 onChange 方法具体实现又是什么样的? 还记得前面我们说 Observer 是如何注册的吗？注册时，我们构建的是 AdapterDataSetObserver。 该类是 AbsListView 的内部类。 AbsListView.AdapterDataSetObserver 继承自 AdapterView.AdapterDataSetObserver onChange 方法的主要逻辑都在 AdapterDataSetObserver 中 12345678910111213141516171819202122class AdapterDataSetObserver extends DataSetObserver &#123; //代码省略 ... @Override public void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); requestLayout(); &#125; //代码省略 ...&#125; onChange 方法中，会获取当前 Adapter 中的数据集的新数量，方法的最后调用 ListView 的 requestLayout() 方法重新进行布局。 从上面的分析中，我们可以看到 AbsListView 是抽象的观察者 ListView 是具体的观察者 Adapter 接口是抽象的被观察者 BaseAdapter 是具体的被观察者，其内部实际上是通过 android.database 包下的 Observerable 来实现注册和监听的。 小结 AdapterView 中有一个 AdapterDataSetObserver 内部类， 在 ListView 中设置 Adapter（即调用 ListView 的 setAdapter 方法）时，其内部会构建一个 AdapterDataSetObserver，并注册到 Adapter 中。可见该场景中 ListView 扮演一个观察者角色。 而 Adapter 中有一个数据集可观察者 DataSetObserable。即一个被观察者。 数据集发生变化时，开发者手动调用 Adapter.notifyDataSetChanged 方法，notifyDataSetChanged 会调用 DataSetObserverable.notifyChanged() notifyChanged() 方法会遍历所有观察者，并调用观察者的 onChanged 方法， onChanged 会获取 Adapter 中数据集的新数量，同时会调用 View.requestLayout 方法通知 ListView 更新布局，刷新用户界面。 虽然 RecyclerView 直接继承自 ViewGroup，而不是 AdapterView ，但是更新列表数据集方法的内部也是通过观察者模式来实现的。只是在其中多提供了单个数据或者指定范围数据更新等回调接口，供开发者使用。感兴趣的同学可以去看看 RecyclerView 中观察者模式的实现。 作者水平有限，疏漏之处，恳请指出。 参考 《Android 源码设计模式解析与实战》 第十二章]]></content>
      <categories>
        <category>原理分析</category>
        <category>Android 进阶</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>原理分析</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toast 原理]]></title>
    <url>%2Fblog%2F2017%2F07%2F28%2FToast%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Toast.makeText(context,”msg”,Toast.Length_SHORT).show();`我们都知道调用了这行代码，便会触发显示 Toast 信息，但是从调用开始到显示出来的具体过程是怎么样的，里面具体实现又是怎么样的呢？ 在 Toast 内部有两类 IPC 过程。 第一类： Toast 访问 NotificationManagerService 第二类：NotificationManagerService 回调 Toast 里的 TN 接口。 Toast 属于系统 Window，它内部的视图由两种方式指定，一种是系统默认的样式，另一种是自定义一个 view 然后通过 setView 方法将 view 设置进去。不管哪一种方式，它们都对应 Toast 的一个 View 类型的内部成员 mNextView。 Toast 提供 show 和 cancel 方法分别用于显示和隐藏 view，它们的内部都是一个 IPC 过程。 Toast 有定时取消功能，所以系统采用了 Handler（利用其中的 sendMessageDelayed() 方法） Toast.show() 调用流程大致如下： 先来看看 Toast.makeText 方法1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123; Toast result = new Toast(context);//创建一个新的 Toast 对象 LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取 LayoutInflater View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); //渲染出系统默认的布局 TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text);//将我们的信息设置到 TextView 中去 result.mNextView = v;//把 view 赋给 Toast 内部的View result.mDuration = duration;//设置 toast 时长 return result;&#125; 再瞧一瞧 Toast.show(); 方法12345678910111213141516public void show() &#123; if (mNextView == null) &#123;//判断，如果没有设置 Toast 的 view，就抛出异常 throw new RuntimeException(&quot;setView must have been called&quot;); &#125; INotificationManager service = getService();//获取 INotificationManager String pkg = mContext.getOpPackageName();// 获取调用者的包名 TN tn = mTN;//给 TN 赋值 tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; 这里面有几个地方看起来比较陌生 INotificationManager 是什么，TN 又是什么？ INotificationManager 的值是从 getService() 方法中得来的。我们先查看下 getService() 的内部实现：1234567static private INotificationManager getService() &#123; if (sService != null) &#123; return sService; &#125; sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService;&#125; 了解 Binder 的同学应该一看便知道，这里用到了 Binder。 INotificationManager 的具体实现在 NotificationManagerService 中，简便起见，后续内容将 NotificationManagerService 称为 NMS。 TN 又是什么？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140private static class TN extends ITransientNotification.Stub &#123; final Runnable mHide = new Runnable() &#123; @Override public void run() &#123; handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; &#125; &#125;; private final WindowManager.LayoutParams mParams = new WindowManager.LayoutParams(); final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; IBinder token = (IBinder) msg.obj; handleShow(token); &#125; &#125;; int mGravity; int mX, mY; float mHorizontalMargin; float mVerticalMargin; View mView; View mNextView; int mDuration; WindowManager mWM; static final long SHORT_DURATION_TIMEOUT = 5000; static final long LONG_DURATION_TIMEOUT = 1000; TN() &#123; // XXX This should be changed to use a Dialog, with a Theme.Toast // defined that sets up the layout params appropriately. final WindowManager.LayoutParams params = mParams; params.height = WindowManager.LayoutParams.WRAP_CONTENT; params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.format = PixelFormat.TRANSLUCENT; params.windowAnimations = com.android.internal.R.style.Animation_Toast; params.type = WindowManager.LayoutParams.TYPE_TOAST; params.setTitle("Toast"); params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE; &#125; /** * schedule handleShow into the right thread */ @Override public void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "SHOW: " + this); mHandler.obtainMessage(0, windowToken).sendToTarget(); &#125; /** * schedule handleHide into the right thread */ @Override public void hide() &#123; if (localLOGV) Log.v(TAG, "HIDE: " + this); mHandler.post(mHide); &#125; public void handleShow(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, "HANDLE SHOW: " + this + " mView=" + mView + " mNextView=" + mNextView); if (mView != mNextView) &#123; // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) &#123; context = mView.getContext(); &#125; mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123; mParams.horizontalWeight = 1.0f; &#125; if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123; mParams.verticalWeight = 1.0f; &#125; mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; mParams.hideTimeoutMilliseconds = mDuration == Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT; mParams.token = windowToken; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; if (localLOGV) Log.v(TAG, "ADD! " + mView + " in " + this); mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125; &#125; private void trySendAccessibilityEvent() &#123; AccessibilityManager accessibilityManager = AccessibilityManager.getInstance(mView.getContext()); if (!accessibilityManager.isEnabled()) &#123; return; &#125; // treat toasts as notifications since they are used to // announce a transient piece of information to the user AccessibilityEvent event = AccessibilityEvent.obtain( AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED); event.setClassName(getClass().getName()); event.setPackageName(mView.getContext().getPackageName()); mView.dispatchPopulateAccessibilityEvent(event); accessibilityManager.sendAccessibilityEvent(event); &#125; public void handleHide() &#123; if (localLOGV) Log.v(TAG, "HANDLE HIDE: " + this + " mView=" + mView); if (mView != null) &#123; // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeViewImmediate(mView); &#125; mView = null; &#125; &#125;&#125; TN 是 Toast 的一个私有的静态内部类，继承自 ITransientNotification.Stub 也是用到了 Binder 机制。 在回到 show 方法。该方法最后调用了 service.enqueueToast(pkg, tn, mDuration); 方法。我们到 NMS 看看该方法的主要实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 @Overridepublic void enqueueToast(String pkg, ITransientNotification callback, int duration)&#123; //.... final boolean isSystemToast = isCallerSystem() || ("android".equals(pkg));//是否是 android 系统的 toast final boolean isPackageSuspended = isPackageSuspendedForUser(pkg, Binder.getCallingUid()); //... synchronized (mToastQueue) &#123; int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try &#123; ToastRecord record; int index = indexOfToastLocked(pkg, callback);//根据包名和回调来获取的对应包名的 Toast 的在 mToastQueue 中的位置（如果有的话） //如果对应包名的 Toast 已经存在了，则直接在原位更新，不会把它排到队尾 if (index &gt;= 0) &#123; record = mToastQueue.get(index); record.update(duration); &#125; else &#123; //限制非系统应用的数量（不能超过 50），防止 DOS 攻击同时也是为了解决内存泄漏问题 if (!isSystemToast) &#123; int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) &#123; final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) &#123; count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123; Slog.e(TAG, "Package has already posted " + count + " toasts. Not showing more. Package=" + pkg); return; &#125; &#125; &#125; &#125; Binder token = new Binder(); mWindowManagerInternal.addWindowToken(token, WindowManager.LayoutParams.TYPE_TOAST); record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord mToastQueue.add(record);//加入 mToastQueue index = mToastQueue.size() - 1; keepProcessAliveIfNeededLocked(callingPid); &#125; if (index == 0) &#123; showNextToastLocked();//显示下一条 Toast &#125; &#125; finally &#123; Binder.restoreCallingIdentity(callingId); &#125; &#125;&#125; 该方法会将 Toast 请求封装为 ToastRecord 并将其添加进 mToastQueue 队列中。 mToastQueue 是一个 ArrayList 注意：每个非系统应用最多只能有 50 个ToastRecord。如果超出了最大值，就会出错。 这样做主要是为了 防止 DOS（Denial Of Service） 拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 将 ToastRecord 加入队列之后， enqueueToast 还调用了 showNextToastLocked(); 方法, 该方法的具体实现如下：12345678910111213void showNextToastLocked() &#123; ToastRecord record = mToastQueue.get(0); while (record != null) &#123; if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try &#123; record.callback.show(record.token);//调用 record 对象中 callback 的 show 方法 scheduleTimeoutLocked(record); //超时提醒，控制显示时间 return; &#125; catch (RemoteException e) &#123; //...代码省略 &#125; &#125;&#125; 这里的 callBack 是什么？ 它是在 ToastRecord 中的，瞅瞅 ToastRecord 的构造方法。12345678ToastRecord(int pid, String pkg, ITransientNotification callback, int duration, Binder token) &#123; this.pid = pid; this.pkg = pkg; this.callback = callback; this.duration = duration; this.token = token;&#125; 在 enqueueToast 方法中，将 Toast 包装为 ToastRecord ，创建了 ToastRecord 对象。 record = new ToastRecord(callingPid, pkg, callback, duration, token);//将 Toast 包装为 ToastRecord callBack 是 enqueueToast 中的一个参数，我们的调用如下： service.enqueueToast(pkg, tn, mDuration); 没错，callBack 实际上就是前面讲到的 Toast 的内部类 TN。 回到前面看看，TN 确实继承了 ITransientNotification.Stub。 showNextToastLocked() 方法调用 callBack 的 show() 方法来显示 Toast。 12345@Overridepublic void show(IBinder windowToken) &#123; if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.obtainMessage(0, windowToken).sendToTarget();&#125; 1234567final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; IBinder token = (IBinder) msg.obj; handleShow(token); &#125;&#125;; 其具体实现又是在 handleShow(token);1234567891011121314151617public void handleShow(IBinder windowToken) &#123; if (mView != mNextView) &#123; // 如果有必要的话，将还在显示的 toast 隐藏掉 handleHide(); mView = mNextView; //代码省略 mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);//获取 windowManager //省略代码，给布局参数赋值 if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; mWM.addView(mView, mParams); trySendAccessibilityEvent(); &#125;&#125; 以上代码核心在于12`mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);``mWM.addView(mView, mParams);` 将 Toast 的视图添加到 Window 中。 这样 View 就能顺利显示出来了。 你可能会问，为什么 TN 调用 show 方法要用到的 Handler ？ 因为该方法是被是被 NMS 以跨进程方式调用的，因此它们运行在 Binder 线程池中。为了将执行环境切换到 Toast 请求所在的线程，在它们内部使用了 Handler。 那么时间到了 Toast 又是怎么样取消的呢？ 在令 Toast 显示方法调用过程中 我们也调用了 scheduleTimeoutLocked(record); 方法。 123456private void scheduleTimeoutLocked(ToastRecord r)&#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;//设置 延迟时间 mHandler.sendMessageDelayed(m, delay);&#125; SHORT_DELAY 为 2s LONG_DELAY 为 3.5s scheduleTimeoutLocked 会发出消息给 hanlder,收到相应的信息后 handleMessage 方法会调用handleTimeout((ToastRecord)msg.obj);, 该方法又会调用 cancelToastLocked(index); 123456789void cancelToastLocked(int index) &#123; ToastRecord record = mToastQueue.get(index); try &#123; record.callback.hide();// &#125; catch (RemoteException e) &#123; //代码省略 &#125; //代码省略&#125; 可以看到隐藏 Toast 的实现也是在 TN 中的。与 handleShow 对应，有一个 handleHide 方法。该方法会将 Toast 的视图从 Window 中移除。如下所示：12345678public void handleHide() &#123; if (mView != null) &#123; if (mView.getParent() != null) &#123; mWM.removeViewImmediate(mView); &#125; mView = null; &#125;&#125;]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
      <tags>
        <tag>原理分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之单例模式]]></title>
    <url>%2Fblog%2F2017%2F07%2F20%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、什么是单例模式？wiki 给出的定义如下：单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。 比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 二、为什么要使用单例模式？ 有一些对象的内存消耗比较大，创建多次会造成很大的资源开支。 方便配置。 例如 网络请求经常要用到 cookie，如果使用 OkHttp 可以将其封装为一个单例工具类，内部使用 CookJar 对 cookie 进行管理，这样后续的请求就会方便很多。 安全性。比如 SQLite 数据库的增删查改，通过单例对象对外提供增删查改功能，可以避免一些并发错误。 三、单例模式的实现方式1. 饿汉模式1234567891011public class Singleton &#123; private static Singleton sInstance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance() &#123; return sInstance; &#125;&#125; 在声明静态对象时就把它初始化。（因为饿，所以迫不及待先把它 new 出来） 2. 懒汉模式1234567891011121314public class Singleton &#123; private static Singleton sInstance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (sInstance == null) &#123; sInstance = new Singleton(); &#125; return sInstance; &#125;&#125; 在 getInstance 方法中添加了 synchronized 关键字，也就是 一个问题：即使 instance 已经被初始化，之后的每次调用还是会 进行同步，这样会消耗不必要的资源 为什么叫做懒汉呢？其实可以理解为懒加载，有需要的时候，再把它加载出来。 懒汉单例模式的 优点：单例只有在使用时才会被实例化，在一定程度上节约了资源。 缺点：第一次加载时需要及时地实例化，反应稍慢，最大的问题是：每次调用都会进行同步，造成不必要的同步开销。 3. 双重校验锁 ( DCL )DCL 既能够在需要时才初始化实例，又能够保证线程安全，而且单例对象初始化后才调用 getInstance 不进行同步锁。12345678910public static Singleton getInstance() &#123; if (sInstance == null) &#123; synchronized (Singleton.class) &#123; if (sInstance == null) &#123; sInstance = new Singleton(); &#125; &#125; &#125; return sInstance;&#125; 为什么在同步块内还要再进行判空？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 为什么要加 volitale 关键字？sInstance = new Singleton();这句代码会被编译成多条汇编指令，它大致做了 3 件事情 给 Singleton 实例分配内存 调用 Singleton 的构造函数，初始化成员字段 将 sInstance 对象指向分配的内存空间 但是由于 Java 编译器允许处理器乱序执行，以及 JDK 1.5 之前 JMM（Java Memory Model， Java 内存模型） 中 cache、寄存器到主内存回写顺序的规定，上面的 2 和 3 的顺序是无法保证的。 如果是 1-3-2，那么当 3 执行完，并且 2 还没有执行的话，被切换到到线程 B，这时 sInstance 已经非空（因为 3 已经被执行了嘛），若 此时线程 B 直接取走 sInstance 使用时就会报错。 解决：JDK 1.5 之后，SUN 官方调整了 JVM，具体化了 volatile 关键字（禁止指令重排序）。 如果是在 JDK 1.5 之后，那么只需要把 sInstance 的声明 改为 private volatile static Singleton sInstance; 即可 4. 静态内部类单例模式DCL 在某些情况下会出现失效的问题。这个问题被称为双重检查锁定（DCL）失效。 123456789101112public class Singleton&#123; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static final Singleton sInstance = new Singleton(); &#125;&#125; 第一次调用 Singleton 的 getInstance 方法时才会导致 sInstance 被初始化。因此，第一次调用 getInstance 方法会导致虚拟机加载 SingletonHolder 类，这种方式不仅能够确保线程安全，也能保证单例对象的唯一性。 所以这是推荐使用的单例模式实现方式 5. 枚举单例对枚举不了解可以先看看枚举这篇文章 写法简单是枚举单例 最大的优点。123public enum Singleton&#123; INSTANCE;&#125; 获取对象可以这么写： Singleton singleton = Singleton.INSTANCE; 枚举在 Java 中与普通的类是一样的，不仅能够有字段，还能定义自己的方法。 12345678910public enum Singleton&#123; INSTANCE; //枚举内部可以定义成员； private String mString; //枚举内部可以定义方法； public void doSth() &#123; //do sth &#125;&#125; 最重要的是默认枚举实例的创建是线程安全的，并且任何情况下它都是一个单例。 上述几种方式中，在一个情况下都会重新创建对象的情况，那就是反序列化。 即使构造函数是私有的，反序列化是依然可以通过特殊的途径去创建类的一个新的实例，相当于 调用该类的构造函数。 反序列化操作提供了一个很特别的钩子函数，类中具有一个私有的、被实例化的方法 readResolve(),这个方法可以让开发人员控制对象的反序列化。 上述几种单例方法中如果要杜绝单例对象在被反序列化时重新生成对象，那必须加入如下方法：123private Object readResolve() throws ObjectStreamException &#123; return sInstance;&#125; 也就是在 readResolve 方法中将 sInstance 对象返回，而不是默认的重新生成一个新的对象。 而对于枚举，并不存在这个问题，因为即使反序列化也不会重新生成新的实例。 6. 使用容器实现单例模式1234567891011121314151617public class SingletonManager &#123; private static Map&lt;String, Object&gt; sObjectMap = new HashMap&lt;&gt;(); private SingletonManager() &#123; &#125; public static void registerService(String key, Object instance) &#123; if (!sObjectMap.containsKey(key)) &#123; sObjectMap.put(key, instance); &#125; &#125; public static Object getService(String key) &#123; return sObjectMap.get(key); &#125;&#125; 在程序的初始，将多种单例类型注入到一个统一的管理类中，使用时格根据 key 获取对象对应类型的对象。 这种实现方式主要是方便对单例对象进行统一管理。 小结 不管使用哪一种形式实现单例模式，核心原理都是==将构造函数私有化==，并且==通过静态方法获取唯一的的实例==。 在获取的过程中必须保证线程安全、防止反序列化导致重新生成实例对象等问题。 使用时的注意点避免内存泄漏 Android 开发中使用单例模式，如果获取单例对象需要使用 Context，那么尽量使用 ApplicationContext(只要用 context.getApplicationContext() 即可获取)。因为如果使用其他 Context（如 Activity) 可能会造成 Activiity 生命周期 执行完成之后，因为其引用被单例所持有，而无法被回收。 多进程环境下，单例模式会失效。 Android 源码中的单例模式简述我们经常会通过 Context 去获取系统服务，如 LayoutInflater、NetworkStatsManager，这些服务在创建时会以键值对的形式缓存到 HashMap 中，便于管理。 需要时就通过调用 context.getSystemService(String name) 方法获取 。首先会以 name 作为 key，到 hashMap 中查找中相应的服务，如果对应的服务为 null 就创建一个实例，并将该实例缓存到 HashMap 中；如果对应的服务已经存在，则直接返回。 参考资料与学习资源推荐 wiki 单例模式 Android 源码设计模式 单例模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC 机制]]></title>
    <url>%2Fblog%2F2017%2F05%2F04%2FAndroid%20IPC-%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android IPC简介IPC 是 Inter-Process Communication 的缩写，含义为 进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。aIPC 不是 Android 所独有的，任何一个操作系统都需要有相应的 IPC 机制。 在 Android 中最有特色的进程间通信方式就是 Binder 了， 通过 Binder 可以轻松实现进程间通信。 除了 Binder ，Android 还支持 Socket， 通过 Socket 也可以实现任意两个终端之间的通信，当然一个设备的两个进程之间的也可以通过 Socket 进行通信。 多进程的情况分两种： 一个应用因为某些原因自身需要采用多进程模式来实现 可能的原因如下： 有些模块需要运行在单独的进程中 加大一个应用可使用的内存 当前应用需要向其他应用获取数据。 2 Android中的多进程模式通过给四大组件指定 android:process属性，可以轻易地开启多线程模式。 1 开启多进程模式一般地，在 Android 中多进程是指一个应用中存在多个进程的情况（此处不讨论两个应用之间的多进程情况） 首先，在 Android 中使用多进程只有一种方法， 在 manifest 文件中，给四大组件 指定 android:process 属性。 其实还有一种非常规的多进程方法—— 通过 JNI 在 native 层去 fork 一个新的进程。 根据 process 的属性值不同，创建不同的进程。 问题：使用 「：xxx」与 使用 「xxx.xxx.xxx」两种方式有区别吗？ 「：」的含义是指在当前的进程名前面附上当前的包名，即 这是一种简写的方法 进程名以「：」开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中， 而进程名不以「：」开头的进程属于全局进程，其他应用通过 ShareUID 方式可以和它跑在同一个进程中。 Android 系统会为每个应用分配一个 唯一的 UID，具有相同 UID 的应用才能共享数据。 两个应用跑在同一个进程中 需要 这两个应用有 相同的 shareUID 并且 签名相同。 这种情况下，可以互相访问对方的私有目录，如 data 目录。 2 多进程模式的运行机制==一个进程 = 一个 虚拟机== Android 为每个应用分配了一个独立的虚拟机，或者说为每个进程分配一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间，这就导致了不同虚拟机范文同一个类的对象会产生多份副本。 一般来说，使用多进程会造成以下几方面问题 静态成员和单例模式完全失效 线程同步机制完全失效 SharePreferences 的可靠性下降，好像有多进程模式？有，但是不稳定，所以系统已经不推荐使用了。 Application 会多次创建 可以这样理解同一个应用间的多进程： 它就相当于两个不同的应用采用了 ShareUID 的模式，这样能够更加直接地理解多进程模式的本质。 3 IPC基础概念介绍3.1 Serializable接口Serializable接口 ：Java 所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。 使用：- 只要在类的声明中指明一个类似下面的标识即可自动实现 *默认的* 序列化过程（可以自定义）。 - `private static final long serialVersionUID = 87138828109787189L;` 这个 serialVersionUID 可以没有，但是这样会对反序列化过程产生影响。 serialVersionUID 是用来辅助序列化过程的，原则上序列化后的数据中的 serialVersionUID 只有和当前类的 serialVersionUID 相同才能正常地被反序列化。 serialVersionUID 的详细工作机制： 序列化是把当前类的 serialVersionUID 写入序列化的文件中（也可能是其他中介）当反序列化时会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的版本与当前类的版本是相同的，这时可以成功反序列化。 否则说明当前类和序列化的类相比发生了 某些变化，例如：成员变量的数量、类型可能发生了改变，这时无法正常序列化，会报如下错误：1Exception in thread &quot;main&quot; java.io.InvalidClassException: projectname.clasname; local class incompatible: stream classdesc serialVersionUID = -6009442170907349114, local class serialVersionUID = 6529685098267757690 一般而言，我们应该手动指定 serialVersionUID 的值，比如 1L，也可以让 Eclipse 根据当前类的的结构去自动生成它的 hash 值，这样序列化和反序列化时两者的 serialVersionUID是相同的，可以正常进行反序列化。 如果类的结构发生了改变，比如增加/删除了 某些成员变量，那么系统就会重新计算当前类的 hash 值并把它赋值给 serialVersionUID ，这个时候当前类的 serialVersionUID 就会和序列化数据不一致，于是反序列化失败。 如果手动指定了serialVersionUID 就不会有这个问题。 但是如果类结构发生了 ==非常规性改变==，比如修改了类名、修改了成员变量类型，这个时候尽管 serialVersionUID 验证通过了，但是反序列化过程还是会失败，因为类结构发生了毁灭性变化，根本无法从老版本的数据中还原出一个新的类结构的对象。 综上，类结构不变且类的版本不变（没有增加或者删除成员变量）的情况下，不指定 serialVersionUID 是没有问题的，但是为了提高稳定性，还是要指定。 两点要注意的： 静态成员变量属于类不属于对象，所以不会参与序列化过程。 用 transient 关键字标记的 成员变量不参与序列化过程。 系统的默认序列化过程也是可以改变的。只要重新实现 writeObject 和 readObject 方法即可。 如何进行对象的序列化和反序列化？采用 ObjectOutputStream ObjectInputStream 即可轻松实现。12345678User user = new User(name);ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;cache.txt&quot;));objectOutputStream.writeObject(user);objectOutputStream.close();ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;cache.txt&quot;));User newUser = objectInputStream.readObject();objectInputStream.close(); 3.2 Parcelable接口通过实现Parcelable接口序列化对象的步骤：1、声明实现接口Parcelable2、实现Parcelable的方法 writeToParcel，将你的对象序列化为一个Parcel对象3、实例化静态内部对象CREATOR实现接口Parcelable.Creator ，实现 反序列化 Parcelable 的方法说明 方法 功能 标记位 createFromParcel 从序列化后的对象中创建原始对象 newArray 创建指定长度的原始对象数组 User(Parcel in) 从序列化后的对象中创建原始对象 writeToParcel(Parcel dest, int flags) 将当前的对象写入序列化结构中，其中 flags 标识有两种值，0 或者 1； 为 1 时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为 0 PARCELABLE_WRITE_RETURN_VALUE describeContents 返回当前对象的描述，仅当当前对象中存在 文件描述符，才返回 1，几乎所有情况都返回 0 CONTENT_FILE_DESCRIPTOR 新建一个类，实现 Parcelable 接口，然后写好成员变量，再 alt + enter 自动补全代码。123456789101112131415161718192021222324252627282930313233343536373839public class User implements Parcelable &#123; private String mName; private int mAge; private String mAddress; private Book mBook; protected User(Parcel in) &#123;//从序列化后的对象中创建原始对象 mName = in.readString(); mAge = in.readInt(); mAddress = in.readString(); mBook = in.readParcelable(Book.class.getClassLoader());//因为 book 也是一个可序列化对象，所以它的反序列化过程需要传递当前线程的上下文 类加载器 &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123;//将当前的对象写入序列化结构中，其中 flags 标识有两种值，0 或者 1； 为 1 时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为 0 dest.writeString(mName); dest.writeInt(mAge); dest.writeString(mAddress); dest.writeParcelable(mBook, flags); &#125; @Override public int describeContents() &#123;//如无特殊情况，这个方法都是返回 0，仅当当前对象中存在 文件描述符，才返回 1 return 0; &#125; //反序列化 public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123;//创建指定长度的原始对象数组 return new User[size]; &#125; &#125;;&#125; 对比 Serializable 是 Java 中的序列化接口，使用起来简单但是==开销很大==，序列化和反序列化需要大量的 I/O 操作。 而 Parcelable 是 Android 中序列化方式，更适合使用在 Android 平台上，==效率高==。 缺点：使用起来麻烦。 Parcelable 主要用在内存序列化上 通过 Parcelable 将对象序列化到存储设备中 或者将对象序列化后存储通过网络传输也都是可以的，但是这个过程会稍显复杂，在这两种情况下，建议使用 Serializable 接口。 3.3 Binder直观来说，Binder 是 Android 的一个类，它实现了 IBinder 接口。 从 IPC 角度来说， Binder 是 Android 中的一种跨进程通信方式 Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是 /dev/binder， 该通信方式在 Linux 上没有。 从 Android FrameWork 角度来看， Binder 是 ServiceManager 连接各种 Manager (ActivityManager、 WindowManager， 等等)和相应的 ManagerService 的桥梁 从 Android 应用层 来说，Binder 是客户端和服务端进行通信的媒介，当 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，通过这个 Binder 对象，客户端就可以获取服务端提供的数据或服务（包括普通的服务 和 AIDL服务） Android 开发中，Binder 主要用在 Service 中，包括 AIDL 和 Messenger， 普通 Service 中的 Binder 不涉及进程间通信，所以较为简单，无法涉及核心 Messenger 的底层其实是 AIDL 示例中，编写代码时，查找 aidl 生成的接口，Project ==》app==》build ==》source==》debug==》com.xxx.xx.xx==》 目标类 ==注意==：AIDL 的特殊之处：尽管两个类都位于同一个包中，还是需要导入相应的类。 ==所有==可以在 Binder 中传输的接口都需要继承自 IInterface 接口。 栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/* * This file is auto-generated. DO NOT MODIFY. * Original file: D:\\Android_RDC_project\\AndroidLearning\\app\\src\\main\\aidl\\com\\android\\rdc\\androidlearning\\IBookManager.aidl */package com.android.rdc.androidlearning;public interface IBookManager extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.android.rdc.androidlearning.IBookManager &#123; private static final java.lang.String DESCRIPTOR = "com.android.rdc.androidlearning.IBookManager";//Binder 的唯一标识，一般用当前 Binder 的全类名表示 /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * 将（服务端的 Binder 对象）转换为（客户端所需的 AIDL 类型的对象） * 若服务端与 客户端处在同一个进程，则返回服务端的 Stub 对象本身 * 否则返回系统封装后的 Stub.Proxy * Cast an IBinder object into an com.android.rdc.androidlearning.IBookManager interface, * generating a proxy if needed. */ public static com.android.rdc.androidlearning.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.android.rdc.androidlearning.IBookManager))) &#123; return ((com.android.rdc.androidlearning.IBookManager) iin); &#125; return new com.android.rdc.androidlearning.IBookManager.Stub.Proxy(obj); &#125; /** * 返回当前的 Binder 对象 * */ @Override public android.os.IBinder asBinder() &#123; return this; &#125; /** * 运行在『服务端』的 Binder 线程池中，客户端发起 ，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理 * 通过code 可以确定请求的目标方法 * （如果目标方法有参数的话） 从 data 中取出目标方法所需的参数，然后执行 * 当目标方法执行完毕后，（如果有返回值的话）向 reply 中写入返回值 * 如果 onTransact 返回 false ，那么客户端的请求失败。因此可以利用这个特性来做权限验证。 * */ @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.android.rdc.androidlearning.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); com.android.rdc.androidlearning.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.android.rdc.androidlearning.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.android.rdc.androidlearning.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * 此方法运行在『客户端』 * */ @Override public java.util.List&lt;com.android.rdc.androidlearning.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.android.rdc.androidlearning.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);//调用 transact 发起远程请求。然后当前线程挂起， _reply.readException();// RPC 过程返回后，当前线程继续执行 _result = _reply.createTypedArrayList(com.android.rdc.androidlearning.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; /** * 执行过程与 getBookList 一样， * */ @Override public void addBook(com.android.rdc.androidlearning.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public java.util.List&lt;com.android.rdc.androidlearning.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.android.rdc.androidlearning.Book book) throws android.os.RemoteException;&#125; 4 Android中的IPC方式4.1 使用Bundle四大组件中的三大组件（Activity、Service、Receiver）都是支持在 Intent 中传递 Bundle 数据的，Bundle 实现了 Parcelable 接口，所以它可以方便地在不同的进程间 传输。 因此，当我们在一个进程中启动了另一个进程的 Activity、Service、Receiver，我们就可以在 Bundle 中附加我们需要传输给远程进程的信息并通过 Intent 传递出去。 当然我们所传输的数据必须能够被序列化，如： 基本数据类型 实现了 Parcelable 接口的对象。 实现了 Serialiable 接口的对象。 一些 Android 支持的特殊对象。 Charserquence StringArrayList IntegerArrayList Size … 特殊的使用场景：进程 A 要进行计算，并将计算结果发送给进程 B，但是该计算结果不支持放入 Bundle 中。 解决：在 A 中，通过 Intent 来启动线程 B 的一个 Service 组件（比如 IntentService），让 Service 在后台计算，计算完以后再启动 B 进程中想要启动的目标组件。 核心思想：将原本需要在 A 进程的计算任务转移到 B 进程的服务中，这样就避免了进程间通信的问题，而且代价也不大。 4.2 使用文件共享两个进程通过读/写同一个文件交换数据。 比如，进程 A 写入，进程 B 读取。 背景知识： Window 上，一个文件如果被加了排斥锁将会导致其他线程无法对其进行访问（包括读和写）。 Android 基于 Linux，其读/写文件可以无限制地进行，甚至两个线程对同一个文件并行写也是允许的。（尽管这可能会出现一些问题） 应用： 序列化一个对象到文件系统中的同时，从另一个进程中恢复这个对象。 另一个进程成功地恢复之前存储的对象的内容，但是他们本质还是两个对象。 可能存在的问题：并发读/写，读出的内容可能不是最新的。 解决： 设法避免 考虑使用线程同步来限制，多个线程的写操作。 文件共享适合对数据同步要求不高的进程之间进行通信。 SharepreferenceSharePreference 是个特例 底层通过 xml 文件的方式来存储键值对，，一般而言，它位于 /data/data/当前应用的包名/share_prefs 目录下， 由于系统对 SharePreference 的读写操作有一定的缓存策略，即在内存*有一份 SharePreferce 的缓存。在多进程模式下，系统对它的读写操作就变得不可靠。高并发状态下，SharePreference 很大几率会丢失数据。 不建议在进程间通信使用 SharePreference 4.3 使用Messenger『信使』通过它可以在不同进程中传递 Message 对象，在 Message 中放入我们需要传递的数据，就可以实现进程间的数据传递了。 Messenger 一次处理一个请求，所以服务端不用考虑线程同步的问题（因为不存在并发执行的情形）。 1. 服务端进程客户端进程在 Messager 中进行数据传递必须将数据放入 Messenger 中， Message 中支持数据类型就是 Messenger 所支持的传输类型 Message 中所能使用的载体只有 int what; int ar1 int arg2 Messenger replyTo Object obj 2 之前 obj 字段不支持跨进程传输 2 之后 obj 也仅系统提供的实现 Parcelable 接口的的对象 即 FrameWork class Bundle 还好我们有 Bundle ，支持比较多的数据类型 如果要让『服务端』能够回复信息。 那么当客户端发送消息的时候，需要把 接收服务端回复的 Messenger 通过 Message 的 replyTo 参数传递给服务端。4.4 使用AIDL Android 接口定义语言(Android Interface Definition Language) Messenger 只能传递消息，不能跨进程调用方法。而且只能串行处理客户端发来的请求。 虽然它底层也是使用 AIDL 实现的。 可以使用 AIDL 来实现跨进程的方法调用。 aidl 文件的作用是 sdk 根据它来生成相应的 java 代码，也就是在编译时有用，在编译完之后，即使删除掉 aidl 文件，也是可以的，但是这样的话如果重新编译就没法生成 java 代码了。 将编写的 .aidl 文件保存在项目的 src/ 目录内，当你开发应用时，SDK 工具会在项目的 gen/ 目录中生成 IBinder 接口文件。生成的文件名与 .aidl 文件名一致，只是使用了 .java 扩展名（例如，IRemoteService.aidl 生成的文件名是 IRemoteService.java）。 如果使用 Android Studio，增量编译几乎会立即生成 Binder 类。 如果不是使用 Android Studio，则 Gradle 工具会在下一次开发应用时生成 Binder 类 通常应该在编写完 .aidl 文件后立即用 gradle assembleDebug （或 gradle assembleRelease）编译项目，以便您的代码能够链接到生成的类。 1. 服务端用一个 Service 来监听客户的连接请求，创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 实现该接口。 2. 客户端 绑定服务端 Service， 绑定成功后将服务端返回的 IBinder 转化为 AIDL 接口所属的类型 注意不是平时那样强转，而是 IBookManager.Stub.asInterface(iBinder); 接着就可以使用 AIDL 中的方法了。 AIDL 支持的数据类型： 基本数据类型 CharSequence List 只支持 ArrayList Map 只支持 HashMap Parcelable AIDL：AIDL 接口本身也可以在 AIDL 文件中使用 AIDL 中无法使用普通的接口 注意： 自定义的 Parcelable对象一定要显式地 import 进来。（不管它们是否与当前的 AIDL 文件位于同一个包中） 如果 AIDL 文件中用到了自定义的 Parcelable 对象，必须使用新建一个和它同名的 aidl 文件，并在其中声明它为 parcelable 类型 如 Book.java Book.aidl 要在其中声明 pacelable Book; 基本数据类型以外的参数需要==标上方向== in 输入型参数，类似于普通方法的参数 out 输出型参数， 类似于返回值 inout 输入输入型参数 所以说，输入输出是针对这个方法而言的，而不是 C/S 结构中的输入/输出。 AIDL 接口中只支持方法，不支持声明静态变量（==跟传统的接口有区别==） AIDL 包结构在客户端与服务端要保持一致，否则运行会出错。 因为客户端需要反序列化服务端中和 aidl 接口相关的类。 AIDL 接口中所支持的是抽象的 List ，而 List 只是一个接口，虽然服务端使用 CopyOnWriteArrayList ,但是在 Binder 中会按照 List 的规范去访问数据并最终形成一个 ArrayList 传递给客户端。 ConcurrentHashMap 同理 在服务端调用客户端（注册时的使用的接口中)的方法，在客户端的 Binder 线程池中执行。 对象是不能直接跨进程传输的，对象的跨进程传输本质上都是反序列化过程 RemoteCallBackList 是系统专门用来发删除跨进程的 listener 的接口。 它是一个泛型，支持管理任意的 AIDL 接口 public class RemoteCallBackList&lt;E extends IInterface&gt; 当客户端进程终止之后， RemoteCallBackList 能够自动溢出客户端所注册的 listener 其内部有一个 ArrayMap&lt;IBinder,CallBack&gt;用来专门保存所有的 AIDL 回调 CallBack 封装了真正的远程 listener。当客户端注册 listener 的时候，会将其中的信息存入 mCallBack 中12IBinder key = listener.asBinder();callBack value = new Callback(listener,cookie); 多次跨进程传输客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个 共同点，那就是==它们底层的 Binder 对象是同一个== ==注意==: RemoteCallBackList 使用方式比较特别。并不像 list 那样 beginBroadcast() finishBroadcast() 这两个方法==一定要配对使用== getBroadcastItem()12345678final int N = mCallBackList.beginBroadcast();for (int i = 0; i &lt; N; i++) &#123; IOnNewBookArrivedListener l = mCallBackList.getBroadcastItem(i); if (l != null) &#123; l.onNewBookArrived(book); &#125;&#125;mCallBackList.finishBroadcast(); 客户端的 onServiceConnected 和 onServiceDisconnected(ComponentName name)都执行在 UI 线程中，不可以在里面调用服务端耗时的方法。 服务端方法本身运行在服务端的 Binder 线程池中，所以服务端方法本身即可执行大量耗时操作。 不要在服务端方法中开线程去执行异步任务。 服务端也有可能运行在 UI 线程，这时要尽量避免调用耗时方法。 Binder 死亡后 进程空间分为用户空间和内核空间 用户空间，数据互相隔离 内核空间 数据共享 通过内核 实现跨进程调用 进程 A 调用进程 B 的函数 知道调用的是哪一个对象的哪一个方法 传递方法参数 进程 B 执行完之后，返回相应的数据给进程 A。 本质上就是 数据的传递。 客户端调用的进程 Binder 对象的引用（一个代理），实际执行还是在服务端的。 Client 进程的的操作实际上对代理对象的操作，代理对象利用 Binder 驱动找到真正的 Binder对象，并通知 Server 进程完成操作。 采用的是 C/S 的架构。 4.5 使用ContentProvider待补充 4.6 使用Socket待补充 参考资料与学习资源推荐 《Android开发艺术探索》 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！ ##]]></content>
      <categories>
        <category>Android 进阶</category>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service 全面总结]]></title>
    <url>%2Fblog%2F2017%2F05%2F03%2FService-%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Service 是一种计算型的组件。 一、使用场景线程还是服务？简单地说，服务是一种不需要用户交互也可在后台运行的组件。 因此，我们应该仅在必要时才创建服务。 如需在主线程外部（也就是工作线程）执行工作，并且只是在用户正在与应用交互时才有此需要，则应创建新线程而非服务。 如果确实要使用服务，则默认情况下，它仍会在应用的主线程中运行，因此，如果服务执行的是密集型或阻塞性操作，那么应该在服务内创建新线程。 注意：默认情况下，服务与服务声明所在的应用运行于同一进程，而且运行于该应用的主线程中。为了避免影响应用性能，您应在服务内启动新线程。 因为默认情况下，它会在应用不管是否用服务，耗时的操作都是需要另外起一个线程的。 从概念上看，服务是一个组件，线程是操作系统的最小执行单位。 直接起 Thread 的可控性没那么高，它所依附的 Activity finish 掉之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。你没有办法在不同的 Activity 中对同一 Thread 进行控制。 可以提高进程的优先级，使得进程没那么容易被 kill。如果是一个长期的任务（比如说长轮询），那么用 Service 去做比较合适。 通过在 manifest 里声明 Service，把需要后台相对长期运行的逻辑放在 Service 里，你便获得了这样的保障：只要系统内存不是极端不够用，你的 Service 一定不会被 kill 掉。对系统而言，当看到一个进程里有 Service 在运行，这个进程就具有较高的优先级，会在内存不足被杀的行列里排得比较靠后。 从交互的角度看，如果是不需要用户交互也可以在后台运行，那么可以用服务。如果是在用户与应用交互时（比如说：在设置页面修改用户信息，同步到服务器上面去）那么可以用线程。如果确定要用 Thread，还可以考虑使用 AsyncTask 或 HandlerThread，而非传统的 Thread 类。 所以直接用线程还是起一个服务关键得看任务的类型。是否是长期耗时的任务，是否需要跟用户交互？ 二、3 种启动方式方式一、start Service 调用者只是负责启动它和停止它，或者在启动它的时候通过 Intent 传递一点数据给它，除此之外，两者没有数据交换、没有其他的功能调用，这两个组件之间基本上互不影响。 如果希望服务返回结果，则启动服务的客户端可以为广播创建一个 PendingIntent （使用 getBroadcast()），并==通过启动服务的 Intent 传递给服务==。然后，服务就可以使用广播传递结果。可以获取到 pendingIntent，然后呢？ 服务内部也可以直接构造 PendingIntent 啊。 如果是通过客户端的传递的，那么有多个客户端，可以根据传递的 intent 分别处理？ 如果因为系统内存不足被 kill，之后的具体行为与 onStartCommand 方法的返回值相匹配。 生命周期：多个服务启动请求会导致多次对服务的 onStartCommand() 进行相应的调用。但是，要停止服务，只需一个服务停止请求（使用 stopSelf() 或 stopService()）即可。 方式二、bind Service 其他组件通过调用 bindService() 绑定 Service，让它运行起来；再通过调用 unbindService()解除绑定。 组件和 Service 之间的调用是通过 Binder 来进行的。我们可以把 Binder 看作是一个连接其他组件和 Service 的桥梁。 需要注意的是，如果是在同一个进程内，可以直接继承 Binder,然后在里面实现提供给调用者的功能。 如果是跨进程，可以使用 aidl。 将要提供给调用方的功能接口写在 aidl 文件中。build 之后，继承 Stub ,实现相应的功能。 调用方在 onServiceConnected 方法中，获取到服务端提供的 IBinder 对象就可以像调用普通函数一样，调用相应的方法了。 如果是远程调用的话，将对方提供的 IBinder 类 通过 asInterface 方法进行转换。如果是在服务端，返回 binder 实体，如果是在客户端，返回 binder Proxy。 如果需要提供接口给调用方使用，可以通过 onBind 方法中返回一个可供调用者使用的 Binder 对象。 需要注意的是，如果用户主动解除绑定，onServiceDisconnected()是不会被触发的。 如果组件是通过调用 bindService() 来创建服务（且未调用 onStartCommand()，则服务只会在该组件与其绑定时运行。一旦该服务与所有客户端之间的绑定全部取消，系统便会销毁。 即使为服务启用了绑定，一旦服务收到对 onStartCommand() 的调用（也就是在 bind 之后又使用 start 的方式去启动应用），则必须手动停止服务。（内部调用 stopSelf 或者 由另一个组件通过调用stopService() 来停止它） 多个客户端先后进行 bindService 只有第一个调用 bindService 时会调用 Service#onBind 方法，后续的都是直接在 ServiceConnection 中返回。 绑定是异步的。bindService() 会立即返回，但是「不会」使 IBinder 返回客户端。要接收 IBinder，客户端必须创建一个 ServiceConnection 实例，并将其传递给 bindService()。ServiceConnection 包括一个回调方法，系统通过调用它来传递 IBinder。IBinder 返回是异步的。 注：只有 Activity、Service 和 ContentProvider 可以绑定到服务 — 无法从广播接收器绑定到服务。 创建支持 bindService 的 Service 的关键在于，自定义一个直接/间接实现了 IBinder 接口的类（编写功能代码提供相应的功能）然后通过 onBind 方法把该类的实例传递给客户端。 注意：Service.onBind如果返回null，则调用 bindService 会启动 Service，但不会连接上 Service，因此 ServiceConnection.onServiceConnected 不会被调用，但你任然需要使用 unbindService 函数断开它，这样 Service 才会停止。 创建提供绑定的 Service创建提供绑定的服务时，您必须提供 IBinder，用以提供客户端用来与服务进行交互的接口。 您可以通过三种方法定义接口： 1. 直接继承 Binder 类适用场景：服务是供单个应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中乃至 Service 中可用的公共方法。 如果服务只是 app 的后台工作线程，则优先采用这种方法。 2. 使用 Messenger如需让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口。服务可以这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，后者随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向服务发送命令。此外，客户端还可定义自有 Messenger，以便服务回传消息。 这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，这意味着开发者无需进行线程安全控制 3.使用 AIDLAIDL（Android 接口定义语言）执行所有将对象分解成原语的工作，操作系统可以识别这些原语并将它们编组到各进程中，以执行 IPC。 之前采用 Messenger 的方法实际上是以 AIDL 作为其底层结构。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便服务一次接收一个请求。 不过，如果您想让服务同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的服务必须具备多线程处理能力，并采用线程安全式设计。 如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现接口并处理 IPC 的抽象类，您随后可在服务内对其进行扩展。 方式三、混合型，同时使用 start 和 bindService 并不是只能给一个组件使用，它可以同时服务于多个组件。所以一个 Service 既可以是 Start Service，也可以是 Bind Service。只要把两者需要实现的地方都实现了就行。组件 A 可以通过 startService()运行一个 Service，组件 B 可以通过 bindService()再次运行同一个 Service。 生命周期可以绑定到已经使用 startService() 启动的服务。例如，可以通过使用 Intent（标识要播放的音乐）调用 startService() 来启动后台音乐服务。随后，可能在用户需要稍加控制播放器或获取有关当前播放歌曲的信息时，Activity 可以通过调用 bindService() 绑定到服务。在这种情况下，除非所有客户端均取消绑定，否则 stopService() 或 stopSelf() 不会实际停止服务。 先 startService 然后 bindSerive 先 bindService 然后 startService 在混合模式下，只有等到调用了 stopSelf 或 stopService 以及 所有的客户端都取消绑定，服务才会停止 官方流程图 onRebind（Intent intent） 方法与 Activity#onNewIntent 方法类似。该方法是否被调用取决于 onUnbind 方法是否返回 true。当所有的客户端都调用了 unBindService，而没有调用 stopService 的时候，可以避免这种情况。 如果是 true，当有新的调用过来的时候，可以在 onReBind 方法中拿到 intent。 如果为 false，当有新的调用过来的时候，会走 onBindonRebind() 返回空值，但客户端仍在其 onServiceConnected() 回调中接收 IBinder。 如果要同时支持 start 和 bind，需要同时实现两套方法。 onStartCommand onBind 这两个方法都含有一个 Intent 参数 附： 应该始终捕获 DeadObjectException 异常，它们是在连接中断时引发的。这是远程方法引发的唯一异常。 对象是跨进程计数的引用。 通常应该在客户端生命周期的匹配引入 (bring-up) 和退出 (tear-down) 时刻期间配对绑定和取消绑定。 例如：如果您只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。如果您希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。请注意，这意味着您的 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当您提高该进程的权重时，系统终止该进程的可能性会增加。 注：通常情况下，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，您应该使发生在这些转换期间的处理保持在最低水平。此外，如果您的应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一个 Activity 绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务。 （Activity 文档中介绍了这种有关 Activity 如何协调其生命周期的 Activity 转换。） manifest 文件中声明服务android:name 属性是唯一必需的属性，用于指定服务的类名。 三、创建服务从传统上讲，您可以扩展两个类来创建启动服务： Service所有服务的基类。扩展此类时，必须创建一个用于执行所有服务工作的新线程，因为默认情况下，服务将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。 IntentServiceService 的子类，它使用工作线程逐一处理（串行处理）所有启动请求。如果您不要求服务同时处理多个请求，这是最好的选择。 您只需实现 onHandleIntent() 方法即可，该方法会接收每个启动请求的 Intent，使您能够执行后台工作。 IntentService 执行以下操作： 自动创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。 创建工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。 在处理完所有启动请求后停止服务，因此您永远不必调用 stopSelf()。 提供 onBind() 的默认实现（返回 null）。 提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。 在前台中显示、移除要从前台移除服务，请调用 stopForeground()。此方法采用一个布尔值，指示是否也移除状态栏通知。 此方法不会停止服务。 但是，如果在服务正在前台运行时将其停止，则通知也会被移除 Start Service 和 Bind Service 四、LocalService 还是 RemoteService？什么时候选择 local service（即不指定额外的进程），什么时候选择 remote service（额外的进程）？ 通常我们会把真的需要长期运行的 Service（例如 IM 之类）放在单独的进程里，这样 UI 所在的进程在必要的时候仍然可以被系统 kill 掉来腾出内存。 而 local service 通常用来处理一些需要短期运行但仍然超出 activity 活动周期的任务，打个比方，发送短信或彩信。这样的任务执行完以后，service 就可以 stop 自己，仍然不妨碍整个 UI 进程被回收掉。 五、何时会被 kill？ 当且仅当内存不足，而此时有其他进程的 Activty 具有用户焦点（或者说，在于用户交互）时，android 系统会强制 stop 服务。 如果将服务绑定到具有用户焦点的 Activity，则它不太可能会终止； 如果将服务声明为在前台运行，则它几乎永远不会终止。 如果服务已启动并要长时间运行，则系统会随着时间的推移降低服务在后台任务列表中的位置，而服务也将随之变得非常容易被终止； 如果服务是通过 startService 启动的，需要通过重写 onStartCommand 方法妥善处理系统对它的重启。 因为如果系统终止服务，那么一旦资源变得再次可用，系统便会重启服务（不过这还取决于从 onStartCommand() 返回的值）。 Q:如果仅通过 bindService 启动，服务被 kill 之后，是否重启仍然取决于 onStartCommand 的返回值吗？ 不会，onStartCommand 方法都没有被调用，怎么知道它的返回值呢？ 参考资料与学习资源推荐 Start Service 和 Bind Service Service Bind Service Android 中 Local Service 最本质的作用是什么？ Android 中的 Service 全面总结 由于本人水平有限，可能出于误解或者笔误难免出错，如果发现有问题或者对文中内容存在疑问欢迎在下面评论区告诉我，请对问题描述尽量详细，以帮助我可以快速找到问题根源。谢谢！]]></content>
      <categories>
        <category>Android 基础</category>
      </categories>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 消息机制解析]]></title>
    <url>%2Fblog%2F2017%2F04%2F28%2FAndroid-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述提起 Handler，相信大家都不会陌生，日常开发中不可避免地要使用到它。今天要讲的是消息机制。消息机制？咋听起来有点抽象。其实我们在使用 Handler 的时候，就使用了 Android 的消息机制。 从开发的角度来看，Handler 是 Android 消息机制的上层接口，这使得开发过程中只需要设计这方面的内容即可。但是作为一名合格的开发者，弄清它的实现原理是很有必要的。 俗话说得好，一图胜千言，我们先来看下 Android 消息机制简单示意图（图片参考自这篇文章）。 我们把 Thread 比作是一个 发动机，MessageQueue 看作是一条流水线，Message 就像是流水线上的工人，Looper 是流水线下的滚筒，Handler 像是一个工人，它负责把 Message 这个产品送到流水线上，最后又负责把它取走。 这幅图中的各个组件的说明如下： Looper ==》 滚轮 MessageQueue ==》 流水线 Message ==&gt; 流水线上的产品 Handler ==》 扮演把『产品』送进流水线，完了以后又把『产品』取走的角色 Thread ==》 动力 另外还有一个重要概念 ——ThreadLocal 图中没有标明出来。下面对各个部分进行详细介绍。 Android 的消息机制分析从 Handler 出发相信很多做 Android 开发的同学都写过与下面相似的代码。在子线程中做一些耗时操作，比如网络请求，操作完成之后，将返回的数据包装为 Message 对象然后调用 sendMessageXxx 方法，最后在 handleMessage 方法中对结果进行处理。 12345678910111213141516171819202122232425Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 1: //handle break; default: super.handleMessage(msg); &#125; &#125;&#125;;public void do() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //do sth Message message = mHandler.obtainMessage(); message.what = 1; message.obj = result; mHandler.sendMessage(message); &#125; &#125;);&#125; 从 Handler.sendMessage(message) 到 Handler.handlerMessage方法经历了什么样的过程？ 我们先看看 sendMessage 方法内部是怎么实现的。 12345678910111213141516171819202122232425262728293031public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 整个调用流程是这样的 sendMessage ==》 sendMessageDelayed ==》 sendMessageAtTime ==》 enqueueMessage ==》 MessageQueue.enqueueMessage 我们可能还会调用 Handler.post(Runnable)方法到目标线程中执行 run 方法。post 方法会先调用 getPostMessage方法将 Runable 包装为 一个 Message 对象，（Runnable 就存储在 callback 中）。其他的 postXxx(Runnable)方法内部实现也是这样的流程，首先将 Runnable 包装为一个 Message 对象然后调用相应的 sendXxx 方法。 123456789public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123;//将 Runnable 包装为一个 Message 对象 Message m = Message.obtain(); m.callback = r; return m;&#125; 从上述的调用流程可以看出 sendXxx 或者 postXxx 方法最终都会调用 MessageQueue 的 enqueueMessage方法，将 Message 追加到 MessageQueue 中。 小结 Handler 的消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。 post 系列方法最终是通过 send 的一系列方法来实现的。 Handler 的发送消息的过程仅仅是向消息队列插入了一条消息。 MessageQueue 对象是从哪里来的？mQueue 是 Handler 的一个成员变量，它是在哪里初始化的呢？先看看 Handler 的构造方法 123456789101112131415public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; //代码省略 mLooper = Looper.myLooper();//获取当前线程的 Looper if (mLooper == null) &#123; throw new RuntimeException(//抛出异常，不能在没有 Looper 的线程创建 Handler "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//从本线程的 Looper 中获取 MessageQueue mCallback = callback;//回调 mAsynchronous = async;//是否异步&#125; 我们看到 mQueue 是从 Looper 中取出的。在解说 Looper 之前，我们先看看前面提到的 MessageQueue 。 MessageQueue 的工作原理MessageQueue 主要包含两个操作：插入和读取（分别对应 enqueueMessage 和 next 方法）。 顾名思义，enqueueMessage 的作用是往队列中插入一条信息。 next() 的作用是从队列中取出一条信息并将其从消息队列中移除。 虽然 MessageQueue 名为消息队列，但是它的内部实现并不是用队列，而是通过一个单链表的数据结构来维护消息列表。 为什么选择使用单链表结构？ 因为 Message 是可以定时发送的，若使用普通的队列，当插入一个发送时间晚于队首 Message 发送时间的新 Message，那么就需要插队，实现起来不方便，而使用优先队列又显得比较复杂。因此就采用了单链表实现。 接下来我们重点看看 enqueueMessage 方法和 next 方法。 enqueueMessage 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; // 要进入队列的消息对象的目标 handler 不能为空 throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; // 要进入队的消息不能处在使用状态 throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123;//入队需要先获取内置锁 if (mQuitting) &#123; // 已经调用过 Looper.quit / Looper.quitSafely 方法。 MessageQueue 中不能再追加 Message 对象 IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle();//回收消息 return false;//返回 false 表示入队失败 &#125; // 标记消息为使用状态；设置消息发送的时间；是否需要唤醒 msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //将消息插入到队首 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; //通过该循环找到合适的插入位置（以发送的时间作为排序的标准） for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; //插入队列的指定位置中 msg.next = p; prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr);//当前处于阻塞状态，通过「写描述符」唤醒线程，从而使得 MessageQueue#next 方法中的 nativePollOnce 能够返回。（实际上运用了 Linux 的 epoll 机制） &#125; &#125; return true;&#125; 从代码中不难看出，enqueueMessaege 虽然有点长，但是逻辑还是比较清晰的。它先做了一些状态判断以及一些边界检测，完了以后再进行单链表的插入操作。 next 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; //代码省略 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //处理 native 层事件（内部使用 Linux 的 epoll 机制），可能会阻塞 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123;//如果消息的目标 Handler 为空 do &#123; // 找出队列中下一个异步 Message 对象 prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 计算下一条消息的执行时间，设置一个唤醒的延迟 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 队首 Message 执行的时机到了，获取一条消息 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse();//标记 Message 为正在使用状态 return msg;//返回消息 &#125; &#125; else &#123; // 队列中没有消息了 nextPollTimeoutMillis = -1; &#125; // 外部调用了 quit 方法。退出 if (mQuitting) &#123; dispose(); //处理底层消息队列。实际上移除了 native 层的消息队列 return null; &#125; if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // 没有可运行的闲置 handler。跳出本次循环再等待。 mBlocked = true; continue; &#125; //代码省略 &#125; &#125; next 方法中有一个死循环，其主要逻辑如下: 如果消息队列中没有消息，那么 next 会一直阻塞在那里。 当队首的消息设置了延迟执行时，会造成短时间的阻塞。 当有新消息到来时，next 方法会返回这条信息并将其从单链表中移除。 当调用了 quit 方法之后，mQuitting 为 true ，next 方法会移除 native 层的消息队列并返回 null。 整个 next 方法的逻辑如下： 从消息队列中依次取出消息。如果这个消息到了执行时间，那么就将该消息返回给 Looper，并且将消息队列链表的指针后移。实际上消息队列维护着一个分发屏障(dispatch barrier)，当一个 Message 的时间戳低于这个值的时候，消息就会被分发给 Handler 进行处理。形象一点？看看下面这张图（图片来自 Android Handler Internals，侵删） 位于 dispatch barrier 左边的 Message 都被阻塞着，位于其右边的是即将分发的 Message。 我们是不是该说下 Looper 了，下下个就到它了，在此之前需要先看看 ThreadLocal 相关知识。 ThreadLocal 简介ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储后，只有在指定线程中才能获取到存储的数据，对于其他线程来说则无法获取到数据。 使用场景： 当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑采用 ThrradLocal。 在 Android 中，Looper 类就是利用了 ThreadLocal 的特性，保证每个线程只存在一个 Looper 对象。 复杂逻辑下的对象传递。 比如监听器的传递。 从 ThreadLocal 的 set 和 get 方法 可以看出，它们所操作的对象都是当前线程的 localValues 对象的 table 数组，因此在不同的线程中访问同一个 ThreadLocal 的 get 和 set 方法，他们对 ThreadLocal 所做的读/写操作仅限于各自线程的内部。 关于 ThreadLocal 的具体介绍请见 这篇文章 理解 ThreadLocal 对后面理解 Looper 有很大的帮助，建议先细看 ThreadLocal 的内容再看后面的内容。 Looper 的工作原理Android 的官方文档中是这么介绍 Looper 的： Looper 是一个用来为单个线程运行消息循环的类。默认情况下线程是没有一个 Looper 跟他们相关联的。如果一个线程需要 looper 的话，可以通过先调用 prepare() 方法初始化一个本线程的 Looper 实例。然后调用 loop 方法让它开始处理信息，一直到循环结束。 我们通常通过 Handler 类与 Looper 的打交道。 一个 线程最多只能有一个 Looper，一个 Looper 中有一个消息队列（前面 Hanlder 中的 MessageQueue 对象就是从 Looper 中取出的），并且持有它所在线程的引用。Looper 就像一个「死循环」（通过 quit 或者 quitSafely 方法可以退出），它会不断地从 MessageQueue 中查看是否有新消息。如果有，就调用 handler.dispatchMessage 方法进行处理；如果没有，就一直阻塞在那里。 创建 Looper我们先看看 Looper 的构造方法： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//创建一个消息队列 mThread = Thread.currentThread(); //把当前线程的对象保存起来&#125; Looper 构造方法中创建了一个消息队列，并且会保存当前线程对象。 创建普通线程上的 LooperLooper 的构造方法是私有的，那么要创建一个 Looper。？调用 Looper.prepare()即可为当前线程创建一个 Looper 对象，接着通过 Looper.loop() 方法开启消息循环。要注意的是：在子线程中，如果手动为其创建了 Looper，那么在所有的任务完成之后，需要调用 quit 方法来终止消息循环，否则这个子线程就会一直处于等待状态。 我们看下 prepare 方法实现 1234567891011121314public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread");//一个线程最多只能有一个 Looper &#125; sThreadLocal.set(new Looper(quitAllowed));//为当前线程创建一个 Looper &#125;public static @Nullable Looper myLooper() &#123;//获取当前线程的 Looper 对象 return sThreadLocal.get();&#125; 创建主线程上的 Looper有一个要注意的地方就是 Looper 的另一个创建方法 —— prepareMainLooper。 prepareMainLooper 在应用的入口方法（ActivityThread.main() ）中被调用，用来启动主线程的消息循环。 123456789101112131415public static void main(String[] args) &#123; //代码省略 Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper();//创建主线程的 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler();//创建主线程的 Handler &#125; //代码省略 Looper.loop();//开启主线程消息循环&#125; 123456789101112131415public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125;public static Looper getMainLooper() &#123;//该方法使得在任何地方都可以获得主线程的消息循环 synchronized (Looper.class) &#123; return sMainLooper; &#125;&#125; 小结在应用启动时会开启一个主线程（UI 线程），并且开启消息循环，应用不断地从该消息队列中取出、处理消息达到程序运行的结果。 loop 方法前面所讲都是 Looper 自身的一些特性，没有提到它是怎么跟其他部分交互的。Looper 与其他 MessageQueue 、Hanlder 的交互主要在 loop 方法中。下面我们来看看 loop 方法的源码。 12345678910111213141516171819202122232425262728293031323334public static void loop() &#123; final Looper me = myLooper();//获取本线程的 Looper if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");//调用 loop 方法之前必须先调用 Looper.prepare() 方法创建 Looper &#125; final MessageQueue queue = me.mQueue;//获取所在线程的消息队列 // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // 阻塞方法，如果没有获取到消息，就一直阻塞在这里 if (msg == null) &#123; //只有当 msg == null 时才会退出循环 return; &#125; // 代码省略 try &#123; msg.target.dispatchMessage(msg);// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。 &#125; finally &#123; // 代码省略 &#125; // 代码省略 // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); // 代码省略 msg.recycleUnchecked();//调用 Message 的回收方法 &#125;&#125; 由源码可见 loop 方法是一个死循环，唯一跳出循环的方式是 MessageQueue 的 next 方法返回了 null。 当我们调用 Looper 的 quit 方法时，Looper 会调用 MessageQueue 的 quit 或 quitSafely 方法来通知消息队列退出，否则 loop 方法会一直循环下去。 另外，代码中可以看到，loop 调用了 MessageQueue 的 next 方法来获取新消息，而 next 是一个阻塞操作，当没有消息时，next 方法会一直阻塞在那里，这也导致了 loop 方法一直阻塞在那里。 msg.target.dispatchMessage(msg);// 这里的 msg.target 是发送这条信息的 Handler 对象，这样 Handler 发送的消息最终又交给它的 dispatchMessage 方法来处理了。 绕了这么一个大圈意义何在？通常我们都会在子线程中调用 Handler.sendMessageXxx 或者 Handler.postXxx 方法， 而Handler 的 dispatchMessage 方法是在创建 Handler 的那个线程中执行的，这样就顺利地将代码切换到目标线程中去执行了。 退出 LooperLooper 也是可以退出的（这里的退出 Looper 主要是指跳出 loop 方法中的死循环）。通过调用 Looper 的 quit 方法或者 quitSafely 方法即可。那么这二者有什么区别？ 调用 Looper 的 quit 方法可以直接退出Looper。 调用 Looper 的 quitSafely 方法只是设定了一个退出标记，然后把消息队列中已有的消息处理完才退出 Looper。 我们来看看这两个方法的实现 12345678//Looper.quitpublic void quit() &#123; mQueue.quit(false);&#125;//Looper.quitSafelypublic void quitSafely() &#123; mQueue.quit(true);&#125; mQueue 的实际类型为 MessageQueue，Looper 的两个 quit 方法都是通过调用 MessageQueue 的 quit 方法来实现的。 1234567891011121314151617181920void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit.");//主线程的 Looper 无法退出。主线程的 Looper 是通过 prepareMainLooper 方法创建的，创建时调用了 prepare（false），也就是令 mQuitAllowed = false &#125; synchronized (this) &#123; if (mQuitting) &#123;//是否正在退出 return; &#125; mQuitting = true; if (safe) &#123; //安全退出,不会取消执行时机早于或等于当前时间的 Message removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked();//移除 MessageQueue 中所有的消息 &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; MessageQueue.next() 方法片段。当调用了 quit 方法之后会使得 mQuitting 为 true，从而导致 next 方法返回 null，一旦 next 方法返回 null， Looper.loop 就跳出了死循环。 1234if (mQuitting) &#123; dispose();//销毁 native 层的消息队列。 return null;&#125; MessageQueue.enqueueMessage 方法片段 1234567if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false;&#125; 从这里实现可以看到，调用了 Looper.quit / quitSafely 方法之后，再通过 Handler 发送的消息无法添加到 MessageQueue 中，此时 Handler 的 send 方法会返回 false。 android.os.MessageQueue#dispose 123456789// 销毁底层的消息队列// Must only be called on the looper thread or the finalizer.//只能在不 looper 线程或者 finalizer 中调用private void dispose() &#123; if (mPtr != 0) &#123; nativeDestroy(mPtr); mPtr = 0; &#125;&#125; 回到 Handler Looper 的 loop 方法中有这样一行代码 msg.target.dispatchMessage(msg);该方法调用的就是 Handler.dispatchMessage 方法。dispatchMessage 方法会根据情况对 Message 进行分发。 Handler.class 代码片段 12345678910111213141516171819202122232425262728293031323334/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg);//回调执行 Runnable 的 run 方法 &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123;//执行创建 Handler 时指定的 Callback#handleMessage 方法。 return; &#125; &#125; handleMessage(msg);//执行 handleMessage(msg) 方法 &#125;&#125;public void handleMessage(Message msg) &#123;//空实现，需要由子类覆写&#125;private static void handleCallback(Message message) &#123; message.callback.run(); // callback 的实际类型为 Runnable，这行代码的作用就是回调 Runnable 的 run 方法&#125;/** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. */public interface Callback &#123; /** * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */ public boolean handleMessage(Message msg);&#125; dispatchMessage 方法的逻辑：如果 Message 自身设置了 callback，那么事件会直接分派给 msg#callback#run 方法处理。否则，如果给 Handler 设置了 Callback 的话，会先将事件分派给 Callback#handleMessage 方法处理，如果返回值为 true，说明不需要再做进一步的处理，如果返回 false或者是没有给 Handler 设置callback 的 话，则会执行 Handler#handleMessage 方法。 Handler 的 Callback 有什么作用呢？ 提供了另一种使用 handler 处理消息的方式，在实例化 Handler 时可以使用Callback ，而不是自己实现一个 handler 子类。 可以做一些消息过滤。 Handler 小结Handler 的工作主要包含消息的发送和接收过程（还有一个「分发过程」）。 消息的发送可以通过 post 的一系列方法以及 send 的一系列方法来实现。 post 系列方法最终是通过 send 的一系列方法来实现的。 查看源码不难发现，Handler 的发送消息的过程仅仅是向 MessageQueue 插入了一条 Message，MessageQueue 的 next 方法就会返回此 Message 给 Looper， Looper 在 loop 方法中对 Message 进行处理，最终由 Looper 交回给 Handler 处理（调用 Handler 的 dispatchMessage 方法）。 数量关系一个线程最多只能有一个 Looper ，一个 MessageQueue，可以有多个 Handler。 MessageQueue 封装在 Looper 中。 问题为什么主线程不会因为 Looper.loop()里的死循环卡死？阻塞是有的，但是不会卡住主要原因有 2 个： 1.Linux 的 epoll 机制当没有消息的时候会 epoll.wait，等待句柄写的时候再唤醒，这个时候其实是阻塞的。 2.所有的 ui 操作都通过 handler 来发消息操作。比如屏幕刷新 16ms 一个消息，你的各种点击事件，就会有句柄写操作，唤醒上文的 wait 操作，所以不会被卡死了。 一个比较形象的比喻： 就像一辆车在圆形赛车道上跑，一边跑(一边执行任务)，比如开到市中心买瓶水，任务完成又回到刚刚离开的地方，继续各种执行买水的任务，直到没有任务了（msg 为空），行了，跑一圈回到起点。睡觉（epoll_wait），有任务叫醒你（唤醒 wait），你又开始跑一圈。边跑边接单。 想进一步了解的同学可以看下知乎上对该问题的讨论 总结Looper 对象封装了消息队列，Looper 对象被封装在 ThreadLocal 中，是线程私有的，不同线程之间的 Looper 无法共享。Handler 通过与 Looper 之间的绑定来实现与执行线程之间的绑定，handler 发送消息时会将 Message 对象追加到与线程相关的消息队列中，然后由 Looper 回调它的分发消息方法，根据情况处理消息。 最后我们看一张完整的流程图（图片参考自Handler 异步通信机制全面解析），笔者修改了原图中的 Handler dispatchMessage 方法描述。 参考资料与学习资源推荐 理解 Java 中的 ThreadLocal 谈谈 ThreadLocal Android 中 Handler 的使用 Handler 异步通信机制全面解析 深入源码解析 Android 中的 Handler,Message,MessageQueue,Looper 探索 Android 大杀器—— Handler 《Android 开发艺术探索》 《Android 源码设计模式解析与实战》 如果本文中有不正确的结论、说法或者表述不清晰的地方，恳请大家指出，共同探讨，共同进步，谢谢!]]></content>
      <categories>
        <category>原理分析</category>
        <category>Android 进阶</category>
      </categories>
      <tags>
        <tag>Android 进阶</tag>
        <tag>原理分析</tag>
      </tags>
  </entry>
</search>
